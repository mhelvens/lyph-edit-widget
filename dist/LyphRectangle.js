(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["OpenPhysiologyModel"] = factory();
	else
		root["OpenPhysiologyModel"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(243);


/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.flag = exports.event = exports.property = exports.default = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _powerAssertVisitorKeys = '{"ArrayExpression":["elements"],"AssignmentExpression":["left","right"],"BinaryExpression":["left","right"],"Directive":["value"],"DirectiveLiteral":[],"BlockStatement":["directives","body"],"BreakStatement":["label"],"CallExpression":["callee","arguments"],"CatchClause":["param","body"],"ConditionalExpression":["test","consequent","alternate"],"ContinueStatement":["label"],"DebuggerStatement":[],"DoWhileStatement":["test","body"],"EmptyStatement":[],"ExpressionStatement":["expression"],"File":["program"],"ForInStatement":["left","right","body"],"ForStatement":["init","test","update","body"],"FunctionDeclaration":["id","params","body","returnType","typeParameters"],"FunctionExpression":["id","params","body","returnType","typeParameters"],"Identifier":["typeAnnotation"],"IfStatement":["test","consequent","alternate"],"LabeledStatement":["label","body"],"StringLiteral":[],"NumericLiteral":[],"NullLiteral":[],"BooleanLiteral":[],"RegExpLiteral":[],"LogicalExpression":["left","right"],"MemberExpression":["object","property"],"NewExpression":["callee","arguments"],"Program":["directives","body"],"ObjectExpression":["properties"],"ObjectMethod":["key","params","body","decorators","returnType","typeParameters"],"ObjectProperty":["key","value","decorators"],"RestElement":["argument","typeAnnotation"],"ReturnStatement":["argument"],"SequenceExpression":["expressions"],"SwitchCase":["test","consequent"],"SwitchStatement":["discriminant","cases"],"ThisExpression":[],"ThrowStatement":["argument"],"TryStatement":["block","handler","finalizer"],"UnaryExpression":["argument"],"UpdateExpression":["argument"],"VariableDeclaration":["declarations"],"VariableDeclarator":["id","init"],"WhileStatement":["test","body"],"WithStatement":["object","body"],"AssignmentPattern":["left","right"],"ArrayPattern":["elements","typeAnnotation"],"ArrowFunctionExpression":["params","body","returnType"],"ClassBody":["body"],"ClassDeclaration":["id","body","superClass","mixins","typeParameters","superTypeParameters","implements","decorators"],"ClassExpression":["id","body","superClass","mixins","typeParameters","superTypeParameters","implements","decorators"],"ExportAllDeclaration":["source"],"ExportDefaultDeclaration":["declaration"],"ExportNamedDeclaration":["declaration","specifiers","source"],"ExportSpecifier":["local","exported"],"ForOfStatement":["left","right","body"],"ImportDeclaration":["specifiers","source"],"ImportDefaultSpecifier":["local"],"ImportNamespaceSpecifier":["local"],"ImportSpecifier":["local","imported"],"MetaProperty":["meta","property"],"ClassMethod":["key","params","body","decorators","returnType","typeParameters"],"ObjectPattern":["properties","typeAnnotation"],"SpreadElement":["argument"],"Super":[],"TaggedTemplateExpression":["tag","quasi"],"TemplateElement":[],"TemplateLiteral":["quasis","expressions"],"YieldExpression":["argument"],"AnyTypeAnnotation":[],"ArrayTypeAnnotation":["elementType"],"BooleanTypeAnnotation":[],"BooleanLiteralTypeAnnotation":[],"NullLiteralTypeAnnotation":[],"ClassImplements":["id","typeParameters"],"ClassProperty":["key","value","typeAnnotation","decorators"],"DeclareClass":["id","typeParameters","extends","body"],"DeclareFunction":["id"],"DeclareInterface":["id","typeParameters","extends","body"],"DeclareModule":["id","body"],"DeclareTypeAlias":["id","typeParameters","right"],"DeclareVariable":["id"],"ExistentialTypeParam":[],"FunctionTypeAnnotation":["typeParameters","params","rest","returnType"],"FunctionTypeParam":["name","typeAnnotation"],"GenericTypeAnnotation":["id","typeParameters"],"InterfaceExtends":["id","typeParameters"],"InterfaceDeclaration":["id","typeParameters","extends","body"],"IntersectionTypeAnnotation":["types"],"MixedTypeAnnotation":[],"NullableTypeAnnotation":["typeAnnotation"],"NumericLiteralTypeAnnotation":[],"NumberTypeAnnotation":[],"StringLiteralTypeAnnotation":[],"StringTypeAnnotation":[],"ThisTypeAnnotation":[],"TupleTypeAnnotation":["types"],"TypeofTypeAnnotation":["argument"],"TypeAlias":["id","typeParameters","right"],"TypeAnnotation":["typeAnnotation"],"TypeCastExpression":["expression","typeAnnotation"],"TypeParameter":["bound"],"TypeParameterDeclaration":["params"],"TypeParameterInstantiation":["params"],"ObjectTypeAnnotation":["properties","indexers","callProperties"],"ObjectTypeCallProperty":["value"],"ObjectTypeIndexer":["id","key","value"],"ObjectTypeProperty":["key","value"],"QualifiedTypeIdentifier":["id","qualification"],"UnionTypeAnnotation":["types"],"VoidTypeAnnotation":[],"JSXAttribute":["name","value"],"JSXClosingElement":["name"],"JSXElement":["openingElement","children","closingElement"],"JSXEmptyExpression":[],"JSXExpressionContainer":["expression"],"JSXIdentifier":[],"JSXMemberExpression":["object","property"],"JSXNamespacedName":["namespace","name"],"JSXOpeningElement":["name","attributes"],"JSXSpreadAttribute":["argument"],"JSXText":[],"Noop":[],"ParenthesizedExpression":["expression"],"AwaitExpression":["argument"],"BindExpression":["object","callee"],"Decorator":["expression"],"DoExpression":["body"],"ExportDefaultSpecifier":["exported"],"ExportNamespaceSpecifier":["exported"],"RestProperty":["argument"],"SpreadProperty":["argument"]}',
	    _powerAssertRecorder = function () { function PowerAssertRecorder() { this.captured = []; } PowerAssertRecorder.prototype._capt = function _capt(value, espath) { this.captured.push({ value: value, espath: espath }); return value; }; PowerAssertRecorder.prototype._expr = function _expr(value, source) { return { powerAssertContext: { value: value, events: this.captured }, source: source }; }; return PowerAssertRecorder; }(),
	    _dec,
	    _desc,
	    _value,
	    _class;
	
	var _includes = __webpack_require__(340);
	
	var _includes2 = _interopRequireDefault(_includes);
	
	var _isArray = __webpack_require__(186);
	
	var _isArray2 = _interopRequireDefault(_isArray);
	
	var _isString = __webpack_require__(187);
	
	var _isString2 = _interopRequireDefault(_isString);
	
	var _set = __webpack_require__(346);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _entries2 = __webpack_require__(185);
	
	var _entries3 = _interopRequireDefault(_entries2);
	
	var _keys2 = __webpack_require__(188);
	
	var _keys3 = _interopRequireDefault(_keys2);
	
	var _isPlainObject = __webpack_require__(342);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _isFunction = __webpack_require__(79);
	
	var _isFunction2 = _interopRequireDefault(_isFunction);
	
	var _isEqual2 = __webpack_require__(445);
	
	var _isEqual3 = _interopRequireDefault(_isEqual2);
	
	var _isBoolean2 = __webpack_require__(43);
	
	var _isBoolean3 = _interopRequireDefault(_isBoolean2);
	
	var _powerAssert = __webpack_require__(69);
	
	var _powerAssert2 = _interopRequireDefault(_powerAssert);
	
	var _misc = __webpack_require__(51);
	
	var _Subject = __webpack_require__(108);
	
	var _BehaviorSubject = __webpack_require__(213);
	
	var _never = __webpack_require__(491);
	
	var _combineLatest = __webpack_require__(33);
	
	var _distinctUntilChanged = __webpack_require__(237);
	
	var _filter = __webpack_require__(16);
	
	var _takeUntil = __webpack_require__(49);
	
	var _skip = __webpack_require__(497);
	
	var _map = __webpack_require__(15);
	
	var _withLatestFrom = __webpack_require__(72);
	
	__webpack_require__(487);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }
	
	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
		var desc = {};
		Object['ke' + 'ys'](descriptor).forEach(function (key) {
			desc[key] = descriptor[key];
		});
		desc.enumerable = !!desc.enumerable;
		desc.configurable = !!desc.configurable;
	
		if ('value' in desc || desc.initializer) {
			desc.writable = true;
		}
	
		desc = decorators.slice().reverse().reduce(function (desc, decorator) {
			return decorator(target, property, desc) || desc;
		}, desc);
	
		if (context && desc.initializer !== void 0) {
			desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
			desc.initializer = undefined;
		}
	
		if (desc.initializer === void 0) {
			Object['define' + 'Property'](target, property, desc);
			desc = null;
		}
	
		return desc;
	}
	
	var $$events = Symbol('$$events');
	var $$properties = Symbol('$$properties');
	var $$settableProperties = Symbol('$$settableProperties');
	var $$initialize = Symbol('$$initialize');
	var $$takeUntil = Symbol('$$takeUntil');
	var $$filterBy = Symbol('$$filterBy');
	var $$currentValues = Symbol('$$currentValues');
	
	/**
	 * Use this as a subclass (or just mix it in) to provide support for
	 * events and observable properties through Kefir.js.
	 *
	 * @export
	 * @class ValueTracker
	 */
	var ValueTracker = (_dec = (0, _misc.args)('s?a?a?f?'), (_class = function () {
		_createClass(ValueTracker, [{
			key: $$initialize,
			value: function value() {
				var _context;
	
				if (this[$$events]) {
					return;
				}
				this[$$events] = {};
				this[$$properties] = {};
				this[$$settableProperties] = {};
				this[$$currentValues] = {};
	
				/* add the events and properties added with ES7 annotations */
				_ref = (_context = this.constructor[$$events] || {}, _entries3.default).call(_context);
	
				if (!(_ref && (typeof _ref[Symbol.iterator] === 'function' || Array.isArray(_ref)))) {
					throw new TypeError('Expected _ref to be iterable, got ' + _inspect(_ref));
				}
	
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
	
				try {
					for (var _iterator = _ref[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var _ref;
	
						var _step$value = _slicedToArray(_step.value, 2);
	
						var key = _step$value[0];
						var options = _step$value[1];
	
						this.newEvent(key, options);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
	
				_ref2 = (_context = this.constructor[$$properties] || {}, _entries3.default).call(_context);
	
				if (!(_ref2 && (typeof _ref2[Symbol.iterator] === 'function' || Array.isArray(_ref2)))) {
					throw new TypeError('Expected _ref2 to be iterable, got ' + _inspect(_ref2));
				}
	
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;
	
				try {
					for (var _iterator2 = _ref2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var _ref2;
	
						var _step2$value = _slicedToArray(_step2.value, 2);
	
						var key = _step2$value[0];
						var options = _step2$value[1];
	
						this.newProperty(key, options);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		}]);
	
		function ValueTracker() {
			_classCallCheck(this, ValueTracker);
	
			this[$$takeUntil] = (0, _never.never)();
			this[$$filterBy] = function () {
				return true;
			};
		}
	
		_createClass(ValueTracker, [{
			key: 'setValueTrackerOptions',
			value: function setValueTrackerOptions(_ref3) {
				var _ref3$takeUntil = _ref3.takeUntil;
				var takeUntil = _ref3$takeUntil === undefined ? (0, _never.never)() : _ref3$takeUntil;
				var _ref3$filterBy = _ref3.filterBy;
				var filterBy = _ref3$filterBy === undefined ? function () {
					return true;
				} : _ref3$filterBy;
	
				this[$$takeUntil] = takeUntil;
				this[$$filterBy] = filterBy;
				this[$$initialize]();
			}
	
			/**
	   * Declares a new event stream for this object.
	   *
	   * @public
	   * @method
	   * @param  {String} name - the name of the event, used to trigger or subscribe to it
	   * @return {Subject} - the created event stream
	   */
	
		}, {
			key: 'newEvent',
			value: function newEvent(name) {
				var _context2;
	
				var _rec = new _powerAssertRecorder(),
				    _rec2 = new _powerAssertRecorder();
	
				var _ref4 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
				_objectDestructuringEmpty(_ref4);
	
				this[$$initialize]();
	
				/* is the event name already taken? */
				(0, _powerAssert2.default)(_rec._expr(_rec._capt(!_rec._capt(_rec._capt(this[_rec._capt($$events, 'arguments/0/argument/object/property')], 'arguments/0/argument/object')[_rec._capt(name, 'arguments/0/argument/property')], 'arguments/0/argument'), 'arguments/0'), {
					content: 'assert(!this[$$events][name], `There is already an event \'${ name }\' on this object.`)',
					filepath: 'src/util/ValueTracker.js',
					line: 85,
					ast: '{"type":"CallExpression","callee":{"type":"Identifier","name":"assert","range":[0,6]},"arguments":[{"type":"UnaryExpression","operator":"!","argument":{"type":"MemberExpression","object":{"type":"MemberExpression","object":{"type":"ThisExpression","range":[8,12]},"property":{"type":"Identifier","name":"$$events","range":[13,21]},"computed":true,"range":[8,22]},"property":{"type":"Identifier","name":"name","range":[23,27]},"computed":true,"range":[8,28]},"prefix":true,"range":[7,28]},{"type":"TemplateLiteral","quasis":[{"type":"TemplateElement","value":{"raw":"There is already an event \'","cooked":"There is already an event \'"},"tail":false,"range":[31,58]},{"type":"TemplateElement","value":{"raw":"\' on this object.","cooked":"\' on this object."},"tail":true,"range":[67,84]}],"expressions":[{"type":"Identifier","name":"name","range":[61,65]}],"range":[30,85]}],"range":[0,86]}',
					tokens: '[{"type":{"label":"name"},"value":"assert","range":[0,6]},{"type":{"label":"("},"range":[6,7]},{"type":{"label":"prefix"},"value":"!","range":[7,8]},{"type":{"label":"this"},"value":"this","range":[8,12]},{"type":{"label":"["},"range":[12,13]},{"type":{"label":"name"},"value":"$$events","range":[13,21]},{"type":{"label":"]"},"range":[21,22]},{"type":{"label":"["},"range":[22,23]},{"type":{"label":"name"},"value":"name","range":[23,27]},{"type":{"label":"]"},"range":[27,28]},{"type":{"label":","},"range":[28,29]},{"type":{"label":"`"},"range":[30,31]},{"type":{"label":"template"},"value":"There is already an event \'","range":[31,58]},{"type":{"label":"${"},"range":[58,60]},{"type":{"label":"name"},"value":"name","range":[61,65]},{"type":{"label":"}"},"range":[66,67]},{"type":{"label":"template"},"value":"\' on this object.","range":[67,84]},{"type":{"label":"`"},"range":[84,85]},{"type":{"label":")"},"range":[85,86]}]',
					visitorKeys: _powerAssertVisitorKeys
				}), 'There is already an event \'' + name + '\' on this object.');
				(0, _powerAssert2.default)(_rec2._expr(_rec2._capt(!_rec2._capt(_rec2._capt(this[_rec2._capt($$properties, 'arguments/0/argument/object/property')], 'arguments/0/argument/object')[_rec2._capt(name, 'arguments/0/argument/property')], 'arguments/0/argument'), 'arguments/0'), {
					content: 'assert(!this[$$properties][name], `There is already a property \'${ name }\' on this object.`)',
					filepath: 'src/util/ValueTracker.js',
					line: 87,
					ast: '{"type":"CallExpression","callee":{"type":"Identifier","name":"assert","range":[0,6]},"arguments":[{"type":"UnaryExpression","operator":"!","argument":{"type":"MemberExpression","object":{"type":"MemberExpression","object":{"type":"ThisExpression","range":[8,12]},"property":{"type":"Identifier","name":"$$properties","range":[13,25]},"computed":true,"range":[8,26]},"property":{"type":"Identifier","name":"name","range":[27,31]},"computed":true,"range":[8,32]},"prefix":true,"range":[7,32]},{"type":"TemplateLiteral","quasis":[{"type":"TemplateElement","value":{"raw":"There is already a property \'","cooked":"There is already a property \'"},"tail":false,"range":[35,64]},{"type":"TemplateElement","value":{"raw":"\' on this object.","cooked":"\' on this object."},"tail":true,"range":[73,90]}],"expressions":[{"type":"Identifier","name":"name","range":[67,71]}],"range":[34,91]}],"range":[0,92]}',
					tokens: '[{"type":{"label":"name"},"value":"assert","range":[0,6]},{"type":{"label":"("},"range":[6,7]},{"type":{"label":"prefix"},"value":"!","range":[7,8]},{"type":{"label":"this"},"value":"this","range":[8,12]},{"type":{"label":"["},"range":[12,13]},{"type":{"label":"name"},"value":"$$properties","range":[13,25]},{"type":{"label":"]"},"range":[25,26]},{"type":{"label":"["},"range":[26,27]},{"type":{"label":"name"},"value":"name","range":[27,31]},{"type":{"label":"]"},"range":[31,32]},{"type":{"label":","},"range":[32,33]},{"type":{"label":"`"},"range":[34,35]},{"type":{"label":"template"},"value":"There is already a property \'","range":[35,64]},{"type":{"label":"${"},"range":[64,66]},{"type":{"label":"name"},"value":"name","range":[67,71]},{"type":{"label":"}"},"range":[72,73]},{"type":{"label":"template"},"value":"\' on this object.","range":[73,90]},{"type":{"label":"`"},"range":[90,91]},{"type":{"label":")"},"range":[91,92]}]',
					visitorKeys: _powerAssertVisitorKeys
				}), 'There is already a property \'' + name + '\' on this object.');
	
				this[$$events][name] = (_context2 = (_context2 = new _Subject.Subject(), _takeUntil.takeUntil).call(_context2, this[$$takeUntil]), _filter.filter).call(_context2, this[$$filterBy]);
	
				return this[$$events][name];
			}
	
			/**
	   * This method defines a new property on this object.
	   *
	   * @public
	   * @method
	   * @param  {String}                   name            - the name of the new property
	   * @param  {Boolean}                 [readonly=false] - whether the value can be manually set
	   * @param  {function(*,*):Boolean}   [isEqual]        - a predicate function by which to test for duplicate values
	   * @param  {function(*):Boolean}     [isValid]        - a predicate function to validate a given value
	   * @param  {*}                       [initial]        - the initial value of this property
	   *
	   * @return {BehaviorSubject} - the property associated with the given name
	   */
	
		}, {
			key: 'newProperty',
			value: function newProperty(name) {
				var _context3,
				    _this = this;
	
				var _rec3 = new _powerAssertRecorder(),
				    _rec4 = new _powerAssertRecorder();
	
				var _ref5 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
				var _ref5$readonly = _ref5.readonly;
				var readonly = _ref5$readonly === undefined ? false : _ref5$readonly;
				var _ref5$isEqual = _ref5.isEqual;
				var isEqual = _ref5$isEqual === undefined ? _isEqual3.default : _ref5$isEqual;
				var _ref5$isValid = _ref5.isValid;
				var isValid = _ref5$isValid === undefined ? function () {
					return true;
				} : _ref5$isValid;
				var initial = _ref5.initial;
	
				this[$$initialize]();
	
				/* is the property name already taken? */
				(0, _powerAssert2.default)(_rec3._expr(_rec3._capt(!_rec3._capt(_rec3._capt(this[_rec3._capt($$events, 'arguments/0/argument/object/property')], 'arguments/0/argument/object')[_rec3._capt(name, 'arguments/0/argument/property')], 'arguments/0/argument'), 'arguments/0'), {
					content: 'assert(!this[$$events][name], `There is already an event \'${ name }\' on this object.`)',
					filepath: 'src/util/ValueTracker.js',
					line: 119,
					ast: '{"type":"CallExpression","callee":{"type":"Identifier","name":"assert","range":[0,6]},"arguments":[{"type":"UnaryExpression","operator":"!","argument":{"type":"MemberExpression","object":{"type":"MemberExpression","object":{"type":"ThisExpression","range":[8,12]},"property":{"type":"Identifier","name":"$$events","range":[13,21]},"computed":true,"range":[8,22]},"property":{"type":"Identifier","name":"name","range":[23,27]},"computed":true,"range":[8,28]},"prefix":true,"range":[7,28]},{"type":"TemplateLiteral","quasis":[{"type":"TemplateElement","value":{"raw":"There is already an event \'","cooked":"There is already an event \'"},"tail":false,"range":[31,58]},{"type":"TemplateElement","value":{"raw":"\' on this object.","cooked":"\' on this object."},"tail":true,"range":[67,84]}],"expressions":[{"type":"Identifier","name":"name","range":[61,65]}],"range":[30,85]}],"range":[0,86]}',
					tokens: '[{"type":{"label":"name"},"value":"assert","range":[0,6]},{"type":{"label":"("},"range":[6,7]},{"type":{"label":"prefix"},"value":"!","range":[7,8]},{"type":{"label":"this"},"value":"this","range":[8,12]},{"type":{"label":"["},"range":[12,13]},{"type":{"label":"name"},"value":"$$events","range":[13,21]},{"type":{"label":"]"},"range":[21,22]},{"type":{"label":"["},"range":[22,23]},{"type":{"label":"name"},"value":"name","range":[23,27]},{"type":{"label":"]"},"range":[27,28]},{"type":{"label":","},"range":[28,29]},{"type":{"label":"`"},"range":[30,31]},{"type":{"label":"template"},"value":"There is already an event \'","range":[31,58]},{"type":{"label":"${"},"range":[58,60]},{"type":{"label":"name"},"value":"name","range":[61,65]},{"type":{"label":"}"},"range":[66,67]},{"type":{"label":"template"},"value":"\' on this object.","range":[67,84]},{"type":{"label":"`"},"range":[84,85]},{"type":{"label":")"},"range":[85,86]}]',
					visitorKeys: _powerAssertVisitorKeys
				}), 'There is already an event \'' + name + '\' on this object.');
				(0, _powerAssert2.default)(_rec4._expr(_rec4._capt(!_rec4._capt(_rec4._capt(this[_rec4._capt($$properties, 'arguments/0/argument/object/property')], 'arguments/0/argument/object')[_rec4._capt(name, 'arguments/0/argument/property')], 'arguments/0/argument'), 'arguments/0'), {
					content: 'assert(!this[$$properties][name], `There is already a property \'${ name }\' on this object.`)',
					filepath: 'src/util/ValueTracker.js',
					line: 121,
					ast: '{"type":"CallExpression","callee":{"type":"Identifier","name":"assert","range":[0,6]},"arguments":[{"type":"UnaryExpression","operator":"!","argument":{"type":"MemberExpression","object":{"type":"MemberExpression","object":{"type":"ThisExpression","range":[8,12]},"property":{"type":"Identifier","name":"$$properties","range":[13,25]},"computed":true,"range":[8,26]},"property":{"type":"Identifier","name":"name","range":[27,31]},"computed":true,"range":[8,32]},"prefix":true,"range":[7,32]},{"type":"TemplateLiteral","quasis":[{"type":"TemplateElement","value":{"raw":"There is already a property \'","cooked":"There is already a property \'"},"tail":false,"range":[35,64]},{"type":"TemplateElement","value":{"raw":"\' on this object.","cooked":"\' on this object."},"tail":true,"range":[73,90]}],"expressions":[{"type":"Identifier","name":"name","range":[67,71]}],"range":[34,91]}],"range":[0,92]}',
					tokens: '[{"type":{"label":"name"},"value":"assert","range":[0,6]},{"type":{"label":"("},"range":[6,7]},{"type":{"label":"prefix"},"value":"!","range":[7,8]},{"type":{"label":"this"},"value":"this","range":[8,12]},{"type":{"label":"["},"range":[12,13]},{"type":{"label":"name"},"value":"$$properties","range":[13,25]},{"type":{"label":"]"},"range":[25,26]},{"type":{"label":"["},"range":[26,27]},{"type":{"label":"name"},"value":"name","range":[27,31]},{"type":{"label":"]"},"range":[31,32]},{"type":{"label":","},"range":[32,33]},{"type":{"label":"`"},"range":[34,35]},{"type":{"label":"template"},"value":"There is already a property \'","range":[35,64]},{"type":{"label":"${"},"range":[64,66]},{"type":{"label":"name"},"value":"name","range":[67,71]},{"type":{"label":"}"},"range":[72,73]},{"type":{"label":"template"},"value":"\' on this object.","range":[73,90]},{"type":{"label":"`"},"range":[90,91]},{"type":{"label":")"},"range":[91,92]}]',
					visitorKeys: _powerAssertVisitorKeys
				}), 'There is already a property \'' + name + '\' on this object.');
	
				/* if isValid is an array, check for inclusion */
				if ((_context3 = isValid, _isArray2.default).call(_context3)) {
					var _context4;
	
					isValid = (_context4 = isValid, _includes2.default).bind(_context4);
				}
	
				/* define the bus which manages the property */
				var subject = this[$$settableProperties][name] = (_context3 = (_context3 = (_context3 = (_context3 = new _BehaviorSubject.BehaviorSubject(initial), _filter.filter).call(_context3, this[$$filterBy]), _filter.filter).call(_context3, isValid.bind(this)), _takeUntil.takeUntil).call(_context3, this[$$takeUntil]), _distinctUntilChanged.distinctUntilChanged).call(_context3, isEqual.bind(this));
				this[$$properties][name] = readonly ? subject.asObservable() : subject;
	
				/* keep track of current value */
				this[$$properties][name].subscribe(function (v) {
					_this[$$currentValues][name] = v;
				});
	
				/* create event version of the property */
				this[$$events][name] = (_context3 = subject.asObservable(), _skip.skip).call(_context3, 1); // skip 'current value' on subscribe
	
				/* return property */
				return this[$$settableProperties][name];
			}
	
			/**
	   * Retrieve an event stream by name. If the name of a property is given, a stream
	   * based on changes to that property is returned.
	   *
	   * @public
	   * @method
	   * @param  {String}  name - the name of the event stream to retrieve
	   * @return {Observable} - the event stream associated with the given name
	   */
	
		}, {
			key: 'e',
			value: function e(name) {
				this[$$initialize]();
				return this[$$events][name] || (0, _never.never)();
			}
	
			/**
	   * Retrieve a property (or multiple properties combined) by name.
	   *
	   * @public
	   * @method
	   * @param  {String?}   name                - the name of the property to retrieve (choose name or deps)
	   * @param  {Array?}    deps                - a list of active dependencies for a derived property
	   * @param  {Array?}    optionalPassiveDeps - an optional list of passive dependencies for a derived property
	   * @param  {Function?} optionalTransformer - an optional function to map the dependencies to a new value for the derived property
	   * @return {BehaviorSubject | Observable} - the property associated with the given name or an observable of combined properties
	   */
	
		}, {
			key: 'p',
			value: function p(name, deps) {
				var optionalPassiveDeps = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
				var optionalTransformer = arguments.length <= 3 || arguments[3] === undefined ? function () {
					for (var _len = arguments.length, a = Array(_len), _key = 0; _key < _len; _key++) {
						a[_key] = arguments[_key];
					}
	
					return a;
				} : arguments[3];
	
				this[$$initialize]();
				if (deps) {
					var _context5, _ref6;
	
					return (_ref6 = (_context5 = _combineLatest.combineLatest.apply(undefined, _toConsumableArray(deps.map(this.p.bind(this)))), _withLatestFrom.withLatestFrom)).call.apply(_ref6, [_context5].concat(_toConsumableArray(optionalPassiveDeps.map(this.p.bind(this))), [function (active) {
						for (var _len2 = arguments.length, passive = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
							passive[_key2 - 1] = arguments[_key2];
						}
	
						return optionalTransformer.apply(undefined, _toConsumableArray(active).concat(passive));
					}]));
				} else if (name) {
					var _rec5 = new _powerAssertRecorder();
	
					(0, _powerAssert2.default)(_rec5._expr(_rec5._capt(_rec5._capt(this[_rec5._capt($$properties, 'arguments/0/object/property')], 'arguments/0/object')[_rec5._capt(name, 'arguments/0/property')], 'arguments/0'), {
						content: 'assert(this[$$properties][name], `No property \'${ name }\' exists.`)',
						filepath: 'src/util/ValueTracker.js',
						line: 180,
						ast: '{"type":"CallExpression","callee":{"type":"Identifier","name":"assert","range":[0,6]},"arguments":[{"type":"MemberExpression","object":{"type":"MemberExpression","object":{"type":"ThisExpression","range":[7,11]},"property":{"type":"Identifier","name":"$$properties","range":[12,24]},"computed":true,"range":[7,25]},"property":{"type":"Identifier","name":"name","range":[26,30]},"computed":true,"range":[7,31]},{"type":"TemplateLiteral","quasis":[{"type":"TemplateElement","value":{"raw":"No property \'","cooked":"No property \'"},"tail":false,"range":[34,47]},{"type":"TemplateElement","value":{"raw":"\' exists.","cooked":"\' exists."},"tail":true,"range":[56,65]}],"expressions":[{"type":"Identifier","name":"name","range":[50,54]}],"range":[33,66]}],"range":[0,67]}',
						tokens: '[{"type":{"label":"name"},"value":"assert","range":[0,6]},{"type":{"label":"("},"range":[6,7]},{"type":{"label":"this"},"value":"this","range":[7,11]},{"type":{"label":"["},"range":[11,12]},{"type":{"label":"name"},"value":"$$properties","range":[12,24]},{"type":{"label":"]"},"range":[24,25]},{"type":{"label":"["},"range":[25,26]},{"type":{"label":"name"},"value":"name","range":[26,30]},{"type":{"label":"]"},"range":[30,31]},{"type":{"label":","},"range":[31,32]},{"type":{"label":"`"},"range":[33,34]},{"type":{"label":"template"},"value":"No property \'","range":[34,47]},{"type":{"label":"${"},"range":[47,49]},{"type":{"label":"name"},"value":"name","range":[50,54]},{"type":{"label":"}"},"range":[55,56]},{"type":{"label":"template"},"value":"\' exists.","range":[56,65]},{"type":{"label":"`"},"range":[65,66]},{"type":{"label":")"},"range":[66,67]}]',
						visitorKeys: _powerAssertVisitorKeys
					}), 'No property \'' + name + '\' exists.');
					return this[$$properties][name];
				}
			}
	
			/**
	   * Retrieve multiple properties by name in an object, possibly transformed.
	   *
	   * @public
	   * @method
	   * @param  {Object}    activeDeps          - a list of active dependencies for a derived property
	   * @param  {Object?}   optionalPassiveDeps - an optional list of passive dependencies for a derived property
	   * @param  {Function?} optionalTransformer - an optional function to map the dependencies to a new value for the derived property
	   * @return {Observable} - an observable of combined properties
	   */
	
		}, {
			key: 'pObj',
			value: function pObj(activeDeps) {
				var optionalPassiveDeps = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
				var optionalTransformer = arguments.length <= 2 || arguments[2] === undefined ? function (obj) {
					return obj;
				} : arguments[2];
	
				this[$$initialize]();
				var bothList = activeDeps.concat(optionalPassiveDeps);
				return this.p(activeDeps, optionalPassiveDeps, function () {
					for (var _len3 = arguments.length, vals = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
						vals[_key3] = arguments[_key3];
					}
	
					return optionalTransformer(Object.assign.apply(Object, [{}].concat(_toConsumableArray(vals.map(function (v, i) {
						return _defineProperty({}, bothList[i], v);
					})))));
				});
			}
	
			/**
	   * Retrieve a property by name. This returns as a Subject
	   * regardless of 'readonly' option, only to be used by
	   * the 'owner' of the property.
	   *
	   * @public
	   * @method
	   * @param  {String} name     - the name of the property to retrieve
	   * @return {BehaviorSubject} - the property associated with the given name
	   */
	
		}, {
			key: 'pSubject',
			value: function pSubject(name) {
				this[$$initialize]();
				return this[$$settableProperties][name];
			}
		}]);
	
		return ValueTracker;
	}(), (_applyDecoratedDescriptor(_class.prototype, 'p', [_dec], Object.getOwnPropertyDescriptor(_class.prototype, 'p'), _class.prototype)), _class));
	exports.default = ValueTracker;
	;
	
	var property = exports.property = function property() {
		var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		return function (target, key) {
			_set2.default.call(target, ['constructor', $$properties, key], options);
			return _extends({
				get: function get() {
					return this[$$currentValues][key];
				}
			}, !options.readonly && {
				set: function set(value) {
					this.p(key).next(value);
				}
			});
		};
	};
	
	var event = exports.event = function event() {
		var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		return function (target, key) {
			var _rec6 = new _powerAssertRecorder();
	
			var match = key.match(/^(\w+)Event$/);
			(0, _powerAssert2.default)(_rec6._expr(_rec6._capt(match, 'arguments/0'), {
				content: 'assert(match)',
				filepath: 'src/util/ValueTracker.js',
				line: 230,
				ast: '{"type":"CallExpression","callee":{"type":"Identifier","name":"assert","range":[0,6]},"arguments":[{"type":"Identifier","name":"match","range":[7,12]}],"range":[0,13]}',
				tokens: '[{"type":{"label":"name"},"value":"assert","range":[0,6]},{"type":{"label":"("},"range":[6,7]},{"type":{"label":"name"},"value":"match","range":[7,12]},{"type":{"label":")"},"range":[12,13]}]',
				visitorKeys: _powerAssertVisitorKeys
			}));
			var name = match[1];
			_set2.default.call(target, ['constructor', $$events, name], options);
			return {
				get: function get() {
					return this.e(name);
				}
			};
		};
	};
	
	var flag = exports.flag = function flag(initial) {
		return property({ isValid: _isBoolean3.default, initial: initial });
	};
	
	function _inspect(input, depth) {
		var maxDepth = 4;
		var maxKeys = 15;

		if (depth === undefined) {
			depth = 0;
		}

		depth += 1;

		if (input === null) {
			return 'null';
		} else if (input === undefined) {
			return 'void';
		} else if (typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean') {
			return typeof input === 'undefined' ? 'undefined' : _typeof(input);
		} else if (Array.isArray(input)) {
			if (input.length > 0) {
				var _ret = function () {
					if (depth > maxDepth) return {
							v: '[...]'
						};

					var first = _inspect(input[0], depth);

					if (input.every(function (item) {
						return _inspect(item, depth) === first;
					})) {
						return {
							v: first.trim() + '[]'
						};
					} else {
						return {
							v: '[' + input.slice(0, maxKeys).map(function (item) {
								return _inspect(item, depth);
							}).join(', ') + (input.length >= maxKeys ? ', ...' : '') + ']'
						};
					}
				}();

				if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
			} else {
				return 'Array';
			}
		} else {
			var _keys = Object.keys(input);

			if (!_keys.length) {
				if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
					return input.constructor.name;
				} else {
					return 'Object';
				}
			}

			if (depth > maxDepth) return '{...}';
			var indent = '  '.repeat(depth - 1);

			var _entries = _keys.slice(0, maxKeys).map(function (key) {
				return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + ': ' + _inspect(input[key], depth) + ';';
			}).join('\n  ' + indent);

			if (_keys.length >= maxKeys) {
				_entries += '\n  ' + indent + '...';
			}

			if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
				return input.constructor.name + ' {\n  ' + indent + _entries + '\n' + indent + '}';
			} else {
				return '{\n  ' + indent + _entries + '\n' + indent + '}';
			}
		}
	}

/***/ },
/* 7 */,
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(58)
	  , core      = __webpack_require__(5)
	  , ctx       = __webpack_require__(171)
	  , hide      = __webpack_require__(263)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(218);
	var Subscription_1 = __webpack_require__(70);
	var Observer_1 = __webpack_require__(485);
	var rxSubscriber_1 = __webpack_require__(146);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parent, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parent = _parent;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            context = observerOrNext;
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (isFunction_1.isFunction(context.unsubscribe)) {
	                this.add(context.unsubscribe.bind(context));
	            }
	            context.unsubscribe = this.unsubscribe.bind(this);
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parent = this._parent;
	            if (!_parent.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parent, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._error) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parent.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parent.syncErrorValue = err;
	                _parent.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._complete) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parent = this._parent;
	        this._context = null;
	        this._parent = null;
	        _parent.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ },
/* 10 */,
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(285);
	module.exports = __webpack_require__(5).Object.assign;

/***/ },
/* 12 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 13 */,
/* 14 */,
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Applies a given `project` function to each value emitted by the source
	 * Observable, and emits the resulting values as an Observable.
	 *
	 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
	 * it passes each source value through a transformation function to get
	 * corresponding output values.</span>
	 *
	 * <img src="./img/map.png" width="100%">
	 *
	 * Similar to the well known `Array.prototype.map` function, this operator
	 * applies a projection to each value and emits that projection in the output
	 * Observable.
	 *
	 * @example <caption>Map every every click to the clientX position of that click</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks.map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link mapTo}
	 * @see {@link pluck}
	 *
	 * @param {function(value: T, index: number): R} project The function to apply
	 * to each `value` emitted by the source Observable. The `index` parameter is
	 * the number `i` for the i-th emission that has happened since the
	 * subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to define what `this` is in the
	 * `project` function.
	 * @return {Observable<R>} An Observable that emits the values from the source
	 * Observable transformed by the given `project` function.
	 * @method map
	 * @owner Observable
	 */
	function map(project, thisArg) {
	    if (typeof project !== 'function') {
	        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
	    }
	    return this.lift(new MapOperator(project, thisArg));
	}
	exports.map = map;
	var MapOperator = (function () {
	    function MapOperator(project, thisArg) {
	        this.project = project;
	        this.thisArg = thisArg;
	    }
	    MapOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
	    };
	    return MapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MapSubscriber = (function (_super) {
	    __extends(MapSubscriber, _super);
	    function MapSubscriber(destination, project, thisArg) {
	        _super.call(this, destination);
	        this.project = project;
	        this.count = 0;
	        this.thisArg = thisArg || this;
	    }
	    // NOTE: This looks unoptimized, but it's actually purposefully NOT
	    // using try/catch optimizations.
	    MapSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.project.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return MapSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=map.js.map

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Filter items emitted by the source Observable by only emitting those that
	 * satisfy a specified predicate.
	 *
	 * <span class="informal">Like
	 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
	 * it only emits a value from the source if it passes a criterion function.</span>
	 *
	 * <img src="./img/filter.png" width="100%">
	 *
	 * Similar to the well-known `Array.prototype.filter` method, this operator
	 * takes values from the source Observable, passes them through a `predicate`
	 * function and only emits those values that yielded `true`.
	 *
	 * @example <caption>Emit only click events whose target was a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
	 * clicksOnDivs.subscribe(x => console.log(x));
	 *
	 * @see {@link distinct}
	 * @see {@link distinctKey}
	 * @see {@link distinctUntilChanged}
	 * @see {@link distinctUntilKeyChanged}
	 * @see {@link ignoreElements}
	 * @see {@link partition}
	 * @see {@link skip}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted, if `false` the value is not passed to the output
	 * Observable. The `index` parameter is the number `i` for the i-th source
	 * emission that has happened since the subscription, starting from the number
	 * `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable} An Observable of values from the source that were
	 * allowed by the `predicate` function.
	 * @method filter
	 * @owner Observable
	 */
	function filter(predicate, thisArg) {
	    return this.lift(new FilterOperator(predicate, thisArg));
	}
	exports.filter = filter;
	var FilterOperator = (function () {
	    function FilterOperator(predicate, thisArg) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	    }
	    FilterOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
	    };
	    return FilterOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FilterSubscriber = (function (_super) {
	    __extends(FilterSubscriber, _super);
	    function FilterSubscriber(destination, predicate, thisArg) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.count = 0;
	        this.predicate = predicate;
	    }
	    // the try catch block below is left specifically for
	    // optimization and perf reasons. a tryCatcher is not necessary here.
	    FilterSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.destination.next(value);
	        }
	    };
	    return FilterSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=filter.js.map

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(453);
	
	module.exports = function pick() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(197);
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	module.exports = root;


/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	module.exports = isArray;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(54);
	var toSubscriber_1 = __webpack_require__(507);
	var symbol_observable_1 = __webpack_require__(220);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    /**
	     * Registers handlers for handling emitted values, error and completions from the observable, and
	     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
	     * @method subscribe
	     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
	     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled
	     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
	     * @return {ISubscription} a subscription reference to the registered handlers
	     */
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this);
	        }
	        else {
	            sink.add(this._subscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` imple will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[symbol_observable_1.default] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ },
/* 21 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports["default"] = function (object, names) {
	  var rename = arguments[2] === undefined ? {} : arguments[2];
	  return names.reduce(function (m, name) {
	    m[rename[name] || name] = function () {
	      for (var _len = arguments.length, s = Array(_len), _key = 0; _key < _len; _key++) {
	        s[_key] = arguments[_key];
	      }
	
	      return this.constructor === Array && object === Math ? object[name].apply(object, this.concat(s)) : object[name].apply(object, [this].concat(s));
	    };
	
	    return m;
	  }, {});
	};
	
	module.exports = exports["default"];

/***/ },
/* 22 */,
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var getLength = __webpack_require__(402),
	    isFunction = __webpack_require__(99),
	    isLength = __webpack_require__(100);
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value)) && !isFunction(value);
	}
	
	module.exports = isArrayLike;


/***/ },
/* 24 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	module.exports = isObject;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var baseHas = __webpack_require__(192),
	    baseKeys = __webpack_require__(376),
	    indexKeys = __webpack_require__(199),
	    isArrayLike = __webpack_require__(23),
	    isIndex = __webpack_require__(65),
	    isPrototype = __webpack_require__(139);
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  var isProto = isPrototype(object);
	  if (!(isProto || isArrayLike(object))) {
	    return baseKeys(object);
	  }
	  var indexes = indexKeys(object),
	      skipIndexes = !!indexes,
	      result = indexes || [],
	      length = result.length;
	
	  for (var key in object) {
	    if (baseHas(object, key) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
	        !(isProto && key == 'constructor')) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = keys;


/***/ },
/* 26 */,
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(278);
	module.exports = __webpack_require__(5).Array.forEach;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(57);
	
	module.exports = function(method, arg){
	  return !!method && fails(function(){
	    arg ? method.call(null, function(){}, 1) : method.call(null);
	  });
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(190);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);
	
	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = array;
	    return apply(func, this, otherArgs);
	  };
	}
	
	module.exports = baseRest;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(515);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(336);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(236)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _jquery = __webpack_require__(62);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	__webpack_require__(338);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _jquery2.default;
	
	// jqMousewheel($);
	
	// /* powertip plugin */
	// import '../../node_modules/jquery-powertip/dist/jquery.powertip.min.js';
	// import '../../node_modules/jquery-powertip/dist/css/jquery.powertip.min.css';
	// import '../../node_modules/jquery-powertip/dist/css/jquery.powertip-dark.min.css';
	
	/* convenience static methods */
	Object.assign(_jquery2.default, {
		svg: function svg(creationString) {
			return this('<svg>' + creationString + '</svg>').children().detach();
		}
	});
	
	/* convenience instance methods */
	Object.assign(_jquery2.default.fn, {
		getBoundingClientRect: function getBoundingClientRect() {
			return this[0].getBoundingClientRect();
		}
	});
	
	/* fix strange bug where case-sensitive attribute name is not used properly */
	_jquery2.default.attrHooks['viewbox'] = {
		set: function set(elem, value, name) {
			elem.setAttributeNS(null, 'viewBox', value + '');
			return value;
		}
	};

/***/ },
/* 32 */,
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isScheduler_1 = __webpack_require__(73);
	var isArray_1 = __webpack_require__(104);
	var ArrayObservable_1 = __webpack_require__(47);
	var combineLatest_1 = __webpack_require__(492);
	/* tslint:enable:max-line-length */
	/**
	 * Combines multiple Observables to create an Observable whose values are
	 * calculated from the latest values of each of its input Observables.
	 *
	 * <span class="informal">Whenever any input Observable emits a value, it
	 * computes a formula using the latest values from all the inputs, then emits
	 * the output of that formula.</span>
	 *
	 * <img src="./img/combineLatest.png" width="100%">
	 *
	 * `combineLatest` combines the values from all the Observables passed as
	 * arguments. This is done by subscribing to each Observable, in order, and
	 * collecting an array of each of the most recent values any time any of the
	 * input Observables emits, then either taking that array and passing it as
	 * arguments to an optional `project` function and emitting the return value of
	 * that, or just emitting the array of recent values directly if there is no
	 * `project` function.
	 *
	 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
	 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
	 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
	 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
	 * bmi.subscribe(x => console.log('BMI is ' + x));
	 *
	 * @see {@link combineAll}
	 * @see {@link merge}
	 * @see {@link withLatestFrom}
	 *
	 * @param {Observable} observable1 An input Observable to combine with the
	 * source Observable.
	 * @param {Observable} observable2 An input Observable to combine with the
	 * source Observable. More than one input Observables may be given as argument.
	 * @param {function} [project] An optional function to project the values from
	 * the combined latest values into a new value on the output Observable.
	 * @param {Scheduler} [scheduler=null] The Scheduler to use for subscribing to
	 * each input Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @static true
	 * @name combineLatest
	 * @owner Observable
	 */
	function combineLatest() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = null;
	    var scheduler = null;
	    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
	        scheduler = observables.pop();
	    }
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    // if the first and only other argument besides the resultSelector is an array
	    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
	    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
	}
	exports.combineLatest = combineLatest;
	//# sourceMappingURL=combineLatest.js.map

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(288);
	module.exports = __webpack_require__(5).Object.keys;

/***/ },
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(441);
	
	module.exports = function defaults() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(372),
	    getValue = __webpack_require__(404);
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	
	module.exports = getNative;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(45);
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;
	
	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	module.exports = toKey;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(12);
	
	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a boolean primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	 * @example
	 *
	 * _.isBoolean(false);
	 * // => true
	 *
	 * _.isBoolean(null);
	 * // => false
	 */
	function isBoolean(value) {
	  return value === true || value === false ||
	    (isObjectLike(value) && objectToString.call(value) == boolTag);
	}
	
	module.exports = isBoolean;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(12);
	
	/** `Object#toString` result references. */
	var numberTag = '[object Number]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `Number` primitive or object.
	 *
	 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	 * classified as numbers, use the `_.isFinite` method.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	 * @example
	 *
	 * _.isNumber(3);
	 * // => true
	 *
	 * _.isNumber(Number.MIN_VALUE);
	 * // => true
	 *
	 * _.isNumber(Infinity);
	 * // => true
	 *
	 * _.isNumber('3');
	 * // => false
	 */
	function isNumber(value) {
	  return typeof value == 'number' ||
	    (isObjectLike(value) && objectToString.call(value) == numberTag);
	}
	
	module.exports = isNumber;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(12);
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}
	
	module.exports = isSymbol;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var OuterSubscriber = (function (_super) {
	    __extends(OuterSubscriber, _super);
	    function OuterSubscriber() {
	        _super.apply(this, arguments);
	    }
	    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.destination.error(error);
	    };
	    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.destination.complete();
	    };
	    return OuterSubscriber;
	}(Subscriber_1.Subscriber));
	exports.OuterSubscriber = OuterSubscriber;
	//# sourceMappingURL=OuterSubscriber.js.map

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(20);
	var ScalarObservable_1 = __webpack_require__(214);
	var EmptyObservable_1 = __webpack_require__(144);
	var isScheduler_1 = __webpack_require__(73);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayObservable = (function (_super) {
	    __extends(ArrayObservable, _super);
	    function ArrayObservable(array, scheduler) {
	        _super.call(this);
	        this.array = array;
	        this.scheduler = scheduler;
	        if (!scheduler && array.length === 1) {
	            this._isScalar = true;
	            this.value = array[0];
	        }
	    }
	    ArrayObservable.create = function (array, scheduler) {
	        return new ArrayObservable(array, scheduler);
	    };
	    /**
	     * Creates an Observable that emits some values you specify as arguments,
	     * immediately one after the other, and then emits a complete notification.
	     *
	     * <span class="informal">Emits the arguments you provide, then completes.
	     * </span>
	     *
	     * <img src="./img/of.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the arguments given, and the complete notification thereafter. It can
	     * be used for composing with other Observables, such as with {@link concat}.
	     * By default, it uses a `null` Scheduler, which means the `next`
	     * notifications are sent synchronously, although with a different Scheduler
	     * it is possible to determine when those notifications will be delivered.
	     *
	     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
	     * var numbers = Rx.Observable.of(10, 20, 30);
	     * var letters = Rx.Observable.of('a', 'b', 'c');
	     * var interval = Rx.Observable.interval(1000);
	     * var result = numbers.concat(letters).concat(interval);
	     * result.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link never}
	     * @see {@link throw}
	     *
	     * @param {...T} values Arguments that represent `next` values to be emitted.
	     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
	     * the emissions of the `next` notifications.
	     * @return {Observable<T>} An Observable that emits each given input value.
	     * @static true
	     * @name of
	     * @owner Observable
	     */
	    ArrayObservable.of = function () {
	        var array = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            array[_i - 0] = arguments[_i];
	        }
	        var scheduler = array[array.length - 1];
	        if (isScheduler_1.isScheduler(scheduler)) {
	            array.pop();
	        }
	        else {
	            scheduler = null;
	        }
	        var len = array.length;
	        if (len > 1) {
	            return new ArrayObservable(array, scheduler);
	        }
	        else if (len === 1) {
	            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
	        }
	        else {
	            return new EmptyObservable_1.EmptyObservable(scheduler);
	        }
	    };
	    ArrayObservable.dispatch = function (state) {
	        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(array[index]);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var array = this.array;
	        var count = array.length;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ArrayObservable.dispatch, 0, {
	                array: array, index: index, count: count, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < count && !subscriber.isUnsubscribed; i++) {
	                subscriber.next(array[i]);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayObservable;
	}(Observable_1.Observable));
	exports.ArrayObservable = ArrayObservable;
	//# sourceMappingURL=ArrayObservable.js.map

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var ArgumentOutOfRangeError_1 = __webpack_require__(500);
	var EmptyObservable_1 = __webpack_require__(144);
	/**
	 * Emits only the first `count` values emitted by the source Observable.
	 *
	 * <span class="informal">Takes the first `count` values from the source, then
	 * completes.</span>
	 *
	 * <img src="./img/take.png" width="100%">
	 *
	 * `take` returns an Observable that emits only the first `count` values emitted
	 * by the source Observable. If the source emits fewer than `count` values then
	 * all of its values are emitted. After that, it completes, regardless if the
	 * source completes.
	 *
	 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
	 * var interval = Rx.Observable.interval(1000);
	 * var five = interval.take(5);
	 * five.subscribe(x => console.log(x));
	 *
	 * @see {@link takeLast}
	 * @see {@link takeUntil}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
	 *
	 * @param {number} count The maximum number of `next` values to emit.
	 * @return {Observable<T>} An Observable that emits only the first `count`
	 * values emitted by the source Observable, or all of the values from the source
	 * if the source emits fewer than `count` values.
	 * @method take
	 * @owner Observable
	 */
	function take(count) {
	    if (count === 0) {
	        return new EmptyObservable_1.EmptyObservable();
	    }
	    else {
	        return this.lift(new TakeOperator(count));
	    }
	}
	exports.take = take;
	var TakeOperator = (function () {
	    function TakeOperator(total) {
	        this.total = total;
	        if (this.total < 0) {
	            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	        }
	    }
	    TakeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new TakeSubscriber(subscriber, this.total));
	    };
	    return TakeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeSubscriber = (function (_super) {
	    __extends(TakeSubscriber, _super);
	    function TakeSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.count = 0;
	    }
	    TakeSubscriber.prototype._next = function (value) {
	        var total = this.total;
	        if (++this.count <= total) {
	            this.destination.next(value);
	            if (this.count === total) {
	                this.destination.complete();
	                this.unsubscribe();
	            }
	        }
	    };
	    return TakeSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=take.js.map

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(46);
	var subscribeToResult_1 = __webpack_require__(50);
	/**
	 * Emits the values emitted by the source Observable until a `notifier`
	 * Observable emits a value.
	 *
	 * <span class="informal">Lets values pass until a second Observable,
	 * `notifier`, emits something. Then, it completes.</span>
	 *
	 * <img src="./img/takeUntil.png" width="100%">
	 *
	 * `takeUntil` subscribes and begins mirroring the source Observable. It also
	 * monitors a second Observable, `notifier` that you provide. If the `notifier`
	 * emits a value or a complete notification, the output Observable stops
	 * mirroring the source Observable and completes.
	 *
	 * @example <caption>Tick every second until the first click happens</caption>
	 * var interval = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = interval.takeUntil(clicks);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeLast}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @param {Observable} notifier The Observable whose first emitted value will
	 * cause the output Observable of `takeUntil` to stop emitting values from the
	 * source Observable.
	 * @return {Observable<T>} An Observable that emits the values from the source
	 * Observable until such time as `notifier` emits its first value.
	 * @method takeUntil
	 * @owner Observable
	 */
	function takeUntil(notifier) {
	    return this.lift(new TakeUntilOperator(notifier));
	}
	exports.takeUntil = takeUntil;
	var TakeUntilOperator = (function () {
	    function TakeUntilOperator(notifier) {
	        this.notifier = notifier;
	    }
	    TakeUntilOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
	    };
	    return TakeUntilOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeUntilSubscriber = (function (_super) {
	    __extends(TakeUntilSubscriber, _super);
	    function TakeUntilSubscriber(destination, notifier) {
	        _super.call(this, destination);
	        this.notifier = notifier;
	        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
	    }
	    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.complete();
	    };
	    TakeUntilSubscriber.prototype.notifyComplete = function () {
	        // noop
	    };
	    return TakeUntilSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=takeUntil.js.map

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(54);
	var isArray_1 = __webpack_require__(104);
	var isPromise_1 = __webpack_require__(503);
	var Observable_1 = __webpack_require__(20);
	var iterator_1 = __webpack_require__(499);
	var InnerSubscriber_1 = __webpack_require__(484);
	var symbol_observable_1 = __webpack_require__(220);
	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
	    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
	    if (destination.isUnsubscribed) {
	        return;
	    }
	    if (result instanceof Observable_1.Observable) {
	        if (result._isScalar) {
	            destination.next(result.value);
	            destination.complete();
	            return;
	        }
	        else {
	            return result.subscribe(destination);
	        }
	    }
	    if (isArray_1.isArray(result)) {
	        for (var i = 0, len = result.length; i < len && !destination.isUnsubscribed; i++) {
	            destination.next(result[i]);
	        }
	        if (!destination.isUnsubscribed) {
	            destination.complete();
	        }
	    }
	    else if (isPromise_1.isPromise(result)) {
	        result.then(function (value) {
	            if (!destination.isUnsubscribed) {
	                destination.next(value);
	                destination.complete();
	            }
	        }, function (err) { return destination.error(err); })
	            .then(null, function (err) {
	            // Escaping the Promise trap: globally throw unhandled errors
	            root_1.root.setTimeout(function () { throw err; });
	        });
	        return destination;
	    }
	    else if (typeof result[iterator_1.$$iterator] === 'function') {
	        for (var _i = 0, _a = result; _i < _a.length; _i++) {
	            var item = _a[_i];
	            destination.next(item);
	            if (destination.isUnsubscribed) {
	                break;
	            }
	        }
	        if (!destination.isUnsubscribed) {
	            destination.complete();
	        }
	    }
	    else if (typeof result[symbol_observable_1.default] === 'function') {
	        var obs = result[symbol_observable_1.default]();
	        if (typeof obs.subscribe !== 'function') {
	            destination.error('invalid observable');
	        }
	        else {
	            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
	        }
	    }
	    else {
	        destination.error(new TypeError('unknown type returned'));
	    }
	}
	exports.subscribeToResult = subscribeToResult;
	//# sourceMappingURL=subscribeToResult.js.map

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.xy_add = exports.stopPropagation = exports.withMod = exports.withoutMod = exports.args = exports.sw = exports.humanMsg = exports.simpleSpaced = exports.arrayContainsValue = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _powerAssertVisitorKeys = '{"ArrayExpression":["elements"],"AssignmentExpression":["left","right"],"BinaryExpression":["left","right"],"Directive":["value"],"DirectiveLiteral":[],"BlockStatement":["directives","body"],"BreakStatement":["label"],"CallExpression":["callee","arguments"],"CatchClause":["param","body"],"ConditionalExpression":["test","consequent","alternate"],"ContinueStatement":["label"],"DebuggerStatement":[],"DoWhileStatement":["test","body"],"EmptyStatement":[],"ExpressionStatement":["expression"],"File":["program"],"ForInStatement":["left","right","body"],"ForStatement":["init","test","update","body"],"FunctionDeclaration":["id","params","body","returnType","typeParameters"],"FunctionExpression":["id","params","body","returnType","typeParameters"],"Identifier":["typeAnnotation"],"IfStatement":["test","consequent","alternate"],"LabeledStatement":["label","body"],"StringLiteral":[],"NumericLiteral":[],"NullLiteral":[],"BooleanLiteral":[],"RegExpLiteral":[],"LogicalExpression":["left","right"],"MemberExpression":["object","property"],"NewExpression":["callee","arguments"],"Program":["directives","body"],"ObjectExpression":["properties"],"ObjectMethod":["key","params","body","decorators","returnType","typeParameters"],"ObjectProperty":["key","value","decorators"],"RestElement":["argument","typeAnnotation"],"ReturnStatement":["argument"],"SequenceExpression":["expressions"],"SwitchCase":["test","consequent"],"SwitchStatement":["discriminant","cases"],"ThisExpression":[],"ThrowStatement":["argument"],"TryStatement":["block","handler","finalizer"],"UnaryExpression":["argument"],"UpdateExpression":["argument"],"VariableDeclaration":["declarations"],"VariableDeclarator":["id","init"],"WhileStatement":["test","body"],"WithStatement":["object","body"],"AssignmentPattern":["left","right"],"ArrayPattern":["elements","typeAnnotation"],"ArrowFunctionExpression":["params","body","returnType"],"ClassBody":["body"],"ClassDeclaration":["id","body","superClass","mixins","typeParameters","superTypeParameters","implements","decorators"],"ClassExpression":["id","body","superClass","mixins","typeParameters","superTypeParameters","implements","decorators"],"ExportAllDeclaration":["source"],"ExportDefaultDeclaration":["declaration"],"ExportNamedDeclaration":["declaration","specifiers","source"],"ExportSpecifier":["local","exported"],"ForOfStatement":["left","right","body"],"ImportDeclaration":["specifiers","source"],"ImportDefaultSpecifier":["local"],"ImportNamespaceSpecifier":["local"],"ImportSpecifier":["local","imported"],"MetaProperty":["meta","property"],"ClassMethod":["key","params","body","decorators","returnType","typeParameters"],"ObjectPattern":["properties","typeAnnotation"],"SpreadElement":["argument"],"Super":[],"TaggedTemplateExpression":["tag","quasi"],"TemplateElement":[],"TemplateLiteral":["quasis","expressions"],"YieldExpression":["argument"],"AnyTypeAnnotation":[],"ArrayTypeAnnotation":["elementType"],"BooleanTypeAnnotation":[],"BooleanLiteralTypeAnnotation":[],"NullLiteralTypeAnnotation":[],"ClassImplements":["id","typeParameters"],"ClassProperty":["key","value","typeAnnotation","decorators"],"DeclareClass":["id","typeParameters","extends","body"],"DeclareFunction":["id"],"DeclareInterface":["id","typeParameters","extends","body"],"DeclareModule":["id","body"],"DeclareTypeAlias":["id","typeParameters","right"],"DeclareVariable":["id"],"ExistentialTypeParam":[],"FunctionTypeAnnotation":["typeParameters","params","rest","returnType"],"FunctionTypeParam":["name","typeAnnotation"],"GenericTypeAnnotation":["id","typeParameters"],"InterfaceExtends":["id","typeParameters"],"InterfaceDeclaration":["id","typeParameters","extends","body"],"IntersectionTypeAnnotation":["types"],"MixedTypeAnnotation":[],"NullableTypeAnnotation":["typeAnnotation"],"NumericLiteralTypeAnnotation":[],"NumberTypeAnnotation":[],"StringLiteralTypeAnnotation":[],"StringTypeAnnotation":[],"ThisTypeAnnotation":[],"TupleTypeAnnotation":["types"],"TypeofTypeAnnotation":["argument"],"TypeAlias":["id","typeParameters","right"],"TypeAnnotation":["typeAnnotation"],"TypeCastExpression":["expression","typeAnnotation"],"TypeParameter":["bound"],"TypeParameterDeclaration":["params"],"TypeParameterInstantiation":["params"],"ObjectTypeAnnotation":["properties","indexers","callProperties"],"ObjectTypeCallProperty":["value"],"ObjectTypeIndexer":["id","key","value"],"ObjectTypeProperty":["key","value"],"QualifiedTypeIdentifier":["id","qualification"],"UnionTypeAnnotation":["types"],"VoidTypeAnnotation":[],"JSXAttribute":["name","value"],"JSXClosingElement":["name"],"JSXElement":["openingElement","children","closingElement"],"JSXEmptyExpression":[],"JSXExpressionContainer":["expression"],"JSXIdentifier":[],"JSXMemberExpression":["object","property"],"JSXNamespacedName":["namespace","name"],"JSXOpeningElement":["name","attributes"],"JSXSpreadAttribute":["argument"],"JSXText":[],"Noop":[],"ParenthesizedExpression":["expression"],"AwaitExpression":["argument"],"BindExpression":["object","callee"],"Decorator":["expression"],"DoExpression":["body"],"ExportDefaultSpecifier":["exported"],"ExportNamespaceSpecifier":["exported"],"RestProperty":["argument"],"SpreadProperty":["argument"]}',
	    _powerAssertRecorder = function () { function PowerAssertRecorder() { this.captured = []; } PowerAssertRecorder.prototype._capt = function _capt(value, espath) { this.captured.push({ value: value, espath: espath }); return value; }; PowerAssertRecorder.prototype._expr = function _expr(value, source) { return { powerAssertContext: { value: value, events: this.captured }, source: source }; }; return PowerAssertRecorder; }(); ////////////////////////////////////////////////////////////////////////////////
	// Schema Data Types                                                          //
	////////////////////////////////////////////////////////////////////////////////
	
	exports.mapOptionalArray = mapOptionalArray;
	exports.wrapInArray = wrapInArray;
	exports.parseCardinality = parseCardinality;
	exports.stringifyCardinality = stringifyCardinality;
	exports.normalizeToRange = normalizeToRange;
	exports.setDefault = setDefault;
	exports.definePropertyByValue = definePropertyByValue;
	exports.definePropertiesByValue = definePropertiesByValue;
	exports.callOrReturn = callOrReturn;
	exports.which = which;
	
	var _isUndefined = __webpack_require__(344);
	
	var _isUndefined2 = _interopRequireDefault(_isUndefined);
	
	var _trim = __webpack_require__(348);
	
	var _trim2 = _interopRequireDefault(_trim);
	
	var _isString = __webpack_require__(187);
	
	var _isString2 = _interopRequireDefault(_isString);
	
	var _isArray = __webpack_require__(186);
	
	var _isArray2 = _interopRequireDefault(_isArray);
	
	var _isNumber = __webpack_require__(63);
	
	var _isNumber2 = _interopRequireDefault(_isNumber);
	
	var _isObject = __webpack_require__(341);
	
	var _isObject2 = _interopRequireDefault(_isObject);
	
	var _isFunction = __webpack_require__(79);
	
	var _isFunction2 = _interopRequireDefault(_isFunction);
	
	var _isSet = __webpack_require__(343);
	
	var _isSet2 = _interopRequireDefault(_isSet);
	
	var _isWeakSet = __webpack_require__(345);
	
	var _isWeakSet2 = _interopRequireDefault(_isWeakSet);
	
	var _entries2 = __webpack_require__(185);
	
	var _entries3 = _interopRequireDefault(_entries2);
	
	var _rearg = __webpack_require__(483);
	
	var _rearg2 = _interopRequireDefault(_rearg);
	
	var _boundNativeMethods = __webpack_require__(162);
	
	var _filter = __webpack_require__(16);
	
	var _zip3 = __webpack_require__(210);
	
	var _zip4 = _interopRequireDefault(_zip3);
	
	var _powerAssert = __webpack_require__(69);
	
	var _powerAssert2 = _interopRequireDefault(_powerAssert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	////////////////////////////////////////////////////////////////////////////////
	
	var arrayContainsValue = exports.arrayContainsValue = function arrayContainsValue(array, value) {
		return array.includes(value);
	};
	
	var simpleSpaced = exports.simpleSpaced = function simpleSpaced(str) {
		return str.replace(/\s+/mg, ' ');
	};
	
	var humanMsg = exports.humanMsg = function humanMsg(strings) {
		var _context;
	
		for (var _len = arguments.length, vals = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			vals[_key - 1] = arguments[_key];
		}
	
		var result = strings[0];
		_zip2 = (0, _zip4.default)(vals, strings.slice(1));
	
		if (!(_zip2 && (typeof _zip2[Symbol.iterator] === 'function' || Array.isArray(_zip2)))) {
			throw new TypeError('Expected _zip2 to be iterable, got ' + _inspect(_zip2));
		}
	
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;
	
		try {
			for (var _iterator = _zip2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var _zip2;
	
				var _step$value = _slicedToArray(_step.value, 2);
	
				var val = _step$value[0];
				var str = _step$value[1];
	
				result += val + simpleSpaced(str);
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	
		return (_context = result, _trim2.default).call(_context);
	};
	
	function mapOptionalArray(val, fn) {
		var _context2;
	
		if ((_context2 = val, _isUndefined2.default).call(_context2)) {
			return [];
		}
		var isArr = (_context2 = val, _isArray2.default).call(_context2);
		val = (isArr ? val : [val]).map(fn);
		return isArr ? val : val[0];
	}
	
	function wrapInArray(val) {
		if (_isUndefined2.default.call(val)) {
			return [];
		}
		if (_isArray2.default.call(val) || _isSet2.default.call(val) || _isWeakSet2.default.call(val)) {
			return [].concat(_toConsumableArray(val));
		}
		return [val];
	}
	
	function parseCardinality(val) {
		var _rec = new _powerAssertRecorder(),
		    _rec2 = new _powerAssertRecorder();
	
		(0, _powerAssert2.default)(_rec._expr(_rec._capt(_isString2.default.call(val), 'arguments/0'), {
			content: 'assert(val::isString(), `\n\t\tA cardinality range has to be a string,\n\t\tbut a value ${ JSON.stringify(val) } was given.\n\t`)',
			filepath: 'src/util/misc.js',
			line: 55,
			ast: '{"type":"CallExpression","callee":{"type":"Identifier","name":"assert","range":[0,6]},"arguments":[{"type":"CallExpression","callee":{"type":"BindExpression","object":{"type":"Identifier","name":"val","range":[7,10]},"callee":{"type":"Identifier","name":"isString","range":[12,20]},"range":[7,20]},"arguments":[],"range":[7,22]},{"type":"TemplateLiteral","quasis":[{"type":"TemplateElement","value":{"raw":"\\n\\t\\tA cardinality range has to be a string,\\n\\t\\tbut a value ","cooked":"\\n\\t\\tA cardinality range has to be a string,\\n\\t\\tbut a value "},"tail":false,"range":[25,14]},{"type":"TemplateElement","value":{"raw":" was given.\\n\\t","cooked":" was given.\\n\\t"},"tail":true,"range":[38,1]}],"expressions":[{"type":"CallExpression","callee":{"type":"MemberExpression","object":{"type":"Identifier","name":"JSON","range":[17,21]},"property":{"type":"Identifier","name":"stringify","range":[22,31]},"computed":false,"range":[17,31]},"arguments":[{"type":"Identifier","name":"val","range":[32,35]}],"range":[17,36]}],"range":[24,2]}],"range":[0,3]}',
			tokens: '[{"type":{"label":"name"},"value":"assert","range":[0,6]},{"type":{"label":"("},"range":[6,7]},{"type":{"label":"name"},"value":"val","range":[7,10]},{"type":{"label":"::"},"value":"::","range":[10,12]},{"type":{"label":"name"},"value":"isString","range":[12,20]},{"type":{"label":"("},"range":[20,21]},{"type":{"label":")"},"range":[21,22]},{"type":{"label":","},"range":[22,23]},{"type":{"label":"`"},"range":[24,25]},{"type":{"label":"template"},"value":"\\n\\t\\tA cardinality range has to be a string,\\n\\t\\tbut a value ","range":[25,14]},{"type":{"label":"${"},"range":[14,16]},{"type":{"label":"name"},"value":"JSON","range":[17,21]},{"type":{"label":"."},"range":[21,22]},{"type":{"label":"name"},"value":"stringify","range":[22,31]},{"type":{"label":"("},"range":[31,32]},{"type":{"label":"name"},"value":"val","range":[32,35]},{"type":{"label":")"},"range":[35,36]},{"type":{"label":"}"},"range":[37,38]},{"type":{"label":"template"},"value":" was given.\\n\\t","range":[38,1]},{"type":{"label":"`"},"range":[1,2]},{"type":{"label":")"},"range":[2,3]}]',
			visitorKeys: _powerAssertVisitorKeys
		}), '\n\t\tA cardinality range has to be a string,\n\t\tbut a value ' + JSON.stringify(val) + ' was given.\n\t');
		var match = val.match(/^(\d+)\.\.(\d+|\*)$/);
		(0, _powerAssert2.default)(_rec2._expr(_rec2._capt(_rec2._capt(match, 'arguments/0/left') && _rec2._capt(_rec2._capt(_rec2._capt(match, 'arguments/0/right/left/object').length, 'arguments/0/right/left') === 3, 'arguments/0/right'), 'arguments/0'), {
			content: 'assert(match && match.length === 3, `\n\t\tA cardinality range has to be in the form "min..max",\n\t\tbut a value ${ JSON.stringify(val) } was given.\n\t`)',
			filepath: 'src/util/misc.js',
			line: 60,
			ast: '{"type":"CallExpression","callee":{"type":"Identifier","name":"assert","range":[0,6]},"arguments":[{"type":"LogicalExpression","operator":"&&","left":{"type":"Identifier","name":"match","range":[7,12]},"right":{"type":"BinaryExpression","operator":"===","left":{"type":"MemberExpression","object":{"type":"Identifier","name":"match","range":[16,21]},"property":{"type":"Identifier","name":"length","range":[22,28]},"computed":false,"range":[16,28]},"right":{"type":"NumericLiteral","value":3,"range":[33,34]},"range":[16,34]},"range":[7,34]},{"type":"TemplateLiteral","quasis":[{"type":"TemplateElement","value":{"raw":"\\n\\t\\tA cardinality range has to be in the form \\"min..max\\",\\n\\t\\tbut a value ","cooked":"\\n\\t\\tA cardinality range has to be in the form \\"min..max\\",\\n\\t\\tbut a value "},"tail":false,"range":[37,14]},{"type":"TemplateElement","value":{"raw":" was given.\\n\\t","cooked":" was given.\\n\\t"},"tail":true,"range":[38,1]}],"expressions":[{"type":"CallExpression","callee":{"type":"MemberExpression","object":{"type":"Identifier","name":"JSON","range":[17,21]},"property":{"type":"Identifier","name":"stringify","range":[22,31]},"computed":false,"range":[17,31]},"arguments":[{"type":"Identifier","name":"val","range":[32,35]}],"range":[17,36]}],"range":[36,2]}],"range":[0,3]}',
			tokens: '[{"type":{"label":"name"},"value":"assert","range":[0,6]},{"type":{"label":"("},"range":[6,7]},{"type":{"label":"name"},"value":"match","range":[7,12]},{"type":{"label":"&&"},"value":"&&","range":[13,15]},{"type":{"label":"name"},"value":"match","range":[16,21]},{"type":{"label":"."},"range":[21,22]},{"type":{"label":"name"},"value":"length","range":[22,28]},{"type":{"label":"==/!="},"value":"===","range":[29,32]},{"type":{"label":"num"},"value":3,"range":[33,34]},{"type":{"label":","},"range":[34,35]},{"type":{"label":"`"},"range":[36,37]},{"type":{"label":"template"},"value":"\\n\\t\\tA cardinality range has to be in the form \\"min..max\\",\\n\\t\\tbut a value ","range":[37,14]},{"type":{"label":"${"},"range":[14,16]},{"type":{"label":"name"},"value":"JSON","range":[17,21]},{"type":{"label":"."},"range":[21,22]},{"type":{"label":"name"},"value":"stringify","range":[22,31]},{"type":{"label":"("},"range":[31,32]},{"type":{"label":"name"},"value":"val","range":[32,35]},{"type":{"label":")"},"range":[35,36]},{"type":{"label":"}"},"range":[37,38]},{"type":{"label":"template"},"value":" was given.\\n\\t","range":[38,1]},{"type":{"label":"`"},"range":[1,2]},{"type":{"label":")"},"range":[2,3]}]',
			visitorKeys: _powerAssertVisitorKeys
		}), '\n\t\tA cardinality range has to be in the form "min..max",\n\t\tbut a value ' + JSON.stringify(val) + ' was given.\n\t');
	
		var _match = _slicedToArray(match, 3);
	
		var min = _match[1];
		var max = _match[2];
	
		if (max === '*') {
			max = Infinity;
		} else {
			max = parseInt(max, 10);
		}
		min = parseInt(min, 10);
		return { min: min, max: max };
	}
	
	function stringifyCardinality(cardinality) {
		var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
		var abbreviate = _ref2.abbreviate;
	
		return cardinality.min === cardinality.max && abbreviate ? '   ' + cardinality.min : cardinality.min + '..' + (cardinality.max === Infinity ? '*' : cardinality.max);
	}
	
	function normalizeToRange(val) {
		var _context3;
	
		if ((_context3 = val, _isNumber2.default).call(_context3)) {
			val = { min: val, max: val };
		} else if (!(_context3 = val, _isObject2.default).call(_context3)) {
			val = {};
		}
		if (!(_context3 = val.min, _isNumber2.default).call(_context3)) {
			val.min = -Infinity;
		}
		if (!(_context3 = val.max, _isNumber2.default).call(_context3)) {
			val.max = Infinity;
		}
		return val;
	}
	
	function setDefault(obj, key, val) {
		var _context4;
	
		if ((_context4 = obj[key], _isUndefined2.default).call(_context4)) {
			obj[key] = val;
		}
	}
	
	var sw = exports.sw = function sw(val) {
		var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
		var _ref3$autoInvoke = _ref3.autoInvoke;
		var autoInvoke = _ref3$autoInvoke === undefined ? true : _ref3$autoInvoke;
		return function (map) {
			var _context5;
	
			var result = val in map ? map[val] : map.default;
			if (autoInvoke && (_context5 = result, _isFunction2.default).call(_context5)) {
				result = result();
			}
			return result;
		};
	};
	
	function definePropertyByValue(key, value) {
		var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	
		_boundNativeMethods.defineProperty.call(this, key, _extends({}, options, { value: value }));
	}
	
	function definePropertiesByValue(obj) {
		var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		_ref = _entries3.default.call(obj);
	
		if (!(_ref && (typeof _ref[Symbol.iterator] === 'function' || Array.isArray(_ref)))) {
			throw new TypeError('Expected _ref to be iterable, got ' + _inspect(_ref));
		}
	
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;
	
		try {
			for (var _iterator2 = _ref[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var _ref;
	
				var _step2$value = _slicedToArray(_step2.value, 2);
	
				var key = _step2$value[0];
				var value = _step2$value[1];
	
				definePropertyByValue.call(this, key, value, options);
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}
	}
	
	function callOrReturn() {
		return _isFunction2.default.call(this) ? this() : this;
	}
	
	// n - number
	// s - string
	// b - boolean
	// f - function
	// O - any Object
	// a - Array
	// d - Date
	// r - RegExp
	// o - other Object (object which isn't Array, Date or RegExp)
	var args = exports.args = function args() {
		for (var _len2 = arguments.length, pattern = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			pattern[_key2] = arguments[_key2];
		}
	
		return function (target, key, descriptor) {
			return _extends({}, descriptor, {
				value: _rearg2.default.expand.apply(_rearg2.default, pattern.concat([descriptor.value]))
			});
		};
	};
	
	var withoutMod = exports.withoutMod = function withoutMod() {
		for (var _len3 = arguments.length, modifiers = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
			modifiers[_key3] = arguments[_key3];
		}
	
		return function (event) {
			return modifiers.every(function (m) {
				return !event[m + 'Key'];
			});
		};
	};
	
	var withMod = exports.withMod = function withMod() {
		for (var _len4 = arguments.length, modifiers = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
			modifiers[_key4] = arguments[_key4];
		}
	
		return function (event) {
			return modifiers.every(function (m) {
				return event[m + 'Key'];
			});
		};
	};
	
	var stopPropagation = exports.stopPropagation = function stopPropagation(event) {
		event.preventDefault();
		event.stopPropagation();
	};
	
	function which(keyCode) {
		return _filter.filter.call(this, function (event) {
			return event.which === keyCode;
		});
	}
	
	var xy_add = exports.xy_add = function xy_add(a, b) {
		return {
			x: a.x + b.x,
			y: a.y + b.y
		};
	};
	
	function _inspect(input, depth) {
		var maxDepth = 4;
		var maxKeys = 15;

		if (depth === undefined) {
			depth = 0;
		}

		depth += 1;

		if (input === null) {
			return 'null';
		} else if (input === undefined) {
			return 'void';
		} else if (typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean') {
			return typeof input === 'undefined' ? 'undefined' : _typeof(input);
		} else if (Array.isArray(input)) {
			if (input.length > 0) {
				var _ret = function () {
					if (depth > maxDepth) return {
							v: '[...]'
						};

					var first = _inspect(input[0], depth);

					if (input.every(function (item) {
						return _inspect(item, depth) === first;
					})) {
						return {
							v: first.trim() + '[]'
						};
					} else {
						return {
							v: '[' + input.slice(0, maxKeys).map(function (item) {
								return _inspect(item, depth);
							}).join(', ') + (input.length >= maxKeys ? ', ...' : '') + ']'
						};
					}
				}();

				if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
			} else {
				return 'Array';
			}
		} else {
			var keys = Object.keys(input);

			if (!keys.length) {
				if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
					return input.constructor.name;
				} else {
					return 'Object';
				}
			}

			if (depth > maxDepth) return '{...}';
			var indent = '  '.repeat(depth - 1);

			var _entries = keys.slice(0, maxKeys).map(function (key) {
				return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + ': ' + _inspect(input[key], depth) + ';';
			}).join('\n  ' + indent);

			if (keys.length >= maxKeys) {
				_entries += '\n  ' + indent + '...';
			}

			if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
				return input.constructor.name + ' {\n  ' + indent + _entries + '\n' + indent + '}';
			} else {
				return '{\n  ' + indent + _entries + '\n' + indent + '}';
			}
		}
	}

/***/ },
/* 52 */,
/* 53 */,
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {"use strict";
	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
	/* tslint:disable:no-unused-variable */
	var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
	var freeGlobal = objectTypes[typeof global] && global;
	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    exports.root = freeGlobal;
	}
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(149)(module), (function() { return this; }())))

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _powerAssertVisitorKeys = "{\"ArrayExpression\":[\"elements\"],\"AssignmentExpression\":[\"left\",\"right\"],\"BinaryExpression\":[\"left\",\"right\"],\"Directive\":[\"value\"],\"DirectiveLiteral\":[],\"BlockStatement\":[\"directives\",\"body\"],\"BreakStatement\":[\"label\"],\"CallExpression\":[\"callee\",\"arguments\"],\"CatchClause\":[\"param\",\"body\"],\"ConditionalExpression\":[\"test\",\"consequent\",\"alternate\"],\"ContinueStatement\":[\"label\"],\"DebuggerStatement\":[],\"DoWhileStatement\":[\"test\",\"body\"],\"EmptyStatement\":[],\"ExpressionStatement\":[\"expression\"],\"File\":[\"program\"],\"ForInStatement\":[\"left\",\"right\",\"body\"],\"ForStatement\":[\"init\",\"test\",\"update\",\"body\"],\"FunctionDeclaration\":[\"id\",\"params\",\"body\",\"returnType\",\"typeParameters\"],\"FunctionExpression\":[\"id\",\"params\",\"body\",\"returnType\",\"typeParameters\"],\"Identifier\":[\"typeAnnotation\"],\"IfStatement\":[\"test\",\"consequent\",\"alternate\"],\"LabeledStatement\":[\"label\",\"body\"],\"StringLiteral\":[],\"NumericLiteral\":[],\"NullLiteral\":[],\"BooleanLiteral\":[],\"RegExpLiteral\":[],\"LogicalExpression\":[\"left\",\"right\"],\"MemberExpression\":[\"object\",\"property\"],\"NewExpression\":[\"callee\",\"arguments\"],\"Program\":[\"directives\",\"body\"],\"ObjectExpression\":[\"properties\"],\"ObjectMethod\":[\"key\",\"params\",\"body\",\"decorators\",\"returnType\",\"typeParameters\"],\"ObjectProperty\":[\"key\",\"value\",\"decorators\"],\"RestElement\":[\"argument\",\"typeAnnotation\"],\"ReturnStatement\":[\"argument\"],\"SequenceExpression\":[\"expressions\"],\"SwitchCase\":[\"test\",\"consequent\"],\"SwitchStatement\":[\"discriminant\",\"cases\"],\"ThisExpression\":[],\"ThrowStatement\":[\"argument\"],\"TryStatement\":[\"block\",\"handler\",\"finalizer\"],\"UnaryExpression\":[\"argument\"],\"UpdateExpression\":[\"argument\"],\"VariableDeclaration\":[\"declarations\"],\"VariableDeclarator\":[\"id\",\"init\"],\"WhileStatement\":[\"test\",\"body\"],\"WithStatement\":[\"object\",\"body\"],\"AssignmentPattern\":[\"left\",\"right\"],\"ArrayPattern\":[\"elements\",\"typeAnnotation\"],\"ArrowFunctionExpression\":[\"params\",\"body\",\"returnType\"],\"ClassBody\":[\"body\"],\"ClassDeclaration\":[\"id\",\"body\",\"superClass\",\"mixins\",\"typeParameters\",\"superTypeParameters\",\"implements\",\"decorators\"],\"ClassExpression\":[\"id\",\"body\",\"superClass\",\"mixins\",\"typeParameters\",\"superTypeParameters\",\"implements\",\"decorators\"],\"ExportAllDeclaration\":[\"source\"],\"ExportDefaultDeclaration\":[\"declaration\"],\"ExportNamedDeclaration\":[\"declaration\",\"specifiers\",\"source\"],\"ExportSpecifier\":[\"local\",\"exported\"],\"ForOfStatement\":[\"left\",\"right\",\"body\"],\"ImportDeclaration\":[\"specifiers\",\"source\"],\"ImportDefaultSpecifier\":[\"local\"],\"ImportNamespaceSpecifier\":[\"local\"],\"ImportSpecifier\":[\"local\",\"imported\"],\"MetaProperty\":[\"meta\",\"property\"],\"ClassMethod\":[\"key\",\"params\",\"body\",\"decorators\",\"returnType\",\"typeParameters\"],\"ObjectPattern\":[\"properties\",\"typeAnnotation\"],\"SpreadElement\":[\"argument\"],\"Super\":[],\"TaggedTemplateExpression\":[\"tag\",\"quasi\"],\"TemplateElement\":[],\"TemplateLiteral\":[\"quasis\",\"expressions\"],\"YieldExpression\":[\"argument\"],\"AnyTypeAnnotation\":[],\"ArrayTypeAnnotation\":[\"elementType\"],\"BooleanTypeAnnotation\":[],\"BooleanLiteralTypeAnnotation\":[],\"NullLiteralTypeAnnotation\":[],\"ClassImplements\":[\"id\",\"typeParameters\"],\"ClassProperty\":[\"key\",\"value\",\"typeAnnotation\",\"decorators\"],\"DeclareClass\":[\"id\",\"typeParameters\",\"extends\",\"body\"],\"DeclareFunction\":[\"id\"],\"DeclareInterface\":[\"id\",\"typeParameters\",\"extends\",\"body\"],\"DeclareModule\":[\"id\",\"body\"],\"DeclareTypeAlias\":[\"id\",\"typeParameters\",\"right\"],\"DeclareVariable\":[\"id\"],\"ExistentialTypeParam\":[],\"FunctionTypeAnnotation\":[\"typeParameters\",\"params\",\"rest\",\"returnType\"],\"FunctionTypeParam\":[\"name\",\"typeAnnotation\"],\"GenericTypeAnnotation\":[\"id\",\"typeParameters\"],\"InterfaceExtends\":[\"id\",\"typeParameters\"],\"InterfaceDeclaration\":[\"id\",\"typeParameters\",\"extends\",\"body\"],\"IntersectionTypeAnnotation\":[\"types\"],\"MixedTypeAnnotation\":[],\"NullableTypeAnnotation\":[\"typeAnnotation\"],\"NumericLiteralTypeAnnotation\":[],\"NumberTypeAnnotation\":[],\"StringLiteralTypeAnnotation\":[],\"StringTypeAnnotation\":[],\"ThisTypeAnnotation\":[],\"TupleTypeAnnotation\":[\"types\"],\"TypeofTypeAnnotation\":[\"argument\"],\"TypeAlias\":[\"id\",\"typeParameters\",\"right\"],\"TypeAnnotation\":[\"typeAnnotation\"],\"TypeCastExpression\":[\"expression\",\"typeAnnotation\"],\"TypeParameter\":[\"bound\"],\"TypeParameterDeclaration\":[\"params\"],\"TypeParameterInstantiation\":[\"params\"],\"ObjectTypeAnnotation\":[\"properties\",\"indexers\",\"callProperties\"],\"ObjectTypeCallProperty\":[\"value\"],\"ObjectTypeIndexer\":[\"id\",\"key\",\"value\"],\"ObjectTypeProperty\":[\"key\",\"value\"],\"QualifiedTypeIdentifier\":[\"id\",\"qualification\"],\"UnionTypeAnnotation\":[\"types\"],\"VoidTypeAnnotation\":[],\"JSXAttribute\":[\"name\",\"value\"],\"JSXClosingElement\":[\"name\"],\"JSXElement\":[\"openingElement\",\"children\",\"closingElement\"],\"JSXEmptyExpression\":[],\"JSXExpressionContainer\":[\"expression\"],\"JSXIdentifier\":[],\"JSXMemberExpression\":[\"object\",\"property\"],\"JSXNamespacedName\":[\"namespace\",\"name\"],\"JSXOpeningElement\":[\"name\",\"attributes\"],\"JSXSpreadAttribute\":[\"argument\"],\"JSXText\":[],\"Noop\":[],\"ParenthesizedExpression\":[\"expression\"],\"AwaitExpression\":[\"argument\"],\"BindExpression\":[\"object\",\"callee\"],\"Decorator\":[\"expression\"],\"DoExpression\":[\"body\"],\"ExportDefaultSpecifier\":[\"exported\"],\"ExportNamespaceSpecifier\":[\"exported\"],\"RestProperty\":[\"argument\"],\"SpreadProperty\":[\"argument\"]}",
	    _powerAssertRecorder = function () { function PowerAssertRecorder() { this.captured = []; } PowerAssertRecorder.prototype._capt = function _capt(value, espath) { this.captured.push({ value: value, espath: espath }); return value; }; PowerAssertRecorder.prototype._expr = function _expr(value, source) { return { powerAssertContext: { value: value, events: this.captured }, source: source }; }; return PowerAssertRecorder; }();
	
	var _templateObject = _taggedTemplateLiteral(["\n\t\t\t\tThe ", " event does not exist.\n\t\t\t"], ["\n\t\t\t\tThe ", " event does not exist.\n\t\t\t"]),
	    _templateObject2 = _taggedTemplateLiteral(["\n\t\t\t\tThe ", " property does not exist.\n\t\t\t"], ["\n\t\t\t\tThe ", " property does not exist.\n\t\t\t"]);
	
	exports.setEquals = setEquals;
	exports.copySetContent = copySetContent;
	
	var _Subject2 = __webpack_require__(108);
	
	var _BehaviorSubject = __webpack_require__(213);
	
	var _merge = __webpack_require__(215);
	
	var _map = __webpack_require__(15);
	
	var _powerAssert = __webpack_require__(69);
	
	var _powerAssert2 = _interopRequireDefault(_powerAssert);
	
	var _misc = __webpack_require__(51);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _extendableBuiltin(cls) {
		function ExtendableBuiltin() {
			var instance = Reflect.construct(cls, Array.from(arguments));
			Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
			return instance;
		}
	
		ExtendableBuiltin.prototype = Object.create(cls.prototype, {
			constructor: {
				value: cls,
				enumerable: false,
				writable: true,
				configurable: true
			}
		});
	
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(ExtendableBuiltin, cls);
		} else {
			ExtendableBuiltin.__proto__ = cls;
		}
	
		return ExtendableBuiltin;
	}
	
	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
	
	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var $$set = Symbol('$$set');
	var $$addSubject = Symbol('$$addSubject');
	var $$deleteSubject = Symbol('$$deleteSubject');
	var $$valueObservable = Symbol('$$valueObservable');
	var $$disableNextReplay = Symbol('$$disableNextReplay');
	
	var AddReplaySubject = function (_Subject) {
		_inherits(AddReplaySubject, _Subject);
	
		function AddReplaySubject(initialSet) {
			var _rec = new _powerAssertRecorder();
	
			_classCallCheck(this, AddReplaySubject);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AddReplaySubject).call(this));
	
			(0, _powerAssert2.default)(_rec._expr(_rec._capt(_rec._capt(initialSet, "arguments/0/object")[_rec._capt(_rec._capt(Symbol, "arguments/0/property/object").iterator, "arguments/0/property")], "arguments/0"), {
				content: "assert(initialSet[Symbol.iterator])",
				filepath: "src/util/ObservableSet.js",
				line: 17,
				ast: "{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"assert\",\"range\":[0,6]},\"arguments\":[{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"initialSet\",\"range\":[7,17]},\"property\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\",\"range\":[18,24]},\"property\":{\"type\":\"Identifier\",\"name\":\"iterator\",\"range\":[25,33]},\"computed\":false,\"range\":[18,33]},\"computed\":true,\"range\":[7,34]}],\"range\":[0,35]}",
				tokens: "[{\"type\":{\"label\":\"name\"},\"value\":\"assert\",\"range\":[0,6]},{\"type\":{\"label\":\"(\"},\"range\":[6,7]},{\"type\":{\"label\":\"name\"},\"value\":\"initialSet\",\"range\":[7,17]},{\"type\":{\"label\":\"[\"},\"range\":[17,18]},{\"type\":{\"label\":\"name\"},\"value\":\"Symbol\",\"range\":[18,24]},{\"type\":{\"label\":\".\"},\"range\":[24,25]},{\"type\":{\"label\":\"name\"},\"value\":\"iterator\",\"range\":[25,33]},{\"type\":{\"label\":\"]\"},\"range\":[33,34]},{\"type\":{\"label\":\")\"},\"range\":[34,35]}]",
				visitorKeys: _powerAssertVisitorKeys
			}));
			_this._setReference = initialSet;
			return _this;
		}
	
		_createClass(AddReplaySubject, [{
			key: "normalSubscribe",
			value: function normalSubscribe() {
				this[$$disableNextReplay] = true;
				return this.subscribe.apply(this, arguments);
			}
			// noinspection JSDuplicatedDeclaration
	
		}, {
			key: "_subscribe",
			value: function _subscribe(subscriber) {
				var subscription = _get(Object.getPrototypeOf(AddReplaySubject.prototype), "_subscribe", this).call(this, subscriber);
				if (subscription && !subscription.isUnsubscribed && !this[$$disableNextReplay]) {
					this._setReference.forEach(subscriber.next.bind(subscriber));
				}
				this[$$disableNextReplay] = false;
				return subscription;
			}
		}]);
	
		return AddReplaySubject;
	}(_Subject2.Subject);
	
	var ObservableSet = function (_extendableBuiltin2) {
		_inherits(ObservableSet, _extendableBuiltin2);
	
		function ObservableSet() {
			var initialContent = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	
			_classCallCheck(this, ObservableSet);
	
			var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(ObservableSet).call(this));
	
			_this2[$$addSubject] = new AddReplaySubject(_this2);
			_this2[$$addSubject].normalSubscribe(_this2.add.bind(_this2));
	
			_this2[$$deleteSubject] = new _Subject2.Subject();
			_this2[$$deleteSubject].subscribe(_this2.delete.bind(_this2));
	
			initialContent.forEach(_this2.add.bind(_this2));
	
			var valueSubject = new _BehaviorSubject.BehaviorSubject(new Set(_this2));
			_this2[$$addSubject].normalSubscribe(function () {
				valueSubject.next(new Set(_this2));
			});
			_this2[$$deleteSubject].subscribe(function () {
				valueSubject.next(new Set(_this2));
			});
			_this2[$$valueObservable] = valueSubject.asObservable();
			return _this2;
		}
	
		_createClass(ObservableSet, [{
			key: "e",
			value: function e(op) {
				switch (op) {
					case 'add':
						{
							return this[$$addSubject];
						}
					case 'delete':
						{
							return this[$$deleteSubject];
						}
					default:
						(0, _powerAssert2.default)(false, (0, _misc.humanMsg)(_templateObject, op));
				}
			}
		}, {
			key: "p",
			value: function p(name) {
				switch (name) {
					case 'value':
						{
							return this[$$valueObservable];
						}
					default:
						(0, _powerAssert2.default)(false, (0, _misc.humanMsg)(_templateObject2, name));
				}
			}
		}, {
			key: "add",
			value: function add(obj) {
				if (!this.has(obj)) {
					_get(Object.getPrototypeOf(ObservableSet.prototype), "add", this).call(this, obj);
					this.e('add').next(obj);
				}
				return this;
			}
		}, {
			key: "delete",
			value: function _delete(obj) {
				if (this.has(obj)) {
					_get(Object.getPrototypeOf(ObservableSet.prototype), "delete", this).call(this, obj);
					this.e('delete').next(obj);
					return true;
				}
				return false;
			}
		}, {
			key: "clear",
			value: function clear() {
				_ref = this;
	
				if (!(_ref && (typeof _ref[Symbol.iterator] === 'function' || Array.isArray(_ref)))) {
					throw new TypeError("Expected _ref to be iterable, got " + _inspect(_ref));
				}
	
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
	
				try {
					for (var _iterator = _ref[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var _ref;
	
						var value = _step.value;
						this.delete(value);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
	
				return this;
			}
		}]);
	
		return ObservableSet;
	}(_extendableBuiltin(Set));
	
	exports.default = ObservableSet;
	function setEquals(setA, setB) {
		setA = new Set(setA);
		setB = new Set(setB);
		if (setA.size !== setB.size) return false;
	
		if (!(setA && (typeof setA[Symbol.iterator] === 'function' || Array.isArray(setA)))) {
			throw new TypeError("Expected setA to be iterable, got " + _inspect(setA));
		}
	
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;
	
		try {
			for (var _iterator2 = setA[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var a = _step2.value;
				if (!setB.has(a)) return false;
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}
	
		return true;
	}
	
	function copySetContent(reference, newContent) {
		newContent = new Set(newContent);
	
		if (!(reference && (typeof reference[Symbol.iterator] === 'function' || Array.isArray(reference)))) {
			throw new TypeError("Expected reference to be iterable, got " + _inspect(reference));
		}
	
		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;
	
		try {
			for (var _iterator3 = reference[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var e = _step3.value;
	
				if (!newContent.has(e)) {
					reference.delete(e);
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}
	
		if (!(newContent && (typeof newContent[Symbol.iterator] === 'function' || Array.isArray(newContent)))) {
			throw new TypeError("Expected newContent to be iterable, got " + _inspect(newContent));
		}
	
		var _iteratorNormalCompletion4 = true;
		var _didIteratorError4 = false;
		var _iteratorError4 = undefined;
	
		try {
			for (var _iterator4 = newContent[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
				var _e = _step4.value;
	
				if (!reference.has(_e)) {
					reference.add(_e);
				}
			}
		} catch (err) {
			_didIteratorError4 = true;
			_iteratorError4 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion4 && _iterator4.return) {
					_iterator4.return();
				}
			} finally {
				if (_didIteratorError4) {
					throw _iteratorError4;
				}
			}
		}
	}
	
	function _inspect(input, depth) {
		var maxDepth = 4;
		var maxKeys = 15;

		if (depth === undefined) {
			depth = 0;
		}

		depth += 1;

		if (input === null) {
			return 'null';
		} else if (input === undefined) {
			return 'void';
		} else if (typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean') {
			return typeof input === "undefined" ? "undefined" : _typeof(input);
		} else if (Array.isArray(input)) {
			if (input.length > 0) {
				var _ret = function () {
					if (depth > maxDepth) return {
							v: '[...]'
						};

					var first = _inspect(input[0], depth);

					if (input.every(function (item) {
						return _inspect(item, depth) === first;
					})) {
						return {
							v: first.trim() + '[]'
						};
					} else {
						return {
							v: '[' + input.slice(0, maxKeys).map(function (item) {
								return _inspect(item, depth);
							}).join(', ') + (input.length >= maxKeys ? ', ...' : '') + ']'
						};
					}
				}();

				if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
			} else {
				return 'Array';
			}
		} else {
			var keys = Object.keys(input);

			if (!keys.length) {
				if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
					return input.constructor.name;
				} else {
					return 'Object';
				}
			}

			if (depth > maxDepth) return '{...}';
			var indent = '  '.repeat(depth - 1);
			var entries = keys.slice(0, maxKeys).map(function (key) {
				return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + ': ' + _inspect(input[key], depth) + ';';
			}).join('\n  ' + indent);

			if (keys.length >= maxKeys) {
				entries += '\n  ' + indent + '...';
			}

			if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
				return input.constructor.name + ' {\n  ' + indent + entries + '\n' + indent + '}';
			} else {
				return '{\n  ' + indent + entries + '\n' + indent + '}';
			}
		}
	}

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(57)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 57 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 58 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.2.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-05-20T17:23Z
	 */
	
	(function( global, factory ) {
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];
	
	var document = window.document;
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var support = {};
	
	
	
	var
		version = "2.2.4",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
	
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// Start with an empty selector
		selector: "",
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?
	
				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :
	
				// Return all the elements in a clean array
				slice.call( this );
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor();
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
	
			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {
	
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {
	
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend( {
	
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
	
			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
		},
	
		isPlainObject: function( obj ) {
			var key;
	
			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}
	
			// Not own constructor property must be Object
			if ( obj.constructor &&
					!hasOwn.call( obj, "constructor" ) &&
					!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
				return false;
			}
	
			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for ( key in obj ) {}
	
			return key === undefined || hasOwn.call( obj, key );
		},
	
		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
	
			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;
	
			code = jQuery.trim( code );
	
			if ( code ) {
	
				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf( "use strict" ) === 1 ) {
					script = document.createElement( "script" );
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {
	
					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval
	
					indirect( code );
				}
			}
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		each: function( obj, callback ) {
			var length, i = 0;
	
			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );
	
	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	/* jshint ignore: end */
	
	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );
	
	function isArrayLike( obj ) {
	
		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.1
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-10-17
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
		rescape = /'|\\/g,
	
		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, nidselect, match, groups, newSelector,
			newContext = context && context.ownerDocument,
	
			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;
	
		results = results || [];
	
		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
	
			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;
	
			if ( documentIsHTML ) {
	
				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
	
					// ID selector
					if ( (m = match[1]) ) {
	
						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {
	
								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}
	
						// Element context
						} else {
	
							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {
	
								results.push( elem );
								return results;
							}
						}
	
					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;
	
					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {
	
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}
	
				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
	
					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;
	
					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {
	
						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rescape, "\\$&" );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}
	
						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
						while ( i-- ) {
							groups[i] = nidselect + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );
	
						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}
	
					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");
	
		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );
	
		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( (parent = document.defaultView) && parent.top !== parent ) {
			// Support: IE 11
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );
	
			// Support: IE 9 - 10 only
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( document.createComment("") );
			return !div.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {
	
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
	
								// Seek `elem` from a previously-cached index
	
								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});
	
								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});
	
									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}
	
								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {
	
										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {
	
											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});
	
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});
	
												uniqueCache[ type ] = [ dirruns, diff ];
											}
	
											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},
	
			"disabled": function( elem ) {
				return elem.disabled === true;
			},
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
	
							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
	
							if ( (oldCache = uniqueCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ dir ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}
	
				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;
	
				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {
	
			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	
	
	
	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;
	
		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};
	
	
	var siblings = function( n, elem ) {
		var matched = [];
	
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}
	
		return matched;
	};
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
	
		}
	
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
	
		}
	
		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}
	
			qualifier = jQuery.filter( qualifier, elements );
		}
	
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};
	
	jQuery.fn.extend( {
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	
		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
	
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );
	
						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {
	
							// Inject the element directly into the jQuery object
							this.length = 1;
							this[ 0 ] = elem;
						}
	
						this.context = document;
						this.selector = selector;
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[ 0 ] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :
	
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;
	
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
	
					// Always skip document fragments
					if ( cur.nodeType < 11 && ( pos ?
						pos.index( cur ) > -1 :
	
						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {
	
						matched.push( cur );
						break;
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );
	
	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
	
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );
	
	
	
	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
	
			// Last fire value for non-forgettable lists
			memory,
	
			// Flag to know if list was already fired
			fired,
	
			// Flag to prevent firing
			locked,
	
			// Actual callback list
			list = [],
	
			// Queue of execution data for repeatable lists
			queue = [],
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
			// Fire callbacks
			fire = function() {
	
				// Enforce single-firing
				locked = options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {
	
						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if ( locked ) {
	
					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];
	
					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
	
						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}
	
						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
	
									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );
	
						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
	
							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	jQuery.extend( {
	
		Deferred: function( func ) {
			var tuples = [
	
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
	
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this === promise ? newDefer.promise() : this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Keep pipe for back-compat
			promise.pipe = promise.then;
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];
	
				// promise[ done | fail | progress ] = list.add
				promise[ tuple[ 1 ] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add( function() {
	
						// state = [ resolved | rejected ]
						state = stateString;
	
					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}
	
				// deferred[ resolve | reject | notify ]
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,
	
				// the count of uncompleted subordinates
				remaining = length !== 1 ||
					( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
	
				// the master Deferred.
				// If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
	
				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},
	
				progressValues, progressContexts, resolveContexts;
	
			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.progress( updateFunc( i, progressContexts, progressValues ) )
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject );
					} else {
						--remaining;
					}
				}
			}
	
			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}
	
			return deferred.promise();
		}
	} );
	
	
	// The deferred used on DOM ready
	var readyList;
	
	jQuery.fn.ready = function( fn ) {
	
		// Add the callback
		jQuery.ready.promise().done( fn );
	
		return this;
	};
	
	jQuery.extend( {
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
	
			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	} );
	
	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}
	
	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {
	
			readyList = jQuery.Deferred();
	
			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if ( document.readyState === "complete" ||
				( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
	
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout( jQuery.ready );
	
			} else {
	
				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed );
	
				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed );
			}
		}
		return readyList.promise( obj );
	};
	
	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
	
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}
	
		return chainable ?
			elems :
	
			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {
	
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	
	
	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	
	Data.prototype = {
	
		register: function( owner, initial ) {
			var value = initial || {};
	
			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if ( owner.nodeType ) {
				owner[ this.expando ] = value;
	
			// Otherwise secure it in a non-enumerable, non-writable property
			// configurability must be true to allow the property to be
			// deleted with the delete operator
			} else {
				Object.defineProperty( owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				} );
			}
			return owner[ this.expando ];
		},
		cache: function( owner ) {
	
			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( !acceptData( owner ) ) {
				return {};
			}
	
			// Check if the owner object already has a cache
			var value = owner[ this.expando ];
	
			// If not, create one
			if ( !value ) {
				value = {};
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {
	
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;
	
					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}
	
			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );
	
			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
	
				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
				owner[ this.expando ] && owner[ this.expando ][ key ];
		},
		access: function( owner, key, value ) {
			var stored;
	
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {
	
				stored = this.get( owner, key );
	
				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase( key ) );
			}
	
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				cache = owner[ this.expando ];
	
			if ( cache === undefined ) {
				return;
			}
	
			if ( key === undefined ) {
				this.register( owner );
	
			} else {
	
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
	
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );
	
					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {
	
						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}
	
				i = name.length;
	
				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}
	
			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
	
				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();
	
	var dataUser = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
	
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch ( e ) {}
	
				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );
	
	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );
	
					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}
	
			return access( this, function( value ) {
				var data, camelKey;
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
	
					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get( elem, key ) ||
	
						// Try to find dashed key if it exists (gh-2779)
						// This is for 2.2.x only
						dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );
	
					if ( data !== undefined ) {
						return data;
					}
	
					camelKey = jQuery.camelCase( key );
	
					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				camelKey = jQuery.camelCase( key );
				this.each( function() {
	
					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get( this, camelKey );
	
					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set( this, camelKey, value );
	
					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
						dataUser.set( this, key, value );
					}
				} );
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );
	
	
	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );
	
	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}
	
			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
	
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
	
	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
	
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHidden = function( elem, el ) {
	
			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" ||
				!jQuery.contains( elem.ownerDocument, elem );
		};
	
	
	
	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() { return tween.cur(); } :
				function() { return jQuery.css( elem, prop, "" ); },
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );
	
		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
	
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];
	
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
	
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
	
			do {
	
				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";
	
				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );
	
			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}
	
		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;
	
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = ( /^(?:checkbox|radio)$/i );
	
	var rtagName = ( /<([\w:-]+)/ );
	
	var rscriptType = ( /^$|\/(?:java|ecma)script/i );
	
	
	
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
	
		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
		_default: [ 0, "", "" ]
	};
	
	// Support: IE9
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	
	function getAll( context, tag ) {
	
		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];
	
		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}
	
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	
	var rhtml = /<|&#?\w+;/;
	
	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			elem = elems[ i ];
	
			if ( elem || elem === 0 ) {
	
				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
	
					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );
	
				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
	
					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
	
					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}
	
					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );
	
					// Remember the top-level container
					tmp = fragment.firstChild;
	
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
	
		// Remove wrapper from fragment
		fragment.textContent = "";
	
		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {
	
			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}
	
			contains = jQuery.contains( elem.ownerDocument, elem );
	
			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );
	
			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}
	
			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}
	
		return fragment;
	}
	
	
	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;
	
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
	
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
	
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}
	
		if ( data == null && fn == null ) {
	
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
	
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
	
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}
	
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
	
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
	
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {
	
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
	
			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},
	
		dispatch: function( event ) {
	
			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );
	
			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}
	
			return handlerQueue;
		},
	
		// Includes some event props shared by KeyEvent and MouseEvent
		props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
			"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),
	
		fixHooks: {},
	
		keyHooks: {
			props: "char charCode key keyCode".split( " " ),
			filter: function( event, original ) {
	
				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}
	
				return event;
			}
		},
	
		mouseHooks: {
			props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
				"screenX screenY toElement" ).split( " " ),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;
	
				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;
	
					event.pageX = original.clientX +
						( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
						( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY +
						( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
						( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}
	
				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}
	
				return event;
			}
		},
	
		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}
	
			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];
	
			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
	
			event = new jQuery.Event( originalEvent );
	
			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}
	
			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}
	
			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}
	
			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},
	
		special: {
			load: {
	
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
	
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
	
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
	
		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};
	
	jQuery.Event = function( src, props ) {
	
		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
	
					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );
	
	jQuery.fn.extend( {
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
	
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
	
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
	
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );
	
	
	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
	
		// Support: IE 10-11, Edge 10240+
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
	
			elem.getElementsByTagName( "tbody" )[ 0 ] ||
				elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
			elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}
	
		return elem;
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			dataUser.set( dest, udataCur );
		}
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	function domManip( collection, args, callback, ignored ) {
	
		// Flatten any nested arrays
		args = concat.apply( [], args );
	
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );
	
		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}
	
		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;
	
			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}
	
			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;
	
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;
	
					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );
	
						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
	
							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}
	
					callback.call( collection[ i ], node, i );
				}
	
				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;
	
					// Reenable scripts
					jQuery.map( scripts, restoreScript );
	
					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {
	
							if ( node.src ) {
	
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}
	
		return collection;
	}
	
	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;
	
		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}
	
			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}
	
		return elem;
	}
	
	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},
	
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {
	
						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );
	
	jQuery.fn.extend( {
	
		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,
	
		detach: function( selector ) {
			return remove( this, selector, true );
		},
	
		remove: function( selector ) {
			return remove( this, selector );
		},
	
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},
	
		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},
	
		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},
	
		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = jQuery.htmlPrefilter( value );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var ignored = [];
	
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;
	
				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}
	
			// Force callback invocation
			}, ignored );
		}
	} );
	
	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	} );
	
	
	var iframe,
		elemdisplay = {
	
			// Support: Firefox
			// We have to pre-define these values for FF (#10227)
			HTML: "block",
			BODY: "block"
		};
	
	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */
	
	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
	
			display = jQuery.css( elem[ 0 ], "display" );
	
		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();
	
		return display;
	}
	
	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];
	
		if ( !display ) {
			display = actualDisplay( nodeName, doc );
	
			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {
	
				// Use the already-created iframe if possible
				iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
					.appendTo( doc.documentElement );
	
				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;
	
				// Support: IE
				doc.write();
				doc.close();
	
				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}
	
			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}
	
		return display;
	}
	var rmargin = ( /^margin/ );
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
	
			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if ( !view || !view.opener ) {
				view = window;
			}
	
			return view.getComputedStyle( elem );
		};
	
	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	var documentElement = document.documentElement;
	
	
	
	( function() {
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}
	
		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =
	
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );
	
			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";
	
			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";
	
			documentElement.removeChild( container );
		}
	
		jQuery.extend( support, {
			pixelPosition: function() {
	
				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
	
				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
	
				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function() {
	
				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );
	
				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
	
					// Support: Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;box-sizing:content-box;" +
					"display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild( container );
	
				ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );
	
				documentElement.removeChild( container );
				div.removeChild( marginDiv );
	
				return ret;
			}
		} );
	} )();
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;
	
		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}
	
		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
	
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
	
			// Support: IE9-11+
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
	
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
	
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}
	
	
	var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}
	
	function setPositiveNumber( elem, value, subtract ) {
	
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
	
			// If we already have the right measurement, avoid augmentation
			4 :
	
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
	
			val = 0;
	
		for ( ; i < 4; i += 2 ) {
	
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
	
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
	
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
	
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;
	
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			values[ index ] = dataPriv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {
	
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}
	
				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = dataPriv.access(
						elem,
						"olddisplay",
						defaultDisplay( elem.nodeName )
					);
				}
			} else {
				hidden = isHidden( elem );
	
				if ( display !== "none" || !hidden ) {
					dataPriv.set(
						elem,
						"olddisplay",
						hidden ? display : jQuery.css( elem, "display" )
					);
				}
			}
		}
	
		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}
	
		return elements;
	}
	
	jQuery.extend( {
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );
	
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}
	
				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {
	
					style[ name ] = value;
				}
	
			} else {
	
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
	
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );
	
	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
						elem.offsetWidth === 0 ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);
	
				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {
	
					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}
	
				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );
	
	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);
	
	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );
	
	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each( function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
	
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
	
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back Compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );
	
		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always( function() {
	
				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}
	
		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
	
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );
	
			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
	
			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	
		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
	
			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}
	
		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", {} );
			}
	
			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done( function() {
					jQuery( elem ).hide();
				} );
			}
			anim.done( function() {
				var prop;
	
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
	
				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}
	
		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
			style.display = display;
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	
					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ] );
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
	
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length ; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilters: [ defaultPrefilter ],
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {
	
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );
	
	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );
	
	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
	
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		window.clearInterval( timerId );
	
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
	
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};
	
	
	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;
	
		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();
	
	
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );
	
	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}
	
			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}
	
			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}
	
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				elem.setAttribute( name, value + "" );
				return value;
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			ret = jQuery.find.attr( elem, name );
	
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					propName = jQuery.propFix[ name ] || name;
	
					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {
	
						// Set corresponding property to false
						elem[ propName ] = false;
					}
	
					elem.removeAttribute( name );
				}
			}
		}
	} );
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
	
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
	
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	} );
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );
	
	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				return ( elem[ name ] = value );
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			return elem[ name ];
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
	
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},
	
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );
	
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	
	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );
	
	
	
	
	var rclass = /[\t\r\n\f]/g;
	
	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}
	
	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
	
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
	
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}
	
			return this.each( function() {
				var className, i, self, classNames;
	
				if ( type === "string" ) {
	
					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];
	
					while ( ( className = classNames[ i++ ] ) ) {
	
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {
	
						// Store className if set
						dataPriv.set( this, "__className__", className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},
	
		hasClass: function( selector ) {
			var className, elem,
				i = 0;
	
			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}
	
			return false;
		}
	} );
	
	
	
	
	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;
	
	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}
	
					ret = elem.value;
	
					return typeof ret === "string" ?
	
						// Handle most common string cases
						ret.replace( rreturn, "" ) :
	
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each( function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );
	
	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {
	
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
	
						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
	
								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ?
									!option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );
	
	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	
	jQuery.extend( jQuery.event, {
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf( "." ) > -1 ) {
	
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);
	
			jQuery.event.trigger( e, null, elem );
		}
	
	} );
	
	jQuery.fn.extend( {
	
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );
	
	
	jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
		function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );
	
	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );
	
	
	
	
	support.focusin = "onfocusin" in window;
	
	
	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );
	
					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;
	
	var nonce = jQuery.now();
	
	var rquery = ( /\?/ );
	
	
	
	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE9
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
	
				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {
	
					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
	
					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
	
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
	
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
	
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend( {
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
	
				// URL without anti-cache param
				cacheURL,
	
				// Response headers
				responseHeadersString,
				responseHeaders,
	
				// timeout handle
				timeoutTimer,
	
				// Url cleanup var
				urlAnchor,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				// Loop variable
				i,
	
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
	
				// Callbacks context
				callbackContext = s.context || s,
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,
	
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),
	
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
	
				// The jqXHR state
				state = 0,
	
				// Default abort message
				strAbort = "canceled",
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
	
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
	
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;
	
			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
				.replace( rprotocol, location.protocol + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
	
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );
	
				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
	
					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {
	
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
	
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?
	
						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :
	
						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
	
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
	
				// If request was aborted inside ajaxSend, stop there
				if ( state === 2 ) {
					return jqXHR;
				}
	
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}
	
				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
	
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
	
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Called once
				if ( state === 2 ) {
					return;
				}
	
				// State is "done" now
				state = 2;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
	
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
	
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,
	
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		} );
	};
	
	
	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;
	
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapAll( html.call( this, i ) );
				} );
			}
	
			if ( this[ 0 ] ) {
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map( function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				} ).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}
	
			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			} );
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},
	
		unwrap: function() {
			return this.parent().each( function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			} ).end();
		}
	} );
	
	
	jQuery.expr.filters.hidden = function( elem ) {
		return !jQuery.expr.filters.visible( elem );
	};
	jQuery.expr.filters.visible = function( elem ) {
	
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};
	
	
	
	
	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
	
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
	
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
	
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
	
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
	
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
	
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};
	
		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );
	
		} else {
	
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};
	
	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {
	
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();
	
				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};
	
	var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();
	
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
	
									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
	
										// Support: IE9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );
	
					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
	
							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {
	
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}
	
					// Create the abort callback
					callback = callback( "abort" );
	
					try {
	
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
	
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
	
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// Force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always( function() {
	
				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );
	
				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}
	
				// Save back as free
				if ( s[ callbackName ] ) {
	
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			} );
	
			// Delegate to script
			return "script";
		}
	} );
	
	
	
	
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;
	
		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}
	
		parsed = buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	// Keep a copy of the old load method
	var _load = jQuery.fn.load;
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}
	
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );
	
		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,
	
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );
	
	
	
	
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};
	
	
	
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
	
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend( {
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}
	
			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;
	
			if ( !doc ) {
				return;
			}
	
			docElem = doc.documentElement;
	
			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}
	
			box = elem.getBoundingClientRect();
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
	
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
	
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;
	
				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || documentElement;
			} );
		}
	} );
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );
	
	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {
	
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
	
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		} );
	} );
	
	
	jQuery.fn.extend( {
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
	
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},
		size: function() {
			return this.length;
		}
	} );
	
	jQuery.fn.andSelf = jQuery.fn.addBack;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}
	
	return jQuery;
	}));


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(44);
	
	module.exports = function isNumber() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 64 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array ? array.length : 0,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}
	
	module.exports = arrayMap;


/***/ },
/* 65 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	module.exports = isIndex;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(19),
	    isSymbol = __webpack_require__(45);
	
	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;
	
	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}
	
	module.exports = isKey;


/***/ },
/* 67 */
/***/ function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}
	
	module.exports = eq;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(19),
	    isObjectLike = __webpack_require__(12);
	
	/** `Object#toString` result references. */
	var stringTag = '[object String]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
	}
	
	module.exports = isString;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * power-assert.js - Power Assert in JavaScript.
	 *
	 * https://github.com/power-assert-js/power-assert
	 *
	 * Copyright (c) 2013-2016 Takuto Wada
	 * Licensed under the MIT license.
	 *   https://github.com/power-assert-js/power-assert/blob/master/MIT-LICENSE.txt
	 */
	'use strict';
	
	var baseAssert = __webpack_require__(242);
	var _deepEqual = __webpack_require__(514);
	var empower = __webpack_require__(322);
	var formatter = __webpack_require__(473);
	var extend = __webpack_require__(516);
	var define = __webpack_require__(315);
	var empowerOptions = {
	    modifyMessageOnRethrow: true,
	    saveContextOnRethrow: true
	};
	
	if (typeof baseAssert.deepStrictEqual !== 'function') {
	    baseAssert.deepStrictEqual = function deepStrictEqual (actual, expected, message) {
	        if (!_deepEqual(actual, expected, true)) {
	            baseAssert.fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
	        }
	    };
	}
	if (typeof baseAssert.notDeepStrictEqual !== 'function') {
	    baseAssert.notDeepStrictEqual = function notDeepStrictEqual (actual, expected, message) {
	        if (_deepEqual(actual, expected, true)) {
	            baseAssert.fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	        }
	    };
	}
	
	function customize (customOptions) {
	    var options = customOptions || {};
	    var poweredAssert = empower(
	        baseAssert,
	        formatter(options.output),
	        extend(empowerOptions, options.assertion)
	    );
	    poweredAssert.customize = customize;
	    return poweredAssert;
	}
	
	var defaultAssert = customize();
	define(defaultAssert, { '__esModule': true });
	defaultAssert['default'] = defaultAssert;
	module.exports = defaultAssert;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(104);
	var isObject_1 = __webpack_require__(502);
	var isFunction_1 = __webpack_require__(218);
	var tryCatch_1 = __webpack_require__(147);
	var errorObject_1 = __webpack_require__(103);
	var UnsubscriptionError_1 = __webpack_require__(501);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.isUnsubscribed = false;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this._subscriptions = null;
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                (errors = errors || []).push(errorObject_1.errorObject.e);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            var index = -1;
	            var len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(err.errors);
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `isUnsubscribed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {
	            return;
	        }
	        var sub = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                sub = new Subscription(teardown);
	            case 'object':
	                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {
	                    break;
	                }
	                else if (this.isUnsubscribed) {
	                    sub.unsubscribe();
	                }
	                else {
	                    (this._subscriptions || (this._subscriptions = [])).push(sub);
	                }
	                break;
	            default:
	                throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        return sub;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        // HACK: This might be redundant because of the logic in `add()`
	        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.isUnsubscribed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	//# sourceMappingURL=Subscription.js.map

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(46);
	var subscribeToResult_1 = __webpack_require__(50);
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, emitting values only from the most recently projected Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link switch}.</span>
	 *
	 * <img src="./img/switchMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each time it observes one of these
	 * inner Observables, the output Observable begins emitting the items emitted by
	 * that inner Observable. When a new inner Observable is emitted, `switchMap`
	 * stops emitting items from the earlier-emitted inner Observable and begins
	 * emitting items from the new one. It continues to behave like this for
	 * subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switch}
	 * @see {@link switchMapTo}
	 *
	 * @param {function(value: T, ?index: number): Observable} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking only the values from the most recently
	 * projected inner Observable.
	 * @method switchMap
	 * @owner Observable
	 */
	function switchMap(project, resultSelector) {
	    return this.lift(new SwitchMapOperator(project, resultSelector));
	}
	exports.switchMap = switchMap;
	var SwitchMapOperator = (function () {
	    function SwitchMapOperator(project, resultSelector) {
	        this.project = project;
	        this.resultSelector = resultSelector;
	    }
	    SwitchMapOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
	    };
	    return SwitchMapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchMapSubscriber = (function (_super) {
	    __extends(SwitchMapSubscriber, _super);
	    function SwitchMapSubscriber(destination, project, resultSelector) {
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.index = 0;
	    }
	    SwitchMapSubscriber.prototype._next = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (error) {
	            this.destination.error(error);
	            return;
	        }
	        this._innerSub(result, value, index);
	    };
	    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
	    };
	    SwitchMapSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.isUnsubscribed) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return SwitchMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=switchMap.js.map

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(46);
	var subscribeToResult_1 = __webpack_require__(50);
	/**
	 * Combines the source Observable with other Observables to create an Observable
	 * whose values are calculated from the latest values of each, only when the
	 * source emits.
	 *
	 * <span class="informal">Whenever the source Observable emits a value, it
	 * computes a formula using that value plus the latest values from other input
	 * Observables, then emits the output of that formula.</span>
	 *
	 * <img src="./img/withLatestFrom.png" width="100%">
	 *
	 * `withLatestFrom` combines each value from the source Observable (the
	 * instance) with the latest values from the other input Observables only when
	 * the source emits a value, optionally using a `project` function to determine
	 * the value to be emitted on the output Observable. All input Observables must
	 * emit at least one value before the output Observable will emit a value.
	 *
	 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var result = clicks.withLatestFrom(timer);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link combineLatest}
	 *
	 * @param {Observable} other An input Observable to combine with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {Function} [project] Projection function for combining values
	 * together. Receives all values in order of the Observables passed, where the
	 * first parameter is a value from the source Observable. (e.g.
	 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
	 * passed, arrays will be emitted on the output Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @method withLatestFrom
	 * @owner Observable
	 */
	function withLatestFrom() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i - 0] = arguments[_i];
	    }
	    var project;
	    if (typeof args[args.length - 1] === 'function') {
	        project = args.pop();
	    }
	    var observables = args;
	    return this.lift(new WithLatestFromOperator(observables, project));
	}
	exports.withLatestFrom = withLatestFrom;
	/* tslint:enable:max-line-length */
	var WithLatestFromOperator = (function () {
	    function WithLatestFromOperator(observables, project) {
	        this.observables = observables;
	        this.project = project;
	    }
	    WithLatestFromOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
	    };
	    return WithLatestFromOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WithLatestFromSubscriber = (function (_super) {
	    __extends(WithLatestFromSubscriber, _super);
	    function WithLatestFromSubscriber(destination, observables, project) {
	        _super.call(this, destination);
	        this.observables = observables;
	        this.project = project;
	        this.toRespond = [];
	        var len = observables.length;
	        this.values = new Array(len);
	        for (var i = 0; i < len; i++) {
	            this.toRespond.push(i);
	        }
	        for (var i = 0; i < len; i++) {
	            var observable = observables[i];
	            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
	        }
	    }
	    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values[outerIndex] = innerValue;
	        var toRespond = this.toRespond;
	        if (toRespond.length > 0) {
	            var found = toRespond.indexOf(outerIndex);
	            if (found !== -1) {
	                toRespond.splice(found, 1);
	            }
	        }
	    };
	    WithLatestFromSubscriber.prototype.notifyComplete = function () {
	        // noop
	    };
	    WithLatestFromSubscriber.prototype._next = function (value) {
	        if (this.toRespond.length === 0) {
	            var args = [value].concat(this.values);
	            if (this.project) {
	                this._tryProject(args);
	            }
	            else {
	                this.destination.next(args);
	            }
	        }
	    };
	    WithLatestFromSubscriber.prototype._tryProject = function (args) {
	        var result;
	        try {
	            result = this.project.apply(this, args);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return WithLatestFromSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=withLatestFrom.js.map

/***/ },
/* 73 */
/***/ function(module, exports) {

	"use strict";
	function isScheduler(value) {
	    return value && typeof value.schedule === 'function';
	}
	exports.isScheduler = isScheduler;
	//# sourceMappingURL=isScheduler.js.map

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.gElement = gElement;
	
	var _jquery = __webpack_require__(31);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _snapsvgCjs = __webpack_require__(509);
	
	var _snapsvgCjs2 = _interopRequireDefault(_snapsvgCjs);
	
	__webpack_require__(508);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var paper = (0, _snapsvgCjs2.default)('#svg');
	
	// $(paper.node).css({
	// 	display: 'none'
	// });
	
	function gElement() {
		return paper.g();
	}
	
	exports.default = _snapsvgCjs2.default;

/***/ },
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(438);
	
	module.exports = function assign() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(99);
	
	module.exports = function isFunction() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _dec2, _dec3, _desc, _value, _class, _descriptor, _descriptor2, _descriptor3;
	
	var _pick = __webpack_require__(17);
	
	var _pick2 = _interopRequireDefault(_pick);
	
	var _powerAssert = __webpack_require__(69);
	
	var _powerAssert2 = _interopRequireDefault(_powerAssert);
	
	var _ValueTracker = __webpack_require__(6);
	
	var _switchMap = __webpack_require__(71);
	
	var _partition = __webpack_require__(495);
	
	var _merge = __webpack_require__(156);
	
	var _map = __webpack_require__(15);
	
	var _of = __webpack_require__(157);
	
	var _filter = __webpack_require__(16);
	
	var _startWith = __webpack_require__(238);
	
	var _pairwise = __webpack_require__(145);
	
	var _takeUntil = __webpack_require__(49);
	
	var _isFunction = __webpack_require__(79);
	
	var _isFunction2 = _interopRequireDefault(_isFunction);
	
	var _SvgObject2 = __webpack_require__(244);
	
	var _SvgObject3 = _interopRequireDefault(_SvgObject2);
	
	var _ObservableSet = __webpack_require__(55);
	
	var _ObservableSet2 = _interopRequireDefault(_ObservableSet);
	
	var _rxjs = __webpack_require__(82);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
	
	function _initDefineProp(target, property, descriptor, context) {
		if (!descriptor) return;
		Object.defineProperty(target, property, {
			enumerable: descriptor.enumerable,
			configurable: descriptor.configurable,
			writable: descriptor.writable,
			value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
		});
	}
	
	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
		var desc = {};
		Object['ke' + 'ys'](descriptor).forEach(function (key) {
			desc[key] = descriptor[key];
		});
		desc.enumerable = !!desc.enumerable;
		desc.configurable = !!desc.configurable;
	
		if ('value' in desc || desc.initializer) {
			desc.writable = true;
		}
	
		desc = decorators.slice().reverse().reduce(function (desc, decorator) {
			return decorator(target, property, desc) || desc;
		}, desc);
	
		if (context && desc.initializer !== void 0) {
			desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
			desc.initializer = undefined;
		}
	
		if (desc.initializer === void 0) {
			Object['define' + 'Property'](target, property, desc);
			desc = null;
		}
	
		return desc;
	}
	
	function _initializerWarningHelper(descriptor, context) {
		throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
	}
	
	var SvgEntity = (_dec = (0, _ValueTracker.property)(), _dec2 = (0, _ValueTracker.property)(), _dec3 = (0, _ValueTracker.property)(), (_class = function (_SvgObject) {
		_inherits(SvgEntity, _SvgObject);
	
		function SvgEntity(options) {
			var _context;
	
			_classCallCheck(this, SvgEntity);
	
			/* process options */
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SvgEntity).call(this, options));
	
			_initDefineProp(_this, 'model', _descriptor, _this);
	
			_initDefineProp(_this, 'root', _descriptor2, _this);
	
			_initDefineProp(_this, 'parent', _descriptor3, _this);
	
			_this.children = new _ObservableSet2.default();
			_this.setFromObject(options, ['model', 'parent']);
	
			/* maintain the root of this entity */
			(_context = (_context = _this.p('parent'), _switchMap.switchMap).call(_context, function (e) {
				return e ? e.p('root') : (0, _of.of)(_this);
			}), _rxjs.subscribe_).call(_context, _this.p('root'), function (n) {
				return n();
			});
	
			/* maintain the children of the parent of this entity */
			(_context = (_context = _this.p('parent'), _startWith.startWith).call(_context, null), _pairwise.pairwise).call(_context).subscribe(function (_ref) {
				var _ref2 = _slicedToArray(_ref, 2);
	
				var prev = _ref2[0];
				var curr = _ref2[1];
	
				if (prev) {
					prev.children.delete(_this);
				}
				if (curr) {
					curr.children.add(_this);
				}
			});
	
			/* maintain the parent of the children of this entity */
			_this.children.e('add').subscribe(function (e) {
				e.parent = _this;
			});
			(_context = _this.children.e('delete'), _filter.filter).call(_context, function (e) {
				return e.parent === _this;
			}).subscribe(function (e) {
				e.parent = null;
			});
	
			/* when a parent is dragging, its children are dragging */
			(_context = (_context = _this.p('parent'), _switchMap.switchMap).call(_context, function (parent) {
				return parent ? parent.p('dragging') : (0, _of.of)(true);
			}), _rxjs.subscribe_).call(_context, _this.p('dragging'), function (n) {
				return n();
			});
	
			return _this;
		}
	
		_createClass(SvgEntity, [{
			key: 'findAncestor',
			value: function findAncestor(other) {
				var pred = _isFunction2.default.call(other) ? other : function (o) {
					return o === other;
				};
				if (pred(this)) {
					return this;
				}
				return this.parent && this.parent.findAncestor(pred);
	
				// let current = this;
				// while (current && !pred(current)) { current = current.parent }
				// return current || null;
			}
		}, {
			key: 'traverse',
			value: regeneratorRuntime.mark(function traverse() {
				var order = arguments.length <= 0 || arguments[0] === undefined ? 'pre' : arguments[0];
	
				var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _children, child;
	
				return regeneratorRuntime.wrap(function traverse$(_context2) {
					while (1) {
						switch (_context2.prev = _context2.next) {
							case 0:
								if (!(order === 'pre')) {
									_context2.next = 3;
									break;
								}
	
								_context2.next = 3;
								return this;
	
							case 3:
								_children = this.children;
	
								if (_children && (typeof _children[Symbol.iterator] === 'function' || Array.isArray(_children))) {
									_context2.next = 6;
									break;
								}
	
								throw new TypeError('Expected _children to be iterable, got ' + _inspect(_children));
	
							case 6:
								_iteratorNormalCompletion = true;
								_didIteratorError = false;
								_iteratorError = undefined;
								_context2.prev = 9;
								_iterator = _children[Symbol.iterator]();
	
							case 11:
								if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
									_context2.next = 17;
									break;
								}
	
								child = _step.value;
								return _context2.delegateYield(child.traverse(), 't0', 14);
	
							case 14:
								_iteratorNormalCompletion = true;
								_context2.next = 11;
								break;
	
							case 17:
								_context2.next = 23;
								break;
	
							case 19:
								_context2.prev = 19;
								_context2.t1 = _context2['catch'](9);
								_didIteratorError = true;
								_iteratorError = _context2.t1;
	
							case 23:
								_context2.prev = 23;
								_context2.prev = 24;
	
								if (!_iteratorNormalCompletion && _iterator.return) {
									_iterator.return();
								}
	
							case 26:
								_context2.prev = 26;
	
								if (!_didIteratorError) {
									_context2.next = 29;
									break;
								}
	
								throw _iteratorError;
	
							case 29:
								return _context2.finish(26);
	
							case 30:
								return _context2.finish(23);
	
							case 31:
								if (!(order !== 'pre')) {
									_context2.next = 34;
									break;
								}
	
								_context2.next = 34;
								return this;
	
							case 34:
							case 'end':
								return _context2.stop();
						}
					}
				}, traverse, this, [[9, 19, 23, 31], [24,, 26, 30]]);
			})
		}]);
	
		return SvgEntity;
	}(_SvgObject3.default), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'model', [_dec], {
		enumerable: true,
		initializer: null
	}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'root', [_dec2], {
		enumerable: true,
		initializer: null
	}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, 'parent', [_dec3], {
		enumerable: true,
		initializer: null
	})), _class));
	
	// export default class SvgEntity extends SvgObject {
	//
	// 	model;
	// 	root;
	// 	parent;
	// 	children = new Set();
	//
	// 	constructor(options) {
	// 		super(options);
	// 		Object.assign(this, options::pick('model'));
	//
	// 		// this.setParent(options.parent);
	// 		// this.root.p('draggingSomething').plug(this.p('dragging'));
	// 		// this.root.p('resizingSomething').plug(this.p('resizing'));
	//
	// 		// if (this.parent && this.parent.interactive === false) { this.interactive = false }
	//
	// 		// this.e('delete').subscribe(() => {
	// 		// 	for (let child of this.children) { child.delete() }
	// 		// 	this.parent.children.delete(this);
	// 		// });
	// 	}
	//
	// 	// hasAncestor(pred) {
	// 	// 	return pred(this) || this.parent && this.parent.hasAncestor(pred);
	// 	// }
	//
	// 	// setParent(newParent) {
	// 	// 	// /* check for nesting of model-sharing svg entities */
	// 	// 	// let entity = newParent;
	// 	// 	// while (entity) {
	// 	// 	// 	if (entity.model === this.model) {
	// 	// 	// 		throw new Error(`Nesting Error: Cannot set the parent of this entity to an entity that has a model that is a descendant of the model of this one.`);
	// 	// 	// 	}
	// 	// 	// 	entity = entity.parent;
	// 	// 	// }
	// 	//
	// 	// 	/* actually set parent */
	// 	// 	if (this.parent) { this.parent.children.delete(this) }
	// 	// 	this.parent = newParent;
	// 	// 	if (this.parent) {
	// 	// 		this.parent.children.add(this);
	// 	// 		this.root = this.parent.root;
	// 	// 	} else {
	// 	// 		this.root = this;
	// 	// 	}
	// 	// }
	// 	//
	// 	// traverse(types, fn) {
	// 	// 	if (!fn) { [types, fn] = [null, types] }
	// 	// 	if (types && !Array.isArray(types)) { types = [types] }
	// 	// 	if (!types || types.some(type => this instanceof type)) {
	// 	// 		fn(this);
	// 	// 	}
	// 	// 	for (let child of this.children) {
	// 	// 		child.traverse(types, fn);
	// 	// 	}
	// 	// }
	// 	//
	// 	// moveToFront() {
	// 	// 	for (let c = this; c !== c.root; c = c.parent) {
	// 	// 		c.element.appendTo(c.element.parent());
	// 	// 	}
	// 	// }
	//
	// 	// deleteClicker() {
	// 	// 	if (!this[deleteClicker]) {
	// 	// 		this[deleteClicker] = new DeleteClicker();
	// 	// 		this[deleteClicker].clicks.subscribe((event) => {
	// 	// 			event.stopPropagation();
	// 	// 			this.delete();
	// 	// 		});
	// 	// 	}
	// 	// 	return this[deleteClicker];
	// 	// }
	//
	// 	// startDraggingBy(event, options = {}) {
	// 	// 	let {handle, tracker} = this.draggable();
	// 	// 	if (!handle)  { handle = this.element                }
	// 	// 	else          { handle = this.element.find(handle)   }
	// 	// 	if (!tracker) { tracker = handle                     }
	// 	// 	else          { tracker = this.element.find(tracker) }
	// 	//
	// 	// 	let interactable = interact(tracker[0]);
	// 	//
	// 	// 	Object.assign(event.interaction, options);
	// 	//
	// 	// 	interactable.rectChecker(element => element.getBoundingClientRect());
	// 	// 	event.interaction.start(
	// 	// 		{ name: 'drag' },
	// 	// 		interactable,
	// 	// 		tracker[0]
	// 	// 	);
	// 	//
	// 	// 	return new Promise((resolve) => {
	// 	// 		merge(
	// 	// 			fromEvent(interactable, 'dragend') .map(()=>({ status: 'finished' })),
	// 	// 			fromEvent($('body'), 'keyup').which(27).map(()=>({ status: 'aborted'  }))
	// 	// 		).take(1).subscribe(resolve);
	// 	// 	});
	// 	// }
	//
	// 	// startResizingBy(event, edges = { bottom: true, right: true }) {
	// 	// 	let {handle, tracker} = this.resizable();
	// 	// 	if (!handle)  { handle = this.element                }
	// 	// 	else          { handle = this.element.find(handle)   }
	// 	// 	if (!tracker) { tracker = handle                     }
	// 	// 	else          { tracker = this.element.find(tracker) }
	// 	//
	// 	// 	let interactable = interact(tracker[0]);
	// 	//
	// 	// 	event.interaction.start(
	// 	// 		{ name: 'resize', edges },
	// 	// 		interactable,
	// 	// 		tracker[0]
	// 	// 	);
	// 	//
	// 	// 	return new Promise((resolve) => {
	// 	// 		merge(
	// 	// 			fromEvent(interactable, 'resizeend').map(()=>({ status: 'finished' })),
	// 	// 			$('body').asKefirStream('keyup').which(27) .map(()=>({ status: 'aborted'  }))
	// 	// 		).take(1).subscribe(resolve);
	// 	// 	});
	// 	// 	// return new Promise((resolve) => {
	// 	// 	// 	interact(tracker[0]).on('resizeend', function onResizeEnd() {
	// 	// 	// 		interact(tracker[0]).off('resizeend', onResizeEnd);
	// 	// 	// 		resolve(this);
	// 	// 	// 	}.bind(this));
	// 	// 	// });
	// 	// }
	//
	// 	// to override
	// 	// appendChildElement(newChild) { assert(()=>false) }
	//
	// }
	
	exports.default = SvgEntity;
	
	function _inspect(input, depth) {
		var maxDepth = 4;
		var maxKeys = 15;

		if (depth === undefined) {
			depth = 0;
		}

		depth += 1;

		if (input === null) {
			return 'null';
		} else if (input === undefined) {
			return 'void';
		} else if (typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean') {
			return typeof input === 'undefined' ? 'undefined' : _typeof(input);
		} else if (Array.isArray(input)) {
			if (input.length > 0) {
				var _ret = function () {
					if (depth > maxDepth) return {
							v: '[...]'
						};

					var first = _inspect(input[0], depth);

					if (input.every(function (item) {
						return _inspect(item, depth) === first;
					})) {
						return {
							v: first.trim() + '[]'
						};
					} else {
						return {
							v: '[' + input.slice(0, maxKeys).map(function (item) {
								return _inspect(item, depth);
							}).join(', ') + (input.length >= maxKeys ? ', ...' : '') + ']'
						};
					}
				}();

				if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
			} else {
				return 'Array';
			}
		} else {
			var keys = Object.keys(input);

			if (!keys.length) {
				if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
					return input.constructor.name;
				} else {
					return 'Object';
				}
			}

			if (depth > maxDepth) return '{...}';
			var indent = '  '.repeat(depth - 1);
			var entries = keys.slice(0, maxKeys).map(function (key) {
				return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + ': ' + _inspect(input[key], depth) + ';';
			}).join('\n  ' + indent);

			if (keys.length >= maxKeys) {
				entries += '\n  ' + indent + '...';
			}

			if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
				return input.constructor.name + ' {\n  ' + indent + entries + '\n' + indent + '}';
			} else {
				return '{\n  ' + indent + entries + '\n' + indent + '}';
			}
		}
	}

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _chromaJs = __webpack_require__(255);
	
	var _chromaJs2 = _interopRequireDefault(_chromaJs);
	
	var _goldenColors = __webpack_require__(333);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	Object.assign(_chromaJs2.default, {
		randomHsvGolden: function randomHsvGolden(saturation, value) {
			return _chromaJs2.default.rgb.apply(_chromaJs2.default, _toConsumableArray((0, _goldenColors.getHsvGolden)(saturation, value).toRgb()));
		}
	});
	
	exports.default = _chromaJs2.default;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.subscribe_ = subscribe_;
	exports.shiftedMovementFor = shiftedMovementFor;
	exports.log = log;
	
	var _fromEvent = __webpack_require__(109);
	
	var _combineLatest = __webpack_require__(33);
	
	var _switchMap = __webpack_require__(71);
	
	var _filter = __webpack_require__(16);
	
	var _takeUntil = __webpack_require__(49);
	
	var _withLatestFrom = __webpack_require__(72);
	
	var _take = __webpack_require__(48);
	
	var _map = __webpack_require__(15);
	
	function subscribe_(subject) {
		var nextPipe = arguments.length <= 1 || arguments[1] === undefined ? function (n) {
			return n();
		} : arguments[1];
		var completePipe = arguments.length <= 2 || arguments[2] === undefined ? function (c) {
			return c();
		} : arguments[2];
		var errorPipe = arguments.length <= 3 || arguments[3] === undefined ? function (e) {
			return e();
		} : arguments[3];
	
		return this.subscribe({
			next: function next(v) {
				return nextPipe(function (toDebug) {
					if (typeof toDebug !== 'undefined') {
						debugger;
					}
					return subject.next(v);
				});
			},
			complete: function complete(v) {
				return completePipe(function (toDebug) {
					if (typeof toDebug !== 'undefined') {
						debugger;
					}
					return subject.complete(v);
				});
			},
			error: function error(v) {
				return errorPipe(function (toDebug) {
					if (typeof toDebug !== 'undefined') {
						debugger;
					}
					return subject.error(v);
				});
			}
		});
	}
	
	function shiftedMovementFor(obj_xy) {
		var _context,
		    _this = this;
	
		return (_context = (0, _combineLatest.combineLatest)(_take.take.call(this, 1), _take.take.call(obj_xy, 1), function (ref, obj) {
			return {
				x: obj.x - ref.x,
				y: obj.y - ref.y
			};
		}), _switchMap.switchMap).call(_context, function () {
			return _this;
		}, function (delta, next) {
			return {
				x: next.x + delta.x,
				y: next.y + delta.y
			};
		});
	}
	
	function log() {
		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}
	
		return this.do(function (value) {
			var _console;
	
			(_console = console).log.apply(_console, args.concat([value]));
		});
	}

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(171)
	  , IObject  = __webpack_require__(84)
	  , toObject = __webpack_require__(86)
	  , toLength = __webpack_require__(116)
	  , asc      = __webpack_require__(261);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(170);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 85 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(172);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(440);
	
	module.exports = function at() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(456);
	
	module.exports = function size() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(415),
	    listCacheDelete = __webpack_require__(416),
	    listCacheGet = __webpack_require__(417),
	    listCacheHas = __webpack_require__(418),
	    listCacheSet = __webpack_require__(419);
	
	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	
	module.exports = ListCache;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(67);
	
	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	
	module.exports = assocIndexOf;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(412);
	
	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}
	
	module.exports = getMapData;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var DataView = __webpack_require__(349),
	    Map = __webpack_require__(127),
	    Promise = __webpack_require__(351),
	    Set = __webpack_require__(353),
	    WeakMap = __webpack_require__(356),
	    baseGetTag = __webpack_require__(367),
	    toSource = __webpack_require__(206);
	
	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';
	
	var dataViewTag = '[object DataView]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);
	
	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;
	
	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;
	
	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}
	
	module.exports = getTag;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(41);
	
	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');
	
	module.exports = nativeCreate;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var baseDelay = __webpack_require__(362),
	    baseRest = __webpack_require__(29);
	
	/**
	 * Defers invoking the `func` until the current call stack has cleared. Any
	 * additional arguments are provided to `func` when it's invoked.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to defer.
	 * @param {...*} [args] The arguments to invoke `func` with.
	 * @returns {number} Returns the timer id.
	 * @example
	 *
	 * _.defer(function(text) {
	 *   console.log(text);
	 * }, 'deferred');
	 * // => Logs 'deferred' after one or more milliseconds.
	 */
	var defer = baseRest(function(func, args) {
	  return baseDelay(func, 1, args);
	});
	
	module.exports = defer;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(24);
	
	/** `Object#toString` result references. */
	var funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8 which returns 'object' for typed array and weak map constructors,
	  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}
	
	module.exports = isFunction;


/***/ },
/* 100 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length,
	 *  else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	module.exports = isLength;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var toString = __webpack_require__(141);
	
	/** Used to generate unique IDs. */
	var idCounter = 0;
	
	/**
	 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {string} [prefix=''] The value to prefix the ID with.
	 * @returns {string} Returns the unique ID.
	 * @example
	 *
	 * _.uniqueId('contact_');
	 * // => 'contact_104'
	 *
	 * _.uniqueId();
	 * // => '105'
	 */
	function uniqueId(prefix) {
	  var id = ++idCounter;
	  return toString(prefix) + id;
	}
	
	module.exports = uniqueId;


/***/ },
/* 102 */
/***/ function(module, exports) {

	'use strict';
	
	function BaseRenderer () {
	}
	
	BaseRenderer.prototype.init = function (traversal) {
	    var _this = this;
	    traversal.on('start', function (context) {
	        _this.onStart(context);
	    });
	    traversal.on('data', function (esNode) {
	        _this.onData(esNode);
	    });
	    traversal.on('end', function () {
	        _this.onEnd();
	    });
	};
	
	BaseRenderer.prototype.setWritable = function (writable) {
	    this.writable = writable;
	};
	
	// API
	BaseRenderer.prototype.onStart = function (context) {
	};
	
	// API
	BaseRenderer.prototype.onData = function (esNode) {
	};
	
	// API
	BaseRenderer.prototype.onEnd = function () {
	};
	
	// API
	BaseRenderer.prototype.write = function (str) {
	    this.writable.write(str);
	};
	
	module.exports = BaseRenderer;


/***/ },
/* 103 */
/***/ function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ },
/* 104 */
/***/ function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ },
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(20);
	var Subscriber_1 = __webpack_require__(9);
	var Subscription_1 = __webpack_require__(70);
	var ObjectUnsubscribedError_1 = __webpack_require__(217);
	var SubjectSubscription_1 = __webpack_require__(486);
	var rxSubscriber_1 = __webpack_require__(146);
	/**
	 * @class SubjectSubscriber<T>
	 */
	var SubjectSubscriber = (function (_super) {
	    __extends(SubjectSubscriber, _super);
	    function SubjectSubscriber(destination) {
	        _super.call(this, destination);
	        this.destination = destination;
	    }
	    return SubjectSubscriber;
	}(Subscriber_1.Subscriber));
	exports.SubjectSubscriber = SubjectSubscriber;
	/**
	 * @class Subject<T>
	 */
	var Subject = (function (_super) {
	    __extends(Subject, _super);
	    function Subject() {
	        _super.call(this);
	        this.observers = [];
	        this.isUnsubscribed = false;
	        this.isStopped = false;
	        this.hasError = false;
	        this.thrownError = null;
	    }
	    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
	        return new SubjectSubscriber(this);
	    };
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.next = function (value) {
	        if (this.isUnsubscribed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        if (!this.isStopped) {
	            var observers = this.observers;
	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].next(value);
	            }
	        }
	    };
	    Subject.prototype.error = function (err) {
	        if (this.isUnsubscribed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.hasError = true;
	        this.thrownError = err;
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].error(err);
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.complete = function () {
	        if (this.isUnsubscribed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].complete();
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = true;
	        this.isUnsubscribed = true;
	        this.observers = null;
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.isUnsubscribed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable_1.Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	exports.Subject = Subject;
	/**
	 * @class AnonymousSubject<T>
	 */
	var AnonymousSubject = (function (_super) {
	    __extends(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var destination = this.destination;
	        if (destination && destination.next) {
	            destination.next(value);
	        }
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var destination = this.destination;
	        if (destination && destination.error) {
	            this.destination.error(err);
	        }
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var destination = this.destination;
	        if (destination && destination.complete) {
	            this.destination.complete();
	        }
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var source = this.source;
	        if (source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            return Subscription_1.Subscription.EMPTY;
	        }
	    };
	    return AnonymousSubject;
	}(Subject));
	exports.AnonymousSubject = AnonymousSubject;
	//# sourceMappingURL=Subject.js.map

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var FromEventObservable_1 = __webpack_require__(488);
	exports.fromEvent = FromEventObservable_1.FromEventObservable.create;
	//# sourceMappingURL=fromEvent.js.map

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(54);
	/**
	 * @param PromiseCtor
	 * @return {Promise<T>}
	 * @method toPromise
	 * @owner Observable
	 */
	function toPromise(PromiseCtor) {
	    var _this = this;
	    if (!PromiseCtor) {
	        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	            PromiseCtor = root_1.root.Rx.config.Promise;
	        }
	        else if (root_1.root.Promise) {
	            PromiseCtor = root_1.root.Promise;
	        }
	    }
	    if (!PromiseCtor) {
	        throw new Error('no Promise impl found');
	    }
	    return new PromiseCtor(function (resolve, reject) {
	        var value;
	        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
	    });
	}
	exports.toPromise = toPromise;
	//# sourceMappingURL=toPromise.js.map

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(281);
	module.exports = __webpack_require__(5).Array.map;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(283);
	module.exports = __webpack_require__(5).Array.reduce;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(85);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(113)
	  , IE8_DOM_DEFINE = __webpack_require__(265)
	  , toPrimitive    = __webpack_require__(275)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(56) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(270)
	  , enumBugKeys = __webpack_require__(174);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(178)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	/*jslint vars:false, bitwise:true*/
	/*jshint indent:4*/
	/*global exports:true*/
	(function clone(exports) {
	    'use strict';
	
	    var Syntax,
	        isArray,
	        VisitorOption,
	        VisitorKeys,
	        objectCreate,
	        objectKeys,
	        BREAK,
	        SKIP,
	        REMOVE;
	
	    function ignoreJSHintError() { }
	
	    isArray = Array.isArray;
	    if (!isArray) {
	        isArray = function isArray(array) {
	            return Object.prototype.toString.call(array) === '[object Array]';
	        };
	    }
	
	    function deepCopy(obj) {
	        var ret = {}, key, val;
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                val = obj[key];
	                if (typeof val === 'object' && val !== null) {
	                    ret[key] = deepCopy(val);
	                } else {
	                    ret[key] = val;
	                }
	            }
	        }
	        return ret;
	    }
	
	    function shallowCopy(obj) {
	        var ret = {}, key;
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    ignoreJSHintError(shallowCopy);
	
	    // based on LLVM libc++ upper_bound / lower_bound
	    // MIT License
	
	    function upperBound(array, func) {
	        var diff, len, i, current;
	
	        len = array.length;
	        i = 0;
	
	        while (len) {
	            diff = len >>> 1;
	            current = i + diff;
	            if (func(array[current])) {
	                len = diff;
	            } else {
	                i = current + 1;
	                len -= diff + 1;
	            }
	        }
	        return i;
	    }
	
	    function lowerBound(array, func) {
	        var diff, len, i, current;
	
	        len = array.length;
	        i = 0;
	
	        while (len) {
	            diff = len >>> 1;
	            current = i + diff;
	            if (func(array[current])) {
	                i = current + 1;
	                len -= diff + 1;
	            } else {
	                len = diff;
	            }
	        }
	        return i;
	    }
	    ignoreJSHintError(lowerBound);
	
	    objectCreate = Object.create || (function () {
	        function F() { }
	
	        return function (o) {
	            F.prototype = o;
	            return new F();
	        };
	    })();
	
	    objectKeys = Object.keys || function (o) {
	        var keys = [], key;
	        for (key in o) {
	            keys.push(key);
	        }
	        return keys;
	    };
	
	    function extend(to, from) {
	        var keys = objectKeys(from), key, i, len;
	        for (i = 0, len = keys.length; i < len; i += 1) {
	            key = keys[i];
	            to[key] = from[key];
	        }
	        return to;
	    }
	
	    Syntax = {
	        AssignmentExpression: 'AssignmentExpression',
	        AssignmentPattern: 'AssignmentPattern',
	        ArrayExpression: 'ArrayExpression',
	        ArrayPattern: 'ArrayPattern',
	        ArrowFunctionExpression: 'ArrowFunctionExpression',
	        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
	        BlockStatement: 'BlockStatement',
	        BinaryExpression: 'BinaryExpression',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ClassBody: 'ClassBody',
	        ClassDeclaration: 'ClassDeclaration',
	        ClassExpression: 'ClassExpression',
	        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
	        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        DirectiveStatement: 'DirectiveStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExportAllDeclaration: 'ExportAllDeclaration',
	        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	        ExportNamedDeclaration: 'ExportNamedDeclaration',
	        ExportSpecifier: 'ExportSpecifier',
	        ExpressionStatement: 'ExpressionStatement',
	        ForStatement: 'ForStatement',
	        ForInStatement: 'ForInStatement',
	        ForOfStatement: 'ForOfStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        ImportDeclaration: 'ImportDeclaration',
	        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	        ImportSpecifier: 'ImportSpecifier',
	        Literal: 'Literal',
	        LabeledStatement: 'LabeledStatement',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        MetaProperty: 'MetaProperty',
	        MethodDefinition: 'MethodDefinition',
	        ModuleSpecifier: 'ModuleSpecifier',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        ObjectPattern: 'ObjectPattern',
	        Program: 'Program',
	        Property: 'Property',
	        RestElement: 'RestElement',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SpreadElement: 'SpreadElement',
	        Super: 'Super',
	        SwitchStatement: 'SwitchStatement',
	        SwitchCase: 'SwitchCase',
	        TaggedTemplateExpression: 'TaggedTemplateExpression',
	        TemplateElement: 'TemplateElement',
	        TemplateLiteral: 'TemplateLiteral',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement',
	        YieldExpression: 'YieldExpression'
	    };
	
	    VisitorKeys = {
	        AssignmentExpression: ['left', 'right'],
	        AssignmentPattern: ['left', 'right'],
	        ArrayExpression: ['elements'],
	        ArrayPattern: ['elements'],
	        ArrowFunctionExpression: ['params', 'body'],
	        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
	        BlockStatement: ['body'],
	        BinaryExpression: ['left', 'right'],
	        BreakStatement: ['label'],
	        CallExpression: ['callee', 'arguments'],
	        CatchClause: ['param', 'body'],
	        ClassBody: ['body'],
	        ClassDeclaration: ['id', 'superClass', 'body'],
	        ClassExpression: ['id', 'superClass', 'body'],
	        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
	        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
	        ConditionalExpression: ['test', 'consequent', 'alternate'],
	        ContinueStatement: ['label'],
	        DebuggerStatement: [],
	        DirectiveStatement: [],
	        DoWhileStatement: ['body', 'test'],
	        EmptyStatement: [],
	        ExportAllDeclaration: ['source'],
	        ExportDefaultDeclaration: ['declaration'],
	        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
	        ExportSpecifier: ['exported', 'local'],
	        ExpressionStatement: ['expression'],
	        ForStatement: ['init', 'test', 'update', 'body'],
	        ForInStatement: ['left', 'right', 'body'],
	        ForOfStatement: ['left', 'right', 'body'],
	        FunctionDeclaration: ['id', 'params', 'body'],
	        FunctionExpression: ['id', 'params', 'body'],
	        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
	        Identifier: [],
	        IfStatement: ['test', 'consequent', 'alternate'],
	        ImportDeclaration: ['specifiers', 'source'],
	        ImportDefaultSpecifier: ['local'],
	        ImportNamespaceSpecifier: ['local'],
	        ImportSpecifier: ['imported', 'local'],
	        Literal: [],
	        LabeledStatement: ['label', 'body'],
	        LogicalExpression: ['left', 'right'],
	        MemberExpression: ['object', 'property'],
	        MetaProperty: ['meta', 'property'],
	        MethodDefinition: ['key', 'value'],
	        ModuleSpecifier: [],
	        NewExpression: ['callee', 'arguments'],
	        ObjectExpression: ['properties'],
	        ObjectPattern: ['properties'],
	        Program: ['body'],
	        Property: ['key', 'value'],
	        RestElement: [ 'argument' ],
	        ReturnStatement: ['argument'],
	        SequenceExpression: ['expressions'],
	        SpreadElement: ['argument'],
	        Super: [],
	        SwitchStatement: ['discriminant', 'cases'],
	        SwitchCase: ['test', 'consequent'],
	        TaggedTemplateExpression: ['tag', 'quasi'],
	        TemplateElement: [],
	        TemplateLiteral: ['quasis', 'expressions'],
	        ThisExpression: [],
	        ThrowStatement: ['argument'],
	        TryStatement: ['block', 'handler', 'finalizer'],
	        UnaryExpression: ['argument'],
	        UpdateExpression: ['argument'],
	        VariableDeclaration: ['declarations'],
	        VariableDeclarator: ['id', 'init'],
	        WhileStatement: ['test', 'body'],
	        WithStatement: ['object', 'body'],
	        YieldExpression: ['argument']
	    };
	
	    // unique id
	    BREAK = {};
	    SKIP = {};
	    REMOVE = {};
	
	    VisitorOption = {
	        Break: BREAK,
	        Skip: SKIP,
	        Remove: REMOVE
	    };
	
	    function Reference(parent, key) {
	        this.parent = parent;
	        this.key = key;
	    }
	
	    Reference.prototype.replace = function replace(node) {
	        this.parent[this.key] = node;
	    };
	
	    Reference.prototype.remove = function remove() {
	        if (isArray(this.parent)) {
	            this.parent.splice(this.key, 1);
	            return true;
	        } else {
	            this.replace(null);
	            return false;
	        }
	    };
	
	    function Element(node, path, wrap, ref) {
	        this.node = node;
	        this.path = path;
	        this.wrap = wrap;
	        this.ref = ref;
	    }
	
	    function Controller() { }
	
	    // API:
	    // return property path array from root to current node
	    Controller.prototype.path = function path() {
	        var i, iz, j, jz, result, element;
	
	        function addToPath(result, path) {
	            if (isArray(path)) {
	                for (j = 0, jz = path.length; j < jz; ++j) {
	                    result.push(path[j]);
	                }
	            } else {
	                result.push(path);
	            }
	        }
	
	        // root node
	        if (!this.__current.path) {
	            return null;
	        }
	
	        // first node is sentinel, second node is root element
	        result = [];
	        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
	            element = this.__leavelist[i];
	            addToPath(result, element.path);
	        }
	        addToPath(result, this.__current.path);
	        return result;
	    };
	
	    // API:
	    // return type of current node
	    Controller.prototype.type = function () {
	        var node = this.current();
	        return node.type || this.__current.wrap;
	    };
	
	    // API:
	    // return array of parent elements
	    Controller.prototype.parents = function parents() {
	        var i, iz, result;
	
	        // first node is sentinel
	        result = [];
	        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
	            result.push(this.__leavelist[i].node);
	        }
	
	        return result;
	    };
	
	    // API:
	    // return current node
	    Controller.prototype.current = function current() {
	        return this.__current.node;
	    };
	
	    Controller.prototype.__execute = function __execute(callback, element) {
	        var previous, result;
	
	        result = undefined;
	
	        previous  = this.__current;
	        this.__current = element;
	        this.__state = null;
	        if (callback) {
	            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
	        }
	        this.__current = previous;
	
	        return result;
	    };
	
	    // API:
	    // notify control skip / break
	    Controller.prototype.notify = function notify(flag) {
	        this.__state = flag;
	    };
	
	    // API:
	    // skip child nodes of current node
	    Controller.prototype.skip = function () {
	        this.notify(SKIP);
	    };
	
	    // API:
	    // break traversals
	    Controller.prototype['break'] = function () {
	        this.notify(BREAK);
	    };
	
	    // API:
	    // remove node
	    Controller.prototype.remove = function () {
	        this.notify(REMOVE);
	    };
	
	    Controller.prototype.__initialize = function(root, visitor) {
	        this.visitor = visitor;
	        this.root = root;
	        this.__worklist = [];
	        this.__leavelist = [];
	        this.__current = null;
	        this.__state = null;
	        this.__fallback = null;
	        if (visitor.fallback === 'iteration') {
	            this.__fallback = objectKeys;
	        } else if (typeof visitor.fallback === 'function') {
	            this.__fallback = visitor.fallback;
	        }
	
	        this.__keys = VisitorKeys;
	        if (visitor.keys) {
	            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
	        }
	    };
	
	    function isNode(node) {
	        if (node == null) {
	            return false;
	        }
	        return typeof node === 'object' && typeof node.type === 'string';
	    }
	
	    function isProperty(nodeType, key) {
	        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
	    }
	
	    Controller.prototype.traverse = function traverse(root, visitor) {
	        var worklist,
	            leavelist,
	            element,
	            node,
	            nodeType,
	            ret,
	            key,
	            current,
	            current2,
	            candidates,
	            candidate,
	            sentinel;
	
	        this.__initialize(root, visitor);
	
	        sentinel = {};
	
	        // reference
	        worklist = this.__worklist;
	        leavelist = this.__leavelist;
	
	        // initialize
	        worklist.push(new Element(root, null, null, null));
	        leavelist.push(new Element(null, null, null, null));
	
	        while (worklist.length) {
	            element = worklist.pop();
	
	            if (element === sentinel) {
	                element = leavelist.pop();
	
	                ret = this.__execute(visitor.leave, element);
	
	                if (this.__state === BREAK || ret === BREAK) {
	                    return;
	                }
	                continue;
	            }
	
	            if (element.node) {
	
	                ret = this.__execute(visitor.enter, element);
	
	                if (this.__state === BREAK || ret === BREAK) {
	                    return;
	                }
	
	                worklist.push(sentinel);
	                leavelist.push(element);
	
	                if (this.__state === SKIP || ret === SKIP) {
	                    continue;
	                }
	
	                node = element.node;
	                nodeType = node.type || element.wrap;
	                candidates = this.__keys[nodeType];
	                if (!candidates) {
	                    if (this.__fallback) {
	                        candidates = this.__fallback(node);
	                    } else {
	                        throw new Error('Unknown node type ' + nodeType + '.');
	                    }
	                }
	
	                current = candidates.length;
	                while ((current -= 1) >= 0) {
	                    key = candidates[current];
	                    candidate = node[key];
	                    if (!candidate) {
	                        continue;
	                    }
	
	                    if (isArray(candidate)) {
	                        current2 = candidate.length;
	                        while ((current2 -= 1) >= 0) {
	                            if (!candidate[current2]) {
	                                continue;
	                            }
	                            if (isProperty(nodeType, candidates[current])) {
	                                element = new Element(candidate[current2], [key, current2], 'Property', null);
	                            } else if (isNode(candidate[current2])) {
	                                element = new Element(candidate[current2], [key, current2], null, null);
	                            } else {
	                                continue;
	                            }
	                            worklist.push(element);
	                        }
	                    } else if (isNode(candidate)) {
	                        worklist.push(new Element(candidate, key, null, null));
	                    }
	                }
	            }
	        }
	    };
	
	    Controller.prototype.replace = function replace(root, visitor) {
	        var worklist,
	            leavelist,
	            node,
	            nodeType,
	            target,
	            element,
	            current,
	            current2,
	            candidates,
	            candidate,
	            sentinel,
	            outer,
	            key;
	
	        function removeElem(element) {
	            var i,
	                key,
	                nextElem,
	                parent;
	
	            if (element.ref.remove()) {
	                // When the reference is an element of an array.
	                key = element.ref.key;
	                parent = element.ref.parent;
	
	                // If removed from array, then decrease following items' keys.
	                i = worklist.length;
	                while (i--) {
	                    nextElem = worklist[i];
	                    if (nextElem.ref && nextElem.ref.parent === parent) {
	                        if  (nextElem.ref.key < key) {
	                            break;
	                        }
	                        --nextElem.ref.key;
	                    }
	                }
	            }
	        }
	
	        this.__initialize(root, visitor);
	
	        sentinel = {};
	
	        // reference
	        worklist = this.__worklist;
	        leavelist = this.__leavelist;
	
	        // initialize
	        outer = {
	            root: root
	        };
	        element = new Element(root, null, null, new Reference(outer, 'root'));
	        worklist.push(element);
	        leavelist.push(element);
	
	        while (worklist.length) {
	            element = worklist.pop();
	
	            if (element === sentinel) {
	                element = leavelist.pop();
	
	                target = this.__execute(visitor.leave, element);
	
	                // node may be replaced with null,
	                // so distinguish between undefined and null in this place
	                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
	                    // replace
	                    element.ref.replace(target);
	                }
	
	                if (this.__state === REMOVE || target === REMOVE) {
	                    removeElem(element);
	                }
	
	                if (this.__state === BREAK || target === BREAK) {
	                    return outer.root;
	                }
	                continue;
	            }
	
	            target = this.__execute(visitor.enter, element);
	
	            // node may be replaced with null,
	            // so distinguish between undefined and null in this place
	            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
	                // replace
	                element.ref.replace(target);
	                element.node = target;
	            }
	
	            if (this.__state === REMOVE || target === REMOVE) {
	                removeElem(element);
	                element.node = null;
	            }
	
	            if (this.__state === BREAK || target === BREAK) {
	                return outer.root;
	            }
	
	            // node may be null
	            node = element.node;
	            if (!node) {
	                continue;
	            }
	
	            worklist.push(sentinel);
	            leavelist.push(element);
	
	            if (this.__state === SKIP || target === SKIP) {
	                continue;
	            }
	
	            nodeType = node.type || element.wrap;
	            candidates = this.__keys[nodeType];
	            if (!candidates) {
	                if (this.__fallback) {
	                    candidates = this.__fallback(node);
	                } else {
	                    throw new Error('Unknown node type ' + nodeType + '.');
	                }
	            }
	
	            current = candidates.length;
	            while ((current -= 1) >= 0) {
	                key = candidates[current];
	                candidate = node[key];
	                if (!candidate) {
	                    continue;
	                }
	
	                if (isArray(candidate)) {
	                    current2 = candidate.length;
	                    while ((current2 -= 1) >= 0) {
	                        if (!candidate[current2]) {
	                            continue;
	                        }
	                        if (isProperty(nodeType, candidates[current])) {
	                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
	                        } else if (isNode(candidate[current2])) {
	                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
	                        } else {
	                            continue;
	                        }
	                        worklist.push(element);
	                    }
	                } else if (isNode(candidate)) {
	                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
	                }
	            }
	        }
	
	        return outer.root;
	    };
	
	    function traverse(root, visitor) {
	        var controller = new Controller();
	        return controller.traverse(root, visitor);
	    }
	
	    function replace(root, visitor) {
	        var controller = new Controller();
	        return controller.replace(root, visitor);
	    }
	
	    function extendCommentRange(comment, tokens) {
	        var target;
	
	        target = upperBound(tokens, function search(token) {
	            return token.range[0] > comment.range[0];
	        });
	
	        comment.extendedRange = [comment.range[0], comment.range[1]];
	
	        if (target !== tokens.length) {
	            comment.extendedRange[1] = tokens[target].range[0];
	        }
	
	        target -= 1;
	        if (target >= 0) {
	            comment.extendedRange[0] = tokens[target].range[1];
	        }
	
	        return comment;
	    }
	
	    function attachComments(tree, providedComments, tokens) {
	        // At first, we should calculate extended comment ranges.
	        var comments = [], comment, len, i, cursor;
	
	        if (!tree.range) {
	            throw new Error('attachComments needs range information');
	        }
	
	        // tokens array is empty, we attach comments to tree as 'leadingComments'
	        if (!tokens.length) {
	            if (providedComments.length) {
	                for (i = 0, len = providedComments.length; i < len; i += 1) {
	                    comment = deepCopy(providedComments[i]);
	                    comment.extendedRange = [0, tree.range[0]];
	                    comments.push(comment);
	                }
	                tree.leadingComments = comments;
	            }
	            return tree;
	        }
	
	        for (i = 0, len = providedComments.length; i < len; i += 1) {
	            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
	        }
	
	        // This is based on John Freeman's implementation.
	        cursor = 0;
	        traverse(tree, {
	            enter: function (node) {
	                var comment;
	
	                while (cursor < comments.length) {
	                    comment = comments[cursor];
	                    if (comment.extendedRange[1] > node.range[0]) {
	                        break;
	                    }
	
	                    if (comment.extendedRange[1] === node.range[0]) {
	                        if (!node.leadingComments) {
	                            node.leadingComments = [];
	                        }
	                        node.leadingComments.push(comment);
	                        comments.splice(cursor, 1);
	                    } else {
	                        cursor += 1;
	                    }
	                }
	
	                // already out of owned node
	                if (cursor === comments.length) {
	                    return VisitorOption.Break;
	                }
	
	                if (comments[cursor].extendedRange[0] > node.range[1]) {
	                    return VisitorOption.Skip;
	                }
	            }
	        });
	
	        cursor = 0;
	        traverse(tree, {
	            leave: function (node) {
	                var comment;
	
	                while (cursor < comments.length) {
	                    comment = comments[cursor];
	                    if (node.range[1] < comment.extendedRange[0]) {
	                        break;
	                    }
	
	                    if (node.range[1] === comment.extendedRange[0]) {
	                        if (!node.trailingComments) {
	                            node.trailingComments = [];
	                        }
	                        node.trailingComments.push(comment);
	                        comments.splice(cursor, 1);
	                    } else {
	                        cursor += 1;
	                    }
	                }
	
	                // already out of owned node
	                if (cursor === comments.length) {
	                    return VisitorOption.Break;
	                }
	
	                if (comments[cursor].extendedRange[0] > node.range[1]) {
	                    return VisitorOption.Skip;
	                }
	            }
	        });
	
	        return tree;
	    }
	
	    exports.version = __webpack_require__(339).version;
	    exports.Syntax = Syntax;
	    exports.traverse = traverse;
	    exports.replace = replace;
	    exports.attachComments = attachComments;
	    exports.VisitorKeys = VisitorKeys;
	    exports.VisitorOption = VisitorOption;
	    exports.Controller = Controller;
	    exports.cloneEnvironment = function () { return clone({}); };
	
	    return exports;
	}(exports));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(41),
	    root = __webpack_require__(18);
	
	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');
	
	module.exports = Map;


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(420),
	    mapCacheDelete = __webpack_require__(421),
	    mapCacheGet = __webpack_require__(422),
	    mapCacheHas = __webpack_require__(423),
	    mapCacheSet = __webpack_require__(424);
	
	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	
	module.exports = MapCache;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(18);
	
	/** Built-in value references. */
	var Symbol = root.Symbol;
	
	module.exports = Symbol;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(67);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    object[key] = value;
	  }
	}
	
	module.exports = assignValue;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(358),
	    isFlattenable = __webpack_require__(411);
	
	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;
	
	  predicate || (predicate = isFlattenable);
	  result || (result = []);
	
	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}
	
	module.exports = baseFlatten;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var baseFindIndex = __webpack_require__(364),
	    baseIsNaN = __webpack_require__(371);
	
	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  if (value !== value) {
	    return baseFindIndex(array, baseIsNaN, fromIndex);
	  }
	  var index = fromIndex - 1,
	      length = array.length;
	
	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	module.exports = baseIndexOf;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(369),
	    isObject = __webpack_require__(24),
	    isObjectLike = __webpack_require__(12);
	
	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {boolean} [bitmask] The bitmask of comparison flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - Unordered comparison
	 *     2 - Partial comparison
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, bitmask, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	}
	
	module.exports = baseIsEqual;


/***/ },
/* 134 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	module.exports = baseProperty;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(129),
	    isSymbol = __webpack_require__(45);
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	module.exports = baseToString;


/***/ },
/* 136 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}
	
	module.exports = baseUnary;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(19),
	    stringToPath = __webpack_require__(437);
	
	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value) {
	  return isArray(value) ? value : stringToPath(value);
	}
	
	module.exports = castPath;


/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 139 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	  return value === proto;
	}
	
	module.exports = isPrototype;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLikeObject = __webpack_require__(209);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}
	
	module.exports = isArguments;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(135);
	
	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}
	
	module.exports = toString;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var createFormatter = __webpack_require__(465);
	var appendAst = __webpack_require__(470);
	var FileRenderer = __webpack_require__(482);
	var AssertionRenderer = __webpack_require__(475);
	var DiagramRenderer = __webpack_require__(479);
	var ComparisonRenderer = __webpack_require__(476);
	var defaultOptions = __webpack_require__(143);
	var assign = __webpack_require__(11);
	var map = __webpack_require__(111);
	
	// "Browserify can only analyze static requires. It is not in the scope of browserify to handle dynamic requires."
	// https://github.com/substack/node-browserify/issues/377
	var defaultRendererClasses = {
	    './built-in/file': FileRenderer,
	    './built-in/assertion': AssertionRenderer,
	    './built-in/diagram': DiagramRenderer,
	    './built-in/binary-expression': ComparisonRenderer
	};
	
	function toRendererClass (rendererName) {
	    var RendererClass;
	    if (typeof rendererName === 'function') {
	        RendererClass = rendererName;
	    } else if (typeof rendererName === 'string') {
	        if (defaultRendererClasses[rendererName]) {
	            RendererClass = defaultRendererClasses[rendererName];
	        } else {
	            RendererClass = __webpack_require__(474)(rendererName);
	        }
	    }
	    return RendererClass;
	}
	
	function create (options) {
	    var config = assign(defaultOptions(), options);
	    var rendererClasses = map(config.renderers, toRendererClass);
	    var renderers = map(rendererClasses, function (clazz) {
	        return { ctor: clazz, options: config };
	    });
	    return createFormatter(assign({}, config, {
	        reducers: [
	            appendAst
	        ],
	        renderers: renderers,
	        legacy: true
	    }));
	}
	
	create.renderers = {
	    AssertionRenderer: AssertionRenderer,
	    FileRenderer: FileRenderer,
	    DiagramRenderer: DiagramRenderer,
	    BinaryExpressionRenderer: ComparisonRenderer
	};
	create.defaultOptions = defaultOptions;
	module.exports = create;


/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function defaultOptions () {
	    return {
	        lineDiffThreshold: 5,
	        maxDepth: 1,
	        outputOffset: 2,
	        anonymous: 'Object',
	        circular: '#@Circular#',
	        lineSeparator: '\n',
	        ambiguousEastAsianCharWidth: 2,
	        renderers: [
	            './built-in/file',
	            './built-in/assertion',
	            './built-in/diagram',
	            './built-in/binary-expression'
	        ]
	    };
	};


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(20);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var EmptyObservable = (function (_super) {
	    __extends(EmptyObservable, _super);
	    function EmptyObservable(scheduler) {
	        _super.call(this);
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer and immediately
	     * emits a complete notification.
	     *
	     * <span class="informal">Just emits 'complete', and nothing else.
	     * </span>
	     *
	     * <img src="./img/empty.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the complete notification. It can be used for composing with other
	     * Observables, such as in a {@link mergeMap}.
	     *
	     * @example <caption>Emit the number 7, then complete.</caption>
	     * var result = Rx.Observable.empty().startWith(7);
	     * result.subscribe(x => console.log(x));
	     *
	     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
	     * var interval = Rx.Observable.interval(1000);
	     * var result = interval.mergeMap(x =>
	     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
	     * );
	     * result.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     * @see {@link never}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
	     * the emission of the complete notification.
	     * @return {Observable} An "empty" Observable: emits only the complete
	     * notification.
	     * @static true
	     * @name empty
	     * @owner Observable
	     */
	    EmptyObservable.create = function (scheduler) {
	        return new EmptyObservable(scheduler);
	    };
	    EmptyObservable.dispatch = function (arg) {
	        var subscriber = arg.subscriber;
	        subscriber.complete();
	    };
	    EmptyObservable.prototype._subscribe = function (subscriber) {
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
	        }
	        else {
	            subscriber.complete();
	        }
	    };
	    return EmptyObservable;
	}(Observable_1.Observable));
	exports.EmptyObservable = EmptyObservable;
	//# sourceMappingURL=EmptyObservable.js.map

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Groups pairs of consecutive emissions together and emits them as an array of
	 * two values.
	 *
	 * <span class="informal">Puts the current value and previous value together as
	 * an array, and emits that.</span>
	 *
	 * <img src="./img/pairwise.png" width="100%">
	 *
	 * The Nth emission from the source Observable will cause the output Observable
	 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
	 * pair. For this reason, `pairwise` emits on the second and subsequent
	 * emissions from the source Observable, but not on the first emission, because
	 * there is no previous value in that case.
	 *
	 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var pairs = clicks.pairwise();
	 * var distance = pairs.map(pair => {
	 *   var x0 = pair[0].clientX;
	 *   var y0 = pair[0].clientY;
	 *   var x1 = pair[1].clientX;
	 *   var y1 = pair[1].clientY;
	 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
	 * });
	 * distance.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 *
	 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
	 * consecutive values from the source Observable.
	 * @method pairwise
	 * @owner Observable
	 */
	function pairwise() {
	    return this.lift(new PairwiseOperator());
	}
	exports.pairwise = pairwise;
	var PairwiseOperator = (function () {
	    function PairwiseOperator() {
	    }
	    PairwiseOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new PairwiseSubscriber(subscriber));
	    };
	    return PairwiseOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var PairwiseSubscriber = (function (_super) {
	    __extends(PairwiseSubscriber, _super);
	    function PairwiseSubscriber(destination) {
	        _super.call(this, destination);
	        this.hasPrev = false;
	    }
	    PairwiseSubscriber.prototype._next = function (value) {
	        if (this.hasPrev) {
	            this.destination.next([this.prev, value]);
	        }
	        else {
	            this.hasPrev = true;
	        }
	        this.prev = value;
	    };
	    return PairwiseSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=pairwise.js.map

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(54);
	var Symbol = root_1.root.Symbol;
	exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	//# sourceMappingURL=rxSubscriber.js.map

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(103);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ },
/* 148 */
/***/ function(module, exports) {

	/**
	 * type-name - Just a reasonable typeof
	 *
	 * https://github.com/twada/type-name
	 *
	 * Copyright (c) 2014-2016 Takuto Wada
	 * Licensed under the MIT license.
	 *   https://github.com/twada/type-name/blob/master/LICENSE
	 */
	'use strict';
	
	var toStr = Object.prototype.toString;
	
	function funcName (f) {
	    if (f.name) {
	        return f.name;
	    }
	    var match = /^\s*function\s*([^\(]*)/im.exec(f.toString());
	    return match ? match[1] : '';
	}
	
	function ctorName (obj) {
	    var strName = toStr.call(obj).slice(8, -1);
	    if ((strName === 'Object' || strName === 'Error') && obj.constructor) {
	        return funcName(obj.constructor);
	    }
	    return strName;
	}
	
	function typeName (val) {
	    var type;
	    if (val === null) {
	        return 'null';
	    }
	    type = typeof val;
	    if (type === 'object') {
	        return ctorName(val);
	    }
	    return type;
	}
	
	module.exports = typeName;


/***/ },
/* 149 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var createMathOperation = __webpack_require__(398);
	
	/**
	 * Adds two numbers.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.4.0
	 * @category Math
	 * @param {number} augend The first number in an addition.
	 * @param {number} addend The second number in an addition.
	 * @returns {number} Returns the total.
	 * @example
	 *
	 * _.add(6, 4);
	 * // => 10
	 */
	var add = createMathOperation(function(augend, addend) {
	  return augend + addend;
	}, 0);
	
	module.exports = add;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var merge_1 = __webpack_require__(215);
	exports.merge = merge_1.mergeStatic;
	//# sourceMappingURL=merge.js.map

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(47);
	exports.of = ArrayObservable_1.ArrayObservable.of;
	//# sourceMappingURL=of.js.map

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isScheduler_1 = __webpack_require__(73);
	var ArrayObservable_1 = __webpack_require__(47);
	var mergeAll_1 = __webpack_require__(216);
	/**
	 * Creates an output Observable which sequentially emits all values from every
	 * given input Observable after the current Observable.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * Joins this Observable with multiple other Observables by subscribing to them
	 * one at a time, starting with the source, and merging their results into the
	 * output Observable. Will wait for each Observable to complete before moving
	 * on to the next.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = timer.concat(sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Concatenate 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = timer1.concat(timer2, timer3);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {Observable} other An input Observable to concatenate after the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @method concat
	 * @owner Observable
	 */
	function concat() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return concatStatic.apply(void 0, [this].concat(observables));
	}
	exports.concat = concat;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which sequentially emits all values from every
	 * given input Observable after the current Observable.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * Joins multiple Observables together by subscribing to them one at a time and
	 * merging their results into the output Observable. Will wait for each
	 * Observable to complete before moving on to the next.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = Rx.Observable.concat(timer, sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Concatenate 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = Rx.Observable.concat(timer1, timer2, timer3);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {Observable} input1 An input Observable to concatenate with others.
	 * @param {Observable} input2 An input Observable to concatenate with others.
	 * More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @static true
	 * @name concat
	 * @owner Observable
	 */
	function concatStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var scheduler = null;
	    var args = observables;
	    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
	        scheduler = args.pop();
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
	}
	exports.concatStatic = concatStatic;
	//# sourceMappingURL=concat.js.map

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _dec2, _dec3, _dec4, _dec5, _desc, _value, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
	
	var _jquery = __webpack_require__(31);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _snap = __webpack_require__(74);
	
	var _snap2 = _interopRequireDefault(_snap);
	
	var _pick = __webpack_require__(17);
	
	var _pick2 = _interopRequireDefault(_pick);
	
	var _defaults = __webpack_require__(40);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	var _isNumber2 = __webpack_require__(63);
	
	var _isNumber3 = _interopRequireDefault(_isNumber2);
	
	var _size = __webpack_require__(92);
	
	var _size2 = _interopRequireDefault(_size);
	
	var _at = __webpack_require__(91);
	
	var _at2 = _interopRequireDefault(_at);
	
	var _isNumber4 = __webpack_require__(44);
	
	var _isNumber5 = _interopRequireDefault(_isNumber4);
	
	var _isBoolean2 = __webpack_require__(43);
	
	var _isBoolean3 = _interopRequireDefault(_isBoolean2);
	
	var _defer2 = __webpack_require__(98);
	
	var _defer3 = _interopRequireDefault(_defer2);
	
	var _uniqueId = __webpack_require__(101);
	
	var _uniqueId2 = _interopRequireDefault(_uniqueId);
	
	var _combineLatest = __webpack_require__(33);
	
	var _map = __webpack_require__(15);
	
	var _take = __webpack_require__(48);
	
	var _toPromise = __webpack_require__(110);
	
	var _chroma = __webpack_require__(81);
	
	var _chroma2 = _interopRequireDefault(_chroma);
	
	var _SvgEntity2 = __webpack_require__(80);
	
	var _SvgEntity3 = _interopRequireDefault(_SvgEntity2);
	
	var _ValueTracker = __webpack_require__(6);
	
	var _ObservableSet = __webpack_require__(55);
	
	var _ObservableSet2 = _interopRequireDefault(_ObservableSet);
	
	var _ValueTracker2 = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _initDefineProp(target, property, descriptor, context) {
		if (!descriptor) return;
		Object.defineProperty(target, property, {
			enumerable: descriptor.enumerable,
			configurable: descriptor.configurable,
			writable: descriptor.writable,
			value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
		});
	}
	
	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
		var desc = {};
		Object['ke' + 'ys'](descriptor).forEach(function (key) {
			desc[key] = descriptor[key];
		});
		desc.enumerable = !!desc.enumerable;
		desc.configurable = !!desc.configurable;
	
		if ('value' in desc || desc.initializer) {
			desc.writable = true;
		}
	
		desc = decorators.slice().reverse().reduce(function (desc, decorator) {
			return decorator(target, property, desc) || desc;
		}, desc);
	
		if (context && desc.initializer !== void 0) {
			desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
			desc.initializer = undefined;
		}
	
		if (desc.initializer === void 0) {
			Object['define' + 'Property'](target, property, desc);
			desc = null;
		}
	
		return desc;
	}
	
	function _initializerWarningHelper(descriptor, context) {
		throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
	}
	
	var $$backgroundColor = Symbol('$$backgroundColor');
	
	var BorderLine = (_dec = (0, _ValueTracker.property)({ isValid: _isNumber5.default }), _dec2 = (0, _ValueTracker.property)({ isValid: _isNumber5.default }), _dec3 = (0, _ValueTracker.property)({ isValid: _isNumber5.default }), _dec4 = (0, _ValueTracker.property)({ isValid: _isNumber5.default }), _dec5 = (0, _ValueTracker2.flag)(true), (_class = function (_SvgEntity) {
		_inherits(BorderLine, _SvgEntity);
	
		_createClass(BorderLine, [{
			key: 'toString',
			value: function toString() {
				return '[' + this.constructor.name + ']';
			}
		}]);
	
		function BorderLine(options) {
			_classCallCheck(this, BorderLine);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BorderLine).call(this, options));
	
			_initDefineProp(_this, 'x1', _descriptor, _this);
	
			_initDefineProp(_this, 'y1', _descriptor2, _this);
	
			_initDefineProp(_this, 'x2', _descriptor3, _this);
	
			_initDefineProp(_this, 'y2', _descriptor4, _this);
	
			_initDefineProp(_this, 'movable', _descriptor5, _this);
	
			_this.setFromObject(options, ['x1', 'y1', 'x2', 'y2', 'free', 'movable']);
			return _this;
		}
	
		_createClass(BorderLine, [{
			key: 'createElement',
			value: function createElement() {
				var _this2 = this;
	
				var dimKeys = ['x1', 'y1', 'x2', 'y2'];
	
				var group = (0, _snap.gElement)();
	
				var lineSegment = function () {
					var result = group.line().attr({
						strokeWidth: '2px',
						stroke: 'black',
						shapeRendering: 'crispEdges',
						pointerEvents: 'none'
					});
	
					if (!(dimKeys && (typeof dimKeys[Symbol.iterator] === 'function' || Array.isArray(dimKeys)))) {
						throw new TypeError('Expected dimKeys to be iterable, got ' + _inspect(dimKeys));
					}
	
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;
	
					try {
						var _loop = function _loop() {
							var key = _step.value;
	
							_this2.p(key).subscribe(function (v) {
								return result.attr(_defineProperty({}, key, v));
							});
						};
	
						for (var _iterator = dimKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							_loop();
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
	
					_this2.model.p('nature').subscribe(function (v) {
						result.attr({
							strokeDasharray: v === 'open' ? '5, 5' : 'none'
						});
					});
	
					return result;
				}();
	
				/* return representation(s) of element */
				return {
					element: group.node
				};
			}
		}, {
			key: 'afterCreateElement',
			value: function () {
				var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
					var _this3 = this;
	
					return regeneratorRuntime.wrap(function _callee2$(_context2) {
						while (1) {
							switch (_context2.prev = _context2.next) {
								case 0:
									_get(Object.getPrototypeOf(BorderLine.prototype), 'afterCreateElement', this).call(this);
	
									if (!this.movable) {
										_context2.next = 3;
										break;
									}
	
									return _context2.delegateYield(regeneratorRuntime.mark(function _callee() {
										var parentLyph, result;
										return regeneratorRuntime.wrap(function _callee$(_context) {
											while (1) {
												switch (_context.prev = _context.next) {
													case 0:
														parentLyph = _this3.findAncestor(function (a) {
															return a.free;
														});
	
														/* wait until we can get parentLyph.element */
														// TODO: create 'element ready' promise for this
	
														_context.next = 3;
														return new Promise(function (resolve) {
															setTimeout(resolve);
														});
	
													case 3:
														result = (0, _snap.gElement)().rect();
	
														(0, _jquery2.default)(result.node).css({ opacity: 0 }).attr('controller', '' + _this3).data('controller', _this3);
	
														_this3.p(['x1', 'x2', 'y1', 'y2']).subscribe(function (_ref2) {
															var _ref3 = _slicedToArray(_ref2, 4);
	
															var x1 = _ref3[0];
															var x2 = _ref3[1];
															var y1 = _ref3[2];
															var y2 = _ref3[3];
	
															if (x1 === x2) {
																(0, _jquery2.default)(result.node).css({ cursor: 'col-resize' });
																result.attr({
																	x: x1 - 2,
																	y: y1,
																	width: 5,
																	height: Math.abs(y1 - y2)
																});
															} else {
																(0, _jquery2.default)(result.node).css({ cursor: 'row-resize' });
																result.attr({
																	x: x1,
																	y: y1 - 2,
																	width: Math.abs(x1 - x2),
																	height: 5
																});
															}
														});
	
														parentLyph.inside.jq.children('.foreground').append(result.node);
	
													case 7:
													case 'end':
														return _context.stop();
												}
											}
										}, _callee, _this3);
									})(), 't0', 3);
	
								case 3:
								case 'end':
									return _context2.stop();
							}
						}
					}, _callee2, this);
				}));
	
				function afterCreateElement() {
					return _ref.apply(this, arguments);
				}
	
				return afterCreateElement;
			}()
		}, {
			key: 'drop',
			value: function drop(droppedEntity) {
				// TODO
			}
		}, {
			key: 'draggable',
			get: function get() {
				return false;
			}
		}]);
	
		return BorderLine;
	}(_SvgEntity3.default), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'x1', [_dec], {
		enumerable: true,
		initializer: null
	}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'y1', [_dec2], {
		enumerable: true,
		initializer: null
	}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, 'x2', [_dec3], {
		enumerable: true,
		initializer: null
	}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, 'y2', [_dec4], {
		enumerable: true,
		initializer: null
	}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, 'movable', [_dec5], {
		enumerable: true,
		initializer: null
	})), _class));
	
	// export default class LyphRectangle extends SvgEntity {
	//
	// 	@property({                                          }) x;
	// 	@property({                                          }) y;
	// 	@property({ isValid(w) { return w > this.minWidth  } }) width;
	// 	@property({ isValid(h) { return h > this.minHeight } }) height;
	//
	// 	get axisThickness() { return this.model.layers.length > 0 ? 10 : 0                                }
	// 	get minWidth     () { return 2 * (this.axisThickness + 1)                                         }
	// 	get minHeight    () { return this.axisThickness + (this.model ? this.model.layers.length * 2 : 5) }
	//
	// 	layers = [];
	//
	// 	constructor(options) {
	// 		super(options);
	//
	// 		this.setFromObject(options, {
	// 			showAxis: true
	// 		});
	//
	// 		/* create the layer template boxes */ // TODO: sort by border-shared nodes
	// 		this.layers = [...this.model.layers].map(layer => new LyphRectangle({
	// 			parent:     this,
	// 			model:      layer,
	// 			showAxis:   false
	// 		}));
	//
	// 		/* create a random color (one per layer, stored in the model) */
	// 		if (!this.model[$$backgroundColor]) {
	// 			this.model[$$backgroundColor] = chroma.randomHsvGolden(0.8, 0.8);
	// 		}
	// 	}
	//
	// 	createElement() {
	// 		/* main HTML */
	// 		let clipPathId = uniqueId('clip-path');
	// 		let result = $.svg(`
	// 			<g>
	// 				<rect class="lyphRectangle"></rect>
	// 				<svg class="axis">
	// 					<defs>
	// 						<clipPath id="${clipPathId}">
	// 							<rect x="0" y="0" height="100%" width="100%"></rect>
	// 						</clipPath>
	// 					</defs>
	// 					<rect class="axis-background" x="0" y="0" height="100%" width="100%"></rect>
	// 					<svg class="text-area">
	// 						<text class="minus" stroke="white"> - </text>
	// 						<text class="label" stroke="none" clip-path="url(#${clipPathId})"> ${this.model.name} </text>
	// 						<text class="plus " stroke="white"> + </text>
	// 					</svg>
	// 				</svg>
	// 				<g class="child-container"></g>
	// 			</g>
	// 		`);
	//
	// 		/* extract and style important elements */
	// 		const lyphRectangle = result.find('.lyphRectangle').css({
	// 			stroke:         'black',
	// 			fill:           this.model[$$backgroundColor],
	// 			shapeRendering: 'crispEdges',
	// 			pointerEvents:  'all'
	// 		});
	// 		const axis = result.find('svg.axis').css({
	// 			stroke:         'black',
	// 			fill:           'black',
	// 			shapeRendering: 'crispEdges',
	// 			pointerEvents:  'none',
	// 			overflow:       'visible'
	// 		});
	// 		const textArea = axis.children('svg.text-area').css({
	// 			stroke:         'black',
	// 			fill:           'black',
	// 			shapeRendering: 'crispEdges',
	// 			pointerEvents:  'none',
	// 			overflow:       'hidden'
	// 		});
	// 		axis.children('.axis-background').css({
	// 			stroke:         'black',
	// 			fill:           'black',
	// 			shapeRendering: 'crispEdges'
	// 		});
	// 		const axisText = textArea.children('text').css({
	// 			fill:             'white',
	// 			fontSize:         `14px`,
	// 			textRendering:    'geometricPrecision',
	// 			pointerEvents:    'none',
	// 			dominantBaseline: 'central'
	// 		});
	//
	// 		/* add layer template boxes */
	// 		for (let lTBox of this.layers) {
	// 			result.children('.child-container').append(lTBox.element);
	// 		}
	//
	// 		/* react to dimension changes */
	// 		const at = this.axisThickness;
	// 		let dimensioning = this.p(['x', 'y', 'width', 'height'], [], (x, y, width, height) => ({ x, y, width, height, tX: 0, tY: 4, tWidth: at,      tHeight: height, minusX: '50%',  minusY: '0%',   labelX: '50%', labelY: '50%', plusX: '50%',  plusY: '100%', minusAnchor: 'start', labelAnchor: 'middle', plusAnchor: 'end',   writingMode: 'vertical-rl'   }));
	// 		dimensioning.subscribe((d) => {
	//
	// 			lyphRectangle.attr('x',  d.x );
	// 			lyphRectangle.attr('y', d.y);
	// 			lyphRectangle.attr('width',  d.width );
	// 			lyphRectangle.attr('height', d.height);
	//
	// 			axis.attr('x',      d.x     );
	// 			axis.attr('y',      d.y     );
	// 			axis.attr('width',  at );
	// 			axis.attr('height', d.height);
	//
	// 			textArea.attr('x',      d.tX     );
	// 			textArea.attr('y',      d.tY     );
	// 			textArea.attr('width',  d.tWidth );
	// 			textArea.attr('height', d.tHeight);
	//
	// 			axisText.attr('writing-mode', d.writingMode);
	//
	// 			axisText.filter('.minus').attr('x', d.minusX);
	// 			axisText.filter('.minus').attr('y', d.minusY);
	// 			axisText.filter('.minus').attr('text-anchor', d.minusAnchor);
	//
	// 			axisText.filter('.label').attr('x', d.labelX);
	// 			axisText.filter('.label').attr('y', d.labelY);
	// 			axisText.filter('.label').attr('text-anchor', d.labelAnchor);
	//
	// 			axisText.filter('.plus').attr('x', d.plusX);
	// 			axisText.filter('.plus').attr('y', d.plusY);
	// 			axisText.filter('.plus').attr('text-anchor', d.plusAnchor);
	//
	// 			let layerCount = this.layers.length;
	// 			let layerWidth = (d.width - at) / layerCount;
	// 			for (let i = 0; i < layerCount; ++i) {
	// 				let box = this.layers[i];
	// 				box.x = d.x + at + i * layerWidth;
	// 				box.y = d.y;
	// 				box.width = layerWidth;
	// 				box.height = d.height;
	// 			}
	// 		});
	//
	// 		/* return result */
	// 		return result;
	// 	}
	//
	// 	// plugContainerPositioning() {
	// 	// 	let containerDims = this.xywhr.map(({x, y, width, height, rotation}) => sw(rotation)({
	// 	// 		0: {
	// 	// 			cx:      x,
	// 	// 			cy:      y,
	// 	// 			cwidth:  width,
	// 	// 			cheight: height - this.axisThickness
	// 	// 		},
	// 	// 		90: {
	// 	// 			cx:      x + this.axisThickness,
	// 	// 			cy:      y,
	// 	// 			cwidth:  width - this.axisThickness,
	// 	// 			cheight: height
	// 	// 		},
	// 	// 		180: {
	// 	// 			cx:      x,
	// 	// 			cy:      y + this.axisThickness,
	// 	// 			cwidth:  width,
	// 	// 			cheight: height - this.axisThickness
	// 	// 		},
	// 	// 		270: {
	// 	// 			cx:      x,
	// 	// 			cy:      y,
	// 	// 			cwidth:  width - this.axisThickness,
	// 	// 			cheight: height
	// 	// 		}
	// 	// 	}));
	// 	// 	this.p('cx')     .plug(containerDims.map(get('cx'))     );
	// 	// 	this.p('cy')     .plug(containerDims.map(get('cy'))     );
	// 	// 	this.p('cwidth') .plug(containerDims.map(get('cwidth')) );
	// 	// 	this.p('cheight').plug(containerDims.map(get('cheight')));
	// 	// }
	//
	// 	// draggable() {
	// 	// 	let raw;//, rootRect;
	// 	// 	return {
	// 	// 		autoScroll: true,
	// 	// 		onstart: (event) => { // TODO: make streams for these events somewhere up the class hierarchy
	// 	// 			event.stopPropagation();
	// 	// 			this.moveToFront();
	// 	//
	// 	// 			/* initialize interaction-local variables */
	// 	// 			raw = pick(this, 'x', 'y');
	// 	// 			// rootRect = this.root.boundingBox();
	// 	// 		},
	// 	// 		onmove: ({dx, dy}) => {
	// 	// 			/* update raw coordinates */
	// 	// 			raw.x += dx;
	// 	// 			raw.y += dy;
	// 	//
	// 	// 			/* initialize visible coordinates */
	// 	// 			let visible = clone(raw);
	// 	//
	// 	// 			// TODO: snapping
	// 	//
	// 	// 			/* restriction correction */
	// 	// 			visible.x = clamp( this.root.cx, this.root.cx + this.root.cwidth  - this.width  )( visible.x );
	// 	// 			visible.y = clamp( this.root.cy, this.root.cy + this.root.cheight - this.height )( visible.y );
	// 	//
	// 	// 			/* set the actual visible coordinates */
	// 	// 			Object.assign(this, visible);
	// 	// 		}
	// 	// 	};
	// 	// }
	//
	// 	// resizable() {
	// 	// 	let raw;
	// 	// 	return {
	// 	// 		handle: '.lyphRectangle',
	// 	// 		edges: { left: true, right: true, bottom: true, top: true },
	// 	// 		onstart: (event) => {
	// 	// 			event.stopPropagation();
	// 	// 			this.moveToFront();
	// 	//
	// 	// 			/* initialize interaction-local variables */
	// 	// 			raw  = pick(this, 'x', 'y', 'width', 'height');
	// 	// 		},
	// 	// 		onmove: ({rect, edges, ctrlKey}) => {
	// 	//
	// 	// 			/* update raw coordinates */
	// 	// 			raw.width  = Math.max(rect.width,  this.minWidth );
	// 	// 			raw.height = Math.max(rect.height, this.minHeight);
	// 	//
	// 	// 			/* maintain aspect ratio */
	// 	// 			if (ctrlKey) {
	// 	// 				let correctedSize = this.model.maintainRepresentativeAspectRatio(raw);
	// 	// 				if (correctedSize) { Object.assign(raw, correctedSize) }
	// 	// 			}
	// 	//
	// 	// 			/* correct for left and top edge dragging */
	// 	// 			if (edges.left) { raw.x = rect.left - (raw.width  - rect.width ) }
	// 	// 			if (edges.top)  { raw.y = rect.top  - (raw.height - rect.height) }
	// 	//
	// 	// 			/* initialize visible coordinates */
	// 	// 			let visible = clone(raw);
	// 	//
	// 	// 			// TODO: snapping
	// 	//
	// 	// 			/* restriction correction */
	// 	// 			if (edges.left && visible.x < this.parent.cx) {
	// 	// 				visible.width = (visible.x + visible.width) - this.parent.cx;
	// 	// 				visible.x = this.parent.cx;
	// 	// 			}
	// 	// 			if (edges.top && visible.y < this.parent.cy) {
	// 	// 				visible.height = (visible.y + visible.height) - this.parent.cy;
	// 	// 				visible.y = this.parent.cy;
	// 	// 			}
	// 	// 			if (edges.right && visible.x + visible.width > this.parent.cx + this.parent.cwidth) {
	// 	// 				visible.width = (this.parent.cx + this.parent.cwidth) - visible.x;
	// 	// 			}
	// 	// 			if (edges.bottom && visible.y + visible.height > this.parent.cy + this.parent.cheight) {
	// 	// 				visible.height = (this.parent.cy + this.parent.cheight) - visible.y;
	// 	// 			}
	// 	//
	// 	// 			/* set visible (x, y) based on snapping and restriction */
	// 	// 			this.set(visible);
	// 	// 		}
	// 	// 	};
	// 	// }
	//
	// }
	
	exports.default = BorderLine;
	
	function _inspect(input, depth) {
		var maxDepth = 4;
		var maxKeys = 15;

		if (depth === undefined) {
			depth = 0;
		}

		depth += 1;

		if (input === null) {
			return 'null';
		} else if (input === undefined) {
			return 'void';
		} else if (typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean') {
			return typeof input === 'undefined' ? 'undefined' : _typeof(input);
		} else if (Array.isArray(input)) {
			if (input.length > 0) {
				var _ret3 = function () {
					if (depth > maxDepth) return {
							v: '[...]'
						};

					var first = _inspect(input[0], depth);

					if (input.every(function (item) {
						return _inspect(item, depth) === first;
					})) {
						return {
							v: first.trim() + '[]'
						};
					} else {
						return {
							v: '[' + input.slice(0, maxKeys).map(function (item) {
								return _inspect(item, depth);
							}).join(', ') + (input.length >= maxKeys ? ', ...' : '') + ']'
						};
					}
				}();

				if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === "object") return _ret3.v;
			} else {
				return 'Array';
			}
		} else {
			var keys = Object.keys(input);

			if (!keys.length) {
				if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
					return input.constructor.name;
				} else {
					return 'Object';
				}
			}

			if (depth > maxDepth) return '{...}';
			var indent = '  '.repeat(depth - 1);
			var entries = keys.slice(0, maxKeys).map(function (key) {
				return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + ': ' + _inspect(input[key], depth) + ';';
			}).join('\n  ' + indent);

			if (keys.length >= maxKeys) {
				entries += '\n  ' + indent + '...';
			}

			if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
				return input.constructor.name + ' {\n  ' + indent + entries + '\n' + indent + '}';
			} else {
				return '{\n  ' + indent + entries + '\n' + indent + '}';
			}
		}
	}

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _openPhysiologyModelMinimal = __webpack_require__(464);
	
	var _openPhysiologyModelMinimal2 = _interopRequireDefault(_openPhysiologyModelMinimal);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _openPhysiologyModelMinimal2.default)();

/***/ },
/* 161 */,
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }
	
	var _object = __webpack_require__(252);
	
	_defaults(exports, _interopRequireWildcard(_object));
	
	var _symbolJs = __webpack_require__(253);
	
	_defaults(exports, _interopRequireWildcard(_symbolJs));
	
	var _numberJs = __webpack_require__(251);
	
	_defaults(exports, _interopRequireWildcard(_numberJs));
	
	var _mathJs = __webpack_require__(250);
	
	_defaults(exports, _interopRequireWildcard(_mathJs));
	
	var _dateJs = __webpack_require__(248);
	
	_defaults(exports, _interopRequireWildcard(_dateJs));
	
	var _arrayJs = __webpack_require__(247);
	
	_defaults(exports, _interopRequireWildcard(_arrayJs));
	
	var _arrayBufferJs = __webpack_require__(246);
	
	_defaults(exports, _interopRequireWildcard(_arrayBufferJs));
	
	var _jsonJs = __webpack_require__(249);
	
	_defaults(exports, _interopRequireWildcard(_jsonJs));

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(245)
	var ieee754 = __webpack_require__(334)
	var isArray = __webpack_require__(337)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(163).Buffer, (function() { return this; }())))

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(277);
	module.exports = __webpack_require__(5).Array.filter;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(279);
	module.exports = __webpack_require__(5).Array.indexOf;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(287);
	var $Object = __webpack_require__(5).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 167 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(179)
	  , toLength  = __webpack_require__(116)
	  , toIndex   = __webpack_require__(274);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(167)
	  , toObject  = __webpack_require__(86)
	  , IObject   = __webpack_require__(84)
	  , toLength  = __webpack_require__(116);
	
	module.exports = function(that, callbackfn, aLen, memo, isRight){
	  aFunction(callbackfn);
	  var O      = toObject(that)
	    , self   = IObject(O)
	    , length = toLength(O.length)
	    , index  = isRight ? length - 1 : 0
	    , i      = isRight ? -1 : 1;
	  if(aLen < 2)for(;;){
	    if(index in self){
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if(isRight ? index < 0 : length <= index){
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

/***/ },
/* 170 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(167);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 172 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(85)
	  , document = __webpack_require__(58).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 174 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(170);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(177)('keys')
	  , uid    = __webpack_require__(180);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(58)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 178 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(84)
	  , defined = __webpack_require__(172);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 180 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * empower-core - Power Assert feature enhancer for assert function/object.
	 *
	 * https://github.com/twada/empower-core
	 *
	 * Copyright (c) 2013-2016 Takuto Wada
	 * Licensed under the MIT license.
	 *   https://github.com/twada/empower-core/blob/master/MIT-LICENSE.txt
	 */
	var create = __webpack_require__(259);
	var assign = __webpack_require__(11);
	var defaultOptions = __webpack_require__(320);
	var Decorator = __webpack_require__(319);
	var define = __webpack_require__(321);
	var slice = Array.prototype.slice;
	
	/**
	 * Enhance Power Assert feature to assert function/object.
	 * @param assert target assert function or object to enhance
	 * @param options enhancement options
	 * @return enhanced assert function/object
	 */
	function empowerCore (assert, options) {
	    var typeOfAssert = (typeof assert);
	    var enhancedAssert;
	    if ((typeOfAssert !== 'object' && typeOfAssert !== 'function') || assert === null) {
	        throw new TypeError('empower-core argument should be a function or object.');
	    }
	    if (isEmpowered(assert)) {
	        return assert;
	    }
	    switch (typeOfAssert) {
	    case 'function':
	        enhancedAssert = empowerAssertFunction(assert, options);
	        break;
	    case 'object':
	        enhancedAssert = empowerAssertObject(assert, options);
	        break;
	    default:
	        throw new Error('Cannot be here');
	    }
	    define(enhancedAssert, { _empowered: true });
	    return enhancedAssert;
	}
	
	function empowerAssertObject (assertObject, options) {
	    var config = assign(defaultOptions(), options);
	    var target = config.destructive ? assertObject : create(assertObject);
	    var decorator = new Decorator(target, config);
	    return assign(target, decorator.enhancement());
	}
	
	function empowerAssertFunction (assertFunction, options) {
	    var config = assign(defaultOptions(), options);
	    if (config.destructive) {
	        throw new Error('cannot use destructive:true to function.');
	    }
	    var decorator = new Decorator(assertFunction, config);
	    var enhancement = decorator.enhancement();
	    var powerAssert;
	    if (typeof enhancement === 'function') {
	        powerAssert = function powerAssert () {
	            return enhancement.apply(null, slice.apply(arguments));
	        };
	    } else {
	        powerAssert = function powerAssert () {
	            return assertFunction.apply(null, slice.apply(arguments));
	        };
	    }
	    assign(powerAssert, assertFunction);
	    return assign(powerAssert, enhancement);
	}
	
	function isEmpowered (assertObjectOrFunction) {
	    return assertObjectOrFunction._empowered;
	}
	
	empowerCore.defaultOptions = defaultOptions;
	module.exports = empowerCore;


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(442);
	
	module.exports = function entries() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(19);
	
	module.exports = function isArray() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(68);
	
	module.exports = function isString() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(25);
	
	module.exports = function keys() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(93),
	    stackClear = __webpack_require__(430),
	    stackDelete = __webpack_require__(431),
	    stackGet = __webpack_require__(432),
	    stackHas = __webpack_require__(433),
	    stackSet = __webpack_require__(434);
	
	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  this.__data__ = new ListCache(entries);
	}
	
	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	
	module.exports = Stack;


/***/ },
/* 190 */
/***/ function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}
	
	module.exports = apply;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(137),
	    isKey = __webpack_require__(66),
	    toKey = __webpack_require__(42);
	
	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = isKey(path, object) ? [path] : castPath(path);
	
	  var index = 0,
	      length = path.length;
	
	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}
	
	module.exports = baseGet;


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var getPrototype = __webpack_require__(198);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * The base implementation of `_.has` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHas(object, key) {
	  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
	  // that are composed entirely of index properties, return `false` for
	  // `hasOwnProperty` checks of them.
	  return object != null &&
	    (hasOwnProperty.call(object, key) ||
	      (typeof object == 'object' && key in object && getPrototype(object) === null));
	}
	
	module.exports = baseHas;


/***/ },
/* 193 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	module.exports = baseTimes;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(130);
	
	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  object || (object = {});
	
	  var index = -1,
	      length = props.length;
	
	  while (++index < length) {
	    var key = props[index];
	
	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;
	
	    assignValue(object, key, newValue === undefined ? source[key] : newValue);
	  }
	  return object;
	}
	
	module.exports = copyObject;


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(29),
	    isIterateeCall = __webpack_require__(200);
	
	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;
	
	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;
	
	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}
	
	module.exports = createAssigner;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(354),
	    arraySome = __webpack_require__(359);
	
	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;
	
	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      arrLength = array.length,
	      othLength = other.length;
	
	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;
	
	  stack.set(array, other);
	  stack.set(other, array);
	
	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];
	
	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!seen.has(othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	              return seen.add(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, customizer, bitmask, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}
	
	module.exports = equalArrays;


/***/ },
/* 197 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	module.exports = freeGlobal;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(205);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetPrototype = Object.getPrototypeOf;
	
	/**
	 * Gets the `[[Prototype]]` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {null|Object} Returns the `[[Prototype]]`.
	 */
	var getPrototype = overArg(nativeGetPrototype, Object);
	
	module.exports = getPrototype;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(193),
	    isArguments = __webpack_require__(140),
	    isArray = __webpack_require__(19),
	    isLength = __webpack_require__(100),
	    isString = __webpack_require__(68);
	
	/**
	 * Creates an array of index keys for `object` values of arrays,
	 * `arguments` objects, and strings, otherwise `null` is returned.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array|null} Returns index keys, else `null`.
	 */
	function indexKeys(object) {
	  var length = object ? object.length : undefined;
	  if (isLength(length) &&
	      (isArray(object) || isString(object) || isArguments(object))) {
	    return baseTimes(length, String);
	  }
	  return null;
	}
	
	module.exports = indexKeys;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(67),
	    isArrayLike = __webpack_require__(23),
	    isIndex = __webpack_require__(65),
	    isObject = __webpack_require__(24);
	
	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}
	
	module.exports = isIterateeCall;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(24);
	
	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}
	
	module.exports = isStrictComparable;


/***/ },
/* 202 */
/***/ function(module, exports) {

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);
	
	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}
	
	module.exports = mapToArray;


/***/ },
/* 203 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}
	
	module.exports = matchesStrictComparable;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(197);
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding('util');
	  } catch (e) {}
	}());
	
	module.exports = nodeUtil;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(149)(module)))

/***/ },
/* 205 */
/***/ function(module, exports) {

	/**
	 * Creates a function that invokes `func` with its first argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;


/***/ },
/* 206 */
/***/ function(module, exports) {

	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}
	
	module.exports = toSource;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(191);
	
	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}
	
	module.exports = get;


/***/ },
/* 208 */
/***/ function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	module.exports = identity;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(23),
	    isObjectLike = __webpack_require__(12);
	
	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}
	
	module.exports = isArrayLikeObject;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(29),
	    unzip = __webpack_require__(461);
	
	/**
	 * Creates an array of grouped elements, the first of which contains the
	 * first elements of the given arrays, the second of which contains the
	 * second elements of the given arrays, and so on.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to process.
	 * @returns {Array} Returns the new array of grouped elements.
	 * @example
	 *
	 * _.zip(['a', 'b'], [1, 2], [true, false]);
	 * // => [['a', 1, true], ['b', 2, false]]
	 */
	var zip = baseRest(unzip);
	
	module.exports = zip;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var slice = Array.prototype.slice;
	var isArgs = __webpack_require__(463);
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};
	
	var keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];
	
		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}
	
		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}
	
		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}
	
		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	
			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
	
	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = (function () {
				// Safari 5.0 bug
				return (Object.keys(arguments) || '').length === 2;
			}(1, 2));
			if (!keysWorksWithArguments) {
				var originalKeys = Object.keys;
				Object.keys = function keys(object) {
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					} else {
						return originalKeys(object);
					}
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};
	
	module.exports = keysShim;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(471);


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(108);
	var throwError_1 = __webpack_require__(506);
	var ObjectUnsubscribedError_1 = __webpack_require__(217);
	/**
	 * @class BehaviorSubject<T>
	 */
	var BehaviorSubject = (function (_super) {
	    __extends(BehaviorSubject, _super);
	    function BehaviorSubject(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    BehaviorSubject.prototype.getValue = function () {
	        if (this.hasError) {
	            throwError_1.throwError(this.thrownError);
	        }
	        else if (this.isUnsubscribed) {
	            throwError_1.throwError(new ObjectUnsubscribedError_1.ObjectUnsubscribedError());
	        }
	        else {
	            return this._value;
	        }
	    };
	    Object.defineProperty(BehaviorSubject.prototype, "value", {
	        get: function () {
	            return this.getValue();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BehaviorSubject.prototype._subscribe = function (subscriber) {
	        var subscription = _super.prototype._subscribe.call(this, subscriber);
	        if (subscription && !subscription.isUnsubscribed) {
	            subscriber.next(this._value);
	        }
	        return subscription;
	    };
	    BehaviorSubject.prototype.next = function (value) {
	        _super.prototype.next.call(this, this._value = value);
	    };
	    return BehaviorSubject;
	}(Subject_1.Subject));
	exports.BehaviorSubject = BehaviorSubject;
	//# sourceMappingURL=BehaviorSubject.js.map

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(20);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ScalarObservable = (function (_super) {
	    __extends(ScalarObservable, _super);
	    function ScalarObservable(value, scheduler) {
	        _super.call(this);
	        this.value = value;
	        this.scheduler = scheduler;
	        this._isScalar = true;
	        if (scheduler) {
	            this._isScalar = false;
	        }
	    }
	    ScalarObservable.create = function (value, scheduler) {
	        return new ScalarObservable(value, scheduler);
	    };
	    ScalarObservable.dispatch = function (state) {
	        var done = state.done, value = state.value, subscriber = state.subscriber;
	        if (done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.done = true;
	        this.schedule(state);
	    };
	    ScalarObservable.prototype._subscribe = function (subscriber) {
	        var value = this.value;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ScalarObservable.dispatch, 0, {
	                done: false, value: value, subscriber: subscriber
	            });
	        }
	        else {
	            subscriber.next(value);
	            if (!subscriber.isUnsubscribed) {
	                subscriber.complete();
	            }
	        }
	    };
	    return ScalarObservable;
	}(Observable_1.Observable));
	exports.ScalarObservable = ScalarObservable;
	//# sourceMappingURL=ScalarObservable.js.map

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(47);
	var mergeAll_1 = __webpack_require__(216);
	var isScheduler_1 = __webpack_require__(73);
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (either the source or an
	 * Observable given as argument), and simply forwards (without doing any
	 * transformation) all the values from all the input Observables to the output
	 * Observable. The output Observable only completes once all input Observables
	 * have completed. Any error delivered by an input Observable will be immediately
	 * emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = clicks.merge(timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = timer1.merge(timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {Observable} other An input Observable to merge with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The Scheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} an Observable that emits items that are the result of
	 * every input Observable.
	 * @method merge
	 * @owner Observable
	 */
	function merge() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    observables.unshift(this);
	    return mergeStatic.apply(this, observables);
	}
	exports.merge = merge;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (as arguments), and simply
	 * forwards (without doing any transformation) all the values from all the input
	 * Observables to the output Observable. The output Observable only completes
	 * once all input Observables have completed. Any error delivered by an input
	 * Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {Observable} input1 An input Observable to merge with others.
	 * @param {Observable} input2 An input Observable to merge with others.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The Scheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} an Observable that emits items that are the result of
	 * every input Observable.
	 * @static true
	 * @name merge
	 * @owner Observable
	 */
	function mergeStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var concurrent = Number.POSITIVE_INFINITY;
	    var scheduler = null;
	    var last = observables[observables.length - 1];
	    if (isScheduler_1.isScheduler(last)) {
	        scheduler = observables.pop();
	        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	            concurrent = observables.pop();
	        }
	    }
	    else if (typeof last === 'number') {
	        concurrent = observables.pop();
	    }
	    if (observables.length === 1) {
	        return observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
	}
	exports.mergeStatic = mergeStatic;
	//# sourceMappingURL=merge.js.map

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(46);
	var subscribeToResult_1 = __webpack_require__(50);
	/**
	 * Converts a higher-order Observable into a first-order Observable which
	 * concurrently delivers all values that are emitted on the inner Observables.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables.</span>
	 *
	 * <img src="./img/mergeAll.png" width="100%">
	 *
	 * `mergeAll` subscribes to an Observable that emits Observables, also known as
	 * a higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, it subscribes to that and delivers all the values from the
	 * inner Observable on the output Observable. The output Observable only
	 * completes once all inner Observables have completed. Any error delivered by
	 * a inner Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var firstOrder = higherOrder.mergeAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
	 * var firstOrder = higherOrder.mergeAll(2);
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link exhaust}
	 * @see {@link merge}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits values coming from all the
	 * inner Observables emitted by the source Observable.
	 * @method mergeAll
	 * @owner Observable
	 */
	function mergeAll(concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    return this.lift(new MergeAllOperator(concurrent));
	}
	exports.mergeAll = mergeAll;
	var MergeAllOperator = (function () {
	    function MergeAllOperator(concurrent) {
	        this.concurrent = concurrent;
	    }
	    MergeAllOperator.prototype.call = function (observer, source) {
	        return source._subscribe(new MergeAllSubscriber(observer, this.concurrent));
	    };
	    return MergeAllOperator;
	}());
	exports.MergeAllOperator = MergeAllOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeAllSubscriber = (function (_super) {
	    __extends(MergeAllSubscriber, _super);
	    function MergeAllSubscriber(destination, concurrent) {
	        _super.call(this, destination);
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	    }
	    MergeAllSubscriber.prototype._next = function (observable) {
	        if (this.active < this.concurrent) {
	            this.active++;
	            this.add(subscribeToResult_1.subscribeToResult(this, observable));
	        }
	        else {
	            this.buffer.push(observable);
	        }
	    };
	    MergeAllSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeAllSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeAllSubscriber = MergeAllSubscriber;
	//# sourceMappingURL=mergeAll.js.map

/***/ },
/* 217 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = (function (_super) {
	    __extends(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        var err = _super.call(this, 'object unsubscribed');
	        this.name = err.name = 'ObjectUnsubscribedError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
	//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ },
/* 218 */
/***/ function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * stringifier
	 * 
	 * https://github.com/twada/stringifier
	 *
	 * Copyright (c) 2014-2015 Takuto Wada
	 * Licensed under the MIT license.
	 *   http://twada.mit-license.org/2014-2015
	 */
	'use strict';
	
	var traverse = __webpack_require__(513);
	var typeName = __webpack_require__(148);
	var assign = __webpack_require__(11);
	var s = __webpack_require__(510);
	
	function defaultHandlers () {
	    return {
	        'null': s.always('null'),
	        'undefined': s.always('undefined'),
	        'function': s.prune(),
	        'string': s.json(),
	        'boolean': s.json(),
	        'number': s.number(),
	        'symbol': s.toStr(),
	        'RegExp': s.toStr(),
	        'String': s.newLike(),
	        'Boolean': s.newLike(),
	        'Number': s.newLike(),
	        'Date': s.newLike(),
	        'Array': s.array(),
	        'Object': s.object(),
	        '@default': s.object()
	    };
	}
	
	function defaultOptions () {
	    return {
	        maxDepth: null,
	        indent: null,
	        anonymous: '@Anonymous',
	        circular: '#@Circular#',
	        snip: '..(snip)',
	        lineSeparator: '\n',
	        typeFun: typeName
	    };
	}
	
	function createStringifier (customOptions) {
	    var options = assign({}, defaultOptions(), customOptions);
	    var handlers = assign({}, defaultHandlers(), options.handlers);
	    return function stringifyAny (push, x) {
	        var context = this;
	        var handler = handlerFor(context.node, options, handlers);
	        var currentPath = '/' + context.path.join('/');
	        var customization = handlers[currentPath];
	        var acc = {
	            context: context,
	            options: options,
	            handlers: handlers,
	            push: push
	        };
	        if (typeName(customization) === 'function') {
	            handler = customization;
	        } else if (typeName(customization) === 'number') {
	            handler = s.flow.compose(s.filters.truncate(customization),handler);
	        } else if (context.parent && typeName(context.parent.node) === 'Array' && !(context.key in context.parent.node)) {
	            // sparse arrays
	            handler = s.always('');
	        }
	        handler(acc, x);
	        return push;
	    };
	}
	
	function handlerFor (val, options, handlers) {
	    var tname = options.typeFun(val);
	    if (typeName(handlers[tname]) === 'function') {
	        return handlers[tname];
	    }
	    return handlers['@default'];
	}
	
	function walk (val, reducer) {
	    var buffer = [];
	    var push = function (str) {
	        buffer.push(str);
	    };
	    traverse(val).reduce(reducer, push);
	    return buffer.join('');
	}
	
	function stringify (val, options) {
	    return walk(val, createStringifier(options));
	}
	
	function stringifier (options) {
	    return function (val) {
	        return walk(val, createStringifier(options));
	    };
	}
	
	stringifier.stringify = stringify;
	stringifier.strategies = s;
	stringifier.defaultOptions = defaultOptions;
	stringifier.defaultHandlers = defaultHandlers;
	module.exports = stringifier;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(511);


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _dec2, _desc, _value, _class, _descriptor, _descriptor2;
	
	var _jquery = __webpack_require__(31);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _snap = __webpack_require__(74);
	
	var _snap2 = _interopRequireDefault(_snap);
	
	var _pick = __webpack_require__(17);
	
	var _pick2 = _interopRequireDefault(_pick);
	
	var _defaults = __webpack_require__(40);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	var _isNumber2 = __webpack_require__(63);
	
	var _isNumber3 = _interopRequireDefault(_isNumber2);
	
	var _size = __webpack_require__(92);
	
	var _size2 = _interopRequireDefault(_size);
	
	var _at = __webpack_require__(91);
	
	var _at2 = _interopRequireDefault(_at);
	
	var _isNumber4 = __webpack_require__(44);
	
	var _isNumber5 = _interopRequireDefault(_isNumber4);
	
	var _isBoolean2 = __webpack_require__(43);
	
	var _isBoolean3 = _interopRequireDefault(_isBoolean2);
	
	var _defer2 = __webpack_require__(98);
	
	var _defer3 = _interopRequireDefault(_defer2);
	
	var _uniqueId = __webpack_require__(101);
	
	var _uniqueId2 = _interopRequireDefault(_uniqueId);
	
	var _combineLatest = __webpack_require__(33);
	
	var _map = __webpack_require__(15);
	
	var _take = __webpack_require__(48);
	
	var _toPromise = __webpack_require__(110);
	
	var _chroma = __webpack_require__(81);
	
	var _chroma2 = _interopRequireDefault(_chroma);
	
	var _SvgEntity2 = __webpack_require__(80);
	
	var _SvgEntity3 = _interopRequireDefault(_SvgEntity2);
	
	var _ValueTracker = __webpack_require__(6);
	
	var _ObservableSet = __webpack_require__(55);
	
	var _ObservableSet2 = _interopRequireDefault(_ObservableSet);
	
	var _ValueTracker2 = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
	
	function _initDefineProp(target, property, descriptor, context) {
		if (!descriptor) return;
		Object.defineProperty(target, property, {
			enumerable: descriptor.enumerable,
			configurable: descriptor.configurable,
			writable: descriptor.writable,
			value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
		});
	}
	
	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
		var desc = {};
		Object['ke' + 'ys'](descriptor).forEach(function (key) {
			desc[key] = descriptor[key];
		});
		desc.enumerable = !!desc.enumerable;
		desc.configurable = !!desc.configurable;
	
		if ('value' in desc || desc.initializer) {
			desc.writable = true;
		}
	
		desc = decorators.slice().reverse().reduce(function (desc, decorator) {
			return decorator(target, property, desc) || desc;
		}, desc);
	
		if (context && desc.initializer !== void 0) {
			desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
			desc.initializer = undefined;
		}
	
		if (desc.initializer === void 0) {
			Object['define' + 'Property'](target, property, desc);
			desc = null;
		}
	
		return desc;
	}
	
	function _initializerWarningHelper(descriptor, context) {
		throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
	}
	
	var $$backgroundColor = Symbol('$$backgroundColor');
	
	var NodeGlyph = (_dec = (0, _ValueTracker.property)({ isValid: _isNumber5.default }), _dec2 = (0, _ValueTracker.property)({ isValid: _isNumber5.default }), (_class = function (_SvgEntity) {
		_inherits(NodeGlyph, _SvgEntity);
	
		_createClass(NodeGlyph, [{
			key: 'toString',
			value: function toString() {
				return '[' + this.constructor.name + ']';
			}
		}]);
	
		function NodeGlyph(options) {
			_classCallCheck(this, NodeGlyph);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(NodeGlyph).call(this, options));
	
			_initDefineProp(_this, 'x', _descriptor, _this);
	
			_initDefineProp(_this, 'y', _descriptor2, _this);
	
			_this.setFromObject(options, ['x', 'y']);
			return _this;
		}
	
		_createClass(NodeGlyph, [{
			key: 'createElement',
			value: function createElement() {
	
				var group = (0, _snap.gElement)();
	
				var glyph = group.circle().attr({
					strokeWidth: '1px',
					stroke: '#aa0000',
					fill: '#ff5555',
					r: 9
				});
	
				this.p('x').subscribe(function (x) {
					glyph.attr({ cx: x });
				});
				this.p('y').subscribe(function (y) {
					glyph.attr({ cy: y });
				});
	
				/* return representation(s) of element */
				return {
					element: group.node
				};
			}
		}, {
			key: 'drop',
			value: function drop(droppedEntity) {
				// TODO
			}
		}, {
			key: 'draggable',
			get: function get() {
				return true;
			}
		}]);
	
		return NodeGlyph;
	}(_SvgEntity3.default), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'x', [_dec], {
		enumerable: true,
		initializer: null
	}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'y', [_dec2], {
		enumerable: true,
		initializer: null
	})), _class));
	exports.default = NodeGlyph;

/***/ },
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;
	
	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = end > length ? length : end;
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;
	
	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}
	
	module.exports = baseSlice;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	var toFinite = __webpack_require__(458);
	
	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;
	
	  return result === result ? (remainder ? result - remainder : result) : 0;
	}
	
	module.exports = toInteger;


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(99),
	    isObject = __webpack_require__(24),
	    isSymbol = __webpack_require__(45);
	
	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;
	
	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;
	
	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	
	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;
	
	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;
	
	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;
	
	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = isFunction(value.valueOf) ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}
	
	module.exports = toNumber;


/***/ },
/* 236 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        return setTimeout(fun, 0);
	    } else {
	        return cachedSetTimeout.call(null, fun, 0);
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        clearTimeout(marker);
	    } else {
	        cachedClearTimeout.call(null, marker);
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var tryCatch_1 = __webpack_require__(147);
	var errorObject_1 = __webpack_require__(103);
	/**
	 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
	 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
	 * If a comparator function is not provided, an equality check is used by default.
	 * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.
	 * @return {Observable} an Observable that emits items from the source Observable with distinct values.
	 * @method distinctUntilChanged
	 * @owner Observable
	 */
	function distinctUntilChanged(compare, keySelector) {
	    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
	}
	exports.distinctUntilChanged = distinctUntilChanged;
	var DistinctUntilChangedOperator = (function () {
	    function DistinctUntilChangedOperator(compare, keySelector) {
	        this.compare = compare;
	        this.keySelector = keySelector;
	    }
	    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
	    };
	    return DistinctUntilChangedOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DistinctUntilChangedSubscriber = (function (_super) {
	    __extends(DistinctUntilChangedSubscriber, _super);
	    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
	        _super.call(this, destination);
	        this.keySelector = keySelector;
	        this.hasKey = false;
	        if (typeof compare === 'function') {
	            this.compare = compare;
	        }
	    }
	    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
	        return x === y;
	    };
	    DistinctUntilChangedSubscriber.prototype._next = function (value) {
	        var keySelector = this.keySelector;
	        var key = value;
	        if (keySelector) {
	            key = tryCatch_1.tryCatch(this.keySelector)(value);
	            if (key === errorObject_1.errorObject) {
	                return this.destination.error(errorObject_1.errorObject.e);
	            }
	        }
	        var result = false;
	        if (this.hasKey) {
	            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
	            if (result === errorObject_1.errorObject) {
	                return this.destination.error(errorObject_1.errorObject.e);
	            }
	        }
	        else {
	            this.hasKey = true;
	        }
	        if (Boolean(result) === false) {
	            this.key = key;
	            this.destination.next(value);
	        }
	    };
	    return DistinctUntilChangedSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=distinctUntilChanged.js.map

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(47);
	var ScalarObservable_1 = __webpack_require__(214);
	var EmptyObservable_1 = __webpack_require__(144);
	var concat_1 = __webpack_require__(158);
	var isScheduler_1 = __webpack_require__(73);
	/**
	 * Returns an Observable that emits the items in a specified Iterable before it begins to emit items emitted by the
	 * source Observable.
	 *
	 * <img src="./img/startWith.png" width="100%">
	 *
	 * @param {Values} an Iterable that contains the items you want the modified Observable to emit first.
	 * @return {Observable} an Observable that emits the items in the specified Iterable and then emits the items
	 * emitted by the source Observable.
	 * @method startWith
	 * @owner Observable
	 */
	function startWith() {
	    var array = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        array[_i - 0] = arguments[_i];
	    }
	    var scheduler = array[array.length - 1];
	    if (isScheduler_1.isScheduler(scheduler)) {
	        array.pop();
	    }
	    else {
	        scheduler = null;
	    }
	    var len = array.length;
	    if (len === 1) {
	        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
	    }
	    else if (len > 1) {
	        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
	    }
	    else {
	        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
	    }
	}
	exports.startWith = startWith;
	//# sourceMappingURL=startWith.js.map

/***/ },
/* 239 */
/***/ function(module, exports) {

	var NotAsync = {} ;
	var asyncExit = /^async[\t ]+(return|throw)/ ;
	var asyncFunction = /^async[\t ]+function/ ;
	var atomOrPropertyOrLabel = /^\s*[):;]/ ;
	var removeComments = /([^\n])\/\*(\*(?!\/)|[^\n*])*\*\/([^\n])/g ;
	
	function hasLineTerminatorBeforeNext(st, since) {
	    return st.lineStart >= since;
	}
	
	function test(regex,st,noComment) {
	    var src = st.input.slice(st.start) ;
	    if (noComment) {
	        src = src.replace(removeComments,"$1 $3") ;
	  }
	    return regex.test(src);
	}
	
	/* Return the object holding the parser's 'State'. This is different between acorn ('this')
	 * and babylon ('this.state') */
	function state(p) {
	    if (('state' in p) && p.state.constructor && p.state.constructor.name==='State')
	        return p.state ; // Probably babylon
	    return p ; // Probably acorn
	}
	
	/* Create a new parser derived from the specified parser, so that in the
	 * event of an error we can back out and try again */
	function subParse(parser, pos, extensions) {
	    // NB: The Babylon constructor does NOT expect 'pos' as an argument, and so
	    // the input needs truncation at the start position, however at present
	    // this doesn't work nicely as all the node location/start/end values
	    // are therefore offset. Consequently, this plug-in is NOT currently working
	    // with the (undocumented) Babylon plug-in interface.
	    var p = new parser.constructor(parser.options, parser.input, pos);
	    if (extensions)
	        for (var k in extensions)
	            p[k] = extensions[k] ;
	
	    var src = state(parser) ;
	    var dest = state(p) ;
	    ['inFunction','inAsyncFunction','inAsync','inGenerator','inModule'].forEach(function(k){
	        if (k in src)
	            dest[k] = src[k] ;
	    }) ;
	    p.nextToken();
	    return p;
	}
	
	function asyncAwaitPlugin (parser,options){
	    var es7check = function(){} ;
	
	    parser.extend("initialContext",function(base){
	        return function(){
	            if (this.options.ecmaVersion < 7) {
	                es7check = function(node) {
	                    parser.raise(node.start,"async/await keywords only available when ecmaVersion>=7") ;
	                } ;
	            }
	      this.reservedWords = new RegExp(this.reservedWords.toString().replace(/await|async/g,"").replace("|/","/").replace("/|","/").replace("||","|")) ;
	      this.reservedWordsStrict = new RegExp(this.reservedWordsStrict.toString().replace(/await|async/g,"").replace("|/","/").replace("/|","/").replace("||","|")) ;
	      this.reservedWordsStrictBind = new RegExp(this.reservedWordsStrictBind.toString().replace(/await|async/g,"").replace("|/","/").replace("/|","/").replace("||","|")) ;
	            this.inAsyncFunction = options.inAsyncFunction ;
	            if (options.awaitAnywhere && options.inAsyncFunction)
	                parser.raise(node.start,"The options awaitAnywhere and inAsyncFunction are mutually exclusive") ;
	
	            return base.apply(this,arguments);
	        }
	    }) ;
	
	    parser.extend("shouldParseExportStatement",function(base){
	        return function(){
	            if (this.type.label==='name' && this.value==='async' && test(asyncFunction,state(this))) {
	                return true ;
	            }
	            return base.apply(this,arguments) ;
	        }
	    }) ;
	
	    parser.extend("parseStatement",function(base){
	        return function (declaration, topLevel) {
	            var st = state(this) ;
	            var start = st.start;
	            var startLoc = st.startLoc;
	            if (st.type.label==='name') {
	                if (test(asyncFunction,st,true)) {
	                    var wasAsync = st.inAsyncFunction ;
	                    try {
	                        st.inAsyncFunction = true ;
	                        this.next() ;
	                        var r = this.parseStatement(declaration, topLevel) ;
	                        r.async = true ;
	                        r.start = start;
	                        r.loc && (r.loc.start = startLoc);
	                        r.range && (r.range[0] = start);
	                        return r ;
	                    } finally {
	                        st.inAsyncFunction = wasAsync ;
	                    }
	                } else if ((typeof options==="object" && options.asyncExits) && test(asyncExit,st)) {
	                    // NON-STANDARD EXTENSION iff. options.asyncExits is set, the
	                    // extensions 'async return <expr>?' and 'async throw <expr>?'
	                    // are enabled. In each case they are the standard ESTree nodes
	                    // with the flag 'async:true'
	                    this.next() ;
	                    var r = this.parseStatement(declaration, topLevel) ;
	                    r.async = true ;
	                    r.start = start;
	                    r.loc && (r.loc.start = startLoc);
	                    r.range && (r.range[0] = start);
	                   return r ;
	                }
	            }
	            return base.apply(this,arguments);
	        }
	    }) ;
	
	  parser.extend("parseIdent",function(base){
	        return function(liberal){
	                var id = base.apply(this,arguments);
	                var st = state(this) ;
	                if (st.inAsyncFunction && id.name==='await') {
	                    if (arguments.length===0) {
	                        this.raise(id.start,"'await' is reserved within async functions") ;
	                    }
	                }
	                return id ;
	        }
	    }) ;
	
	    parser.extend("parseExprAtom",function(base){
	        return function(refShorthandDefaultPos){
	            var st = state(this) ;
	            var start = st.start ;
	            var startLoc = st.startLoc;
	            var rhs,r = base.apply(this,arguments);
	            if (r.type==='Identifier') {
	                if (r.name==='async' && !hasLineTerminatorBeforeNext(st, r.end)) {
	                    // Is this really an async function?
	                    var isAsync = st.inAsyncFunction ;
	                    try {
	                        st.inAsyncFunction = true ;
	                        var pp = this ;
	                        var inBody = false ;
	
	                        var parseHooks = {
	                            parseFunctionBody:function(node,isArrowFunction){
	                                try {
	                                    var wasInBody = inBody ;
	                                    inBody = true ;
	                                    return pp.parseFunctionBody.apply(this,arguments) ;
	                                } finally {
	                                    inBody = wasInBody ;
	                                }
	                            },
	                            raise:function(){
	                                try {
	                                    return pp.raise.apply(this,arguments) ;
	                                } catch(ex) {
	                                    throw inBody?ex:NotAsync ;
	                                }
	                            }
	                        } ;
	
	                        rhs = subParse(this,st.start,parseHooks).parseExpression() ;
	                        if (rhs.type==='SequenceExpression')
	                            rhs = rhs.expressions[0] ;
	                        if (rhs.type==='FunctionExpression' || rhs.type==='FunctionDeclaration' || rhs.type==='ArrowFunctionExpression') {
	                            rhs.async = true ;
	                            rhs.start = start;
	                            rhs.loc && (rhs.loc.start = startLoc);
	                            rhs.range && (rhs.range[0] = start);
	                            st.pos = rhs.end;
	                            this.end = rhs.end ;
	                            this.endLoc = rhs.endLoc ;
	                            this.next();
	                            es7check(rhs) ;
	                            return rhs ;
	                        }
	                    } catch (ex) {
	                        if (ex!==NotAsync)
	                            throw ex ;
	                    }
	                    finally {
	                        st.inAsyncFunction = isAsync ;
	                    }
	                }
	                else if (r.name==='await') {
	                    var n = this.startNodeAt(r.start, r.loc && r.loc.start);
	                    if (st.inAsyncFunction) {
	                        rhs = this.parseExprSubscripts() ;
	                        n.operator = 'await' ;
	                        n.argument = rhs ;
	                        n = this.finishNodeAt(n,'AwaitExpression', rhs.end, rhs.loc && rhs.loc.end) ;
	                        es7check(n) ;
	                        return n ;
	                    } else
	                        // NON-STANDARD EXTENSION iff. options.awaitAnywhere is true,
	                        // an 'AwaitExpression' is allowed anywhere the token 'await'
	                        // could not be an identifier with the name 'await'.
	
	                        // Look-ahead to see if this is really a property or label called async or await
	                        if (st.input.slice(r.end).match(atomOrPropertyOrLabel))
	                            return r ; // This is a valid property name or label
	
	                        if (typeof options==="object" && options.awaitAnywhere) {
	                            start = st.start ;
	                            rhs = subParse(this,start-4).parseExprSubscripts() ;
	                            if (rhs.end<=start) {
	                                rhs = subParse(this,start).parseExprSubscripts() ;
	                                n.operator = 'await' ;
	                                n.argument = rhs ;
	                                n = this.finishNodeAt(n,'AwaitExpression', rhs.end, rhs.loc && rhs.loc.end) ;
	                                st.pos = rhs.end;
	                                this.end = rhs.end ;
	                                this.endLoc = rhs.endLoc ;
	                                this.next();
	                                es7check(n) ;
	                                return n ;
	                            }
	                        }
	                }
	            }
	            return r ;
	        }
	    }) ;
	
	    parser.extend('finishNodeAt',function(base){
	            return function(node,type,pos,loc) {
	                if (node.__asyncValue) {
	                    delete node.__asyncValue ;
	                    node.value.async = true ;
	                }
	                return base.apply(this,arguments) ;
	            }
	    }) ;
	
	    parser.extend('finishNode',function(base){
	            return function(node,type) {
	                if (node.__asyncValue) {
	                    delete node.__asyncValue ;
	                    node.value.async = true ;
	                }
	                return base.apply(this,arguments) ;
	            }
	    }) ;
	
	    parser.extend("parsePropertyName",function(base){
	        return function (prop) {
	            var st = state(this) ;
	            var key = base.apply(this,arguments) ;
	            if (key.type === "Identifier" && key.name === "async" && !hasLineTerminatorBeforeNext(st, key.end)) {
	                // Look-ahead to see if this is really a property or label called async or await
	                if (!st.input.slice(key.end).match(atomOrPropertyOrLabel)){
	                    es7check(prop) ;
	                    key = base.apply(this,arguments) ;
	                    if (key.type==='Identifier') {
	                        if (key.name==='constructor')
	                            this.raise(key.start,"'constructor()' cannot be be async") ;
	                        else if (key.name==='set')
	                            this.raise(key.start,"'set <member>(value)' cannot be be async") ;
	                    }
	                    prop.__asyncValue = true ;
	                }
	            }
	            return key;
	        };
	    }) ;
	
	    parser.extend("parseClassMethod",function(base){
	        return function (classBody, method, isGenerator) {
	            var st, wasAsync ;
	            if (method.__asyncValue) {
	                st = state(this) ;
	                wasAsync = st.inAsyncFunction ;
	                st.inAsyncFunction = true ;
	            }
	            var r = base.apply(this,arguments) ;
	            if (st) {
	                st.inAsyncFunction = wasAsync ;
	            }
	            return r ;
	        }
	    }) ;
	    
	    parser.extend("parsePropertyValue",function(base){
	        return function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
	            var st, wasAsync ;
	            if (prop.__asyncValue) {
	                st = state(this) ;
	                wasAsync = st.inAsyncFunction ;
	                st.inAsyncFunction = true ;
	            }
	            var r = base.apply(this,arguments) ;
	            if (st) {
	                st.inAsyncFunction = wasAsync ;
	            }
	            return r ;
	        }
	    }) ;
	}
	
	module.exports = function(acorn) {
	    acorn.plugins.asyncawait = asyncAwaitPlugin ;
	    return acorn
	}


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.acorn = global.acorn || {})));
	}(this, function (exports) { 'use strict';
	
	  // Reserved word lists for various dialects of the language
	
	  var reservedWords = {
	    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	    5: "class enum extends super const export import",
	    6: "enum",
	    7: "enum",
	    strict: "implements interface let package private protected public static yield",
	    strictBind: "eval arguments"
	  }
	
	  // And the keywords
	
	  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"
	
	  var keywords = {
	    5: ecma5AndLessKeywords,
	    6: ecma5AndLessKeywords + " const class extends export import super"
	  }
	
	  // ## Character categories
	
	  // Big ugly regular expressions that match characters in the
	  // whitespace, identifier, and identifier-start categories. These
	  // are only applied when a character is found to actually have a
	  // code point above 128.
	  // Generated by `bin/generate-identifier-regex.js`.
	
	  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fd5\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc"
	  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d01-\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf8\u1cf9\u1dc0-\u1df5\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f"
	
	  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]")
	  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]")
	
	  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null
	
	  // These are a run-length and offset encoded representation of the
	  // >0xffff code points that are a valid part of identifiers. The
	  // offset starts at 0x10000, and each pair of numbers represents an
	  // offset to the next range, and then a size of the range. They were
	  // generated by bin/generate-identifier-regex.js
	  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541]
	  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239]
	
	  // This has a complexity linear to the value of the code. The
	  // assumption is that looking up astral identifier characters is
	  // rare.
	  function isInAstralSet(code, set) {
	    var pos = 0x10000
	    for (var i = 0; i < set.length; i += 2) {
	      pos += set[i]
	      if (pos > code) return false
	      pos += set[i + 1]
	      if (pos >= code) return true
	    }
	  }
	
	  // Test whether a given character code starts an identifier.
	
	  function isIdentifierStart(code, astral) {
	    if (code < 65) return code === 36
	    if (code < 91) return true
	    if (code < 97) return code === 95
	    if (code < 123) return true
	    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))
	    if (astral === false) return false
	    return isInAstralSet(code, astralIdentifierStartCodes)
	  }
	
	  // Test whether a given character is part of an identifier.
	
	  function isIdentifierChar(code, astral) {
	    if (code < 48) return code === 36
	    if (code < 58) return true
	    if (code < 65) return false
	    if (code < 91) return true
	    if (code < 97) return code === 95
	    if (code < 123) return true
	    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))
	    if (astral === false) return false
	    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
	  }
	
	  // ## Token types
	
	  // The assignment of fine-grained, information-carrying type objects
	  // allows the tokenizer to store the information it has about a
	  // token in a way that is very cheap for the parser to look up.
	
	  // All token type variables start with an underscore, to make them
	  // easy to recognize.
	
	  // The `beforeExpr` property is used to disambiguate between regular
	  // expressions and divisions. It is set on all token types that can
	  // be followed by an expression (thus, a slash after them would be a
	  // regular expression).
	  //
	  // The `startsExpr` property is used to check if the token ends a
	  // `yield` expression. It is set on all token types that either can
	  // directly start an expression (like a quotation mark) or can
	  // continue an expression (like the body of a string).
	  //
	  // `isLoop` marks a keyword as starting a loop, which is important
	  // to know when parsing a label, in order to allow or disallow
	  // continue jumps to that label.
	
	  var TokenType = function TokenType(label, conf) {
	    if ( conf === void 0 ) conf = {};
	
	    this.label = label
	    this.keyword = conf.keyword
	    this.beforeExpr = !!conf.beforeExpr
	    this.startsExpr = !!conf.startsExpr
	    this.isLoop = !!conf.isLoop
	    this.isAssign = !!conf.isAssign
	    this.prefix = !!conf.prefix
	    this.postfix = !!conf.postfix
	    this.binop = conf.binop || null
	    this.updateContext = null
	  };
	
	  function binop(name, prec) {
	    return new TokenType(name, {beforeExpr: true, binop: prec})
	  }
	  var beforeExpr = {beforeExpr: true};
	  var startsExpr = {startsExpr: true};
	  // Map keyword names to token types.
	
	  var keywordTypes = {}
	
	  // Succinct definitions of keyword token types
	  function kw(name, options) {
	    if ( options === void 0 ) options = {};
	
	    options.keyword = name
	    return keywordTypes[name] = new TokenType(name, options)
	  }
	
	  var tt = {
	    num: new TokenType("num", startsExpr),
	    regexp: new TokenType("regexp", startsExpr),
	    string: new TokenType("string", startsExpr),
	    name: new TokenType("name", startsExpr),
	    eof: new TokenType("eof"),
	
	    // Punctuation token types.
	    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
	    bracketR: new TokenType("]"),
	    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
	    braceR: new TokenType("}"),
	    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
	    parenR: new TokenType(")"),
	    comma: new TokenType(",", beforeExpr),
	    semi: new TokenType(";", beforeExpr),
	    colon: new TokenType(":", beforeExpr),
	    dot: new TokenType("."),
	    question: new TokenType("?", beforeExpr),
	    arrow: new TokenType("=>", beforeExpr),
	    template: new TokenType("template"),
	    ellipsis: new TokenType("...", beforeExpr),
	    backQuote: new TokenType("`", startsExpr),
	    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),
	
	    // Operators. These carry several kinds of properties to help the
	    // parser use them properly (the presence of these properties is
	    // what categorizes them as operators).
	    //
	    // `binop`, when present, specifies that this operator is a binary
	    // operator, and will refer to its precedence.
	    //
	    // `prefix` and `postfix` mark the operator as a prefix or postfix
	    // unary operator.
	    //
	    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
	    // binary operators with a very low precedence, that should result
	    // in AssignmentExpression nodes.
	
	    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
	    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
	    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
	    prefix: new TokenType("prefix", {beforeExpr: true, prefix: true, startsExpr: true}),
	    logicalOR: binop("||", 1),
	    logicalAND: binop("&&", 2),
	    bitwiseOR: binop("|", 3),
	    bitwiseXOR: binop("^", 4),
	    bitwiseAND: binop("&", 5),
	    equality: binop("==/!=", 6),
	    relational: binop("</>", 7),
	    bitShift: binop("<</>>", 8),
	    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
	    modulo: binop("%", 10),
	    star: binop("*", 10),
	    slash: binop("/", 10),
	    starstar: new TokenType("**", {beforeExpr: true}),
	
	    // Keyword token types.
	    _break: kw("break"),
	    _case: kw("case", beforeExpr),
	    _catch: kw("catch"),
	    _continue: kw("continue"),
	    _debugger: kw("debugger"),
	    _default: kw("default", beforeExpr),
	    _do: kw("do", {isLoop: true, beforeExpr: true}),
	    _else: kw("else", beforeExpr),
	    _finally: kw("finally"),
	    _for: kw("for", {isLoop: true}),
	    _function: kw("function", startsExpr),
	    _if: kw("if"),
	    _return: kw("return", beforeExpr),
	    _switch: kw("switch"),
	    _throw: kw("throw", beforeExpr),
	    _try: kw("try"),
	    _var: kw("var"),
	    _const: kw("const"),
	    _while: kw("while", {isLoop: true}),
	    _with: kw("with"),
	    _new: kw("new", {beforeExpr: true, startsExpr: true}),
	    _this: kw("this", startsExpr),
	    _super: kw("super", startsExpr),
	    _class: kw("class"),
	    _extends: kw("extends", beforeExpr),
	    _export: kw("export"),
	    _import: kw("import"),
	    _null: kw("null", startsExpr),
	    _true: kw("true", startsExpr),
	    _false: kw("false", startsExpr),
	    _in: kw("in", {beforeExpr: true, binop: 7}),
	    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
	    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
	    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
	    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
	  }
	
	  // Matches a whole line break (where CRLF is considered a single
	  // line break). Used to count lines.
	
	  var lineBreak = /\r\n?|\n|\u2028|\u2029/
	  var lineBreakG = new RegExp(lineBreak.source, "g")
	
	  function isNewLine(code) {
	    return code === 10 || code === 13 || code === 0x2028 || code == 0x2029
	  }
	
	  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/
	
	  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g
	
	  function isArray(obj) {
	    return Object.prototype.toString.call(obj) === "[object Array]"
	  }
	
	  // Checks if an object has a property.
	
	  function has(obj, propName) {
	    return Object.prototype.hasOwnProperty.call(obj, propName)
	  }
	
	  // These are used when `options.locations` is on, for the
	  // `startLoc` and `endLoc` properties.
	
	  var Position = function Position(line, col) {
	    this.line = line
	    this.column = col
	  };
	
	  Position.prototype.offset = function offset (n) {
	    return new Position(this.line, this.column + n)
	  };
	
	  var SourceLocation = function SourceLocation(p, start, end) {
	    this.start = start
	    this.end = end
	    if (p.sourceFile !== null) this.source = p.sourceFile
	  };
	
	  // The `getLineInfo` function is mostly useful when the
	  // `locations` option is off (for performance reasons) and you
	  // want to find the line/column position for a given character
	  // offset. `input` should be the code string that the offset refers
	  // into.
	
	  function getLineInfo(input, offset) {
	    for (var line = 1, cur = 0;;) {
	      lineBreakG.lastIndex = cur
	      var match = lineBreakG.exec(input)
	      if (match && match.index < offset) {
	        ++line
	        cur = match.index + match[0].length
	      } else {
	        return new Position(line, offset - cur)
	      }
	    }
	  }
	
	  // A second optional argument can be given to further configure
	  // the parser process. These options are recognized:
	
	  var defaultOptions = {
	    // `ecmaVersion` indicates the ECMAScript version to parse. Must
	    // be either 3, or 5, or 6. This influences support for strict
	    // mode, the set of reserved words, support for getters and
	    // setters and other features. The default is 6.
	    ecmaVersion: 6,
	    // Source type ("script" or "module") for different semantics
	    sourceType: "script",
	    // `onInsertedSemicolon` can be a callback that will be called
	    // when a semicolon is automatically inserted. It will be passed
	    // th position of the comma as an offset, and if `locations` is
	    // enabled, it is given the location as a `{line, column}` object
	    // as second argument.
	    onInsertedSemicolon: null,
	    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
	    // trailing commas.
	    onTrailingComma: null,
	    // By default, reserved words are only enforced if ecmaVersion >= 5.
	    // Set `allowReserved` to a boolean value to explicitly turn this on
	    // an off. When this option has the value "never", reserved words
	    // and keywords can also not be used as property names.
	    allowReserved: null,
	    // When enabled, a return at the top level is not considered an
	    // error.
	    allowReturnOutsideFunction: false,
	    // When enabled, import/export statements are not constrained to
	    // appearing at the top of the program.
	    allowImportExportEverywhere: false,
	    // When enabled, hashbang directive in the beginning of file
	    // is allowed and treated as a line comment.
	    allowHashBang: false,
	    // When `locations` is on, `loc` properties holding objects with
	    // `start` and `end` properties in `{line, column}` form (with
	    // line being 1-based and column 0-based) will be attached to the
	    // nodes.
	    locations: false,
	    // A function can be passed as `onToken` option, which will
	    // cause Acorn to call that function with object in the same
	    // format as tokens returned from `tokenizer().getToken()`. Note
	    // that you are not allowed to call the parser from the
	    // callback—that will corrupt its internal state.
	    onToken: null,
	    // A function can be passed as `onComment` option, which will
	    // cause Acorn to call that function with `(block, text, start,
	    // end)` parameters whenever a comment is skipped. `block` is a
	    // boolean indicating whether this is a block (`/* */`) comment,
	    // `text` is the content of the comment, and `start` and `end` are
	    // character offsets that denote the start and end of the comment.
	    // When the `locations` option is on, two more parameters are
	    // passed, the full `{line, column}` locations of the start and
	    // end of the comments. Note that you are not allowed to call the
	    // parser from the callback—that will corrupt its internal state.
	    onComment: null,
	    // Nodes have their start and end characters offsets recorded in
	    // `start` and `end` properties (directly on the node, rather than
	    // the `loc` object, which holds line/column data. To also add a
	    // [semi-standardized][range] `range` property holding a `[start,
	    // end]` array with the same numbers, set the `ranges` option to
	    // `true`.
	    //
	    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
	    ranges: false,
	    // It is possible to parse multiple files into a single AST by
	    // passing the tree produced by parsing the first file as
	    // `program` option in subsequent parses. This will add the
	    // toplevel forms of the parsed file to the `Program` (top) node
	    // of an existing parse tree.
	    program: null,
	    // When `locations` is on, you can pass this to record the source
	    // file in every node's `loc` object.
	    sourceFile: null,
	    // This value, if given, is stored in every node, whether
	    // `locations` is on or off.
	    directSourceFile: null,
	    // When enabled, parenthesized expressions are represented by
	    // (non-standard) ParenthesizedExpression nodes
	    preserveParens: false,
	    plugins: {}
	  }
	
	  // Interpret and default an options object
	
	  function getOptions(opts) {
	    var options = {}
	    for (var opt in defaultOptions)
	      options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]
	    if (options.allowReserved == null)
	      options.allowReserved = options.ecmaVersion < 5
	
	    if (isArray(options.onToken)) {
	      var tokens = options.onToken
	      options.onToken = function (token) { return tokens.push(token); }
	    }
	    if (isArray(options.onComment))
	      options.onComment = pushComment(options, options.onComment)
	
	    return options
	  }
	
	  function pushComment(options, array) {
	    return function (block, text, start, end, startLoc, endLoc) {
	      var comment = {
	        type: block ? 'Block' : 'Line',
	        value: text,
	        start: start,
	        end: end
	      }
	      if (options.locations)
	        comment.loc = new SourceLocation(this, startLoc, endLoc)
	      if (options.ranges)
	        comment.range = [start, end]
	      array.push(comment)
	    }
	  }
	
	  // Registered plugins
	  var plugins = {}
	
	  function keywordRegexp(words) {
	    return new RegExp("^(" + words.replace(/ /g, "|") + ")$")
	  }
	
	  var Parser = function Parser(options, input, startPos) {
	    this.options = options = getOptions(options)
	    this.sourceFile = options.sourceFile
	    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])
	    var reserved = options.allowReserved ? "" :
	        reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "")
	    this.reservedWords = keywordRegexp(reserved)
	    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict
	    this.reservedWordsStrict = keywordRegexp(reservedStrict)
	    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind)
	    this.input = String(input)
	
	    // Used to signal to callers of `readWord1` whether the word
	    // contained any escape sequences. This is needed because words with
	    // escape sequences must not be interpreted as keywords.
	    this.containsEsc = false
	
	    // Load plugins
	    this.loadPlugins(options.plugins)
	
	    // Set up token state
	
	    // The current position of the tokenizer in the input.
	    if (startPos) {
	      this.pos = startPos
	      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos))
	      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length
	    } else {
	      this.pos = this.lineStart = 0
	      this.curLine = 1
	    }
	
	    // Properties of the current token:
	    // Its type
	    this.type = tt.eof
	    // For tokens that include more information than their type, the value
	    this.value = null
	    // Its start and end offset
	    this.start = this.end = this.pos
	    // And, if locations are used, the {line, column} object
	    // corresponding to those offsets
	    this.startLoc = this.endLoc = this.curPosition()
	
	    // Position information for the previous token
	    this.lastTokEndLoc = this.lastTokStartLoc = null
	    this.lastTokStart = this.lastTokEnd = this.pos
	
	    // The context stack is used to superficially track syntactic
	    // context to predict whether a regular expression is allowed in a
	    // given position.
	    this.context = this.initialContext()
	    this.exprAllowed = true
	
	    // Figure out if it's a module code.
	    this.strict = this.inModule = options.sourceType === "module"
	
	    // Used to signify the start of a potential arrow function
	    this.potentialArrowAt = -1
	
	    // Flags to track whether we are in a function, a generator.
	    this.inFunction = this.inGenerator = false
	    // Labels in scope.
	    this.labels = []
	
	    // If enabled, skip leading hashbang line.
	    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')
	      this.skipLineComment(2)
	  };
	
	  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
	  Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };
	  Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };
	
	  Parser.prototype.extend = function extend (name, f) {
	    this[name] = f(this[name])
	  };
	
	  Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {
	      var this$1 = this;
	
	    for (var name in pluginConfigs) {
	      var plugin = plugins[name]
	      if (!plugin) throw new Error("Plugin '" + name + "' not found")
	      plugin(this$1, pluginConfigs[name])
	    }
	  };
	
	  Parser.prototype.parse = function parse () {
	    var node = this.options.program || this.startNode()
	    this.nextToken()
	    return this.parseTopLevel(node)
	  };
	
	  var pp = Parser.prototype
	
	  // ## Parser utilities
	
	  // Test whether a statement node is the string literal `"use strict"`.
	
	  pp.isUseStrict = function(stmt) {
	    return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
	      stmt.expression.type === "Literal" &&
	      stmt.expression.raw.slice(1, -1) === "use strict"
	  }
	
	  // Predicate that tests whether the next token is of the given
	  // type, and if yes, consumes it as a side effect.
	
	  pp.eat = function(type) {
	    if (this.type === type) {
	      this.next()
	      return true
	    } else {
	      return false
	    }
	  }
	
	  // Tests whether parsed token is a contextual keyword.
	
	  pp.isContextual = function(name) {
	    return this.type === tt.name && this.value === name
	  }
	
	  // Consumes contextual keyword if possible.
	
	  pp.eatContextual = function(name) {
	    return this.value === name && this.eat(tt.name)
	  }
	
	  // Asserts that following token is given contextual keyword.
	
	  pp.expectContextual = function(name) {
	    if (!this.eatContextual(name)) this.unexpected()
	  }
	
	  // Test whether a semicolon can be inserted at the current position.
	
	  pp.canInsertSemicolon = function() {
	    return this.type === tt.eof ||
	      this.type === tt.braceR ||
	      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
	  }
	
	  pp.insertSemicolon = function() {
	    if (this.canInsertSemicolon()) {
	      if (this.options.onInsertedSemicolon)
	        this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)
	      return true
	    }
	  }
	
	  // Consume a semicolon, or, failing that, see if we are allowed to
	  // pretend that there is a semicolon at this position.
	
	  pp.semicolon = function() {
	    if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()
	  }
	
	  pp.afterTrailingComma = function(tokType) {
	    if (this.type == tokType) {
	      if (this.options.onTrailingComma)
	        this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)
	      this.next()
	      return true
	    }
	  }
	
	  // Expect a token of a given type. If found, consume it, otherwise,
	  // raise an unexpected token error.
	
	  pp.expect = function(type) {
	    this.eat(type) || this.unexpected()
	  }
	
	  // Raise an unexpected token error.
	
	  pp.unexpected = function(pos) {
	    this.raise(pos != null ? pos : this.start, "Unexpected token")
	  }
	
	  var DestructuringErrors = function DestructuringErrors() {
	    this.shorthandAssign = 0
	    this.trailingComma = 0
	  };
	
	  pp.checkPatternErrors = function(refDestructuringErrors, andThrow) {
	    var trailing = refDestructuringErrors && refDestructuringErrors.trailingComma
	    if (!andThrow) return !!trailing
	    if (trailing) this.raise(trailing, "Comma is not permitted after the rest element")
	  }
	
	  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
	    var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign
	    if (!andThrow) return !!pos
	    if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns")
	  }
	
	  var pp$1 = Parser.prototype
	
	  // ### Statement parsing
	
	  // Parse a program. Initializes the parser, reads any number of
	  // statements, and wraps them in a Program node.  Optionally takes a
	  // `program` argument.  If present, the statements will be appended
	  // to its body instead of creating a new node.
	
	  pp$1.parseTopLevel = function(node) {
	    var this$1 = this;
	
	    var first = true
	    if (!node.body) node.body = []
	    while (this.type !== tt.eof) {
	      var stmt = this$1.parseStatement(true, true)
	      node.body.push(stmt)
	      if (first) {
	        if (this$1.isUseStrict(stmt)) this$1.setStrict(true)
	        first = false
	      }
	    }
	    this.next()
	    if (this.options.ecmaVersion >= 6) {
	      node.sourceType = this.options.sourceType
	    }
	    return this.finishNode(node, "Program")
	  }
	
	  var loopLabel = {kind: "loop"};
	  var switchLabel = {kind: "switch"};
	  pp$1.isLet = function() {
	    if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != "let") return false
	    skipWhiteSpace.lastIndex = this.pos
	    var skip = skipWhiteSpace.exec(this.input)
	    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)
	    if (nextCh === 91 || nextCh == 123) return true // '{' and '['
	    if (isIdentifierStart(nextCh, true)) {
	      for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}
	      var ident = this.input.slice(next, pos)
	      if (!this.isKeyword(ident)) return true
	    }
	    return false
	  }
	
	  // Parse a single statement.
	  //
	  // If expecting a statement and finding a slash operator, parse a
	  // regular expression literal. This is to handle cases like
	  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
	  // does not help.
	
	  pp$1.parseStatement = function(declaration, topLevel) {
	    var starttype = this.type, node = this.startNode(), kind
	
	    if (this.isLet()) {
	      starttype = tt._var
	      kind = "let"
	    }
	
	    // Most types of statements are recognized by the keyword they
	    // start with. Many are trivial to parse, some require a bit of
	    // complexity.
	
	    switch (starttype) {
	    case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
	    case tt._debugger: return this.parseDebuggerStatement(node)
	    case tt._do: return this.parseDoStatement(node)
	    case tt._for: return this.parseForStatement(node)
	    case tt._function:
	      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()
	      return this.parseFunctionStatement(node)
	    case tt._class:
	      if (!declaration) this.unexpected()
	      return this.parseClass(node, true)
	    case tt._if: return this.parseIfStatement(node)
	    case tt._return: return this.parseReturnStatement(node)
	    case tt._switch: return this.parseSwitchStatement(node)
	    case tt._throw: return this.parseThrowStatement(node)
	    case tt._try: return this.parseTryStatement(node)
	    case tt._const: case tt._var:
	      kind = kind || this.value
	      if (!declaration && kind != "var") this.unexpected()
	      return this.parseVarStatement(node, kind)
	    case tt._while: return this.parseWhileStatement(node)
	    case tt._with: return this.parseWithStatement(node)
	    case tt.braceL: return this.parseBlock()
	    case tt.semi: return this.parseEmptyStatement(node)
	    case tt._export:
	    case tt._import:
	      if (!this.options.allowImportExportEverywhere) {
	        if (!topLevel)
	          this.raise(this.start, "'import' and 'export' may only appear at the top level")
	        if (!this.inModule)
	          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")
	      }
	      return starttype === tt._import ? this.parseImport(node) : this.parseExport(node)
	
	      // If the statement does not start with a statement keyword or a
	      // brace, it's an ExpressionStatement or LabeledStatement. We
	      // simply start parsing an expression, and afterwards, if the
	      // next token is a colon and the expression was a simple
	      // Identifier node, we switch to interpreting it as a label.
	    default:
	      var maybeName = this.value, expr = this.parseExpression()
	      if (starttype === tt.name && expr.type === "Identifier" && this.eat(tt.colon))
	        return this.parseLabeledStatement(node, maybeName, expr)
	      else return this.parseExpressionStatement(node, expr)
	    }
	  }
	
	  pp$1.parseBreakContinueStatement = function(node, keyword) {
	    var this$1 = this;
	
	    var isBreak = keyword == "break"
	    this.next()
	    if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null
	    else if (this.type !== tt.name) this.unexpected()
	    else {
	      node.label = this.parseIdent()
	      this.semicolon()
	    }
	
	    // Verify that there is an actual destination to break or
	    // continue to.
	    for (var i = 0; i < this.labels.length; ++i) {
	      var lab = this$1.labels[i]
	      if (node.label == null || lab.name === node.label.name) {
	        if (lab.kind != null && (isBreak || lab.kind === "loop")) break
	        if (node.label && isBreak) break
	      }
	    }
	    if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword)
	    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
	  }
	
	  pp$1.parseDebuggerStatement = function(node) {
	    this.next()
	    this.semicolon()
	    return this.finishNode(node, "DebuggerStatement")
	  }
	
	  pp$1.parseDoStatement = function(node) {
	    this.next()
	    this.labels.push(loopLabel)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    this.expect(tt._while)
	    node.test = this.parseParenExpression()
	    if (this.options.ecmaVersion >= 6)
	      this.eat(tt.semi)
	    else
	      this.semicolon()
	    return this.finishNode(node, "DoWhileStatement")
	  }
	
	  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
	  // loop is non-trivial. Basically, we have to parse the init `var`
	  // statement or expression, disallowing the `in` operator (see
	  // the second parameter to `parseExpression`), and then check
	  // whether the next token is `in` or `of`. When there is no init
	  // part (semicolon immediately after the opening parenthesis), it
	  // is a regular `for` loop.
	
	  pp$1.parseForStatement = function(node) {
	    this.next()
	    this.labels.push(loopLabel)
	    this.expect(tt.parenL)
	    if (this.type === tt.semi) return this.parseFor(node, null)
	    var isLet = this.isLet()
	    if (this.type === tt._var || this.type === tt._const || isLet) {
	      var init$1 = this.startNode(), kind = isLet ? "let" : this.value
	      this.next()
	      this.parseVar(init$1, true, kind)
	      this.finishNode(init$1, "VariableDeclaration")
	      if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1 &&
	          !(kind !== "var" && init$1.declarations[0].init))
	        return this.parseForIn(node, init$1)
	      return this.parseFor(node, init$1)
	    }
	    var refDestructuringErrors = new DestructuringErrors
	    var init = this.parseExpression(true, refDestructuringErrors)
	    if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
	      this.checkPatternErrors(refDestructuringErrors, true)
	      this.toAssignable(init)
	      this.checkLVal(init)
	      return this.parseForIn(node, init)
	    } else {
	      this.checkExpressionErrors(refDestructuringErrors, true)
	    }
	    return this.parseFor(node, init)
	  }
	
	  pp$1.parseFunctionStatement = function(node) {
	    this.next()
	    return this.parseFunction(node, true)
	  }
	
	  pp$1.parseIfStatement = function(node) {
	    this.next()
	    node.test = this.parseParenExpression()
	    node.consequent = this.parseStatement(false)
	    node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null
	    return this.finishNode(node, "IfStatement")
	  }
	
	  pp$1.parseReturnStatement = function(node) {
	    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
	      this.raise(this.start, "'return' outside of function")
	    this.next()
	
	    // In `return` (and `break`/`continue`), the keywords with
	    // optional arguments, we eagerly look for a semicolon or the
	    // possibility to insert one.
	
	    if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null
	    else { node.argument = this.parseExpression(); this.semicolon() }
	    return this.finishNode(node, "ReturnStatement")
	  }
	
	  pp$1.parseSwitchStatement = function(node) {
	    var this$1 = this;
	
	    this.next()
	    node.discriminant = this.parseParenExpression()
	    node.cases = []
	    this.expect(tt.braceL)
	    this.labels.push(switchLabel)
	
	    // Statements under must be grouped (by label) in SwitchCase
	    // nodes. `cur` is used to keep the node that we are currently
	    // adding statements to.
	
	    for (var cur, sawDefault = false; this.type != tt.braceR;) {
	      if (this$1.type === tt._case || this$1.type === tt._default) {
	        var isCase = this$1.type === tt._case
	        if (cur) this$1.finishNode(cur, "SwitchCase")
	        node.cases.push(cur = this$1.startNode())
	        cur.consequent = []
	        this$1.next()
	        if (isCase) {
	          cur.test = this$1.parseExpression()
	        } else {
	          if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses")
	          sawDefault = true
	          cur.test = null
	        }
	        this$1.expect(tt.colon)
	      } else {
	        if (!cur) this$1.unexpected()
	        cur.consequent.push(this$1.parseStatement(true))
	      }
	    }
	    if (cur) this.finishNode(cur, "SwitchCase")
	    this.next() // Closing brace
	    this.labels.pop()
	    return this.finishNode(node, "SwitchStatement")
	  }
	
	  pp$1.parseThrowStatement = function(node) {
	    this.next()
	    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
	      this.raise(this.lastTokEnd, "Illegal newline after throw")
	    node.argument = this.parseExpression()
	    this.semicolon()
	    return this.finishNode(node, "ThrowStatement")
	  }
	
	  // Reused empty array added for node fields that are always empty.
	
	  var empty = []
	
	  pp$1.parseTryStatement = function(node) {
	    this.next()
	    node.block = this.parseBlock()
	    node.handler = null
	    if (this.type === tt._catch) {
	      var clause = this.startNode()
	      this.next()
	      this.expect(tt.parenL)
	      clause.param = this.parseBindingAtom()
	      this.checkLVal(clause.param, true)
	      this.expect(tt.parenR)
	      clause.body = this.parseBlock()
	      node.handler = this.finishNode(clause, "CatchClause")
	    }
	    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null
	    if (!node.handler && !node.finalizer)
	      this.raise(node.start, "Missing catch or finally clause")
	    return this.finishNode(node, "TryStatement")
	  }
	
	  pp$1.parseVarStatement = function(node, kind) {
	    this.next()
	    this.parseVar(node, false, kind)
	    this.semicolon()
	    return this.finishNode(node, "VariableDeclaration")
	  }
	
	  pp$1.parseWhileStatement = function(node) {
	    this.next()
	    node.test = this.parseParenExpression()
	    this.labels.push(loopLabel)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    return this.finishNode(node, "WhileStatement")
	  }
	
	  pp$1.parseWithStatement = function(node) {
	    if (this.strict) this.raise(this.start, "'with' in strict mode")
	    this.next()
	    node.object = this.parseParenExpression()
	    node.body = this.parseStatement(false)
	    return this.finishNode(node, "WithStatement")
	  }
	
	  pp$1.parseEmptyStatement = function(node) {
	    this.next()
	    return this.finishNode(node, "EmptyStatement")
	  }
	
	  pp$1.parseLabeledStatement = function(node, maybeName, expr) {
	    var this$1 = this;
	
	    for (var i = 0; i < this.labels.length; ++i)
	      if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, "Label '" + maybeName + "' is already declared")
	    var kind = this.type.isLoop ? "loop" : this.type === tt._switch ? "switch" : null
	    for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {
	      var label = this$1.labels[i$1]
	      if (label.statementStart == node.start) {
	        label.statementStart = this$1.start
	        label.kind = kind
	      } else break
	    }
	    this.labels.push({name: maybeName, kind: kind, statementStart: this.start})
	    node.body = this.parseStatement(true)
	    this.labels.pop()
	    node.label = expr
	    return this.finishNode(node, "LabeledStatement")
	  }
	
	  pp$1.parseExpressionStatement = function(node, expr) {
	    node.expression = expr
	    this.semicolon()
	    return this.finishNode(node, "ExpressionStatement")
	  }
	
	  // Parse a semicolon-enclosed block of statements, handling `"use
	  // strict"` declarations when `allowStrict` is true (used for
	  // function bodies).
	
	  pp$1.parseBlock = function(allowStrict) {
	    var this$1 = this;
	
	    var node = this.startNode(), first = true, oldStrict
	    node.body = []
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      var stmt = this$1.parseStatement(true)
	      node.body.push(stmt)
	      if (first && allowStrict && this$1.isUseStrict(stmt)) {
	        oldStrict = this$1.strict
	        this$1.setStrict(this$1.strict = true)
	      }
	      first = false
	    }
	    if (oldStrict === false) this.setStrict(false)
	    return this.finishNode(node, "BlockStatement")
	  }
	
	  // Parse a regular `for` loop. The disambiguation code in
	  // `parseStatement` will already have parsed the init statement or
	  // expression.
	
	  pp$1.parseFor = function(node, init) {
	    node.init = init
	    this.expect(tt.semi)
	    node.test = this.type === tt.semi ? null : this.parseExpression()
	    this.expect(tt.semi)
	    node.update = this.type === tt.parenR ? null : this.parseExpression()
	    this.expect(tt.parenR)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    return this.finishNode(node, "ForStatement")
	  }
	
	  // Parse a `for`/`in` and `for`/`of` loop, which are almost
	  // same from parser's perspective.
	
	  pp$1.parseForIn = function(node, init) {
	    var type = this.type === tt._in ? "ForInStatement" : "ForOfStatement"
	    this.next()
	    node.left = init
	    node.right = this.parseExpression()
	    this.expect(tt.parenR)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    return this.finishNode(node, type)
	  }
	
	  // Parse a list of variable declarations.
	
	  pp$1.parseVar = function(node, isFor, kind) {
	    var this$1 = this;
	
	    node.declarations = []
	    node.kind = kind
	    for (;;) {
	      var decl = this$1.startNode()
	      this$1.parseVarId(decl)
	      if (this$1.eat(tt.eq)) {
	        decl.init = this$1.parseMaybeAssign(isFor)
	      } else if (kind === "const" && !(this$1.type === tt._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual("of")))) {
	        this$1.unexpected()
	      } else if (decl.id.type != "Identifier" && !(isFor && (this$1.type === tt._in || this$1.isContextual("of")))) {
	        this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value")
	      } else {
	        decl.init = null
	      }
	      node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"))
	      if (!this$1.eat(tt.comma)) break
	    }
	    return node
	  }
	
	  pp$1.parseVarId = function(decl) {
	    decl.id = this.parseBindingAtom()
	    this.checkLVal(decl.id, true)
	  }
	
	  // Parse a function declaration or literal (depending on the
	  // `isStatement` parameter).
	
	  pp$1.parseFunction = function(node, isStatement, allowExpressionBody) {
	    this.initFunction(node)
	    if (this.options.ecmaVersion >= 6)
	      node.generator = this.eat(tt.star)
	    var oldInGen = this.inGenerator
	    this.inGenerator = node.generator
	    if (isStatement || this.type === tt.name)
	      node.id = this.parseIdent()
	    this.parseFunctionParams(node)
	    this.parseFunctionBody(node, allowExpressionBody)
	    this.inGenerator = oldInGen
	    return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression")
	  }
	
	  pp$1.parseFunctionParams = function(node) {
	    this.expect(tt.parenL)
	    node.params = this.parseBindingList(tt.parenR, false, false, true)
	  }
	
	  // Parse a class declaration or literal (depending on the
	  // `isStatement` parameter).
	
	  pp$1.parseClass = function(node, isStatement) {
	    var this$1 = this;
	
	    this.next()
	    this.parseClassId(node, isStatement)
	    this.parseClassSuper(node)
	    var classBody = this.startNode()
	    var hadConstructor = false
	    classBody.body = []
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      if (this$1.eat(tt.semi)) continue
	      var method = this$1.startNode()
	      var isGenerator = this$1.eat(tt.star)
	      var isMaybeStatic = this$1.type === tt.name && this$1.value === "static"
	      this$1.parsePropertyName(method)
	      method.static = isMaybeStatic && this$1.type !== tt.parenL
	      if (method.static) {
	        if (isGenerator) this$1.unexpected()
	        isGenerator = this$1.eat(tt.star)
	        this$1.parsePropertyName(method)
	      }
	      method.kind = "method"
	      var isGetSet = false
	      if (!method.computed) {
	        var key = method.key;
	        if (!isGenerator && key.type === "Identifier" && this$1.type !== tt.parenL && (key.name === "get" || key.name === "set")) {
	          isGetSet = true
	          method.kind = key.name
	          key = this$1.parsePropertyName(method)
	        }
	        if (!method.static && (key.type === "Identifier" && key.name === "constructor" ||
	            key.type === "Literal" && key.value === "constructor")) {
	          if (hadConstructor) this$1.raise(key.start, "Duplicate constructor in the same class")
	          if (isGetSet) this$1.raise(key.start, "Constructor can't have get/set modifier")
	          if (isGenerator) this$1.raise(key.start, "Constructor can't be a generator")
	          method.kind = "constructor"
	          hadConstructor = true
	        }
	      }
	      this$1.parseClassMethod(classBody, method, isGenerator)
	      if (isGetSet) {
	        var paramCount = method.kind === "get" ? 0 : 1
	        if (method.value.params.length !== paramCount) {
	          var start = method.value.start
	          if (method.kind === "get")
	            this$1.raiseRecoverable(start, "getter should have no params")
	          else
	            this$1.raiseRecoverable(start, "setter should have exactly one param")
	        }
	        if (method.kind === "set" && method.value.params[0].type === "RestElement")
	          this$1.raise(method.value.params[0].start, "Setter cannot use rest params")
	      }
	    }
	    node.body = this.finishNode(classBody, "ClassBody")
	    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
	  }
	
	  pp$1.parseClassMethod = function(classBody, method, isGenerator) {
	    method.value = this.parseMethod(isGenerator)
	    classBody.body.push(this.finishNode(method, "MethodDefinition"))
	  }
	
	  pp$1.parseClassId = function(node, isStatement) {
	    node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null
	  }
	
	  pp$1.parseClassSuper = function(node) {
	    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null
	  }
	
	  // Parses module export declaration.
	
	  pp$1.parseExport = function(node) {
	    var this$1 = this;
	
	    this.next()
	    // export * from '...'
	    if (this.eat(tt.star)) {
	      this.expectContextual("from")
	      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
	      this.semicolon()
	      return this.finishNode(node, "ExportAllDeclaration")
	    }
	    if (this.eat(tt._default)) { // export default ...
	      var parens = this.type == tt.parenL
	      var expr = this.parseMaybeAssign()
	      var needsSemi = true
	      if (!parens && (expr.type == "FunctionExpression" ||
	                      expr.type == "ClassExpression")) {
	        needsSemi = false
	        if (expr.id) {
	          expr.type = expr.type == "FunctionExpression"
	            ? "FunctionDeclaration"
	            : "ClassDeclaration"
	        }
	      }
	      node.declaration = expr
	      if (needsSemi) this.semicolon()
	      return this.finishNode(node, "ExportDefaultDeclaration")
	    }
	    // export var|const|let|function|class ...
	    if (this.shouldParseExportStatement()) {
	      node.declaration = this.parseStatement(true)
	      node.specifiers = []
	      node.source = null
	    } else { // export { x, y as z } [from '...']
	      node.declaration = null
	      node.specifiers = this.parseExportSpecifiers()
	      if (this.eatContextual("from")) {
	        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
	      } else {
	        // check for keywords used as local names
	        for (var i = 0; i < node.specifiers.length; i++) {
	          if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {
	            this$1.unexpected(node.specifiers[i].local.start)
	          }
	        }
	
	        node.source = null
	      }
	      this.semicolon()
	    }
	    return this.finishNode(node, "ExportNamedDeclaration")
	  }
	
	  pp$1.shouldParseExportStatement = function() {
	    return this.type.keyword || this.isLet()
	  }
	
	  // Parses a comma-separated list of module exports.
	
	  pp$1.parseExportSpecifiers = function() {
	    var this$1 = this;
	
	    var nodes = [], first = true
	    // export { x, y as z } [from '...']
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (this$1.afterTrailingComma(tt.braceR)) break
	      } else first = false
	
	      var node = this$1.startNode()
	      node.local = this$1.parseIdent(this$1.type === tt._default)
	      node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local
	      nodes.push(this$1.finishNode(node, "ExportSpecifier"))
	    }
	    return nodes
	  }
	
	  // Parses import declaration.
	
	  pp$1.parseImport = function(node) {
	    this.next()
	    // import '...'
	    if (this.type === tt.string) {
	      node.specifiers = empty
	      node.source = this.parseExprAtom()
	    } else {
	      node.specifiers = this.parseImportSpecifiers()
	      this.expectContextual("from")
	      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
	    }
	    this.semicolon()
	    return this.finishNode(node, "ImportDeclaration")
	  }
	
	  // Parses a comma-separated list of module imports.
	
	  pp$1.parseImportSpecifiers = function() {
	    var this$1 = this;
	
	    var nodes = [], first = true
	    if (this.type === tt.name) {
	      // import defaultObj, { x, y as z } from '...'
	      var node = this.startNode()
	      node.local = this.parseIdent()
	      this.checkLVal(node.local, true)
	      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"))
	      if (!this.eat(tt.comma)) return nodes
	    }
	    if (this.type === tt.star) {
	      var node$1 = this.startNode()
	      this.next()
	      this.expectContextual("as")
	      node$1.local = this.parseIdent()
	      this.checkLVal(node$1.local, true)
	      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"))
	      return nodes
	    }
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (this$1.afterTrailingComma(tt.braceR)) break
	      } else first = false
	
	      var node$2 = this$1.startNode()
	      node$2.imported = this$1.parseIdent(true)
	      if (this$1.eatContextual("as")) {
	        node$2.local = this$1.parseIdent()
	      } else {
	        node$2.local = node$2.imported
	        if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)
	        if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raise(node$2.local.start, "The keyword '" + node$2.local.name + "' is reserved")
	      }
	      this$1.checkLVal(node$2.local, true)
	      nodes.push(this$1.finishNode(node$2, "ImportSpecifier"))
	    }
	    return nodes
	  }
	
	  var pp$2 = Parser.prototype
	
	  // Convert existing expression atom to assignable pattern
	  // if possible.
	
	  pp$2.toAssignable = function(node, isBinding) {
	    var this$1 = this;
	
	    if (this.options.ecmaVersion >= 6 && node) {
	      switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	        break
	
	      case "ObjectExpression":
	        node.type = "ObjectPattern"
	        for (var i = 0; i < node.properties.length; i++) {
	          var prop = node.properties[i]
	          if (prop.kind !== "init") this$1.raise(prop.key.start, "Object pattern can't contain getter or setter")
	          this$1.toAssignable(prop.value, isBinding)
	        }
	        break
	
	      case "ArrayExpression":
	        node.type = "ArrayPattern"
	        this.toAssignableList(node.elements, isBinding)
	        break
	
	      case "AssignmentExpression":
	        if (node.operator === "=") {
	          node.type = "AssignmentPattern"
	          delete node.operator
	          // falls through to AssignmentPattern
	        } else {
	          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.")
	          break
	        }
	
	      case "AssignmentPattern":
	        if (node.right.type === "YieldExpression")
	          this.raise(node.right.start, "Yield expression cannot be a default value")
	        break
	
	      case "ParenthesizedExpression":
	        node.expression = this.toAssignable(node.expression, isBinding)
	        break
	
	      case "MemberExpression":
	        if (!isBinding) break
	
	      default:
	        this.raise(node.start, "Assigning to rvalue")
	      }
	    }
	    return node
	  }
	
	  // Convert list of expression atoms to binding list.
	
	  pp$2.toAssignableList = function(exprList, isBinding) {
	    var this$1 = this;
	
	    var end = exprList.length
	    if (end) {
	      var last = exprList[end - 1]
	      if (last && last.type == "RestElement") {
	        --end
	      } else if (last && last.type == "SpreadElement") {
	        last.type = "RestElement"
	        var arg = last.argument
	        this.toAssignable(arg, isBinding)
	        if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern")
	          this.unexpected(arg.start)
	        --end
	      }
	
	      if (isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
	        this.unexpected(last.argument.start)
	    }
	    for (var i = 0; i < end; i++) {
	      var elt = exprList[i]
	      if (elt) this$1.toAssignable(elt, isBinding)
	    }
	    return exprList
	  }
	
	  // Parses spread element.
	
	  pp$2.parseSpread = function(refDestructuringErrors) {
	    var node = this.startNode()
	    this.next()
	    node.argument = this.parseMaybeAssign(false, refDestructuringErrors)
	    return this.finishNode(node, "SpreadElement")
	  }
	
	  pp$2.parseRest = function(allowNonIdent) {
	    var node = this.startNode()
	    this.next()
	
	    // RestElement inside of a function parameter must be an identifier
	    if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()
	    else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()
	
	    return this.finishNode(node, "RestElement")
	  }
	
	  // Parses lvalue (assignable) atom.
	
	  pp$2.parseBindingAtom = function() {
	    if (this.options.ecmaVersion < 6) return this.parseIdent()
	    switch (this.type) {
	    case tt.name:
	      return this.parseIdent()
	
	    case tt.bracketL:
	      var node = this.startNode()
	      this.next()
	      node.elements = this.parseBindingList(tt.bracketR, true, true)
	      return this.finishNode(node, "ArrayPattern")
	
	    case tt.braceL:
	      return this.parseObj(true)
	
	    default:
	      this.unexpected()
	    }
	  }
	
	  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {
	    var this$1 = this;
	
	    var elts = [], first = true
	    while (!this.eat(close)) {
	      if (first) first = false
	      else this$1.expect(tt.comma)
	      if (allowEmpty && this$1.type === tt.comma) {
	        elts.push(null)
	      } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
	        break
	      } else if (this$1.type === tt.ellipsis) {
	        var rest = this$1.parseRest(allowNonIdent)
	        this$1.parseBindingListItem(rest)
	        elts.push(rest)
	        if (this$1.type === tt.comma) this$1.raise(this$1.start, "Comma is not permitted after the rest element")
	        this$1.expect(close)
	        break
	      } else {
	        var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)
	        this$1.parseBindingListItem(elem)
	        elts.push(elem)
	      }
	    }
	    return elts
	  }
	
	  pp$2.parseBindingListItem = function(param) {
	    return param
	  }
	
	  // Parses assignment pattern around given atom if possible.
	
	  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
	    left = left || this.parseBindingAtom()
	    if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left
	    var node = this.startNodeAt(startPos, startLoc)
	    node.left = left
	    node.right = this.parseMaybeAssign()
	    return this.finishNode(node, "AssignmentPattern")
	  }
	
	  // Verify that a node is an lval — something that can be assigned
	  // to.
	
	  pp$2.checkLVal = function(expr, isBinding, checkClashes) {
	    var this$1 = this;
	
	    switch (expr.type) {
	    case "Identifier":
	      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
	        this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode")
	      if (checkClashes) {
	        if (has(checkClashes, expr.name))
	          this.raiseRecoverable(expr.start, "Argument name clash")
	        checkClashes[expr.name] = true
	      }
	      break
	
	    case "MemberExpression":
	      if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression")
	      break
	
	    case "ObjectPattern":
	      for (var i = 0; i < expr.properties.length; i++)
	        this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes)
	      break
	
	    case "ArrayPattern":
	      for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {
	        var elem = expr.elements[i$1]
	        if (elem) this$1.checkLVal(elem, isBinding, checkClashes)
	      }
	      break
	
	    case "AssignmentPattern":
	      this.checkLVal(expr.left, isBinding, checkClashes)
	      break
	
	    case "RestElement":
	      this.checkLVal(expr.argument, isBinding, checkClashes)
	      break
	
	    case "ParenthesizedExpression":
	      this.checkLVal(expr.expression, isBinding, checkClashes)
	      break
	
	    default:
	      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue")
	    }
	  }
	
	  var pp$3 = Parser.prototype
	
	  // Check if property name clashes with already added.
	  // Object/class getters and setters are not allowed to clash —
	  // either with each other or with an init property — and in
	  // strict mode, init properties are also not allowed to be repeated.
	
	  pp$3.checkPropClash = function(prop, propHash) {
	    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
	      return
	    var key = prop.key;
	    var name
	    switch (key.type) {
	    case "Identifier": name = key.name; break
	    case "Literal": name = String(key.value); break
	    default: return
	    }
	    var kind = prop.kind;
	    if (this.options.ecmaVersion >= 6) {
	      if (name === "__proto__" && kind === "init") {
	        if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property")
	        propHash.proto = true
	      }
	      return
	    }
	    name = "$" + name
	    var other = propHash[name]
	    if (other) {
	      var isGetSet = kind !== "init"
	      if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))
	        this.raiseRecoverable(key.start, "Redefinition of property")
	    } else {
	      other = propHash[name] = {
	        init: false,
	        get: false,
	        set: false
	      }
	    }
	    other[kind] = true
	  }
	
	  // ### Expression parsing
	
	  // These nest, from the most general expression type at the top to
	  // 'atomic', nondivisible expression types at the bottom. Most of
	  // the functions will simply let the function(s) below them parse,
	  // and, *if* the syntactic construct they handle is present, wrap
	  // the AST node that the inner parser gave them in another node.
	
	  // Parse a full expression. The optional arguments are used to
	  // forbid the `in` operator (in for loops initalization expressions)
	  // and provide reference for storing '=' operator inside shorthand
	  // property assignment in contexts where both object expression
	  // and object pattern might appear (so it's possible to raise
	  // delayed syntax error at correct position).
	
	  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
	    var this$1 = this;
	
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)
	    if (this.type === tt.comma) {
	      var node = this.startNodeAt(startPos, startLoc)
	      node.expressions = [expr]
	      while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))
	      return this.finishNode(node, "SequenceExpression")
	    }
	    return expr
	  }
	
	  // Parse an assignment expression. This includes applications of
	  // operators like `+=`.
	
	  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
	    if (this.inGenerator && this.isContextual("yield")) return this.parseYield()
	
	    var ownDestructuringErrors = false
	    if (!refDestructuringErrors) {
	      refDestructuringErrors = new DestructuringErrors
	      ownDestructuringErrors = true
	    }
	    var startPos = this.start, startLoc = this.startLoc
	    if (this.type == tt.parenL || this.type == tt.name)
	      this.potentialArrowAt = this.start
	    var left = this.parseMaybeConditional(noIn, refDestructuringErrors)
	    if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)
	    if (this.type.isAssign) {
	      this.checkPatternErrors(refDestructuringErrors, true)
	      if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)
	      var node = this.startNodeAt(startPos, startLoc)
	      node.operator = this.value
	      node.left = this.type === tt.eq ? this.toAssignable(left) : left
	      refDestructuringErrors.shorthandAssign = 0 // reset because shorthand default was used correctly
	      this.checkLVal(left)
	      this.next()
	      node.right = this.parseMaybeAssign(noIn)
	      return this.finishNode(node, "AssignmentExpression")
	    } else {
	      if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)
	    }
	    return left
	  }
	
	  // Parse a ternary conditional (`?:`) operator.
	
	  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseExprOps(noIn, refDestructuringErrors)
	    if (this.checkExpressionErrors(refDestructuringErrors)) return expr
	    if (this.eat(tt.question)) {
	      var node = this.startNodeAt(startPos, startLoc)
	      node.test = expr
	      node.consequent = this.parseMaybeAssign()
	      this.expect(tt.colon)
	      node.alternate = this.parseMaybeAssign(noIn)
	      return this.finishNode(node, "ConditionalExpression")
	    }
	    return expr
	  }
	
	  // Start the precedence parser.
	
	  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseMaybeUnary(refDestructuringErrors, false)
	    if (this.checkExpressionErrors(refDestructuringErrors)) return expr
	    return this.parseExprOp(expr, startPos, startLoc, -1, noIn)
	  }
	
	  // Parse binary operators with the operator precedence parsing
	  // algorithm. `left` is the left-hand side of the operator.
	  // `minPrec` provides context that allows the function to stop and
	  // defer further parser to one of its callers when it encounters an
	  // operator that has a lower precedence than the set it is parsing.
	
	  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
	    var prec = this.type.binop
	    if (prec != null && (!noIn || this.type !== tt._in)) {
	      if (prec > minPrec) {
	        var logical = this.type === tt.logicalOR || this.type === tt.logicalAND
	        var op = this.value
	        this.next()
	        var startPos = this.start, startLoc = this.startLoc
	        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)
	        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)
	        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
	      }
	    }
	    return left
	  }
	
	  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
	    var node = this.startNodeAt(startPos, startLoc)
	    node.left = left
	    node.operator = op
	    node.right = right
	    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
	  }
	
	  // Parse unary operators, both prefix and postfix.
	
	  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
	    var this$1 = this;
	
	    var startPos = this.start, startLoc = this.startLoc, expr
	    if (this.type.prefix) {
	      var node = this.startNode(), update = this.type === tt.incDec
	      node.operator = this.value
	      node.prefix = true
	      this.next()
	      node.argument = this.parseMaybeUnary(null, true)
	      this.checkExpressionErrors(refDestructuringErrors, true)
	      if (update) this.checkLVal(node.argument)
	      else if (this.strict && node.operator === "delete" &&
	               node.argument.type === "Identifier")
	        this.raiseRecoverable(node.start, "Deleting local variable in strict mode")
	      else sawUnary = true
	      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression")
	    } else {
	      expr = this.parseExprSubscripts(refDestructuringErrors)
	      if (this.checkExpressionErrors(refDestructuringErrors)) return expr
	      while (this.type.postfix && !this.canInsertSemicolon()) {
	        var node$1 = this$1.startNodeAt(startPos, startLoc)
	        node$1.operator = this$1.value
	        node$1.prefix = false
	        node$1.argument = expr
	        this$1.checkLVal(expr)
	        this$1.next()
	        expr = this$1.finishNode(node$1, "UpdateExpression")
	      }
	    }
	
	    if (!sawUnary && this.eat(tt.starstar))
	      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false)
	    else
	      return expr
	  }
	
	  // Parse call, dot, and `[]`-subscript expressions.
	
	  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseExprAtom(refDestructuringErrors)
	    var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")"
	    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr
	    return this.parseSubscripts(expr, startPos, startLoc)
	  }
	
	  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
	    var this$1 = this;
	
	    for (;;) {
	      if (this$1.eat(tt.dot)) {
	        var node = this$1.startNodeAt(startPos, startLoc)
	        node.object = base
	        node.property = this$1.parseIdent(true)
	        node.computed = false
	        base = this$1.finishNode(node, "MemberExpression")
	      } else if (this$1.eat(tt.bracketL)) {
	        var node$1 = this$1.startNodeAt(startPos, startLoc)
	        node$1.object = base
	        node$1.property = this$1.parseExpression()
	        node$1.computed = true
	        this$1.expect(tt.bracketR)
	        base = this$1.finishNode(node$1, "MemberExpression")
	      } else if (!noCalls && this$1.eat(tt.parenL)) {
	        var node$2 = this$1.startNodeAt(startPos, startLoc)
	        node$2.callee = base
	        node$2.arguments = this$1.parseExprList(tt.parenR, false)
	        base = this$1.finishNode(node$2, "CallExpression")
	      } else if (this$1.type === tt.backQuote) {
	        var node$3 = this$1.startNodeAt(startPos, startLoc)
	        node$3.tag = base
	        node$3.quasi = this$1.parseTemplate()
	        base = this$1.finishNode(node$3, "TaggedTemplateExpression")
	      } else {
	        return base
	      }
	    }
	  }
	
	  // Parse an atomic expression — either a single token that is an
	  // expression, an expression started by a keyword like `function` or
	  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
	  // or `{}`.
	
	  pp$3.parseExprAtom = function(refDestructuringErrors) {
	    var node, canBeArrow = this.potentialArrowAt == this.start
	    switch (this.type) {
	    case tt._super:
	      if (!this.inFunction)
	        this.raise(this.start, "'super' outside of function or class")
	
	    case tt._this:
	      var type = this.type === tt._this ? "ThisExpression" : "Super"
	      node = this.startNode()
	      this.next()
	      return this.finishNode(node, type)
	
	    case tt.name:
	      var startPos = this.start, startLoc = this.startLoc
	      var id = this.parseIdent(this.type !== tt.name)
	      if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow))
	        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id])
	      return id
	
	    case tt.regexp:
	      var value = this.value
	      node = this.parseLiteral(value.value)
	      node.regex = {pattern: value.pattern, flags: value.flags}
	      return node
	
	    case tt.num: case tt.string:
	      return this.parseLiteral(this.value)
	
	    case tt._null: case tt._true: case tt._false:
	      node = this.startNode()
	      node.value = this.type === tt._null ? null : this.type === tt._true
	      node.raw = this.type.keyword
	      this.next()
	      return this.finishNode(node, "Literal")
	
	    case tt.parenL:
	      return this.parseParenAndDistinguishExpression(canBeArrow)
	
	    case tt.bracketL:
	      node = this.startNode()
	      this.next()
	      node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)
	      return this.finishNode(node, "ArrayExpression")
	
	    case tt.braceL:
	      return this.parseObj(false, refDestructuringErrors)
	
	    case tt._function:
	      node = this.startNode()
	      this.next()
	      return this.parseFunction(node, false)
	
	    case tt._class:
	      return this.parseClass(this.startNode(), false)
	
	    case tt._new:
	      return this.parseNew()
	
	    case tt.backQuote:
	      return this.parseTemplate()
	
	    default:
	      this.unexpected()
	    }
	  }
	
	  pp$3.parseLiteral = function(value) {
	    var node = this.startNode()
	    node.value = value
	    node.raw = this.input.slice(this.start, this.end)
	    this.next()
	    return this.finishNode(node, "Literal")
	  }
	
	  pp$3.parseParenExpression = function() {
	    this.expect(tt.parenL)
	    var val = this.parseExpression()
	    this.expect(tt.parenR)
	    return val
	  }
	
	  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
	    var this$1 = this;
	
	    var startPos = this.start, startLoc = this.startLoc, val
	    if (this.options.ecmaVersion >= 6) {
	      this.next()
	
	      var innerStartPos = this.start, innerStartLoc = this.startLoc
	      var exprList = [], first = true
	      var refDestructuringErrors = new DestructuringErrors, spreadStart, innerParenStart
	      while (this.type !== tt.parenR) {
	        first ? first = false : this$1.expect(tt.comma)
	        if (this$1.type === tt.ellipsis) {
	          spreadStart = this$1.start
	          exprList.push(this$1.parseParenItem(this$1.parseRest()))
	          break
	        } else {
	          if (this$1.type === tt.parenL && !innerParenStart) {
	            innerParenStart = this$1.start
	          }
	          exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))
	        }
	      }
	      var innerEndPos = this.start, innerEndLoc = this.startLoc
	      this.expect(tt.parenR)
	
	      if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {
	        this.checkPatternErrors(refDestructuringErrors, true)
	        if (innerParenStart) this.unexpected(innerParenStart)
	        return this.parseParenArrowList(startPos, startLoc, exprList)
	      }
	
	      if (!exprList.length) this.unexpected(this.lastTokStart)
	      if (spreadStart) this.unexpected(spreadStart)
	      this.checkExpressionErrors(refDestructuringErrors, true)
	
	      if (exprList.length > 1) {
	        val = this.startNodeAt(innerStartPos, innerStartLoc)
	        val.expressions = exprList
	        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc)
	      } else {
	        val = exprList[0]
	      }
	    } else {
	      val = this.parseParenExpression()
	    }
	
	    if (this.options.preserveParens) {
	      var par = this.startNodeAt(startPos, startLoc)
	      par.expression = val
	      return this.finishNode(par, "ParenthesizedExpression")
	    } else {
	      return val
	    }
	  }
	
	  pp$3.parseParenItem = function(item) {
	    return item
	  }
	
	  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
	    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
	  }
	
	  // New's precedence is slightly tricky. It must allow its argument to
	  // be a `[]` or dot subscript expression, but not a call — at least,
	  // not without wrapping it in parentheses. Thus, it uses the noCalls
	  // argument to parseSubscripts to prevent it from consuming the
	  // argument list.
	
	  var empty$1 = []
	
	  pp$3.parseNew = function() {
	    var node = this.startNode()
	    var meta = this.parseIdent(true)
	    if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
	      node.meta = meta
	      node.property = this.parseIdent(true)
	      if (node.property.name !== "target")
	        this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target")
	      if (!this.inFunction)
	        this.raiseRecoverable(node.start, "new.target can only be used in functions")
	      return this.finishNode(node, "MetaProperty")
	    }
	    var startPos = this.start, startLoc = this.startLoc
	    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)
	    if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false)
	    else node.arguments = empty$1
	    return this.finishNode(node, "NewExpression")
	  }
	
	  // Parse template expression.
	
	  pp$3.parseTemplateElement = function() {
	    var elem = this.startNode()
	    elem.value = {
	      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
	      cooked: this.value
	    }
	    this.next()
	    elem.tail = this.type === tt.backQuote
	    return this.finishNode(elem, "TemplateElement")
	  }
	
	  pp$3.parseTemplate = function() {
	    var this$1 = this;
	
	    var node = this.startNode()
	    this.next()
	    node.expressions = []
	    var curElt = this.parseTemplateElement()
	    node.quasis = [curElt]
	    while (!curElt.tail) {
	      this$1.expect(tt.dollarBraceL)
	      node.expressions.push(this$1.parseExpression())
	      this$1.expect(tt.braceR)
	      node.quasis.push(curElt = this$1.parseTemplateElement())
	    }
	    this.next()
	    return this.finishNode(node, "TemplateLiteral")
	  }
	
	  // Parse an object literal or binding pattern.
	
	  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
	    var this$1 = this;
	
	    var node = this.startNode(), first = true, propHash = {}
	    node.properties = []
	    this.next()
	    while (!this.eat(tt.braceR)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (this$1.afterTrailingComma(tt.braceR)) break
	      } else first = false
	
	      var prop = this$1.startNode(), isGenerator, startPos, startLoc
	      if (this$1.options.ecmaVersion >= 6) {
	        prop.method = false
	        prop.shorthand = false
	        if (isPattern || refDestructuringErrors) {
	          startPos = this$1.start
	          startLoc = this$1.startLoc
	        }
	        if (!isPattern)
	          isGenerator = this$1.eat(tt.star)
	      }
	      this$1.parsePropertyName(prop)
	      this$1.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors)
	      this$1.checkPropClash(prop, propHash)
	      node.properties.push(this$1.finishNode(prop, "Property"))
	    }
	    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
	  }
	
	  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
	    if (this.eat(tt.colon)) {
	      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)
	      prop.kind = "init"
	    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {
	      if (isPattern) this.unexpected()
	      prop.kind = "init"
	      prop.method = true
	      prop.value = this.parseMethod(isGenerator)
	    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
	               (prop.key.name === "get" || prop.key.name === "set") &&
	               (this.type != tt.comma && this.type != tt.braceR)) {
	      if (isGenerator || isPattern) this.unexpected()
	      prop.kind = prop.key.name
	      this.parsePropertyName(prop)
	      prop.value = this.parseMethod(false)
	      var paramCount = prop.kind === "get" ? 0 : 1
	      if (prop.value.params.length !== paramCount) {
	        var start = prop.value.start
	        if (prop.kind === "get")
	          this.raiseRecoverable(start, "getter should have no params")
	        else
	          this.raiseRecoverable(start, "setter should have exactly one param")
	      }
	      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
	        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params")
	    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	      if (this.keywords.test(prop.key.name) ||
	          (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) ||
	          (this.inGenerator && prop.key.name == "yield"))
	        this.raiseRecoverable(prop.key.start, "'" + prop.key.name + "' can not be used as shorthand property")
	      prop.kind = "init"
	      if (isPattern) {
	        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
	      } else if (this.type === tt.eq && refDestructuringErrors) {
	        if (!refDestructuringErrors.shorthandAssign)
	          refDestructuringErrors.shorthandAssign = this.start
	        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
	      } else {
	        prop.value = prop.key
	      }
	      prop.shorthand = true
	    } else this.unexpected()
	  }
	
	  pp$3.parsePropertyName = function(prop) {
	    if (this.options.ecmaVersion >= 6) {
	      if (this.eat(tt.bracketL)) {
	        prop.computed = true
	        prop.key = this.parseMaybeAssign()
	        this.expect(tt.bracketR)
	        return prop.key
	      } else {
	        prop.computed = false
	      }
	    }
	    return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)
	  }
	
	  // Initialize empty function node.
	
	  pp$3.initFunction = function(node) {
	    node.id = null
	    if (this.options.ecmaVersion >= 6) {
	      node.generator = false
	      node.expression = false
	    }
	  }
	
	  // Parse object or class method.
	
	  pp$3.parseMethod = function(isGenerator) {
	    var node = this.startNode(), oldInGen = this.inGenerator
	    this.inGenerator = isGenerator
	    this.initFunction(node)
	    this.expect(tt.parenL)
	    node.params = this.parseBindingList(tt.parenR, false, false)
	    if (this.options.ecmaVersion >= 6)
	      node.generator = isGenerator
	    this.parseFunctionBody(node, false)
	    this.inGenerator = oldInGen
	    return this.finishNode(node, "FunctionExpression")
	  }
	
	  // Parse arrow function expression with given parameters.
	
	  pp$3.parseArrowExpression = function(node, params) {
	    var oldInGen = this.inGenerator
	    this.inGenerator = false
	    this.initFunction(node)
	    node.params = this.toAssignableList(params, true)
	    this.parseFunctionBody(node, true)
	    this.inGenerator = oldInGen
	    return this.finishNode(node, "ArrowFunctionExpression")
	  }
	
	  // Parse function body and check parameters.
	
	  pp$3.parseFunctionBody = function(node, isArrowFunction) {
	    var isExpression = isArrowFunction && this.type !== tt.braceL
	
	    if (isExpression) {
	      node.body = this.parseMaybeAssign()
	      node.expression = true
	    } else {
	      // Start a new scope with regard to labels and the `inFunction`
	      // flag (restore them to their old value afterwards).
	      var oldInFunc = this.inFunction, oldLabels = this.labels
	      this.inFunction = true; this.labels = []
	      node.body = this.parseBlock(true)
	      node.expression = false
	      this.inFunction = oldInFunc; this.labels = oldLabels
	    }
	
	    // If this is a strict mode function, verify that argument names
	    // are not repeated, and it does not try to bind the words `eval`
	    // or `arguments`.
	    var useStrict = (!isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) ? node.body.body[0] : null;
	    if (this.strict || useStrict) {
	      var oldStrict = this.strict
	      this.strict = true
	      if (node.id)
	        this.checkLVal(node.id, true)
	      this.checkParams(node, useStrict)
	      this.strict = oldStrict
	    } else if (isArrowFunction) {
	      this.checkParams(node, useStrict)
	    }
	  }
	
	  // Checks function params for various disallowed patterns such as using "eval"
	  // or "arguments" and duplicate parameters.
	
	  pp$3.checkParams = function(node, useStrict) {
	      var this$1 = this;
	
	      var nameHash = {}
	      for (var i = 0; i < node.params.length; i++) {
	        if (useStrict && this$1.options.ecmaVersion >= 7 && node.params[i].type !== "Identifier")
	          this$1.raiseRecoverable(useStrict.start, "Illegal 'use strict' directive in function with non-simple parameter list");
	        this$1.checkLVal(node.params[i], true, nameHash)
	      }
	  }
	
	  // Parses a comma-separated list of expressions, and returns them as
	  // an array. `close` is the token type that ends the list, and
	  // `allowEmpty` can be turned on to allow subsequent commas with
	  // nothing in between them to be parsed as `null` (which is needed
	  // for array literals).
	
	  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	    var this$1 = this;
	
	    var elts = [], first = true
	    while (!this.eat(close)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (allowTrailingComma && this$1.afterTrailingComma(close)) break
	      } else first = false
	
	      var elt
	      if (allowEmpty && this$1.type === tt.comma)
	        elt = null
	      else if (this$1.type === tt.ellipsis) {
	        elt = this$1.parseSpread(refDestructuringErrors)
	        if (this$1.type === tt.comma && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
	          refDestructuringErrors.trailingComma = this$1.lastTokStart
	        }
	      } else
	        elt = this$1.parseMaybeAssign(false, refDestructuringErrors)
	      elts.push(elt)
	    }
	    return elts
	  }
	
	  // Parse the next token as an identifier. If `liberal` is true (used
	  // when parsing properties), it will also convert keywords into
	  // identifiers.
	
	  pp$3.parseIdent = function(liberal) {
	    var node = this.startNode()
	    if (liberal && this.options.allowReserved == "never") liberal = false
	    if (this.type === tt.name) {
	      if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&
	          (this.options.ecmaVersion >= 6 ||
	           this.input.slice(this.start, this.end).indexOf("\\") == -1))
	        this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved")
	      if (!liberal && this.inGenerator && this.value === "yield")
	        this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator")
	      node.name = this.value
	    } else if (liberal && this.type.keyword) {
	      node.name = this.type.keyword
	    } else {
	      this.unexpected()
	    }
	    this.next()
	    return this.finishNode(node, "Identifier")
	  }
	
	  // Parses yield expression inside generator.
	
	  pp$3.parseYield = function() {
	    var node = this.startNode()
	    this.next()
	    if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {
	      node.delegate = false
	      node.argument = null
	    } else {
	      node.delegate = this.eat(tt.star)
	      node.argument = this.parseMaybeAssign()
	    }
	    return this.finishNode(node, "YieldExpression")
	  }
	
	  var pp$4 = Parser.prototype
	
	  // This function is used to raise exceptions on parse errors. It
	  // takes an offset integer (into the current `input`) to indicate
	  // the location of the error, attaches the position to the end
	  // of the error message, and then raises a `SyntaxError` with that
	  // message.
	
	  pp$4.raise = function(pos, message) {
	    var loc = getLineInfo(this.input, pos)
	    message += " (" + loc.line + ":" + loc.column + ")"
	    var err = new SyntaxError(message)
	    err.pos = pos; err.loc = loc; err.raisedAt = this.pos
	    throw err
	  }
	
	  pp$4.raiseRecoverable = pp$4.raise
	
	  pp$4.curPosition = function() {
	    if (this.options.locations) {
	      return new Position(this.curLine, this.pos - this.lineStart)
	    }
	  }
	
	  var Node = function Node(parser, pos, loc) {
	    this.type = ""
	    this.start = pos
	    this.end = 0
	    if (parser.options.locations)
	      this.loc = new SourceLocation(parser, loc)
	    if (parser.options.directSourceFile)
	      this.sourceFile = parser.options.directSourceFile
	    if (parser.options.ranges)
	      this.range = [pos, 0]
	  };
	
	  // Start an AST node, attaching a start offset.
	
	  var pp$5 = Parser.prototype
	
	  pp$5.startNode = function() {
	    return new Node(this, this.start, this.startLoc)
	  }
	
	  pp$5.startNodeAt = function(pos, loc) {
	    return new Node(this, pos, loc)
	  }
	
	  // Finish an AST node, adding `type` and `end` properties.
	
	  function finishNodeAt(node, type, pos, loc) {
	    node.type = type
	    node.end = pos
	    if (this.options.locations)
	      node.loc.end = loc
	    if (this.options.ranges)
	      node.range[1] = pos
	    return node
	  }
	
	  pp$5.finishNode = function(node, type) {
	    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
	  }
	
	  // Finish node at given position
	
	  pp$5.finishNodeAt = function(node, type, pos, loc) {
	    return finishNodeAt.call(this, node, type, pos, loc)
	  }
	
	  var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
	    this.token = token
	    this.isExpr = !!isExpr
	    this.preserveSpace = !!preserveSpace
	    this.override = override
	  };
	
	  var types = {
	    b_stat: new TokContext("{", false),
	    b_expr: new TokContext("{", true),
	    b_tmpl: new TokContext("${", true),
	    p_stat: new TokContext("(", false),
	    p_expr: new TokContext("(", true),
	    q_tmpl: new TokContext("`", true, true, function (p) { return p.readTmplToken(); }),
	    f_expr: new TokContext("function", true)
	  }
	
	  var pp$6 = Parser.prototype
	
	  pp$6.initialContext = function() {
	    return [types.b_stat]
	  }
	
	  pp$6.braceIsBlock = function(prevType) {
	    if (prevType === tt.colon) {
	      var parent = this.curContext()
	      if (parent === types.b_stat || parent === types.b_expr)
	        return !parent.isExpr
	    }
	    if (prevType === tt._return)
	      return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
	    if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR)
	      return true
	    if (prevType == tt.braceL)
	      return this.curContext() === types.b_stat
	    return !this.exprAllowed
	  }
	
	  pp$6.updateContext = function(prevType) {
	    var update, type = this.type
	    if (type.keyword && prevType == tt.dot)
	      this.exprAllowed = false
	    else if (update = type.updateContext)
	      update.call(this, prevType)
	    else
	      this.exprAllowed = type.beforeExpr
	  }
	
	  // Token-specific context update code
	
	  tt.parenR.updateContext = tt.braceR.updateContext = function() {
	    if (this.context.length == 1) {
	      this.exprAllowed = true
	      return
	    }
	    var out = this.context.pop()
	    if (out === types.b_stat && this.curContext() === types.f_expr) {
	      this.context.pop()
	      this.exprAllowed = false
	    } else if (out === types.b_tmpl) {
	      this.exprAllowed = true
	    } else {
	      this.exprAllowed = !out.isExpr
	    }
	  }
	
	  tt.braceL.updateContext = function(prevType) {
	    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr)
	    this.exprAllowed = true
	  }
	
	  tt.dollarBraceL.updateContext = function() {
	    this.context.push(types.b_tmpl)
	    this.exprAllowed = true
	  }
	
	  tt.parenL.updateContext = function(prevType) {
	    var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while
	    this.context.push(statementParens ? types.p_stat : types.p_expr)
	    this.exprAllowed = true
	  }
	
	  tt.incDec.updateContext = function() {
	    // tokExprAllowed stays unchanged
	  }
	
	  tt._function.updateContext = function(prevType) {
	    if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else &&
	        !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat))
	      this.context.push(types.f_expr)
	    this.exprAllowed = false
	  }
	
	  tt.backQuote.updateContext = function() {
	    if (this.curContext() === types.q_tmpl)
	      this.context.pop()
	    else
	      this.context.push(types.q_tmpl)
	    this.exprAllowed = false
	  }
	
	  // Object type used to represent tokens. Note that normally, tokens
	  // simply exist as properties on the parser object. This is only
	  // used for the onToken callback and the external tokenizer.
	
	  var Token = function Token(p) {
	    this.type = p.type
	    this.value = p.value
	    this.start = p.start
	    this.end = p.end
	    if (p.options.locations)
	      this.loc = new SourceLocation(p, p.startLoc, p.endLoc)
	    if (p.options.ranges)
	      this.range = [p.start, p.end]
	  };
	
	  // ## Tokenizer
	
	  var pp$7 = Parser.prototype
	
	  // Are we running under Rhino?
	  var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]"
	
	  // Move to the next token
	
	  pp$7.next = function() {
	    if (this.options.onToken)
	      this.options.onToken(new Token(this))
	
	    this.lastTokEnd = this.end
	    this.lastTokStart = this.start
	    this.lastTokEndLoc = this.endLoc
	    this.lastTokStartLoc = this.startLoc
	    this.nextToken()
	  }
	
	  pp$7.getToken = function() {
	    this.next()
	    return new Token(this)
	  }
	
	  // If we're in an ES6 environment, make parsers iterable
	  if (typeof Symbol !== "undefined")
	    pp$7[Symbol.iterator] = function () {
	      var self = this
	      return {next: function () {
	        var token = self.getToken()
	        return {
	          done: token.type === tt.eof,
	          value: token
	        }
	      }}
	    }
	
	  // Toggle strict mode. Re-reads the next number or string to please
	  // pedantic tests (`"use strict"; 010;` should fail).
	
	  pp$7.setStrict = function(strict) {
	    var this$1 = this;
	
	    this.strict = strict
	    if (this.type !== tt.num && this.type !== tt.string) return
	    this.pos = this.start
	    if (this.options.locations) {
	      while (this.pos < this.lineStart) {
	        this$1.lineStart = this$1.input.lastIndexOf("\n", this$1.lineStart - 2) + 1
	        --this$1.curLine
	      }
	    }
	    this.nextToken()
	  }
	
	  pp$7.curContext = function() {
	    return this.context[this.context.length - 1]
	  }
	
	  // Read a single token, updating the parser object's token-related
	  // properties.
	
	  pp$7.nextToken = function() {
	    var curContext = this.curContext()
	    if (!curContext || !curContext.preserveSpace) this.skipSpace()
	
	    this.start = this.pos
	    if (this.options.locations) this.startLoc = this.curPosition()
	    if (this.pos >= this.input.length) return this.finishToken(tt.eof)
	
	    if (curContext.override) return curContext.override(this)
	    else this.readToken(this.fullCharCodeAtPos())
	  }
	
	  pp$7.readToken = function(code) {
	    // Identifier or keyword. '\uXXXX' sequences are allowed in
	    // identifiers, so '\' also dispatches to that.
	    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
	      return this.readWord()
	
	    return this.getTokenFromCode(code)
	  }
	
	  pp$7.fullCharCodeAtPos = function() {
	    var code = this.input.charCodeAt(this.pos)
	    if (code <= 0xd7ff || code >= 0xe000) return code
	    var next = this.input.charCodeAt(this.pos + 1)
	    return (code << 10) + next - 0x35fdc00
	  }
	
	  pp$7.skipBlockComment = function() {
	    var this$1 = this;
	
	    var startLoc = this.options.onComment && this.curPosition()
	    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2)
	    if (end === -1) this.raise(this.pos - 2, "Unterminated comment")
	    this.pos = end + 2
	    if (this.options.locations) {
	      lineBreakG.lastIndex = start
	      var match
	      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
	        ++this$1.curLine
	        this$1.lineStart = match.index + match[0].length
	      }
	    }
	    if (this.options.onComment)
	      this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
	                             startLoc, this.curPosition())
	  }
	
	  pp$7.skipLineComment = function(startSkip) {
	    var this$1 = this;
	
	    var start = this.pos
	    var startLoc = this.options.onComment && this.curPosition()
	    var ch = this.input.charCodeAt(this.pos+=startSkip)
	    while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	      ++this$1.pos
	      ch = this$1.input.charCodeAt(this$1.pos)
	    }
	    if (this.options.onComment)
	      this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
	                             startLoc, this.curPosition())
	  }
	
	  // Called at the start of the parse and after every token. Skips
	  // whitespace and comments, and.
	
	  pp$7.skipSpace = function() {
	    var this$1 = this;
	
	    loop: while (this.pos < this.input.length) {
	      var ch = this$1.input.charCodeAt(this$1.pos)
	      switch (ch) {
	        case 32: case 160: // ' '
	          ++this$1.pos
	          break
	        case 13:
	          if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
	            ++this$1.pos
	          }
	        case 10: case 8232: case 8233:
	          ++this$1.pos
	          if (this$1.options.locations) {
	            ++this$1.curLine
	            this$1.lineStart = this$1.pos
	          }
	          break
	        case 47: // '/'
	          switch (this$1.input.charCodeAt(this$1.pos + 1)) {
	            case 42: // '*'
	              this$1.skipBlockComment()
	              break
	            case 47:
	              this$1.skipLineComment(2)
	              break
	            default:
	              break loop
	          }
	          break
	        default:
	          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	            ++this$1.pos
	          } else {
	            break loop
	          }
	      }
	    }
	  }
	
	  // Called at the end of every token. Sets `end`, `val`, and
	  // maintains `context` and `exprAllowed`, and skips the space after
	  // the token, so that the next one's `start` will point at the
	  // right position.
	
	  pp$7.finishToken = function(type, val) {
	    this.end = this.pos
	    if (this.options.locations) this.endLoc = this.curPosition()
	    var prevType = this.type
	    this.type = type
	    this.value = val
	
	    this.updateContext(prevType)
	  }
	
	  // ### Token reading
	
	  // This is the function that is called to fetch the next token. It
	  // is somewhat obscure, because it works in character codes rather
	  // than characters, and because operator parsing has been inlined
	  // into it.
	  //
	  // All in the name of speed.
	  //
	  pp$7.readToken_dot = function() {
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next >= 48 && next <= 57) return this.readNumber(true)
	    var next2 = this.input.charCodeAt(this.pos + 2)
	    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
	      this.pos += 3
	      return this.finishToken(tt.ellipsis)
	    } else {
	      ++this.pos
	      return this.finishToken(tt.dot)
	    }
	  }
	
	  pp$7.readToken_slash = function() { // '/'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (this.exprAllowed) {++this.pos; return this.readRegexp()}
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(tt.slash, 1)
	  }
	
	  pp$7.readToken_mult_modulo_exp = function(code) { // '%*'
	    var next = this.input.charCodeAt(this.pos + 1)
	    var size = 1
	    var tokentype = code === 42 ? tt.star : tt.modulo
	
	    // exponentiation operator ** and **=
	    if (this.options.ecmaVersion >= 7 && next === 42) {
	      ++size
	      tokentype = tt.starstar
	      next = this.input.charCodeAt(this.pos + 2)
	    }
	
	    if (next === 61) return this.finishOp(tt.assign, size + 1)
	    return this.finishOp(tokentype, size)
	  }
	
	  pp$7.readToken_pipe_amp = function(code) { // '|&'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)
	  }
	
	  pp$7.readToken_caret = function() { // '^'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(tt.bitwiseXOR, 1)
	  }
	
	  pp$7.readToken_plus_min = function(code) { // '+-'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === code) {
	      if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&
	          lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
	        // A `-->` line comment
	        this.skipLineComment(3)
	        this.skipSpace()
	        return this.nextToken()
	      }
	      return this.finishOp(tt.incDec, 2)
	    }
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(tt.plusMin, 1)
	  }
	
	  pp$7.readToken_lt_gt = function(code) { // '<>'
	    var next = this.input.charCodeAt(this.pos + 1)
	    var size = 1
	    if (next === code) {
	      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2
	      if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)
	      return this.finishOp(tt.bitShift, size)
	    }
	    if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&
	        this.input.charCodeAt(this.pos + 3) == 45) {
	      if (this.inModule) this.unexpected()
	      // `<!--`, an XML-style comment that should be interpreted as a line comment
	      this.skipLineComment(4)
	      this.skipSpace()
	      return this.nextToken()
	    }
	    if (next === 61) size = 2
	    return this.finishOp(tt.relational, size)
	  }
	
	  pp$7.readToken_eq_excl = function(code) { // '=!'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)
	    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
	      this.pos += 2
	      return this.finishToken(tt.arrow)
	    }
	    return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)
	  }
	
	  pp$7.getTokenFromCode = function(code) {
	    switch (code) {
	      // The interpretation of a dot depends on whether it is followed
	      // by a digit or another two dots.
	    case 46: // '.'
	      return this.readToken_dot()
	
	      // Punctuation tokens.
	    case 40: ++this.pos; return this.finishToken(tt.parenL)
	    case 41: ++this.pos; return this.finishToken(tt.parenR)
	    case 59: ++this.pos; return this.finishToken(tt.semi)
	    case 44: ++this.pos; return this.finishToken(tt.comma)
	    case 91: ++this.pos; return this.finishToken(tt.bracketL)
	    case 93: ++this.pos; return this.finishToken(tt.bracketR)
	    case 123: ++this.pos; return this.finishToken(tt.braceL)
	    case 125: ++this.pos; return this.finishToken(tt.braceR)
	    case 58: ++this.pos; return this.finishToken(tt.colon)
	    case 63: ++this.pos; return this.finishToken(tt.question)
	
	    case 96: // '`'
	      if (this.options.ecmaVersion < 6) break
	      ++this.pos
	      return this.finishToken(tt.backQuote)
	
	    case 48: // '0'
	      var next = this.input.charCodeAt(this.pos + 1)
	      if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number
	      if (this.options.ecmaVersion >= 6) {
	        if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number
	        if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number
	      }
	      // Anything else beginning with a digit is an integer, octal
	      // number, or float.
	    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
	      return this.readNumber(false)
	
	      // Quotes produce strings.
	    case 34: case 39: // '"', "'"
	      return this.readString(code)
	
	      // Operators are parsed inline in tiny state machines. '=' (61) is
	      // often referred to. `finishOp` simply skips the amount of
	      // characters it is given as second argument, and returns a token
	      // of the type given by its first argument.
	
	    case 47: // '/'
	      return this.readToken_slash()
	
	    case 37: case 42: // '%*'
	      return this.readToken_mult_modulo_exp(code)
	
	    case 124: case 38: // '|&'
	      return this.readToken_pipe_amp(code)
	
	    case 94: // '^'
	      return this.readToken_caret()
	
	    case 43: case 45: // '+-'
	      return this.readToken_plus_min(code)
	
	    case 60: case 62: // '<>'
	      return this.readToken_lt_gt(code)
	
	    case 61: case 33: // '=!'
	      return this.readToken_eq_excl(code)
	
	    case 126: // '~'
	      return this.finishOp(tt.prefix, 1)
	    }
	
	    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'")
	  }
	
	  pp$7.finishOp = function(type, size) {
	    var str = this.input.slice(this.pos, this.pos + size)
	    this.pos += size
	    return this.finishToken(type, str)
	  }
	
	  // Parse a regular expression. Some context-awareness is necessary,
	  // since a '/' inside a '[]' set does not end the expression.
	
	  function tryCreateRegexp(src, flags, throwErrorAt, parser) {
	    try {
	      return new RegExp(src, flags)
	    } catch (e) {
	      if (throwErrorAt !== undefined) {
	        if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message)
	        throw e
	      }
	    }
	  }
	
	  var regexpUnicodeSupport = !!tryCreateRegexp("\uffff", "u")
	
	  pp$7.readRegexp = function() {
	    var this$1 = this;
	
	    var escaped, inClass, start = this.pos
	    for (;;) {
	      if (this$1.pos >= this$1.input.length) this$1.raise(start, "Unterminated regular expression")
	      var ch = this$1.input.charAt(this$1.pos)
	      if (lineBreak.test(ch)) this$1.raise(start, "Unterminated regular expression")
	      if (!escaped) {
	        if (ch === "[") inClass = true
	        else if (ch === "]" && inClass) inClass = false
	        else if (ch === "/" && !inClass) break
	        escaped = ch === "\\"
	      } else escaped = false
	      ++this$1.pos
	    }
	    var content = this.input.slice(start, this.pos)
	    ++this.pos
	    // Need to use `readWord1` because '\uXXXX' sequences are allowed
	    // here (don't ask).
	    var mods = this.readWord1()
	    var tmp = content, tmpFlags = ""
	    if (mods) {
	      var validFlags = /^[gim]*$/
	      if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/
	      if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag")
	      if (mods.indexOf("u") >= 0) {
	        if (regexpUnicodeSupport) {
	          tmpFlags = "u"
	        } else {
	          // Replace each astral symbol and every Unicode escape sequence that
	          // possibly represents an astral symbol or a paired surrogate with a
	          // single ASCII symbol to avoid throwing on regular expressions that
	          // are only valid in combination with the `/u` flag.
	          // Note: replacing with the ASCII symbol `x` might cause false
	          // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	          // perfectly valid pattern that is equivalent to `[a-b]`, but it would
	          // be replaced by `[x-b]` which throws an error.
	          tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
	            code = Number("0x" + code)
	            if (code > 0x10FFFF) this$1.raise(start + offset + 3, "Code point out of bounds")
	            return "x"
	          })
	          tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x")
	          tmpFlags = tmpFlags.replace("u", "")
	        }
	      }
	    }
	    // Detect invalid regular expressions.
	    var value = null
	    // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
	    // so don't do detection if we are running under Rhino
	    if (!isRhino) {
	      tryCreateRegexp(tmp, tmpFlags, start, this)
	      // Get a regular expression object for this pattern-flag pair, or `null` in
	      // case the current environment doesn't support the flags it uses.
	      value = tryCreateRegexp(content, mods)
	    }
	    return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})
	  }
	
	  // Read an integer in the given radix. Return null if zero digits
	  // were read, the integer value otherwise. When `len` is given, this
	  // will return `null` unless the integer has exactly `len` digits.
	
	  pp$7.readInt = function(radix, len) {
	    var this$1 = this;
	
	    var start = this.pos, total = 0
	    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	      var code = this$1.input.charCodeAt(this$1.pos), val
	      if (code >= 97) val = code - 97 + 10 // a
	      else if (code >= 65) val = code - 65 + 10 // A
	      else if (code >= 48 && code <= 57) val = code - 48 // 0-9
	      else val = Infinity
	      if (val >= radix) break
	      ++this$1.pos
	      total = total * radix + val
	    }
	    if (this.pos === start || len != null && this.pos - start !== len) return null
	
	    return total
	  }
	
	  pp$7.readRadixNumber = function(radix) {
	    this.pos += 2 // 0x
	    var val = this.readInt(radix)
	    if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix)
	    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number")
	    return this.finishToken(tt.num, val)
	  }
	
	  // Read an integer, octal integer, or floating-point number.
	
	  pp$7.readNumber = function(startsWithDot) {
	    var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48
	    if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number")
	    var next = this.input.charCodeAt(this.pos)
	    if (next === 46) { // '.'
	      ++this.pos
	      this.readInt(10)
	      isFloat = true
	      next = this.input.charCodeAt(this.pos)
	    }
	    if (next === 69 || next === 101) { // 'eE'
	      next = this.input.charCodeAt(++this.pos)
	      if (next === 43 || next === 45) ++this.pos // '+-'
	      if (this.readInt(10) === null) this.raise(start, "Invalid number")
	      isFloat = true
	    }
	    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number")
	
	    var str = this.input.slice(start, this.pos), val
	    if (isFloat) val = parseFloat(str)
	    else if (!octal || str.length === 1) val = parseInt(str, 10)
	    else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number")
	    else val = parseInt(str, 8)
	    return this.finishToken(tt.num, val)
	  }
	
	  // Read a string value, interpreting backslash-escapes.
	
	  pp$7.readCodePoint = function() {
	    var ch = this.input.charCodeAt(this.pos), code
	
	    if (ch === 123) {
	      if (this.options.ecmaVersion < 6) this.unexpected()
	      var codePos = ++this.pos
	      code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos)
	      ++this.pos
	      if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds")
	    } else {
	      code = this.readHexChar(4)
	    }
	    return code
	  }
	
	  function codePointToString(code) {
	    // UTF-16 Decoding
	    if (code <= 0xFFFF) return String.fromCharCode(code)
	    code -= 0x10000
	    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
	  }
	
	  pp$7.readString = function(quote) {
	    var this$1 = this;
	
	    var out = "", chunkStart = ++this.pos
	    for (;;) {
	      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, "Unterminated string constant")
	      var ch = this$1.input.charCodeAt(this$1.pos)
	      if (ch === quote) break
	      if (ch === 92) { // '\'
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        out += this$1.readEscapedChar(false)
	        chunkStart = this$1.pos
	      } else {
	        if (isNewLine(ch)) this$1.raise(this$1.start, "Unterminated string constant")
	        ++this$1.pos
	      }
	    }
	    out += this.input.slice(chunkStart, this.pos++)
	    return this.finishToken(tt.string, out)
	  }
	
	  // Reads template string tokens.
	
	  pp$7.readTmplToken = function() {
	    var this$1 = this;
	
	    var out = "", chunkStart = this.pos
	    for (;;) {
	      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, "Unterminated template")
	      var ch = this$1.input.charCodeAt(this$1.pos)
	      if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'
	        if (this$1.pos === this$1.start && this$1.type === tt.template) {
	          if (ch === 36) {
	            this$1.pos += 2
	            return this$1.finishToken(tt.dollarBraceL)
	          } else {
	            ++this$1.pos
	            return this$1.finishToken(tt.backQuote)
	          }
	        }
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        return this$1.finishToken(tt.template, out)
	      }
	      if (ch === 92) { // '\'
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        out += this$1.readEscapedChar(true)
	        chunkStart = this$1.pos
	      } else if (isNewLine(ch)) {
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        ++this$1.pos
	        switch (ch) {
	          case 13:
	            if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos
	          case 10:
	            out += "\n"
	            break
	          default:
	            out += String.fromCharCode(ch)
	            break
	        }
	        if (this$1.options.locations) {
	          ++this$1.curLine
	          this$1.lineStart = this$1.pos
	        }
	        chunkStart = this$1.pos
	      } else {
	        ++this$1.pos
	      }
	    }
	  }
	
	  // Used to read escaped characters
	
	  pp$7.readEscapedChar = function(inTemplate) {
	    var ch = this.input.charCodeAt(++this.pos)
	    ++this.pos
	    switch (ch) {
	    case 110: return "\n" // 'n' -> '\n'
	    case 114: return "\r" // 'r' -> '\r'
	    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
	    case 117: return codePointToString(this.readCodePoint()) // 'u'
	    case 116: return "\t" // 't' -> '\t'
	    case 98: return "\b" // 'b' -> '\b'
	    case 118: return "\u000b" // 'v' -> '\u000b'
	    case 102: return "\f" // 'f' -> '\f'
	    case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\r\n'
	    case 10: // ' \n'
	      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }
	      return ""
	    default:
	      if (ch >= 48 && ch <= 55) {
	        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]
	        var octal = parseInt(octalStr, 8)
	        if (octal > 255) {
	          octalStr = octalStr.slice(0, -1)
	          octal = parseInt(octalStr, 8)
	        }
	        if (octalStr !== "0" && (this.strict || inTemplate)) {
	          this.raise(this.pos - 2, "Octal literal in strict mode")
	        }
	        this.pos += octalStr.length - 1
	        return String.fromCharCode(octal)
	      }
	      return String.fromCharCode(ch)
	    }
	  }
	
	  // Used to read character escape sequences ('\x', '\u', '\U').
	
	  pp$7.readHexChar = function(len) {
	    var codePos = this.pos
	    var n = this.readInt(16, len)
	    if (n === null) this.raise(codePos, "Bad character escape sequence")
	    return n
	  }
	
	  // Read an identifier, and return it as a string. Sets `this.containsEsc`
	  // to whether the word contained a '\u' escape.
	  //
	  // Incrementally adds only escaped chars, adding other chunks as-is
	  // as a micro-optimization.
	
	  pp$7.readWord1 = function() {
	    var this$1 = this;
	
	    this.containsEsc = false
	    var word = "", first = true, chunkStart = this.pos
	    var astral = this.options.ecmaVersion >= 6
	    while (this.pos < this.input.length) {
	      var ch = this$1.fullCharCodeAtPos()
	      if (isIdentifierChar(ch, astral)) {
	        this$1.pos += ch <= 0xffff ? 1 : 2
	      } else if (ch === 92) { // "\"
	        this$1.containsEsc = true
	        word += this$1.input.slice(chunkStart, this$1.pos)
	        var escStart = this$1.pos
	        if (this$1.input.charCodeAt(++this$1.pos) != 117) // "u"
	          this$1.raise(this$1.pos, "Expecting Unicode escape sequence \\uXXXX")
	        ++this$1.pos
	        var esc = this$1.readCodePoint()
	        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
	          this$1.raise(escStart, "Invalid Unicode escape")
	        word += codePointToString(esc)
	        chunkStart = this$1.pos
	      } else {
	        break
	      }
	      first = false
	    }
	    return word + this.input.slice(chunkStart, this.pos)
	  }
	
	  // Read an identifier or keyword token. Will check for reserved
	  // words when necessary.
	
	  pp$7.readWord = function() {
	    var word = this.readWord1()
	    var type = tt.name
	    if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word))
	      type = keywordTypes[word]
	    return this.finishToken(type, word)
	  }
	
	  var version = "3.3.0"
	
	  // The main exported interface (under `self.acorn` when in the
	  // browser) is a `parse` function that takes a code string and
	  // returns an abstract syntax tree as specified by [Mozilla parser
	  // API][api].
	  //
	  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
	
	  function parse(input, options) {
	    return new Parser(options, input).parse()
	  }
	
	  // This function tries to parse a single expression at a given
	  // offset in a string. Useful for parsing mixed-language formats
	  // that embed JavaScript expressions.
	
	  function parseExpressionAt(input, pos, options) {
	    var p = new Parser(options, input, pos)
	    p.nextToken()
	    return p.parseExpression()
	  }
	
	  // Acorn is organized as a tokenizer and a recursive-descent parser.
	  // The `tokenizer` export provides an interface to the tokenizer.
	
	  function tokenizer(input, options) {
	    return new Parser(options, input)
	  }
	
	  exports.version = version;
	  exports.parse = parse;
	  exports.parseExpressionAt = parseExpressionAt;
	  exports.tokenizer = tokenizer;
	  exports.Parser = Parser;
	  exports.plugins = plugins;
	  exports.defaultOptions = defaultOptions;
	  exports.Position = Position;
	  exports.SourceLocation = SourceLocation;
	  exports.getLineInfo = getLineInfo;
	  exports.Node = Node;
	  exports.TokenType = TokenType;
	  exports.tokTypes = tt;
	  exports.TokContext = TokContext;
	  exports.tokContexts = types;
	  exports.isIdentifierChar = isIdentifierChar;
	  exports.isIdentifierStart = isIdentifierStart;
	  exports.Token = Token;
	  exports.isNewLine = isNewLine;
	  exports.lineBreak = lineBreak;
	  exports.lineBreakG = lineBreakG;
	
	  Object.defineProperty(exports, '__esModule', { value: true });
	
	}));

/***/ },
/* 241 */
/***/ function(module, exports) {

	
	/**
	 * Array#filter.
	 *
	 * @param {Array} arr
	 * @param {Function} fn
	 * @param {Object=} self
	 * @return {Array}
	 * @throw TypeError
	 */
	
	module.exports = function (arr, fn, self) {
	  if (arr.filter) return arr.filter(fn, self);
	  if (void 0 === arr || null === arr) throw new TypeError;
	  if ('function' != typeof fn) throw new TypeError;
	  var ret = [];
	  for (var i = 0; i < arr.length; i++) {
	    if (!hasOwn.call(arr, i)) continue;
	    var val = arr[i];
	    if (fn.call(self, val, i, arr)) ret.push(val);
	  }
	  return ret;
	};
	
	var hasOwn = Object.prototype.hasOwnProperty;


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:
	
	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }
	
	  var x = a.length;
	  var y = b.length;
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }
	
	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}
	
	// based on node assert, original notice:
	
	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var util = __webpack_require__(30);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.
	
	var assert = module.exports = ok;
	
	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })
	
	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;
	
	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }
	
	      this.stack = out;
	    }
	  }
	};
	
	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);
	
	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}
	
	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.
	
	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.
	
	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}
	
	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;
	
	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.
	
	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;
	
	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);
	
	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};
	
	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);
	
	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};
	
	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);
	
	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};
	
	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};
	
	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;
	
	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;
	
	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;
	
	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;
	
	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};
	
	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }
	
	    memos.actual.push(actual);
	    memos.expected.push(expected);
	
	    return objEquiv(actual, expected, strict, memos);
	  }
	}
	
	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	
	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}
	
	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);
	
	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};
	
	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}
	
	
	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);
	
	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};
	
	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
	
	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};
	
	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }
	
	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }
	
	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }
	
	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }
	
	  return expected.call({}, actual) === true;
	}
	
	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}
	
	function _throws(shouldThrow, block, expected, message) {
	  var actual;
	
	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }
	
	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }
	
	  actual = _tryBlock(block);
	
	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');
	
	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }
	
	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;
	
	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }
	
	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}
	
	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);
	
	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};
	
	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};
	
	assert.ifError = function(err) { if (err) throw err; };
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _desc, _value, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9;
	
	var _jquery = __webpack_require__(31);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _snap = __webpack_require__(74);
	
	var _snap2 = _interopRequireDefault(_snap);
	
	var _pick = __webpack_require__(17);
	
	var _pick2 = _interopRequireDefault(_pick);
	
	var _defaults = __webpack_require__(40);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	var _isNumber2 = __webpack_require__(63);
	
	var _isNumber3 = _interopRequireDefault(_isNumber2);
	
	var _size = __webpack_require__(92);
	
	var _size2 = _interopRequireDefault(_size);
	
	var _at = __webpack_require__(91);
	
	var _at2 = _interopRequireDefault(_at);
	
	var _assign = __webpack_require__(78);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _sortBy = __webpack_require__(347);
	
	var _sortBy2 = _interopRequireDefault(_sortBy);
	
	var _isNumber4 = __webpack_require__(44);
	
	var _isNumber5 = _interopRequireDefault(_isNumber4);
	
	var _isBoolean2 = __webpack_require__(43);
	
	var _isBoolean3 = _interopRequireDefault(_isBoolean2);
	
	var _add2 = __webpack_require__(155);
	
	var _add3 = _interopRequireDefault(_add2);
	
	var _defer2 = __webpack_require__(98);
	
	var _defer3 = _interopRequireDefault(_defer2);
	
	var _zip2 = __webpack_require__(210);
	
	var _zip3 = _interopRequireDefault(_zip2);
	
	var _uniqueId = __webpack_require__(101);
	
	var _uniqueId2 = _interopRequireDefault(_uniqueId);
	
	var _combineLatest = __webpack_require__(33);
	
	var _of = __webpack_require__(157);
	
	var _merge = __webpack_require__(156);
	
	var _map = __webpack_require__(15);
	
	var _filter = __webpack_require__(16);
	
	var _pairwise = __webpack_require__(145);
	
	var _withLatestFrom = __webpack_require__(72);
	
	var _take = __webpack_require__(48);
	
	var _takeUntil = __webpack_require__(49);
	
	var _mergeMap = __webpack_require__(494);
	
	var _switchMap = __webpack_require__(71);
	
	var _toPromise = __webpack_require__(110);
	
	var _concat = __webpack_require__(158);
	
	var _chroma = __webpack_require__(81);
	
	var _chroma2 = _interopRequireDefault(_chroma);
	
	var _SvgEntity2 = __webpack_require__(80);
	
	var _SvgEntity3 = _interopRequireDefault(_SvgEntity2);
	
	var _ValueTracker = __webpack_require__(6);
	
	var _ObservableSet = __webpack_require__(55);
	
	var _ObservableSet2 = _interopRequireDefault(_ObservableSet);
	
	var _BorderLine = __webpack_require__(159);
	
	var _BorderLine2 = _interopRequireDefault(_BorderLine);
	
	var _model = __webpack_require__(160);
	
	var _model2 = _interopRequireDefault(_model);
	
	var _rxjs = __webpack_require__(82);
	
	var _ValueTracker2 = __webpack_require__(6);
	
	var _NodeGlyph = __webpack_require__(221);
	
	var _NodeGlyph2 = _interopRequireDefault(_NodeGlyph);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _initDefineProp(target, property, descriptor, context) {
		if (!descriptor) return;
		Object.defineProperty(target, property, {
			enumerable: descriptor.enumerable,
			configurable: descriptor.configurable,
			writable: descriptor.writable,
			value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
		});
	}
	
	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
		var desc = {};
		Object['ke' + 'ys'](descriptor).forEach(function (key) {
			desc[key] = descriptor[key];
		});
		desc.enumerable = !!desc.enumerable;
		desc.configurable = !!desc.configurable;
	
		if ('value' in desc || desc.initializer) {
			desc.writable = true;
		}
	
		desc = decorators.slice().reverse().reduce(function (desc, decorator) {
			return decorator(target, property, desc) || desc;
		}, desc);
	
		if (context && desc.initializer !== void 0) {
			desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
			desc.initializer = undefined;
		}
	
		if (desc.initializer === void 0) {
			Object['define' + 'Property'](target, property, desc);
			desc = null;
		}
	
		return desc;
	}
	
	function _initializerWarningHelper(descriptor, context) {
		throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
	}
	
	var $$backgroundColor = Symbol('$$backgroundColor');
	var $$toBeRecycled = Symbol('$$toBeRecycled');
	var $$recycle = Symbol('$$recycle');
	var $$relativeLayerPosition = Symbol('$$relativeLayerPosition');
	
	var LyphRectangle = (_dec = (0, _ValueTracker2.flag)(true), _dec2 = (0, _ValueTracker.property)({ isValid: _isNumber5.default }), _dec3 = (0, _ValueTracker.property)({ isValid: _isNumber5.default }), _dec4 = (0, _ValueTracker.property)({
		isValid: function isValid(w) {
			return _isNumber3.default.call(w) && w > this.minWidth;
		}
	}), _dec5 = (0, _ValueTracker.property)({
		isValid: function isValid(h) {
			return _isNumber3.default.call(h) && h > this.minHeight;
		}
	}), _dec6 = (0, _ValueTracker.property)(), _dec7 = (0, _ValueTracker.property)(), _dec8 = (0, _ValueTracker.property)(), _dec9 = (0, _ValueTracker.property)(), (_class = function (_SvgEntity) {
		_inherits(LyphRectangle, _SvgEntity);
	
		_createClass(LyphRectangle, [{
			key: 'axisThickness',
			get: function get() {
				return this.model.axis ? 14 : 0;
			}
		}, {
			key: 'minWidth',
			get: function get() {
				return 2 * (this.axisThickness + 1);
			}
		}, {
			key: 'minHeight',
			get: function get() {
				var _context;
	
				return this.axisThickness + (this.model ? (_context = this.model.layers, _size2.default).call(_context) * 2 : 5);
			}
		}]);
	
		function LyphRectangle(options) {
			_classCallCheck(this, LyphRectangle);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LyphRectangle).call(this, options));
	
			_initDefineProp(_this, 'free', _descriptor, _this);
	
			_initDefineProp(_this, 'x', _descriptor2, _this);
	
			_initDefineProp(_this, 'y', _descriptor3, _this);
	
			_initDefineProp(_this, 'width', _descriptor4, _this);
	
			_initDefineProp(_this, 'height', _descriptor5, _this);
	
			_this.layers = new _ObservableSet2.default();
			_this.pureParts = new _ObservableSet2.default();
			_this.segments = new _ObservableSet2.default();
			_this.nodes = new _ObservableSet2.default();
			_this.radialBorders = new _ObservableSet2.default();
			_this.longitudinalBorders = new _ObservableSet2.default();
	
			_initDefineProp(_this, 'leftBorder', _descriptor6, _this);
	
			_initDefineProp(_this, 'rightBorder', _descriptor7, _this);
	
			_initDefineProp(_this, 'topBorder', _descriptor8, _this);
	
			_initDefineProp(_this, 'bottomBorder', _descriptor9, _this);
	
			_this.setFromObject(options, ['x', 'y', 'width', 'height'], { showAxis: !!_this.model.axis });
	
			_this[$$toBeRecycled] = new WeakMap();
	
			/* create the border artefacts */
			_ref = ['radialBorders', 'longitudinalBorders'];
	
			if (!(_ref && (typeof _ref[Symbol.iterator] === 'function' || Array.isArray(_ref)))) {
				throw new TypeError('Expected _ref to be iterable, got ' + _inspect(_ref));
			}
	
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;
	
			try {
				for (var _iterator = _ref[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _context2;
	
					var _ref;
	
					var setKey = _step.value;
	
					(_context2 = (_context2 = _this.model[setKey].e('add'), _map.map).call(_context2, function (border) {
						return _this[$$recycle](border) || new _BorderLine2.default({
							parent: _this,
							model: border,
							movable: _this.free
						});
					}), _rxjs.subscribe_).call(_context2, _this[setKey].e('add'), function (n) {
						return n();
					});
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
	
			_ref2 = ['layers', 'segments', 'pureParts', 'radialBorders', 'longitudinalBorders', 'nodes'];
	
			if (!(_ref2 && (typeof _ref2[Symbol.iterator] === 'function' || Array.isArray(_ref2)))) {
				throw new TypeError('Expected _ref2 to be iterable, got ' + _inspect(_ref2));
			}
	
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;
	
			try {
				for (var _iterator2 = _ref2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var _context3;
	
					var _ref2;
	
					var _setKey = _step2.value;
	
					(_context3 = _this[_setKey].e('add'), _rxjs.subscribe_).call(_context3, _this.children.e('add'), function (n) {
						return n();
					});
					(_context3 = _this.children.e('delete'), _rxjs.subscribe_).call(_context3, _this[_setKey].e('delete'), function (n) {
						return n();
					});
				}
	
				/* create a random color (one per layer, stored in the model) */
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
	
			if (!_this.model[$$backgroundColor]) {
				_this.model[$$backgroundColor] = _chroma2.default.randomHsvGolden(0.8, 0.8);
			}
	
			return _this;
		}
	
		_createClass(LyphRectangle, [{
			key: 'createElement',
			value: function createElement() {
				var _this2 = this;
	
				var at = this.axisThickness;
				var group = (0, _snap.gElement)();
	
				var lyphRectangle = function () {
	
					var shadow = group.rect().attr({
						filter: (0, _snap2.default)('#svg').filter(_snap2.default.filter.shadow(8, 8, 4, '#111111', 0.4))
					});
					_this2.p(['free', 'dragging']).subscribe(function (_ref3) {
						var _ref4 = _slicedToArray(_ref3, 2);
	
						var f = _ref4[0];
						var d = _ref4[1];
	
						shadow.attr({ visibility: f && d ? 'visible' : 'hidden' });
					});
	
					var result = group.rect().attr({
						stroke: 'none',
						fill: _this2.model[$$backgroundColor],
						shapeRendering: 'crispEdges'
					});
	
					_this2.p('x').subscribe(function (x) {
						result.attr({ x: x + 1 });
						shadow.attr({ x: x + 1 });
					});
					_this2.p('y').subscribe(function (y) {
						result.attr({ y: y + 1 });
						shadow.attr({ y: y + 1 });
					});
					_this2.p('width').subscribe(function (width) {
						result.attr({ width: width });
						shadow.attr({ width: width });
					});
					_this2.p('height').subscribe(function (height) {
						result.attr({ height: height });
						shadow.attr({ height: height });
					});
				}();
	
				var highlightedBorder = function () {
					var result = (0, _snap.gElement)().g().attr({
						pointerEvents: 'none'
					});
					result.rect().attr({
						stroke: 'black',
						strokeWidth: '3px'
					});
					result.rect().attr({
						stroke: 'white',
						strokeWidth: '1px'
					});
					var rects = result.selectAll('rect').attr({
						fill: 'none',
						shapeRendering: 'crispEdges',
						pointerEvents: 'none'
					});
	
					_this2.p(['highlighted', 'dragging'], function (highlighted, dragging) {
						return {
							visibility: highlighted && !dragging ? 'visible' : 'hidden'
						};
					}).subscribe(result.attr.bind(result));
	
					_this2.p('x').subscribe(function (x) {
						rects.attr({ x: x - 3 });
					});
					_this2.p('y').subscribe(function (y) {
						rects.attr({ y: y - 3 });
					});
					_this2.p('width').subscribe(function (width) {
						rects.attr({ width: width + 6 });
					});
					_this2.p('height').subscribe(function (height) {
						rects.attr({ height: height + 6 });
					});
	
					(0, _jquery2.default)('#foreground').append(result.node);
	
					return result.node;
				}();
	
				var axis = function () {
	
					if (!_this2.showAxis) {
						return null;
					}
	
					var result = group.g().addClass('axis').attr({
						pointerEvents: 'none'
					});
	
					var background = result.rect().attr({
						stroke: 'black',
						fill: 'black',
						shapeRendering: 'crispEdges',
						height: at
					});
					_this2.p('x').subscribe(function (x) {
						return background.attr({ x: x });
					});
					_this2.p(['y', 'height']).subscribe(function (_ref5) {
						var _ref6 = _slicedToArray(_ref5, 2);
	
						var y = _ref6[0];
						var height = _ref6[1];
						return background.attr({ y: y + height - at });
					});
					_this2.p('width').subscribe(function (width) {
						return background.attr({ width: width });
					});
	
					var clipPath = result.rect().addClass('axis-clip-path').attr({
						height: at
					});
					var minusText = result.text().attr({
						textAnchor: 'middle'
					});
					minusText.node.innerHTML = '&minus;';
					var labelText = result.text().attr({
						textAnchor: 'middle',
						clip: clipPath
					});
					var plusText = result.text().attr({
						text: '+',
						textAnchor: 'middle'
					});
					var allText = group.selectAll('text').attr({
						fill: 'white',
						fontSize: at + 'px',
						textRendering: 'geometricPrecision',
						pointerEvents: 'none',
						dominantBaseline: 'central'
					});
	
					_this2.p(['x', 'width']).subscribe(function (_ref7) {
						var _ref8 = _slicedToArray(_ref7, 2);
	
						var x = _ref8[0];
						var width = _ref8[1];
	
						minusText.attr({ x: x + at / 2 });
						labelText.attr({ x: x + width / 2 });
						plusText.attr({ x: x + width - at / 2 });
						clipPath.attr({
							x: x + at,
							width: width - 2 * at
						});
					});
	
					_this2.p(['y', 'height']).subscribe(function (_ref9) {
						var _ref10 = _slicedToArray(_ref9, 2);
	
						var y = _ref10[0];
						var height = _ref10[1];
	
						allText.attr({ y: y + height - at / 2 });
						clipPath.attr({ y: y + height - at });
					});
	
					_this2.model.p('name').subscribe(function (n) {
						labelText.attr({ text: n });
					});
	
					return result;
				}();
	
				/* convenience function to use in partonomy setup */
				var takeUntilImNoLongerParent = function (me) {
					return function takeUntilImNoLongerParent(a) {
						var _context4;
	
						return _takeUntil.takeUntil.call(this, (_context4 = a.p('parent'), _filter.filter).call(_context4, function (p) {
							return p !== me;
						}));
					};
				}(this);
	
				group.g().addClass('layers');
	
				group.g().addClass('parts');
				group.g().addClass('nodes');
	
				// TODO: segments
	
				var borderGroup = function () {
					var result = group.g().addClass('borders');
	
					_this2.leftBorder = null;
					_this2.rightBorder = null;
	
					_this2.radialBorders.e('add').subscribe(function (borderLine) {
						var _context5;
	
						result.append(borderLine.element.svg);
						(_context5 = _this2.p('y'), _rxjs.subscribe_).call(_context5, borderLine.p('y1'), function (n) {
							return n();
						});
						(_context5 = _this2.p(['y', 'height'], _add3.default), _rxjs.subscribe_).call(_context5, borderLine.p('y2'), function (n) {
							return n();
						});
						if (!_this2.leftBorder) {
							var _context6;
	
							_this2.leftBorder = borderLine;
							(_context6 = _this2.p('x'), _rxjs.subscribe_).call(_context6, borderLine.p('x1'), function (n) {
								return n();
							});
							(_context6 = _this2.p('x'), _rxjs.subscribe_).call(_context6, borderLine.p('x2'), function (n) {
								return n();
							});
						} else if (!_this2.rightBorder) {
							var _context7;
	
							_this2.rightBorder = borderLine;
							(_context7 = _this2.p(['x', 'width'], _add3.default), _rxjs.subscribe_).call(_context7, borderLine.p('x1'), function (n) {
								return n();
							});
							(_context7 = _this2.p(['x', 'width'], _add3.default), _rxjs.subscribe_).call(_context7, borderLine.p('x2'), function (n) {
								return n();
							});
						}
					});
					_this2.radialBorders.e('delete').subscribe(function (borderLine) {
						if (borderLine === _this2.leftBorder) {
							_this2.leftBorder = null;
						} else if (borderLine === _this2.rightBorder) {
							_this2.rightBorder = null;
						}
						borderLine.element.remove();
					}); // TODO: proper deleting
	
	
					_this2.topBorder = null;
					_this2.bottomBorder = null; // also axis
	
					_this2.longitudinalBorders.e('add').subscribe(function (borderLine) {
						var _context8;
	
						result.append(borderLine.element.svg);
						(_context8 = _this2.p('x'), _rxjs.subscribe_).call(_context8, borderLine.p('x1'), function (n) {
							return n();
						});
						(_context8 = _this2.p(['x', 'width'], _add3.default), _rxjs.subscribe_).call(_context8, borderLine.p('x2'), function (n) {
							return n();
						});
						if (!_this2.topBorder) {
							var _context9;
	
							_this2.topBorder = borderLine;
							(_context9 = _this2.p('y'), _rxjs.subscribe_).call(_context9, borderLine.p('y1'), function (n) {
								return n();
							});
							(_context9 = _this2.p('y'), _rxjs.subscribe_).call(_context9, borderLine.p('y2'), function (n) {
								return n();
							});
						} else if (!_this2.bottomBorder) {
							var _context10;
	
							_this2.bottomBorder = borderLine;
							(_context10 = _this2.p(['y', 'height'], _add3.default), _rxjs.subscribe_).call(_context10, borderLine.p('y1'), function (n) {
								return n();
							});
							(_context10 = _this2.p(['y', 'height'], _add3.default), _rxjs.subscribe_).call(_context10, borderLine.p('y2'), function (n) {
								return n();
							});
						}
					});
					_this2.longitudinalBorders.e('delete').subscribe(function (borderLine) {
						if (borderLine === _this2.topBorder) {
							_this2.topBorder = null;
						} else if (borderLine === _this2.bottomBorder) {
							_this2.bottomBorder = null;
						}
						borderLine.element.remove();
					}); // TODO: proper deleting
				}();
	
				/* return representation(s) of element */
				return {
					element: group.node
				};
			}
		}, {
			key: $$recycle,
			value: function value(model) {
				if (!this[$$toBeRecycled].has(model)) {
					return false;
				}
				var result = this[$$toBeRecycled].get(model);
				this[$$toBeRecycled].delete(model);
				return result;
			}
		}, {
			key: 'afterCreateElement',
			value: function () {
				var _ref11 = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
					var _context11,
					    _this3 = this;
	
					return regeneratorRuntime.wrap(function _callee$(_context16) {
						while (1) {
							switch (_context16.prev = _context16.next) {
								case 0:
									_get(Object.getPrototypeOf(LyphRectangle.prototype), 'afterCreateElement', this).call(this);
	
									/* wait until we have some coordinates */
									_context16.next = 3;
									return (_context11 = (_context11 = this.p(['x', 'y', 'width', 'height']), _take.take).call(_context11, 1), _toPromise.toPromise).call(_context11);
	
								case 3:
	
									/* new layer in the model --> new layer artifact */
									this[$$relativeLayerPosition] = new WeakMap();
									(_context11 = (_context11 = (_context11 = this.model['-->HasLayer'].e('add'), _map.map).call(_context11, function (rel) {
										return { layer: rel[2], relativePosition: rel.p('relativePosition') };
									}), _map.map).call(_context11, function (_ref12) {
										var layer = _ref12.layer;
										var relativePosition = _ref12.relativePosition;
	
										var layerBox = _this3[$$recycle](layer) || new LyphRectangle({
											parent: _this3,
											model: layer,
											showAxis: false,
											free: false
										});
										_this3[$$relativeLayerPosition].set(layerBox, relativePosition);
										return layerBox;
									}), _rxjs.subscribe_).call(_context11, this.layers.e('add'), function (n) {
										return n();
									});
	
									/* new layer artifact --> house svg element */
									this.layers.e('add').subscribe(function (layer) {
										var _context12;
	
										_this3.inside.jq.children('.layers').append(layer.element);
										var removed = (_context12 = layer.p('parent'), _filter.filter).call(_context12, function (parent) {
											return parent !== _this3;
										});
										removed.subscribe(function () {
											if (layer.element.jq.parent()[0] === _this3.element) {
												layer.element.jq.remove();
											}
										});
									});
	
									/* new layer artifact --> move it together with its parent */
									(_context11 = (_context11 = (_context11 = this.layers.p('value'), _map.map).call(_context11, function (layers) {
										return [].concat(_toConsumableArray(layers));
									}), _map.map).call(_context11, function (layers) {
										var _context13;
	
										return {
											dimensions: _this3.pObj(['x', 'y', 'width', 'height']),
											layers: layers,
											relativePositions: layers.map((_context13 = _this3[$$relativeLayerPosition]).get.bind(_context13))
										};
									}), _switchMap.switchMap).call(_context11, function (_ref13) {
										var dimensions = _ref13.dimensions;
										var relativePositions = _ref13.relativePositions;
										return (0, _combineLatest.combineLatest)(dimensions, relativePositions);
									}, function (_ref14, _ref15) {
										var layers = _ref14.layers;
	
										var _ref16 = _slicedToArray(_ref15, 2);
	
										var _ref16$ = _ref16[0];
										var width = _ref16$.width;
										var height = _ref16$.height;
										var x = _ref16$.x;
										var y = _ref16$.y;
										var relativePositions = _ref16[1];
										return {
											layers: _sortBy2.default.call(layers, function (l, i) {
												return relativePositions[i];
											}),
											wh_layer: {
												width: width,
												height: (height - _this3.axisThickness) / layers.length
											},
											xy_parent: { x: x, y: y }
										};
									}).subscribe(function (_ref17) {
										var layers = _ref17.layers;
										var _ref17$wh_layer = _ref17.wh_layer;
										var width = _ref17$wh_layer.width;
										var height = _ref17$wh_layer.height;
										var _ref17$xy_parent = _ref17.xy_parent;
										var x = _ref17$xy_parent.x;
										var y = _ref17$xy_parent.y;
	
										// console.log(Object.entries(layers));
										for (var i = 0; i < layers.length; ++i) {
											var layer = layers[i];
											_assign2.default.call(layer, {
												width: width,
												height: height,
												x: x,
												y: y + i * height
											});
										}
									});
	
									/* new part in the model --> new part artifact */
									(_context11 = (_context11 = (_context11 = (_context11 = (_context11 = this.model['-->HasPart'].e('add'), _filter.filter).call(_context11, function (c) {
										return c.class === 'HasPart';
									}), _map.map).call(_context11, function (c) {
										return c[2];
									}), _withLatestFrom.withLatestFrom).call(_context11, this.p('x'), this.p('y'), this.p('width'), this.p('height')), _map.map).call(_context11, function (_ref18) {
										var _ref19 = _slicedToArray(_ref18, 5);
	
										var part = _ref19[0];
										var x = _ref19[1];
										var y = _ref19[2];
										var width = _ref19[3];
										var height = _ref19[4];
										return _this3[$$recycle](part) || new LyphRectangle({
											model: part,
											x: x + 5,
											y: y + 5,
											width: width / 2,
											height: height / 2
										});
									}).do(function (artefact) {
										artefact.free = true;
									}), _rxjs.subscribe_).call(_context11, this.pureParts.e('add'), function (n) {
										return n();
									});
	
									/* new part artifact --> house svg element + move it together with its parent */
									this.pureParts.e('add').subscribe(function (part) {
										var _context14;
	
										_this3.inside.jq.children('.parts').append(part.element);
										var removed = (_context14 = part.p('parent'), _filter.filter).call(_context14, function (parent) {
											return parent !== _this3;
										});
	
										(_context14 = (_context14 = _this3.pObj(['x', 'y']), _takeUntil.takeUntil).call(_context14, removed), _rxjs.shiftedMovementFor).call(_context14, part.pObj(['x', 'y'])).subscribe(_assign2.default.bind(part));
	
										removed.subscribe(function () {
											if (part.element.jq.parent()[0] === _this3.element) {
												part.element.jq.remove();
											}
										});
									});
	
									/* new node in the model --> new node artifact */
									(_context11 = (_context11 = (_context11 = (_context11 = this.model['-->ContainsNode'].e('add'), _map.map).call(_context11, function (c) {
										return c[2];
									}), _withLatestFrom.withLatestFrom).call(_context11, this.p('x'), this.p('y')), _map.map).call(_context11, function (_ref20) {
										var _ref21 = _slicedToArray(_ref20, 3);
	
										var node = _ref21[0];
										var x = _ref21[1];
										var y = _ref21[2];
										return _this3[$$recycle](node) || new _NodeGlyph2.default({
											model: node,
											x: x + 5,
											y: y + 5
										});
									}).do(function (artefact) {
										artefact.free = true;
									}), _rxjs.subscribe_).call(_context11, this.nodes.e('add'), function (n) {
										return n();
									});
	
									/* new node artifact --> house svg element + move it together with its parent */
									this.nodes.e('add').subscribe(function (node) {
										var _context15;
	
										_this3.inside.jq.children('.nodes').append(node.element);
										var removed = (_context15 = node.p('parent'), _filter.filter).call(_context15, function (parent) {
											return parent !== _this3;
										});
	
										(_context15 = (_context15 = _this3.pObj(['x', 'y']), _takeUntil.takeUntil).call(_context15, removed), _rxjs.shiftedMovementFor).call(_context15, node.pObj(['x', 'y'])).subscribe(_assign2.default.bind(node));
	
										removed.subscribe(function () {
											if (node.element.jq.parent()[0] === _this3.element) {
												node.element.jq.remove();
											}
										});
									});
	
								case 11:
								case 'end':
									return _context16.stop();
							}
						}
					}, _callee, this);
				}));
	
				function afterCreateElement() {
					return _ref11.apply(this, arguments);
				}
	
				return afterCreateElement;
			}()
		}, {
			key: 'drop',
			value: function drop(droppedEntity) {
				if (_model2.default.classes.Lyph.hasInstance(droppedEntity.model)) {
					// if a lyph artefact was dropped
					this[$$toBeRecycled].set(droppedEntity.model, droppedEntity);
					droppedEntity.model.parent = null;
					// this.model.children.delete(droppedEntity.model);
					this.model.parts.add(droppedEntity.model);
				}
			}
		}, {
			key: 'draggable',
			get: function get() {
				return true;
			}
		}]);
	
		return LyphRectangle;
	}(_SvgEntity3.default), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'free', [_dec], {
		enumerable: true,
		initializer: null
	}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'x', [_dec2], {
		enumerable: true,
		initializer: null
	}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, 'y', [_dec3], {
		enumerable: true,
		initializer: null
	}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, 'width', [_dec4], {
		enumerable: true,
		initializer: null
	}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, 'height', [_dec5], {
		enumerable: true,
		initializer: null
	}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, 'leftBorder', [_dec6], {
		enumerable: true,
		initializer: null
	}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, 'rightBorder', [_dec7], {
		enumerable: true,
		initializer: null
	}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, 'topBorder', [_dec8], {
		enumerable: true,
		initializer: null
	}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, 'bottomBorder', [_dec9], {
		enumerable: true,
		initializer: null
	})), _class));
	
	// export default class LyphRectangle extends SvgEntity {
	//
	// 	@property({                                          }) x;
	// 	@property({                                          }) y;
	// 	@property({ isValid(w) { return w > this.minWidth  } }) width;
	// 	@property({ isValid(h) { return h > this.minHeight } }) height;
	//
	// 	get axisThickness() { return this.model.layers.length > 0 ? 10 : 0                                }
	// 	get minWidth     () { return 2 * (this.axisThickness + 1)                                         }
	// 	get minHeight    () { return this.axisThickness + (this.model ? this.model.layers.length * 2 : 5) }
	//
	// 	layers = [];
	//
	// 	constructor(options) {
	// 		super(options);
	//
	// 		this.setFromObject(options, {
	// 			showAxis: true
	// 		});
	//
	// 		/* create the layer template boxes */ // TODO: sort by border-shared nodes
	// 		this.layers = [...this.model.layers].map(layer => new LyphRectangle({
	// 			parent:     this,
	// 			model:      layer,
	// 			showAxis:   false
	// 		}));
	//
	// 		/* create a random color (one per layer, stored in the model) */
	// 		if (!this.model[$$backgroundColor]) {
	// 			this.model[$$backgroundColor] = chroma.randomHsvGolden(0.8, 0.8);
	// 		}
	// 	}
	//
	// 	createElement() {
	// 		/* main HTML */
	// 		let clipPathId = uniqueId('clip-path');
	// 		let result = $.svg(`
	// 			<g>
	// 				<rect class="lyphRectangle"></rect>
	// 				<svg class="axis">
	// 					<defs>
	// 						<clipPath id="${clipPathId}">
	// 							<rect x="0" y="0" height="100%" width="100%"></rect>
	// 						</clipPath>
	// 					</defs>
	// 					<rect class="axis-background" x="0" y="0" height="100%" width="100%"></rect>
	// 					<svg class="text-area">
	// 						<text class="minus" stroke="white"> - </text>
	// 						<text class="label" stroke="none" clip-path="url(#${clipPathId})"> ${this.model.name} </text>
	// 						<text class="plus " stroke="white"> + </text>
	// 					</svg>
	// 				</svg>
	// 				<g class="child-container"></g>
	// 			</g>
	// 		`);
	//
	// 		/* extract and style important elements */
	// 		const lyphRectangle = result.find('.lyphRectangle').css({
	// 			stroke:         'black',
	// 			fill:           this.model[$$backgroundColor],
	// 			shapeRendering: 'crispEdges',
	// 			pointerEvents:  'all'
	// 		});
	// 		const axis = result.find('svg.axis').css({
	// 			stroke:         'black',
	// 			fill:           'black',
	// 			shapeRendering: 'crispEdges',
	// 			pointerEvents:  'none',
	// 			overflow:       'visible'
	// 		});
	// 		const textArea = axis.children('svg.text-area').css({
	// 			stroke:         'black',
	// 			fill:           'black',
	// 			shapeRendering: 'crispEdges',
	// 			pointerEvents:  'none',
	// 			overflow:       'hidden'
	// 		});
	// 		axis.children('.axis-background').css({
	// 			stroke:         'black',
	// 			fill:           'black',
	// 			shapeRendering: 'crispEdges'
	// 		});
	// 		const axisText = textArea.children('text').css({
	// 			fill:             'white',
	// 			fontSize:         `14px`,
	// 			textRendering:    'geometricPrecision',
	// 			pointerEvents:    'none',
	// 			dominantBaseline: 'central'
	// 		});
	//
	// 		/* add layer template boxes */
	// 		for (let lTBox of this.layers) {
	// 			result.children('.child-container').append(lTBox.element);
	// 		}
	//
	// 		/* react to dimension changes */
	// 		const at = this.axisThickness;
	// 		let dimensioning = this.p(['x', 'y', 'width', 'height'], [], (x, y, width, height) => ({ x, y, width, height, tX: 0, tY: 4, tWidth: at,      tHeight: height, minusX: '50%',  minusY: '0%',   labelX: '50%', labelY: '50%', plusX: '50%',  plusY: '100%', minusAnchor: 'start', labelAnchor: 'middle', plusAnchor: 'end',   writingMode: 'vertical-rl'   }));
	// 		dimensioning.subscribe((d) => {
	//
	// 			lyphRectangle.attr('x',  d.x );
	// 			lyphRectangle.attr('y', d.y);
	// 			lyphRectangle.attr('width',  d.width );
	// 			lyphRectangle.attr('height', d.height);
	//
	// 			axis.attr('x',      d.x     );
	// 			axis.attr('y',      d.y     );
	// 			axis.attr('width',  at );
	// 			axis.attr('height', d.height);
	//
	// 			textArea.attr('x',      d.tX     );
	// 			textArea.attr('y',      d.tY     );
	// 			textArea.attr('width',  d.tWidth );
	// 			textArea.attr('height', d.tHeight);
	//
	// 			axisText.attr('writing-mode', d.writingMode);
	//
	// 			axisText.filter('.minus').attr('x', d.minusX);
	// 			axisText.filter('.minus').attr('y', d.minusY);
	// 			axisText.filter('.minus').attr('text-anchor', d.minusAnchor);
	//
	// 			axisText.filter('.label').attr('x', d.labelX);
	// 			axisText.filter('.label').attr('y', d.labelY);
	// 			axisText.filter('.label').attr('text-anchor', d.labelAnchor);
	//
	// 			axisText.filter('.plus').attr('x', d.plusX);
	// 			axisText.filter('.plus').attr('y', d.plusY);
	// 			axisText.filter('.plus').attr('text-anchor', d.plusAnchor);
	//
	// 			let layerCount = this.layers.length;
	// 			let layerWidth = (d.width - at) / layerCount;
	// 			for (let i = 0; i < layerCount; ++i) {
	// 				let box = this.layers[i];
	// 				box.x = d.x + at + i * layerWidth;
	// 				box.y = d.y;
	// 				box.width = layerWidth;
	// 				box.height = d.height;
	// 			}
	// 		});
	//
	// 		/* return result */
	// 		return result;
	// 	}
	//
	// 	// plugContainerPositioning() {
	// 	// 	let containerDims = this.xywhr.map(({x, y, width, height, rotation}) => sw(rotation)({
	// 	// 		0: {
	// 	// 			cx:      x,
	// 	// 			cy:      y,
	// 	// 			cwidth:  width,
	// 	// 			cheight: height - this.axisThickness
	// 	// 		},
	// 	// 		90: {
	// 	// 			cx:      x + this.axisThickness,
	// 	// 			cy:      y,
	// 	// 			cwidth:  width - this.axisThickness,
	// 	// 			cheight: height
	// 	// 		},
	// 	// 		180: {
	// 	// 			cx:      x,
	// 	// 			cy:      y + this.axisThickness,
	// 	// 			cwidth:  width,
	// 	// 			cheight: height - this.axisThickness
	// 	// 		},
	// 	// 		270: {
	// 	// 			cx:      x,
	// 	// 			cy:      y,
	// 	// 			cwidth:  width - this.axisThickness,
	// 	// 			cheight: height
	// 	// 		}
	// 	// 	}));
	// 	// 	this.p('cx')     .plug(containerDims.map(get('cx'))     );
	// 	// 	this.p('cy')     .plug(containerDims.map(get('cy'))     );
	// 	// 	this.p('cwidth') .plug(containerDims.map(get('cwidth')) );
	// 	// 	this.p('cheight').plug(containerDims.map(get('cheight')));
	// 	// }
	//
	// 	// draggable() {
	// 	// 	let raw;//, rootRect;
	// 	// 	return {
	// 	// 		autoScroll: true,
	// 	// 		onstart: (event) => { // TODO: make streams for these events somewhere up the class hierarchy
	// 	// 			event.stopPropagation();
	// 	// 			this.moveToFront();
	// 	//
	// 	// 			/* initialize interaction-local variables */
	// 	// 			raw = pick(this, 'x', 'y');
	// 	// 			// rootRect = this.root.boundingBox();
	// 	// 		},
	// 	// 		onmove: ({dx, dy}) => {
	// 	// 			/* update raw coordinates */
	// 	// 			raw.x += dx;
	// 	// 			raw.y += dy;
	// 	//
	// 	// 			/* initialize visible coordinates */
	// 	// 			let visible = clone(raw);
	// 	//
	// 	// 			// TODO: snapping
	// 	//
	// 	// 			/* restriction correction */
	// 	// 			visible.x = clamp( this.root.cx, this.root.cx + this.root.cwidth  - this.width  )( visible.x );
	// 	// 			visible.y = clamp( this.root.cy, this.root.cy + this.root.cheight - this.height )( visible.y );
	// 	//
	// 	// 			/* set the actual visible coordinates */
	// 	// 			Object.assign(this, visible);
	// 	// 		}
	// 	// 	};
	// 	// }
	//
	// 	// resizable() {
	// 	// 	let raw;
	// 	// 	return {
	// 	// 		handle: '.lyphRectangle',
	// 	// 		edges: { left: true, right: true, bottom: true, top: true },
	// 	// 		onstart: (event) => {
	// 	// 			event.stopPropagation();
	// 	// 			this.moveToFront();
	// 	//
	// 	// 			/* initialize interaction-local variables */
	// 	// 			raw  = pick(this, 'x', 'y', 'width', 'height');
	// 	// 		},
	// 	// 		onmove: ({rect, edges, ctrlKey}) => {
	// 	//
	// 	// 			/* update raw coordinates */
	// 	// 			raw.width  = Math.max(rect.width,  this.minWidth );
	// 	// 			raw.height = Math.max(rect.height, this.minHeight);
	// 	//
	// 	// 			/* maintain aspect ratio */
	// 	// 			if (ctrlKey) {
	// 	// 				let correctedSize = this.model.maintainRepresentativeAspectRatio(raw);
	// 	// 				if (correctedSize) { Object.assign(raw, correctedSize) }
	// 	// 			}
	// 	//
	// 	// 			/* correct for left and top edge dragging */
	// 	// 			if (edges.left) { raw.x = rect.left - (raw.width  - rect.width ) }
	// 	// 			if (edges.top)  { raw.y = rect.top  - (raw.height - rect.height) }
	// 	//
	// 	// 			/* initialize visible coordinates */
	// 	// 			let visible = clone(raw);
	// 	//
	// 	// 			// TODO: snapping
	// 	//
	// 	// 			/* restriction correction */
	// 	// 			if (edges.left && visible.x < this.parent.cx) {
	// 	// 				visible.width = (visible.x + visible.width) - this.parent.cx;
	// 	// 				visible.x = this.parent.cx;
	// 	// 			}
	// 	// 			if (edges.top && visible.y < this.parent.cy) {
	// 	// 				visible.height = (visible.y + visible.height) - this.parent.cy;
	// 	// 				visible.y = this.parent.cy;
	// 	// 			}
	// 	// 			if (edges.right && visible.x + visible.width > this.parent.cx + this.parent.cwidth) {
	// 	// 				visible.width = (this.parent.cx + this.parent.cwidth) - visible.x;
	// 	// 			}
	// 	// 			if (edges.bottom && visible.y + visible.height > this.parent.cy + this.parent.cheight) {
	// 	// 				visible.height = (this.parent.cy + this.parent.cheight) - visible.y;
	// 	// 			}
	// 	//
	// 	// 			/* set visible (x, y) based on snapping and restriction */
	// 	// 			this.set(visible);
	// 	// 		}
	// 	// 	};
	// 	// }
	//
	// }
	
	exports.default = LyphRectangle;
	
	function _inspect(input, depth) {
		var maxDepth = 4;
		var maxKeys = 15;

		if (depth === undefined) {
			depth = 0;
		}

		depth += 1;

		if (input === null) {
			return 'null';
		} else if (input === undefined) {
			return 'void';
		} else if (typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean') {
			return typeof input === 'undefined' ? 'undefined' : _typeof(input);
		} else if (Array.isArray(input)) {
			if (input.length > 0) {
				var _ret = function () {
					if (depth > maxDepth) return {
							v: '[...]'
						};

					var first = _inspect(input[0], depth);

					if (input.every(function (item) {
						return _inspect(item, depth) === first;
					})) {
						return {
							v: first.trim() + '[]'
						};
					} else {
						return {
							v: '[' + input.slice(0, maxKeys).map(function (item) {
								return _inspect(item, depth);
							}).join(', ') + (input.length >= maxKeys ? ', ...' : '') + ']'
						};
					}
				}();

				if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
			} else {
				return 'Array';
			}
		} else {
			var keys = Object.keys(input);

			if (!keys.length) {
				if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
					return input.constructor.name;
				} else {
					return 'Object';
				}
			}

			if (depth > maxDepth) return '{...}';
			var indent = '  '.repeat(depth - 1);
			var entries = keys.slice(0, maxKeys).map(function (key) {
				return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + ': ' + _inspect(input[key], depth) + ';';
			}).join('\n  ' + indent);

			if (keys.length >= maxKeys) {
				entries += '\n  ' + indent + '...';
			}

			if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
				return input.constructor.name + ' {\n  ' + indent + entries + '\n' + indent + '}';
			} else {
				return '{\n  ' + indent + entries + '\n' + indent + '}';
			}
		}
	}

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _powerAssertVisitorKeys = '{"ArrayExpression":["elements"],"AssignmentExpression":["left","right"],"BinaryExpression":["left","right"],"Directive":["value"],"DirectiveLiteral":[],"BlockStatement":["directives","body"],"BreakStatement":["label"],"CallExpression":["callee","arguments"],"CatchClause":["param","body"],"ConditionalExpression":["test","consequent","alternate"],"ContinueStatement":["label"],"DebuggerStatement":[],"DoWhileStatement":["test","body"],"EmptyStatement":[],"ExpressionStatement":["expression"],"File":["program"],"ForInStatement":["left","right","body"],"ForStatement":["init","test","update","body"],"FunctionDeclaration":["id","params","body","returnType","typeParameters"],"FunctionExpression":["id","params","body","returnType","typeParameters"],"Identifier":["typeAnnotation"],"IfStatement":["test","consequent","alternate"],"LabeledStatement":["label","body"],"StringLiteral":[],"NumericLiteral":[],"NullLiteral":[],"BooleanLiteral":[],"RegExpLiteral":[],"LogicalExpression":["left","right"],"MemberExpression":["object","property"],"NewExpression":["callee","arguments"],"Program":["directives","body"],"ObjectExpression":["properties"],"ObjectMethod":["key","params","body","decorators","returnType","typeParameters"],"ObjectProperty":["key","value","decorators"],"RestElement":["argument","typeAnnotation"],"ReturnStatement":["argument"],"SequenceExpression":["expressions"],"SwitchCase":["test","consequent"],"SwitchStatement":["discriminant","cases"],"ThisExpression":[],"ThrowStatement":["argument"],"TryStatement":["block","handler","finalizer"],"UnaryExpression":["argument"],"UpdateExpression":["argument"],"VariableDeclaration":["declarations"],"VariableDeclarator":["id","init"],"WhileStatement":["test","body"],"WithStatement":["object","body"],"AssignmentPattern":["left","right"],"ArrayPattern":["elements","typeAnnotation"],"ArrowFunctionExpression":["params","body","returnType"],"ClassBody":["body"],"ClassDeclaration":["id","body","superClass","mixins","typeParameters","superTypeParameters","implements","decorators"],"ClassExpression":["id","body","superClass","mixins","typeParameters","superTypeParameters","implements","decorators"],"ExportAllDeclaration":["source"],"ExportDefaultDeclaration":["declaration"],"ExportNamedDeclaration":["declaration","specifiers","source"],"ExportSpecifier":["local","exported"],"ForOfStatement":["left","right","body"],"ImportDeclaration":["specifiers","source"],"ImportDefaultSpecifier":["local"],"ImportNamespaceSpecifier":["local"],"ImportSpecifier":["local","imported"],"MetaProperty":["meta","property"],"ClassMethod":["key","params","body","decorators","returnType","typeParameters"],"ObjectPattern":["properties","typeAnnotation"],"SpreadElement":["argument"],"Super":[],"TaggedTemplateExpression":["tag","quasi"],"TemplateElement":[],"TemplateLiteral":["quasis","expressions"],"YieldExpression":["argument"],"AnyTypeAnnotation":[],"ArrayTypeAnnotation":["elementType"],"BooleanTypeAnnotation":[],"BooleanLiteralTypeAnnotation":[],"NullLiteralTypeAnnotation":[],"ClassImplements":["id","typeParameters"],"ClassProperty":["key","value","typeAnnotation","decorators"],"DeclareClass":["id","typeParameters","extends","body"],"DeclareFunction":["id"],"DeclareInterface":["id","typeParameters","extends","body"],"DeclareModule":["id","body"],"DeclareTypeAlias":["id","typeParameters","right"],"DeclareVariable":["id"],"ExistentialTypeParam":[],"FunctionTypeAnnotation":["typeParameters","params","rest","returnType"],"FunctionTypeParam":["name","typeAnnotation"],"GenericTypeAnnotation":["id","typeParameters"],"InterfaceExtends":["id","typeParameters"],"InterfaceDeclaration":["id","typeParameters","extends","body"],"IntersectionTypeAnnotation":["types"],"MixedTypeAnnotation":[],"NullableTypeAnnotation":["typeAnnotation"],"NumericLiteralTypeAnnotation":[],"NumberTypeAnnotation":[],"StringLiteralTypeAnnotation":[],"StringTypeAnnotation":[],"ThisTypeAnnotation":[],"TupleTypeAnnotation":["types"],"TypeofTypeAnnotation":["argument"],"TypeAlias":["id","typeParameters","right"],"TypeAnnotation":["typeAnnotation"],"TypeCastExpression":["expression","typeAnnotation"],"TypeParameter":["bound"],"TypeParameterDeclaration":["params"],"TypeParameterInstantiation":["params"],"ObjectTypeAnnotation":["properties","indexers","callProperties"],"ObjectTypeCallProperty":["value"],"ObjectTypeIndexer":["id","key","value"],"ObjectTypeProperty":["key","value"],"QualifiedTypeIdentifier":["id","qualification"],"UnionTypeAnnotation":["types"],"VoidTypeAnnotation":[],"JSXAttribute":["name","value"],"JSXClosingElement":["name"],"JSXElement":["openingElement","children","closingElement"],"JSXEmptyExpression":[],"JSXExpressionContainer":["expression"],"JSXIdentifier":[],"JSXMemberExpression":["object","property"],"JSXNamespacedName":["namespace","name"],"JSXOpeningElement":["name","attributes"],"JSXSpreadAttribute":["argument"],"JSXText":[],"Noop":[],"ParenthesizedExpression":["expression"],"AwaitExpression":["argument"],"BindExpression":["object","callee"],"Decorator":["expression"],"DoExpression":["body"],"ExportDefaultSpecifier":["exported"],"ExportNamespaceSpecifier":["exported"],"RestProperty":["argument"],"SpreadProperty":["argument"]}',
	    _powerAssertRecorder = function () { function PowerAssertRecorder() { this.captured = []; } PowerAssertRecorder.prototype._capt = function _capt(value, espath) { this.captured.push({ value: value, espath: espath }); return value; }; PowerAssertRecorder.prototype._expr = function _expr(value, source) { return { powerAssertContext: { value: value, events: this.captured }, source: source }; }; return PowerAssertRecorder; }(),
	    _dec,
	    _dec2,
	    _dec3,
	    _desc,
	    _value,
	    _class,
	    _descriptor,
	    _descriptor2;
	
	var _templateObject = _taggedTemplateLiteral(['\n\t\t\t\tThis element is already being created. Do not\n\t\t\t\tuse \'this.element\' during the creation process.\n\t\t\t'], ['\n\t\t\t\tThis element is already being created. Do not\n\t\t\t\tuse \'this.element\' during the creation process.\n\t\t\t']);
	
	var _pick = __webpack_require__(17);
	
	var _pick2 = _interopRequireDefault(_pick);
	
	var _keys = __webpack_require__(188);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _defaults = __webpack_require__(40);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	var _isFunction = __webpack_require__(79);
	
	var _isFunction2 = _interopRequireDefault(_isFunction);
	
	var _isNumber2 = __webpack_require__(44);
	
	var _isNumber3 = _interopRequireDefault(_isNumber2);
	
	var _isBoolean2 = __webpack_require__(43);
	
	var _isBoolean3 = _interopRequireDefault(_isBoolean2);
	
	var _jquery = __webpack_require__(31);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _powerAssert = __webpack_require__(69);
	
	var _powerAssert2 = _interopRequireDefault(_powerAssert);
	
	var _ValueTracker2 = __webpack_require__(6);
	
	var _ValueTracker3 = _interopRequireDefault(_ValueTracker2);
	
	var _misc = __webpack_require__(51);
	
	var _boundNativeMethods = __webpack_require__(162);
	
	var _ValueTracker4 = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _initDefineProp(target, property, descriptor, context) {
		if (!descriptor) return;
		Object.defineProperty(target, property, {
			enumerable: descriptor.enumerable,
			configurable: descriptor.configurable,
			writable: descriptor.writable,
			value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
		});
	}
	
	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
		var desc = {};
		Object['ke' + 'ys'](descriptor).forEach(function (key) {
			desc[key] = descriptor[key];
		});
		desc.enumerable = !!desc.enumerable;
		desc.configurable = !!desc.configurable;
	
		if ('value' in desc || desc.initializer) {
			desc.writable = true;
		}
	
		desc = decorators.slice().reverse().reduce(function (desc, decorator) {
			return decorator(target, property, desc) || desc;
		}, desc);
	
		if (context && desc.initializer !== void 0) {
			desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
			desc.initializer = undefined;
		}
	
		if (desc.initializer === void 0) {
			Object['define' + 'Property'](target, property, desc);
			desc = null;
		}
	
		return desc;
	}
	
	function _initializerWarningHelper(descriptor, context) {
		throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
	}
	
	var $$svg = Symbol('$$svg');
	var $$creatingElement = Symbol('$$creatingElement');
	var $$create = Symbol('$$create');
	var $$creation = Symbol('$$creation');
	
	var SvgObject = (_dec = (0, _ValueTracker4.flag)(false), _dec2 = (0, _ValueTracker4.flag)(false), _dec3 = (0, _misc.args)('oa?o?'), (_class = function (_ValueTracker) {
		_inherits(SvgObject, _ValueTracker);
	
		_createClass(SvgObject, [{
			key: 'toString',
			value: function toString() {
				return '[' + this.constructor.name + ': ' + (this.model && this.model.name) + ']';
			}
		}]);
	
		function SvgObject(options) {
			_classCallCheck(this, SvgObject);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SvgObject).call(this, options));
	
			_initDefineProp(_this, 'highlighted', _descriptor, _this);
	
			_initDefineProp(_this, 'dragging', _descriptor2, _this);
	
			_this.setFromObject(options, ['free', 'highlighted', 'dragging']);
			return _this;
		}
	
		_createClass(SvgObject, [{
			key: $$create,
			value: function value() {
				if (!this[$$creation]) {
					var _rec = new _powerAssertRecorder(),
					    _context;
	
					(0, _powerAssert2.default)(_rec._expr(_rec._capt(!_rec._capt(this[_rec._capt($$creatingElement, 'arguments/0/argument/property')], 'arguments/0/argument'), 'arguments/0'), {
						content: 'assert(!this[$$creatingElement], humanMsg`\n\t\t\t\tThis element is already being created. Do not\n\t\t\t\tuse \'this.element\' during the creation process.\n\t\t\t`)',
						filepath: 'src/artefacts/SvgObject.js',
						line: 43,
						ast: '{"type":"CallExpression","callee":{"type":"Identifier","name":"assert","range":[0,6]},"arguments":[{"type":"UnaryExpression","operator":"!","argument":{"type":"MemberExpression","object":{"type":"ThisExpression","range":[8,12]},"property":{"type":"Identifier","name":"$$creatingElement","range":[13,30]},"computed":true,"range":[8,31]},"prefix":true,"range":[7,31]},{"type":"TaggedTemplateExpression","tag":{"type":"Identifier","name":"humanMsg","range":[33,41]},"quasi":{"type":"TemplateLiteral","quasis":[{"type":"TemplateElement","value":{"raw":"\\n\\t\\t\\t\\tThis element is already being created. Do not\\n\\t\\t\\t\\tuse \'this.element\' during the creation process.\\n\\t\\t\\t","cooked":"\\n\\t\\t\\t\\tThis element is already being created. Do not\\n\\t\\t\\t\\tuse \'this.element\' during the creation process.\\n\\t\\t\\t"},"tail":true,"range":[42,3]}],"expressions":[],"range":[41,4]},"range":[33,4]}],"range":[0,5]}',
						tokens: '[{"type":{"label":"name"},"value":"assert","range":[0,6]},{"type":{"label":"("},"range":[6,7]},{"type":{"label":"prefix"},"value":"!","range":[7,8]},{"type":{"label":"this"},"value":"this","range":[8,12]},{"type":{"label":"["},"range":[12,13]},{"type":{"label":"name"},"value":"$$creatingElement","range":[13,30]},{"type":{"label":"]"},"range":[30,31]},{"type":{"label":","},"range":[31,32]},{"type":{"label":"name"},"value":"humanMsg","range":[33,41]},{"type":{"label":"`"},"range":[41,42]},{"type":{"label":"template"},"value":"\\n\\t\\t\\t\\tThis element is already being created. Do not\\n\\t\\t\\t\\tuse \'this.element\' during the creation process.\\n\\t\\t\\t","range":[42,3]},{"type":{"label":"`"},"range":[3,4]},{"type":{"label":")"},"range":[4,5]}]',
						visitorKeys: _powerAssertVisitorKeys
					}), (0, _misc.humanMsg)(_templateObject));
					this[$$creatingElement] = true;
	
					this[$$creation] = this.createElement();
	
					var el = this[$$creation].element;
					_defaults2.default.call(el, { jq: (0, _jquery2.default)(el), svg: Snap(el) });
					if (!this[$$creation].inside) {
						this[$$creation].inside = this[$$creation].element;
					} else {
						var _el = this[$$creation].inside;
						_defaults2.default.call(_el, { jq: (0, _jquery2.default)(_el), svg: Snap(_el) });
					}
	
					this[$$creation].inside.svg.g().addClass('foreground');
					(0, _jquery2.default)(this[$$creation].inside).data('controller', this);
					(0, _jquery2.default)(this[$$creation].inside).attr('controller', this.constructor.name + ':' + (this.model ? this.model.name : '')); // for css-selectors
	
					this[$$creatingElement] = false;
	
					if ((_context = this.afterCreateElement, _isFunction2.default).call(_context)) {
						this.afterCreateElement();
					}
				}
				return this[$$creation];
			}
		}, {
			key: 'afterCreateElement',
			value: function afterCreateElement() {
				var _this2 = this;
	
				/* manage 'dragging' property */
				this.p('dragging').subscribe(function (dragging) {
					_this2.element.jq.css(dragging ? { pointerEvents: 'none', opacity: 0.8 } : { pointerEvents: 'auto', opacity: 1 });
					// this.element.jq.css(dragging
					// 	? { pointerEvents: 'none',    opacity: 0.8 }
					// 	: { pointerEvents: 'inherit', opacity: 1   });
				});
			}
		}, {
			key: 'setFromObject',
			value: function setFromObject(obj) {
				var _context2;
	
				var picked = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
				var defaultValues = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	
				var keyVals = (_context2 = _pick2.default.call(obj, [].concat(_toConsumableArray(picked), _toConsumableArray(_keys2.default.call(defaultValues)))), _defaults2.default).call(_context2, defaultValues);
				_boundNativeMethods.assign.call(this, keyVals);
			}
		}, {
			key: 'moveToFront',
			value: function moveToFront() {
				this.element.parentElement.appendChild(this.element);
			}
		}, {
			key: 'element',
			get: function get() {
				return this[$$create]().element;
			}
		}, {
			key: 'inside',
			get: function get() {
				return this[$$create]().inside;
			}
		}, {
			key: 'draggable',
			get: function get() {
				return false;
			}
		}]);
	
		return SvgObject;
	}(_ValueTracker3.default), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'highlighted', [_dec], {
		enumerable: true,
		initializer: null
	}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'dragging', [_dec2], {
		enumerable: true,
		initializer: null
	}), _applyDecoratedDescriptor(_class.prototype, 'setFromObject', [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, 'setFromObject'), _class.prototype)), _class));
	
	// export default class SvgObject extends ValueTracker {
	//
	// 	// properties //////////////////////////////////////////////////////////////////////////////////
	//
	// 	// @property({initial: false}) dragging;
	// 	// @property({initial: false}) resizing;
	// 	// @property({initial: false}) hovering;
	// 	//
	// 	// interactive = true;
	//
	//
	// 	// public //////////////////////////////////////////////////////////////////////////////////////
	//
	// 	constructor(options) {
	// 		super(options);
	// 		Object.assign(this, options::pick('interactive'));
	// 	}
	//
	// 	get element() {
	// 		if (!this._element) {
	// 			if (this.creatingElement) {
	// 				throw new Error(`This element is already being created. Do not use 'this.element' during the creation process.`);
	// 			}
	// 			this.creatingElement = true;
	// 			this._element = this.createElement();
	// 			delete this.creatingElement;
	// 			this._element.data('controller', this);
	// 			this._element.attr('controller', true);
	// 			// if (this.interactive === false) {
	// 			this._element.css({ pointerEvents: 'none' });
	// 			// } else {
	// 			// 	this._makeInteractable(this._element);
	// 			// }
	// 			this.e('delete').subscribe(::this._element.remove);
	// 		}
	// 		return this._element;
	// 	};
	//
	// 	// private /////////////////////////////////////////////////////////////////////////////////////
	//
	// 	// _makeInteractable(mainElement) {
	// 	// 	if (this.draggable) {
	// 	// 		let {handle, tracker, ...draggableOptions} = this.draggable();
	// 	// 		if (!handle)  { handle = mainElement                }
	// 	// 		else          { handle = mainElement.find(handle)   }
	// 	// 		if (!tracker) { tracker = handle                    }
	// 	// 		else          { tracker = mainElement.find(tracker) }
	// 	// 		interact(tracker[0]).draggable({
	// 	// 			...draggableOptions,
	// 	// 			onstart: (event) => {
	// 	// 				event.stopPropagation();
	// 	// 				this.dragging = true;
	// 	// 				(draggableOptions.onstart || identity)(event);
	// 	// 			},
	// 	// 			onend: (event) => {
	// 	// 				event.stopPropagation();
	// 	// 				(draggableOptions.onend || identity)(event);
	// 	// 				this.dragging = false;
	// 	// 			}
	// 	// 		});
	// 	// 	}
	// 	// 	if (this.resizable) {
	// 	// 		let {handle, tracker, ...resizableOptions} = this.resizable();
	// 	// 		if (!handle)  { handle = mainElement                }
	// 	// 		else          { handle = mainElement.find(handle)   }
	// 	// 		if (!tracker) { tracker = handle                    }
	// 	// 		else          { tracker = mainElement.find(tracker) }
	// 	// 		interact(handle[0]).resizable({
	// 	// 			...resizableOptions,
	// 	// 			onstart: (event) => {
	// 	// 				event.stopPropagation();
	// 	// 				this.resizing = true;
	// 	// 				(resizableOptions.onstart || identity)(event);
	// 	// 			},
	// 	// 			onend: (event) => {
	// 	// 				event.stopPropagation();
	// 	// 				(resizableOptions.onend || identity)(event);
	// 	// 				this.resizing = false;
	// 	// 			}
	// 	// 		});
	// 	// 		interact(tracker[0]).rectChecker(e => e.getBoundingClientRect());
	// 	// 	}
	// 	// 	if (this.dropzone) {
	// 	// 		let {handle, ...dropzoneOptions} = this.dropzone();
	// 	// 		if (!handle)  { handle = mainElement                }
	// 	// 		else          { handle = mainElement.find(handle)   }
	// 	// 		interact(handle[0]).dropzone(dropzoneOptions);
	// 	// 	}
	// 	// };
	//
	// }
	
	exports.default = SvgObject;

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _functionGenerator = __webpack_require__(21);
	
	var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
	
	exports['default'] = (0, _functionGenerator2['default'])(ArrayBuffer, ['isView', 'transfer']);
	module.exports = exports['default'];

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _functionGenerator = __webpack_require__(21);
	
	var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
	
	exports['default'] = (0, _functionGenerator2['default'])(Array, ['isArray', 'observe']);
	module.exports = exports['default'];

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _functionGenerator = __webpack_require__(21);
	
	var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
	
	exports['default'] = (0, _functionGenerator2['default'])(Date, ['parse'], {
	  parse: 'toUnixOffset'
	});
	module.exports = exports['default'];

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _functionGenerator = __webpack_require__(21);
	
	var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
	
	exports['default'] = (0, _functionGenerator2['default'])(JSON, ['parse', 'stringify'], {
	  parse: 'toObject',
	  stringify: 'toJSON'
	});
	module.exports = exports['default'];

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _functionGenerator = __webpack_require__(21);
	
	var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
	
	exports['default'] = (0, _functionGenerator2['default'])(Math, ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'cbrt', 'ceil', 'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'hypot', 'imul', 'log', 'log10', 'log1p', 'log2', 'max', 'min', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc']);
	module.exports = exports['default'];

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _functionGenerator = __webpack_require__(21);
	
	var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
	
	exports['default'] = (0, _functionGenerator2['default'])(Number, ['isFinite', 'isInteger', 'isNaN', 'isSafeInteger', 'parseFloat', 'parseInt'], {
	  parseFloat: 'toFloat',
	  parseInt: 'toInt'
	});
	module.exports = exports['default'];

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _functionGenerator = __webpack_require__(21);
	
	var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
	
	exports['default'] = (0, _functionGenerator2['default'])(Object, ['assign', 'create', 'defineProperties', 'defineProperty', 'freeze', 'getOwnPropertyDescriptor', 'getOwnPropertyNames', 'getOwnPropertySymbols', 'getPrototypeOf', 'is', 'isExtensible', 'isFrozen', 'isSealed', 'keys', 'observe', 'preventExtensions', 'seal', 'setPrototypeOf'], {
	  getPrototypeOf: 'getPrototype',
	  setPrototypeOf: 'setPrototype'
	});
	module.exports = exports['default'];

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _functionGenerator = __webpack_require__(21);
	
	var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
	
	exports['default'] = (0, _functionGenerator2['default'])(Symbol, ['for', 'keyFor'], {
	  'for': 'toSymbol',
	  keyFor: 'key'
	});
	module.exports = exports['default'];

/***/ },
/* 254 */
/***/ function(module, exports) {

	'use strict';
	module.exports.parse = parse;
	module.exports.generate = generate;
	
	// TODO(jamestalmage): Allow full range of identifier characters instead of just ASCII
	//
	// This will likely require a build step
	//
	// SPEC: http://www.ecma-international.org/ecma-262/5.1/#sec-7.6
	//
	// TOOLING:
	//    https://github.com/mathiasbynens/regenerate
	//    https://www.npmjs.com/package/regjsgen
	
	var regex = /^\s*(?:([A-Za-z$_][A-Za-z0-9$_]*)\s*\.)?\s*([A-Za-z$_][A-Za-z0-9$_]*)\s*\(\s*((?:[A-Za-z$_][A-Za-z0-9$_]*)|(?:\[\s*[A-Za-z$_][A-Za-z0-9$_]*\s*]))?((?:\s*,\s*(?:(?:[A-Za-z$_][A-Za-z0-9$_]*)|(?:\[\s*[A-Za-z$_][A-Za-z0-9$_]*\s*])))+)?\s*\)\s*$/;
	
	function parse(str) {
		var match = regex.exec(str);
		if (!match) {
			return null;
		}
	
		var callee;
		if (match[1]) {
			callee = {
				type: 'MemberExpression',
				object: match[1],
				member: match[2]
			};
		} else {
			callee = {
				type: 'Identifier',
				name: match[2]
			};
		}
	
		var args = match[4] || '';
		args = args.split(',');
		if (match[3]) {
			args[0] = match[3];
		}
		var trimmed = [];
		args.forEach(function (str) {
			var optional = false;
			str = str.replace(/\s+/g, '');
			if (!str.length) {
				return;
			}
			if (str.charAt(0) === '[' && str.charAt(str.length - 1) === ']') {
				optional = true;
				str = str.substring(1, str.length - 1);
			}
			trimmed.push({
				name: str,
				optional: optional
			});
		});
	
		return {
			callee: callee,
			args: trimmed
		};
	}
	
	function generate(parsed) {
		var callee;
		if (parsed.callee.type === 'MemberExpression') {
			callee = [
				parsed.callee.object,
				'.',
				parsed.callee.member
			];
		} else {
			callee = [parsed.callee.name];
		}
		return callee.concat([
			'(',
			parsed.args.map(function (arg) {
				return arg.optional ? '[' + arg.name + ']' : arg.name;
			}).join(', '),
			')'
		]).join('');
	}


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {
	/**
	 * @license
	 *
	 * chroma.js - JavaScript library for color conversions
	 * 
	 * Copyright (c) 2011-2015, Gregor Aisch
	 * All rights reserved.
	 * 
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 * 
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 * 
	 * 3. The name Gregor Aisch may not be used to endorse or promote products
	 *    derived from this software without specific prior written permission.
	 * 
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 */
	
	(function() {
	  var Color, DEG2RAD, LAB_CONSTANTS, PI, PITHIRD, RAD2DEG, TWOPI, _guess_formats, _guess_formats_sorted, _input, _interpolators, abs, atan2, bezier, blend, blend_f, brewer, burn, chroma, clip_rgb, cmyk2rgb, colors, cos, css2rgb, darken, dodge, each, floor, hex2rgb, hsi2rgb, hsl2css, hsl2rgb, hsv2rgb, interpolate, interpolate_hsx, interpolate_lab, interpolate_num, interpolate_rgb, lab2lch, lab2rgb, lab_xyz, lch2lab, lch2rgb, lighten, limit, log, luminance_x, m, max, multiply, normal, num2rgb, overlay, pow, rgb2cmyk, rgb2css, rgb2hex, rgb2hsi, rgb2hsl, rgb2hsv, rgb2lab, rgb2lch, rgb2luminance, rgb2num, rgb2temperature, rgb2xyz, rgb_xyz, rnd, root, round, screen, sin, sqrt, temperature2rgb, type, unpack, w3cx11, xyz_lab, xyz_rgb,
	    slice = [].slice;
	
	  type = (function() {
	
	    /*
	    for browser-safe type checking+
	    ported from jQuery's $.type
	     */
	    var classToType, len, name, o, ref;
	    classToType = {};
	    ref = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
	    for (o = 0, len = ref.length; o < len; o++) {
	      name = ref[o];
	      classToType["[object " + name + "]"] = name.toLowerCase();
	    }
	    return function(obj) {
	      var strType;
	      strType = Object.prototype.toString.call(obj);
	      return classToType[strType] || "object";
	    };
	  })();
	
	  limit = function(x, min, max) {
	    if (min == null) {
	      min = 0;
	    }
	    if (max == null) {
	      max = 1;
	    }
	    if (x < min) {
	      x = min;
	    }
	    if (x > max) {
	      x = max;
	    }
	    return x;
	  };
	
	  unpack = function(args) {
	    if (args.length >= 3) {
	      return [].slice.call(args);
	    } else {
	      return args[0];
	    }
	  };
	
	  clip_rgb = function(rgb) {
	    var i;
	    for (i in rgb) {
	      if (i < 3) {
	        if (rgb[i] < 0) {
	          rgb[i] = 0;
	        }
	        if (rgb[i] > 255) {
	          rgb[i] = 255;
	        }
	      } else if (i === 3) {
	        if (rgb[i] < 0) {
	          rgb[i] = 0;
	        }
	        if (rgb[i] > 1) {
	          rgb[i] = 1;
	        }
	      }
	    }
	    return rgb;
	  };
	
	  PI = Math.PI, round = Math.round, cos = Math.cos, floor = Math.floor, pow = Math.pow, log = Math.log, sin = Math.sin, sqrt = Math.sqrt, atan2 = Math.atan2, max = Math.max, abs = Math.abs;
	
	  TWOPI = PI * 2;
	
	  PITHIRD = PI / 3;
	
	  DEG2RAD = PI / 180;
	
	  RAD2DEG = 180 / PI;
	
	  chroma = function() {
	    if (arguments[0] instanceof Color) {
	      return arguments[0];
	    }
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(Color, arguments, function(){});
	  };
	
	  _interpolators = [];
	
	  if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
	    module.exports = chroma;
	  }
	
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return chroma;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {
	    root = typeof exports !== "undefined" && exports !== null ? exports : this;
	    root.chroma = chroma;
	  }
	
	  chroma.version = '1.1.1';
	
	
	  /**
	      chroma.js
	  
	      Copyright (c) 2011-2013, Gregor Aisch
	      All rights reserved.
	  
	      Redistribution and use in source and binary forms, with or without
	      modification, are permitted provided that the following conditions are met:
	  
	      * Redistributions of source code must retain the above copyright notice, this
	        list of conditions and the following disclaimer.
	  
	      * Redistributions in binary form must reproduce the above copyright notice,
	        this list of conditions and the following disclaimer in the documentation
	        and/or other materials provided with the distribution.
	  
	      * The name Gregor Aisch may not be used to endorse or promote products
	        derived from this software without specific prior written permission.
	  
	      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	  
	      @source: https://github.com/gka/chroma.js
	   */
	
	  _input = {};
	
	  _guess_formats = [];
	
	  _guess_formats_sorted = false;
	
	  Color = (function() {
	    function Color() {
	      var arg, args, chk, len, len1, me, mode, o, w;
	      me = this;
	      args = [];
	      for (o = 0, len = arguments.length; o < len; o++) {
	        arg = arguments[o];
	        if (arg != null) {
	          args.push(arg);
	        }
	      }
	      mode = args[args.length - 1];
	      if (_input[mode] != null) {
	        me._rgb = clip_rgb(_input[mode](unpack(args.slice(0, -1))));
	      } else {
	        if (!_guess_formats_sorted) {
	          _guess_formats = _guess_formats.sort(function(a, b) {
	            return b.p - a.p;
	          });
	          _guess_formats_sorted = true;
	        }
	        for (w = 0, len1 = _guess_formats.length; w < len1; w++) {
	          chk = _guess_formats[w];
	          mode = chk.test.apply(chk, args);
	          if (mode) {
	            break;
	          }
	        }
	        if (mode) {
	          me._rgb = clip_rgb(_input[mode].apply(_input, args));
	        }
	      }
	      if (me._rgb == null) {
	        console.warn('unknown format: ' + args);
	      }
	      if (me._rgb == null) {
	        me._rgb = [0, 0, 0];
	      }
	      if (me._rgb.length === 3) {
	        me._rgb.push(1);
	      }
	    }
	
	    Color.prototype.alpha = function(alpha) {
	      if (arguments.length) {
	        this._rgb[3] = alpha;
	        return this;
	      }
	      return this._rgb[3];
	    };
	
	    Color.prototype.toString = function() {
	      return this.name();
	    };
	
	    return Color;
	
	  })();
	
	  chroma._input = _input;
	
	
	  /**
	  	ColorBrewer colors for chroma.js
	  
	  	Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The 
	  	Pennsylvania State University.
	  
	  	Licensed under the Apache License, Version 2.0 (the "License"); 
	  	you may not use this file except in compliance with the License.
	  	You may obtain a copy of the License at	
	  	http://www.apache.org/licenses/LICENSE-2.0
	  
	  	Unless required by applicable law or agreed to in writing, software distributed
	  	under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
	  	CONDITIONS OF ANY KIND, either express or implied. See the License for the
	  	specific language governing permissions and limitations under the License.
	  
	      @preserve
	   */
	
	  chroma.brewer = brewer = {
	    OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
	    PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
	    BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
	    Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
	    BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
	    YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
	    YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
	    Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
	    RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
	    Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
	    YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
	    Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
	    GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
	    Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
	    YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
	    PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
	    Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
	    PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
	    Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
	    RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
	    RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
	    PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
	    PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
	    RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
	    BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
	    RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
	    PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
	    Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
	    Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
	    Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
	    Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
	    Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
	    Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
	    Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
	    Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']
	  };
	
	
	  /**
	  	X11 color names
	  
	  	http://www.w3.org/TR/css3-color/#svg-color
	   */
	
	  w3cx11 = {
	    indigo: "#4b0082",
	    gold: "#ffd700",
	    hotpink: "#ff69b4",
	    firebrick: "#b22222",
	    indianred: "#cd5c5c",
	    yellow: "#ffff00",
	    mistyrose: "#ffe4e1",
	    darkolivegreen: "#556b2f",
	    olive: "#808000",
	    darkseagreen: "#8fbc8f",
	    pink: "#ffc0cb",
	    tomato: "#ff6347",
	    lightcoral: "#f08080",
	    orangered: "#ff4500",
	    navajowhite: "#ffdead",
	    lime: "#00ff00",
	    palegreen: "#98fb98",
	    darkslategrey: "#2f4f4f",
	    greenyellow: "#adff2f",
	    burlywood: "#deb887",
	    seashell: "#fff5ee",
	    mediumspringgreen: "#00fa9a",
	    fuchsia: "#ff00ff",
	    papayawhip: "#ffefd5",
	    blanchedalmond: "#ffebcd",
	    chartreuse: "#7fff00",
	    dimgray: "#696969",
	    black: "#000000",
	    peachpuff: "#ffdab9",
	    springgreen: "#00ff7f",
	    aquamarine: "#7fffd4",
	    white: "#ffffff",
	    orange: "#ffa500",
	    lightsalmon: "#ffa07a",
	    darkslategray: "#2f4f4f",
	    brown: "#a52a2a",
	    ivory: "#fffff0",
	    dodgerblue: "#1e90ff",
	    peru: "#cd853f",
	    lawngreen: "#7cfc00",
	    chocolate: "#d2691e",
	    crimson: "#dc143c",
	    forestgreen: "#228b22",
	    darkgrey: "#a9a9a9",
	    lightseagreen: "#20b2aa",
	    cyan: "#00ffff",
	    mintcream: "#f5fffa",
	    silver: "#c0c0c0",
	    antiquewhite: "#faebd7",
	    mediumorchid: "#ba55d3",
	    skyblue: "#87ceeb",
	    gray: "#808080",
	    darkturquoise: "#00ced1",
	    goldenrod: "#daa520",
	    darkgreen: "#006400",
	    floralwhite: "#fffaf0",
	    darkviolet: "#9400d3",
	    darkgray: "#a9a9a9",
	    moccasin: "#ffe4b5",
	    saddlebrown: "#8b4513",
	    grey: "#808080",
	    darkslateblue: "#483d8b",
	    lightskyblue: "#87cefa",
	    lightpink: "#ffb6c1",
	    mediumvioletred: "#c71585",
	    slategrey: "#708090",
	    red: "#ff0000",
	    deeppink: "#ff1493",
	    limegreen: "#32cd32",
	    darkmagenta: "#8b008b",
	    palegoldenrod: "#eee8aa",
	    plum: "#dda0dd",
	    turquoise: "#40e0d0",
	    lightgrey: "#d3d3d3",
	    lightgoldenrodyellow: "#fafad2",
	    darkgoldenrod: "#b8860b",
	    lavender: "#e6e6fa",
	    maroon: "#800000",
	    yellowgreen: "#9acd32",
	    sandybrown: "#f4a460",
	    thistle: "#d8bfd8",
	    violet: "#ee82ee",
	    navy: "#000080",
	    magenta: "#ff00ff",
	    dimgrey: "#696969",
	    tan: "#d2b48c",
	    rosybrown: "#bc8f8f",
	    olivedrab: "#6b8e23",
	    blue: "#0000ff",
	    lightblue: "#add8e6",
	    ghostwhite: "#f8f8ff",
	    honeydew: "#f0fff0",
	    cornflowerblue: "#6495ed",
	    slateblue: "#6a5acd",
	    linen: "#faf0e6",
	    darkblue: "#00008b",
	    powderblue: "#b0e0e6",
	    seagreen: "#2e8b57",
	    darkkhaki: "#bdb76b",
	    snow: "#fffafa",
	    sienna: "#a0522d",
	    mediumblue: "#0000cd",
	    royalblue: "#4169e1",
	    lightcyan: "#e0ffff",
	    green: "#008000",
	    mediumpurple: "#9370db",
	    midnightblue: "#191970",
	    cornsilk: "#fff8dc",
	    paleturquoise: "#afeeee",
	    bisque: "#ffe4c4",
	    slategray: "#708090",
	    darkcyan: "#008b8b",
	    khaki: "#f0e68c",
	    wheat: "#f5deb3",
	    teal: "#008080",
	    darkorchid: "#9932cc",
	    deepskyblue: "#00bfff",
	    salmon: "#fa8072",
	    darkred: "#8b0000",
	    steelblue: "#4682b4",
	    palevioletred: "#db7093",
	    lightslategray: "#778899",
	    aliceblue: "#f0f8ff",
	    lightslategrey: "#778899",
	    lightgreen: "#90ee90",
	    orchid: "#da70d6",
	    gainsboro: "#dcdcdc",
	    mediumseagreen: "#3cb371",
	    lightgray: "#d3d3d3",
	    mediumturquoise: "#48d1cc",
	    lemonchiffon: "#fffacd",
	    cadetblue: "#5f9ea0",
	    lightyellow: "#ffffe0",
	    lavenderblush: "#fff0f5",
	    coral: "#ff7f50",
	    purple: "#800080",
	    aqua: "#00ffff",
	    whitesmoke: "#f5f5f5",
	    mediumslateblue: "#7b68ee",
	    darkorange: "#ff8c00",
	    mediumaquamarine: "#66cdaa",
	    darksalmon: "#e9967a",
	    beige: "#f5f5dc",
	    blueviolet: "#8a2be2",
	    azure: "#f0ffff",
	    lightsteelblue: "#b0c4de",
	    oldlace: "#fdf5e6",
	    rebeccapurple: "#663399"
	  };
	
	  chroma.colors = colors = w3cx11;
	
	  lab2rgb = function() {
	    var a, args, b, g, l, r, x, y, z;
	    args = unpack(arguments);
	    l = args[0], a = args[1], b = args[2];
	    y = (l + 16) / 116;
	    x = isNaN(a) ? y : y + a / 500;
	    z = isNaN(b) ? y : y - b / 200;
	    y = LAB_CONSTANTS.Yn * lab_xyz(y);
	    x = LAB_CONSTANTS.Xn * lab_xyz(x);
	    z = LAB_CONSTANTS.Zn * lab_xyz(z);
	    r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);
	    g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
	    b = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);
	    r = limit(r, 0, 255);
	    g = limit(g, 0, 255);
	    b = limit(b, 0, 255);
	    return [r, g, b, args.length > 3 ? args[3] : 1];
	  };
	
	  xyz_rgb = function(r) {
	    return round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow(r, 1 / 2.4) - 0.055));
	  };
	
	  lab_xyz = function(t) {
	    if (t > LAB_CONSTANTS.t1) {
	      return t * t * t;
	    } else {
	      return LAB_CONSTANTS.t2 * (t - LAB_CONSTANTS.t0);
	    }
	  };
	
	  LAB_CONSTANTS = {
	    Kn: 18,
	    Xn: 0.950470,
	    Yn: 1,
	    Zn: 1.088830,
	    t0: 0.137931034,
	    t1: 0.206896552,
	    t2: 0.12841855,
	    t3: 0.008856452
	  };
	
	  rgb2lab = function() {
	    var b, g, r, ref, ref1, x, y, z;
	    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
	    ref1 = rgb2xyz(r, g, b), x = ref1[0], y = ref1[1], z = ref1[2];
	    return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
	  };
	
	  rgb_xyz = function(r) {
	    if ((r /= 255) <= 0.04045) {
	      return r / 12.92;
	    } else {
	      return pow((r + 0.055) / 1.055, 2.4);
	    }
	  };
	
	  xyz_lab = function(t) {
	    if (t > LAB_CONSTANTS.t3) {
	      return pow(t, 1 / 3);
	    } else {
	      return t / LAB_CONSTANTS.t2 + LAB_CONSTANTS.t0;
	    }
	  };
	
	  rgb2xyz = function() {
	    var b, g, r, ref, x, y, z;
	    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
	    r = rgb_xyz(r);
	    g = rgb_xyz(g);
	    b = rgb_xyz(b);
	    x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS.Xn);
	    y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / LAB_CONSTANTS.Yn);
	    z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / LAB_CONSTANTS.Zn);
	    return [x, y, z];
	  };
	
	  chroma.lab = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(Color, slice.call(arguments).concat(['lab']), function(){});
	  };
	
	  _input.lab = lab2rgb;
	
	  Color.prototype.lab = function() {
	    return rgb2lab(this._rgb);
	  };
	
	  bezier = function(colors) {
	    var I, I0, I1, c, lab0, lab1, lab2, lab3, ref, ref1, ref2;
	    colors = (function() {
	      var len, o, results;
	      results = [];
	      for (o = 0, len = colors.length; o < len; o++) {
	        c = colors[o];
	        results.push(chroma(c));
	      }
	      return results;
	    })();
	    if (colors.length === 2) {
	      ref = (function() {
	        var len, o, results;
	        results = [];
	        for (o = 0, len = colors.length; o < len; o++) {
	          c = colors[o];
	          results.push(c.lab());
	        }
	        return results;
	      })(), lab0 = ref[0], lab1 = ref[1];
	      I = function(t) {
	        var i, lab;
	        lab = (function() {
	          var o, results;
	          results = [];
	          for (i = o = 0; o <= 2; i = ++o) {
	            results.push(lab0[i] + t * (lab1[i] - lab0[i]));
	          }
	          return results;
	        })();
	        return chroma.lab.apply(chroma, lab);
	      };
	    } else if (colors.length === 3) {
	      ref1 = (function() {
	        var len, o, results;
	        results = [];
	        for (o = 0, len = colors.length; o < len; o++) {
	          c = colors[o];
	          results.push(c.lab());
	        }
	        return results;
	      })(), lab0 = ref1[0], lab1 = ref1[1], lab2 = ref1[2];
	      I = function(t) {
	        var i, lab;
	        lab = (function() {
	          var o, results;
	          results = [];
	          for (i = o = 0; o <= 2; i = ++o) {
	            results.push((1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i]);
	          }
	          return results;
	        })();
	        return chroma.lab.apply(chroma, lab);
	      };
	    } else if (colors.length === 4) {
	      ref2 = (function() {
	        var len, o, results;
	        results = [];
	        for (o = 0, len = colors.length; o < len; o++) {
	          c = colors[o];
	          results.push(c.lab());
	        }
	        return results;
	      })(), lab0 = ref2[0], lab1 = ref2[1], lab2 = ref2[2], lab3 = ref2[3];
	      I = function(t) {
	        var i, lab;
	        lab = (function() {
	          var o, results;
	          results = [];
	          for (i = o = 0; o <= 2; i = ++o) {
	            results.push((1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i]);
	          }
	          return results;
	        })();
	        return chroma.lab.apply(chroma, lab);
	      };
	    } else if (colors.length === 5) {
	      I0 = bezier(colors.slice(0, 3));
	      I1 = bezier(colors.slice(2, 5));
	      I = function(t) {
	        if (t < 0.5) {
	          return I0(t * 2);
	        } else {
	          return I1((t - 0.5) * 2);
	        }
	      };
	    }
	    return I;
	  };
	
	  chroma.bezier = function(colors) {
	    var f;
	    f = bezier(colors);
	    f.scale = function() {
	      return chroma.scale(f);
	    };
	    return f;
	  };
	
	
	  /*
	      chroma.js
	  
	      Copyright (c) 2011-2013, Gregor Aisch
	      All rights reserved.
	  
	      Redistribution and use in source and binary forms, with or without
	      modification, are permitted provided that the following conditions are met:
	  
	      * Redistributions of source code must retain the above copyright notice, this
	        list of conditions and the following disclaimer.
	  
	      * Redistributions in binary form must reproduce the above copyright notice,
	        this list of conditions and the following disclaimer in the documentation
	        and/or other materials provided with the distribution.
	  
	      * The name Gregor Aisch may not be used to endorse or promote products
	        derived from this software without specific prior written permission.
	  
	      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	  
	      @source: https://github.com/gka/chroma.js
	   */
	
	  chroma.cubehelix = function(start, rotations, hue, gamma, lightness) {
	    var dh, dl, f;
	    if (start == null) {
	      start = 300;
	    }
	    if (rotations == null) {
	      rotations = -1.5;
	    }
	    if (hue == null) {
	      hue = 1;
	    }
	    if (gamma == null) {
	      gamma = 1;
	    }
	    if (lightness == null) {
	      lightness = [0, 1];
	    }
	    dl = lightness[1] - lightness[0];
	    dh = 0;
	    f = function(fract) {
	      var a, amp, b, cos_a, g, h, l, r, sin_a;
	      a = TWOPI * ((start + 120) / 360 + rotations * fract);
	      l = pow(lightness[0] + dl * fract, gamma);
	      h = dh !== 0 ? hue[0] + fract * dh : hue;
	      amp = h * l * (1 - l) / 2;
	      cos_a = cos(a);
	      sin_a = sin(a);
	      r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
	      g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
	      b = l + amp * (+1.97294 * cos_a);
	      return chroma(clip_rgb([r * 255, g * 255, b * 255]));
	    };
	    f.start = function(s) {
	      if (s == null) {
	        return start;
	      }
	      start = s;
	      return f;
	    };
	    f.rotations = function(r) {
	      if (r == null) {
	        return rotations;
	      }
	      rotations = r;
	      return f;
	    };
	    f.gamma = function(g) {
	      if (g == null) {
	        return gamma;
	      }
	      gamma = g;
	      return f;
	    };
	    f.hue = function(h) {
	      if (h == null) {
	        return hue;
	      }
	      hue = h;
	      if (type(hue) === 'array') {
	        dh = hue[1] - hue[0];
	        if (dh === 0) {
	          hue = hue[1];
	        }
	      } else {
	        dh = 0;
	      }
	      return f;
	    };
	    f.lightness = function(h) {
	      if (h == null) {
	        return lightness;
	      }
	      lightness = h;
	      if (type(lightness) === 'array') {
	        dl = lightness[1] - lightness[0];
	        if (dl === 0) {
	          lightness = lightness[1];
	        }
	      } else {
	        dl = 0;
	      }
	      return f;
	    };
	    f.scale = function() {
	      return chroma.scale(f);
	    };
	    f.hue(hue);
	    return f;
	  };
	
	  chroma.random = function() {
	    var code, digits, i, o;
	    digits = '0123456789abcdef';
	    code = '#';
	    for (i = o = 0; o < 6; i = ++o) {
	      code += digits.charAt(floor(Math.random() * 16));
	    }
	    return new Color(code);
	  };
	
	  chroma.average = function(colors) {
	    var a, b, c, g, l, len, o, r, rgba;
	    r = g = b = a = 0;
	    l = colors.length;
	    for (o = 0, len = colors.length; o < len; o++) {
	      c = colors[o];
	      rgba = chroma(c).rgba();
	      r += rgba[0];
	      g += rgba[1];
	      b += rgba[2];
	      a += rgba[3];
	    }
	    return new Color(r / l, g / l, b / l, a / l);
	  };
	
	  _input.rgb = function() {
	    var k, ref, results, v;
	    ref = unpack(arguments);
	    results = [];
	    for (k in ref) {
	      v = ref[k];
	      results.push(v);
	    }
	    return results;
	  };
	
	  chroma.rgb = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(Color, slice.call(arguments).concat(['rgb']), function(){});
	  };
	
	  Color.prototype.rgb = function() {
	    return this._rgb.slice(0, 3);
	  };
	
	  Color.prototype.rgba = function() {
	    return this._rgb;
	  };
	
	  _guess_formats.push({
	    p: 15,
	    test: function(n) {
	      var a;
	      a = unpack(arguments);
	      if (type(a) === 'array' && a.length === 3) {
	        return 'rgb';
	      }
	      if (a.length === 4 && type(a[3]) === "number" && a[3] >= 0 && a[3] <= 1) {
	        return 'rgb';
	      }
	    }
	  });
	
	  hex2rgb = function(hex) {
	    var a, b, g, r, rgb, u;
	    if (hex.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
	      if (hex.length === 4 || hex.length === 7) {
	        hex = hex.substr(1);
	      }
	      if (hex.length === 3) {
	        hex = hex.split("");
	        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
	      }
	      u = parseInt(hex, 16);
	      r = u >> 16;
	      g = u >> 8 & 0xFF;
	      b = u & 0xFF;
	      return [r, g, b, 1];
	    }
	    if (hex.match(/^#?([A-Fa-f0-9]{8})$/)) {
	      if (hex.length === 9) {
	        hex = hex.substr(1);
	      }
	      u = parseInt(hex, 16);
	      r = u >> 24 & 0xFF;
	      g = u >> 16 & 0xFF;
	      b = u >> 8 & 0xFF;
	      a = round((u & 0xFF) / 0xFF * 100) / 100;
	      return [r, g, b, a];
	    }
	    if ((_input.css != null) && (rgb = _input.css(hex))) {
	      return rgb;
	    }
	    throw "unknown color: " + hex;
	  };
	
	  rgb2hex = function(channels, mode) {
	    var a, b, g, hxa, r, str, u;
	    if (mode == null) {
	      mode = 'rgb';
	    }
	    r = channels[0], g = channels[1], b = channels[2], a = channels[3];
	    u = r << 16 | g << 8 | b;
	    str = "000000" + u.toString(16);
	    str = str.substr(str.length - 6);
	    hxa = '0' + round(a * 255).toString(16);
	    hxa = hxa.substr(hxa.length - 2);
	    return "#" + (function() {
	      switch (mode.toLowerCase()) {
	        case 'rgba':
	          return str + hxa;
	        case 'argb':
	          return hxa + str;
	        default:
	          return str;
	      }
	    })();
	  };
	
	  _input.hex = function(h) {
	    return hex2rgb(h);
	  };
	
	  chroma.hex = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(Color, slice.call(arguments).concat(['hex']), function(){});
	  };
	
	  Color.prototype.hex = function(mode) {
	    if (mode == null) {
	      mode = 'rgb';
	    }
	    return rgb2hex(this._rgb, mode);
	  };
	
	  _guess_formats.push({
	    p: 10,
	    test: function(n) {
	      if (arguments.length === 1 && type(n) === "string") {
	        return 'hex';
	      }
	    }
	  });
	
	  hsl2rgb = function() {
	    var args, b, c, g, h, i, l, o, r, ref, s, t1, t2, t3;
	    args = unpack(arguments);
	    h = args[0], s = args[1], l = args[2];
	    if (s === 0) {
	      r = g = b = l * 255;
	    } else {
	      t3 = [0, 0, 0];
	      c = [0, 0, 0];
	      t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
	      t1 = 2 * l - t2;
	      h /= 360;
	      t3[0] = h + 1 / 3;
	      t3[1] = h;
	      t3[2] = h - 1 / 3;
	      for (i = o = 0; o <= 2; i = ++o) {
	        if (t3[i] < 0) {
	          t3[i] += 1;
	        }
	        if (t3[i] > 1) {
	          t3[i] -= 1;
	        }
	        if (6 * t3[i] < 1) {
	          c[i] = t1 + (t2 - t1) * 6 * t3[i];
	        } else if (2 * t3[i] < 1) {
	          c[i] = t2;
	        } else if (3 * t3[i] < 2) {
	          c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6;
	        } else {
	          c[i] = t1;
	        }
	      }
	      ref = [round(c[0] * 255), round(c[1] * 255), round(c[2] * 255)], r = ref[0], g = ref[1], b = ref[2];
	    }
	    if (args.length > 3) {
	      return [r, g, b, args[3]];
	    } else {
	      return [r, g, b];
	    }
	  };
	
	  rgb2hsl = function(r, g, b) {
	    var h, l, min, ref, s;
	    if (r !== void 0 && r.length >= 3) {
	      ref = r, r = ref[0], g = ref[1], b = ref[2];
	    }
	    r /= 255;
	    g /= 255;
	    b /= 255;
	    min = Math.min(r, g, b);
	    max = Math.max(r, g, b);
	    l = (max + min) / 2;
	    if (max === min) {
	      s = 0;
	      h = Number.NaN;
	    } else {
	      s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
	    }
	    if (r === max) {
	      h = (g - b) / (max - min);
	    } else if (g === max) {
	      h = 2 + (b - r) / (max - min);
	    } else if (b === max) {
	      h = 4 + (r - g) / (max - min);
	    }
	    h *= 60;
	    if (h < 0) {
	      h += 360;
	    }
	    return [h, s, l];
	  };
	
	  chroma.hsl = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(Color, slice.call(arguments).concat(['hsl']), function(){});
	  };
	
	  _input.hsl = hsl2rgb;
	
	  Color.prototype.hsl = function() {
	    return rgb2hsl(this._rgb);
	  };
	
	  hsv2rgb = function() {
	    var args, b, f, g, h, i, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, s, t, v;
	    args = unpack(arguments);
	    h = args[0], s = args[1], v = args[2];
	    v *= 255;
	    if (s === 0) {
	      r = g = b = v;
	    } else {
	      if (h === 360) {
	        h = 0;
	      }
	      if (h > 360) {
	        h -= 360;
	      }
	      if (h < 0) {
	        h += 360;
	      }
	      h /= 60;
	      i = floor(h);
	      f = h - i;
	      p = v * (1 - s);
	      q = v * (1 - s * f);
	      t = v * (1 - s * (1 - f));
	      switch (i) {
	        case 0:
	          ref = [v, t, p], r = ref[0], g = ref[1], b = ref[2];
	          break;
	        case 1:
	          ref1 = [q, v, p], r = ref1[0], g = ref1[1], b = ref1[2];
	          break;
	        case 2:
	          ref2 = [p, v, t], r = ref2[0], g = ref2[1], b = ref2[2];
	          break;
	        case 3:
	          ref3 = [p, q, v], r = ref3[0], g = ref3[1], b = ref3[2];
	          break;
	        case 4:
	          ref4 = [t, p, v], r = ref4[0], g = ref4[1], b = ref4[2];
	          break;
	        case 5:
	          ref5 = [v, p, q], r = ref5[0], g = ref5[1], b = ref5[2];
	      }
	    }
	    r = round(r);
	    g = round(g);
	    b = round(b);
	    return [r, g, b, args.length > 3 ? args[3] : 1];
	  };
	
	  rgb2hsv = function() {
	    var b, delta, g, h, min, r, ref, s, v;
	    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
	    min = Math.min(r, g, b);
	    max = Math.max(r, g, b);
	    delta = max - min;
	    v = max / 255.0;
	    if (max === 0) {
	      h = Number.NaN;
	      s = 0;
	    } else {
	      s = delta / max;
	      if (r === max) {
	        h = (g - b) / delta;
	      }
	      if (g === max) {
	        h = 2 + (b - r) / delta;
	      }
	      if (b === max) {
	        h = 4 + (r - g) / delta;
	      }
	      h *= 60;
	      if (h < 0) {
	        h += 360;
	      }
	    }
	    return [h, s, v];
	  };
	
	  chroma.hsv = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(Color, slice.call(arguments).concat(['hsv']), function(){});
	  };
	
	  _input.hsv = hsv2rgb;
	
	  Color.prototype.hsv = function() {
	    return rgb2hsv(this._rgb);
	  };
	
	  num2rgb = function(num) {
	    var b, g, r;
	    if (type(num) === "number" && num >= 0 && num <= 0xFFFFFF) {
	      r = num >> 16;
	      g = (num >> 8) & 0xFF;
	      b = num & 0xFF;
	      return [r, g, b, 1];
	    }
	    console.warn("unknown num color: " + num);
	    return [0, 0, 0, 1];
	  };
	
	  rgb2num = function() {
	    var b, g, r, ref;
	    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
	    return (r << 16) + (g << 8) + b;
	  };
	
	  chroma.num = function(num) {
	    return new Color(num, 'num');
	  };
	
	  Color.prototype.num = function(mode) {
	    if (mode == null) {
	      mode = 'rgb';
	    }
	    return rgb2num(this._rgb, mode);
	  };
	
	  _input.num = num2rgb;
	
	  _guess_formats.push({
	    p: 10,
	    test: function(n) {
	      if (arguments.length === 1 && type(n) === "number" && n >= 0 && n <= 0xFFFFFF) {
	        return 'num';
	      }
	    }
	  });
	
	  css2rgb = function(css) {
	    var aa, ab, hsl, i, m, o, rgb, w;
	    css = css.toLowerCase();
	    if ((chroma.colors != null) && chroma.colors[css]) {
	      return hex2rgb(chroma.colors[css]);
	    }
	    if (m = css.match(/rgb\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*\)/)) {
	      rgb = m.slice(1, 4);
	      for (i = o = 0; o <= 2; i = ++o) {
	        rgb[i] = +rgb[i];
	      }
	      rgb[3] = 1;
	    } else if (m = css.match(/rgba\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*,\s*([01]|[01]?\.\d+)\)/)) {
	      rgb = m.slice(1, 5);
	      for (i = w = 0; w <= 3; i = ++w) {
	        rgb[i] = +rgb[i];
	      }
	    } else if (m = css.match(/rgb\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
	      rgb = m.slice(1, 4);
	      for (i = aa = 0; aa <= 2; i = ++aa) {
	        rgb[i] = round(rgb[i] * 2.55);
	      }
	      rgb[3] = 1;
	    } else if (m = css.match(/rgba\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
	      rgb = m.slice(1, 5);
	      for (i = ab = 0; ab <= 2; i = ++ab) {
	        rgb[i] = round(rgb[i] * 2.55);
	      }
	      rgb[3] = +rgb[3];
	    } else if (m = css.match(/hsl\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
	      hsl = m.slice(1, 4);
	      hsl[1] *= 0.01;
	      hsl[2] *= 0.01;
	      rgb = hsl2rgb(hsl);
	      rgb[3] = 1;
	    } else if (m = css.match(/hsla\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
	      hsl = m.slice(1, 4);
	      hsl[1] *= 0.01;
	      hsl[2] *= 0.01;
	      rgb = hsl2rgb(hsl);
	      rgb[3] = +m[4];
	    }
	    return rgb;
	  };
	
	  rgb2css = function(rgba) {
	    var mode;
	    mode = rgba[3] < 1 ? 'rgba' : 'rgb';
	    if (mode === 'rgb') {
	      return mode + '(' + rgba.slice(0, 3).map(round).join(',') + ')';
	    } else if (mode === 'rgba') {
	      return mode + '(' + rgba.slice(0, 3).map(round).join(',') + ',' + rgba[3] + ')';
	    } else {
	
	    }
	  };
	
	  rnd = function(a) {
	    return round(a * 100) / 100;
	  };
	
	  hsl2css = function(hsl, alpha) {
	    var mode;
	    mode = alpha < 1 ? 'hsla' : 'hsl';
	    hsl[0] = rnd(hsl[0] || 0);
	    hsl[1] = rnd(hsl[1] * 100) + '%';
	    hsl[2] = rnd(hsl[2] * 100) + '%';
	    if (mode === 'hsla') {
	      hsl[3] = alpha;
	    }
	    return mode + '(' + hsl.join(',') + ')';
	  };
	
	  _input.css = function(h) {
	    return css2rgb(h);
	  };
	
	  chroma.css = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(Color, slice.call(arguments).concat(['css']), function(){});
	  };
	
	  Color.prototype.css = function(mode) {
	    if (mode == null) {
	      mode = 'rgb';
	    }
	    if (mode.slice(0, 3) === 'rgb') {
	      return rgb2css(this._rgb);
	    } else if (mode.slice(0, 3) === 'hsl') {
	      return hsl2css(this.hsl(), this.alpha());
	    }
	  };
	
	  _input.named = function(name) {
	    return hex2rgb(w3cx11[name]);
	  };
	
	  _guess_formats.push({
	    p: 20,
	    test: function(n) {
	      if (arguments.length === 1 && (w3cx11[n] != null)) {
	        return 'named';
	      }
	    }
	  });
	
	  Color.prototype.name = function(n) {
	    var h, k;
	    if (arguments.length) {
	      if (w3cx11[n]) {
	        this._rgb = hex2rgb(w3cx11[n]);
	      }
	      this._rgb[3] = 1;
	      this;
	    }
	    h = this.hex();
	    for (k in w3cx11) {
	      if (h === w3cx11[k]) {
	        return k;
	      }
	    }
	    return h;
	  };
	
	  lch2lab = function() {
	
	    /*
	    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.
	    These formulas were invented by David Dalrymple to obtain maximum contrast without going
	    out of gamut if the parameters are in the range 0-1.
	    
	    A saturation multiplier was added by Gregor Aisch
	     */
	    var c, h, l, ref;
	    ref = unpack(arguments), l = ref[0], c = ref[1], h = ref[2];
	    h = h * DEG2RAD;
	    return [l, cos(h) * c, sin(h) * c];
	  };
	
	  lch2rgb = function() {
	    var L, a, args, b, c, g, h, l, r, ref, ref1;
	    args = unpack(arguments);
	    l = args[0], c = args[1], h = args[2];
	    ref = lch2lab(l, c, h), L = ref[0], a = ref[1], b = ref[2];
	    ref1 = lab2rgb(L, a, b), r = ref1[0], g = ref1[1], b = ref1[2];
	    return [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255), args.length > 3 ? args[3] : 1];
	  };
	
	  lab2lch = function() {
	    var a, b, c, h, l, ref;
	    ref = unpack(arguments), l = ref[0], a = ref[1], b = ref[2];
	    c = sqrt(a * a + b * b);
	    h = (atan2(b, a) * RAD2DEG + 360) % 360;
	    if (round(c * 10000) === 0) {
	      h = Number.NaN;
	    }
	    return [l, c, h];
	  };
	
	  rgb2lch = function() {
	    var a, b, g, l, r, ref, ref1;
	    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
	    ref1 = rgb2lab(r, g, b), l = ref1[0], a = ref1[1], b = ref1[2];
	    return lab2lch(l, a, b);
	  };
	
	  chroma.lch = function() {
	    var args;
	    args = unpack(arguments);
	    return new Color(args, 'lch');
	  };
	
	  chroma.hcl = function() {
	    var args;
	    args = unpack(arguments);
	    return new Color(args, 'hcl');
	  };
	
	  _input.lch = lch2rgb;
	
	  _input.hcl = function() {
	    var c, h, l, ref;
	    ref = unpack(arguments), h = ref[0], c = ref[1], l = ref[2];
	    return lch2rgb([l, c, h]);
	  };
	
	  Color.prototype.lch = function() {
	    return rgb2lch(this._rgb);
	  };
	
	  Color.prototype.hcl = function() {
	    return rgb2lch(this._rgb).reverse();
	  };
	
	  rgb2cmyk = function(mode) {
	    var b, c, f, g, k, m, r, ref, y;
	    if (mode == null) {
	      mode = 'rgb';
	    }
	    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
	    r = r / 255;
	    g = g / 255;
	    b = b / 255;
	    k = 1 - Math.max(r, Math.max(g, b));
	    f = k < 1 ? 1 / (1 - k) : 0;
	    c = (1 - r - k) * f;
	    m = (1 - g - k) * f;
	    y = (1 - b - k) * f;
	    return [c, m, y, k];
	  };
	
	  cmyk2rgb = function() {
	    var alpha, args, b, c, g, k, m, r, y;
	    args = unpack(arguments);
	    c = args[0], m = args[1], y = args[2], k = args[3];
	    alpha = args.length > 4 ? args[4] : 1;
	    if (k === 1) {
	      return [0, 0, 0, alpha];
	    }
	    r = c >= 1 ? 0 : round(255 * (1 - c) * (1 - k));
	    g = m >= 1 ? 0 : round(255 * (1 - m) * (1 - k));
	    b = y >= 1 ? 0 : round(255 * (1 - y) * (1 - k));
	    return [r, g, b, alpha];
	  };
	
	  _input.cmyk = function() {
	    return cmyk2rgb(unpack(arguments));
	  };
	
	  chroma.cmyk = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(Color, slice.call(arguments).concat(['cmyk']), function(){});
	  };
	
	  Color.prototype.cmyk = function() {
	    return rgb2cmyk(this._rgb);
	  };
	
	  _input.gl = function() {
	    var i, k, o, rgb, v;
	    rgb = (function() {
	      var ref, results;
	      ref = unpack(arguments);
	      results = [];
	      for (k in ref) {
	        v = ref[k];
	        results.push(v);
	      }
	      return results;
	    }).apply(this, arguments);
	    for (i = o = 0; o <= 2; i = ++o) {
	      rgb[i] *= 255;
	    }
	    return rgb;
	  };
	
	  chroma.gl = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(Color, slice.call(arguments).concat(['gl']), function(){});
	  };
	
	  Color.prototype.gl = function() {
	    var rgb;
	    rgb = this._rgb;
	    return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];
	  };
	
	  rgb2luminance = function(r, g, b) {
	    var ref;
	    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
	    r = luminance_x(r);
	    g = luminance_x(g);
	    b = luminance_x(b);
	    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
	  };
	
	  luminance_x = function(x) {
	    x /= 255;
	    if (x <= 0.03928) {
	      return x / 12.92;
	    } else {
	      return pow((x + 0.055) / 1.055, 2.4);
	    }
	  };
	
	  _interpolators = [];
	
	  interpolate = function(col1, col2, f, m) {
	    var interpol, len, o, res;
	    if (f == null) {
	      f = 0.5;
	    }
	    if (m == null) {
	      m = 'rgb';
	    }
	
	    /*
	    interpolates between colors
	    f = 0 --> me
	    f = 1 --> col
	     */
	    if (type(col1) !== 'object') {
	      col1 = chroma(col1);
	    }
	    if (type(col2) !== 'object') {
	      col2 = chroma(col2);
	    }
	    for (o = 0, len = _interpolators.length; o < len; o++) {
	      interpol = _interpolators[o];
	      if (m === interpol[0]) {
	        res = interpol[1](col1, col2, f, m);
	        break;
	      }
	    }
	    if (res == null) {
	      throw "color mode " + m + " is not supported";
	    }
	    res.alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
	    return res;
	  };
	
	  chroma.interpolate = interpolate;
	
	  Color.prototype.interpolate = function(col2, f, m) {
	    return interpolate(this, col2, f, m);
	  };
	
	  chroma.mix = interpolate;
	
	  Color.prototype.mix = Color.prototype.interpolate;
	
	  interpolate_rgb = function(col1, col2, f, m) {
	    var xyz0, xyz1;
	    xyz0 = col1._rgb;
	    xyz1 = col2._rgb;
	    return new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
	  };
	
	  _interpolators.push(['rgb', interpolate_rgb]);
	
	  Color.prototype.luminance = function(lum, mode) {
	    var cur_lum, eps, max_iter, test;
	    if (mode == null) {
	      mode = 'rgb';
	    }
	    if (!arguments.length) {
	      return rgb2luminance(this._rgb);
	    }
	    if (lum === 0) {
	      this._rgb = [0, 0, 0, this._rgb[3]];
	    } else if (lum === 1) {
	      this._rgb = [255, 255, 255, this._rgb[3]];
	    } else {
	      eps = 1e-7;
	      max_iter = 20;
	      test = function(l, h) {
	        var lm, m;
	        m = l.interpolate(h, 0.5, mode);
	        lm = m.luminance();
	        if (Math.abs(lum - lm) < eps || !max_iter--) {
	          return m;
	        }
	        if (lm > lum) {
	          return test(l, m);
	        }
	        return test(m, h);
	      };
	      cur_lum = rgb2luminance(this._rgb);
	      this._rgb = (cur_lum > lum ? test(chroma('black'), this) : test(this, chroma('white'))).rgba();
	    }
	    return this;
	  };
	
	  temperature2rgb = function(kelvin) {
	    var b, g, r, temp;
	    temp = kelvin / 100;
	    if (temp < 66) {
	      r = 255;
	      g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);
	      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);
	    } else {
	      r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);
	      g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);
	      b = 255;
	    }
	    return clip_rgb([r, g, b]);
	  };
	
	  rgb2temperature = function() {
	    var b, eps, g, maxTemp, minTemp, r, ref, rgb, temp;
	    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
	    minTemp = 1000;
	    maxTemp = 40000;
	    eps = 0.4;
	    while (maxTemp - minTemp > eps) {
	      temp = (maxTemp + minTemp) * 0.5;
	      rgb = temperature2rgb(temp);
	      if ((rgb[2] / rgb[0]) >= (b / r)) {
	        maxTemp = temp;
	      } else {
	        minTemp = temp;
	      }
	    }
	    return round(temp);
	  };
	
	  chroma.temperature = chroma.kelvin = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(Color, slice.call(arguments).concat(['temperature']), function(){});
	  };
	
	  _input.temperature = _input.kelvin = _input.K = temperature2rgb;
	
	  Color.prototype.temperature = function() {
	    return rgb2temperature(this._rgb);
	  };
	
	  Color.prototype.kelvin = Color.prototype.temperature;
	
	  chroma.contrast = function(a, b) {
	    var l1, l2, ref, ref1;
	    if ((ref = type(a)) === 'string' || ref === 'number') {
	      a = new Color(a);
	    }
	    if ((ref1 = type(b)) === 'string' || ref1 === 'number') {
	      b = new Color(b);
	    }
	    l1 = a.luminance();
	    l2 = b.luminance();
	    if (l1 > l2) {
	      return (l1 + 0.05) / (l2 + 0.05);
	    } else {
	      return (l2 + 0.05) / (l1 + 0.05);
	    }
	  };
	
	  Color.prototype.get = function(modechan) {
	    var channel, i, me, mode, ref, src;
	    me = this;
	    ref = modechan.split('.'), mode = ref[0], channel = ref[1];
	    src = me[mode]();
	    if (channel) {
	      i = mode.indexOf(channel);
	      if (i > -1) {
	        return src[i];
	      } else {
	        return console.warn('unknown channel ' + channel + ' in mode ' + mode);
	      }
	    } else {
	      return src;
	    }
	  };
	
	  Color.prototype.set = function(modechan, value) {
	    var channel, i, me, mode, ref, src;
	    me = this;
	    ref = modechan.split('.'), mode = ref[0], channel = ref[1];
	    if (channel) {
	      src = me[mode]();
	      i = mode.indexOf(channel);
	      if (i > -1) {
	        if (type(value) === 'string') {
	          switch (value.charAt(0)) {
	            case '+':
	              src[i] += +value;
	              break;
	            case '-':
	              src[i] += +value;
	              break;
	            case '*':
	              src[i] *= +(value.substr(1));
	              break;
	            case '/':
	              src[i] /= +(value.substr(1));
	              break;
	            default:
	              src[i] = +value;
	          }
	        } else {
	          src[i] = value;
	        }
	      } else {
	        console.warn('unknown channel ' + channel + ' in mode ' + mode);
	      }
	    } else {
	      src = value;
	    }
	    me._rgb = chroma(src, mode).alpha(me.alpha())._rgb;
	    return me;
	  };
	
	  Color.prototype.darken = function(amount) {
	    var lab, me;
	    if (amount == null) {
	      amount = 1;
	    }
	    me = this;
	    lab = me.lab();
	    lab[0] -= LAB_CONSTANTS.Kn * amount;
	    return chroma.lab(lab).alpha(me.alpha());
	  };
	
	  Color.prototype.brighten = function(amount) {
	    if (amount == null) {
	      amount = 1;
	    }
	    return this.darken(-amount);
	  };
	
	  Color.prototype.darker = Color.prototype.darken;
	
	  Color.prototype.brighter = Color.prototype.brighten;
	
	  Color.prototype.saturate = function(amount) {
	    var lch, me;
	    if (amount == null) {
	      amount = 1;
	    }
	    me = this;
	    lch = me.lch();
	    lch[1] += amount * LAB_CONSTANTS.Kn;
	    if (lch[1] < 0) {
	      lch[1] = 0;
	    }
	    return chroma.lch(lch).alpha(me.alpha());
	  };
	
	  Color.prototype.desaturate = function(amount) {
	    if (amount == null) {
	      amount = 1;
	    }
	    return this.saturate(-amount);
	  };
	
	  Color.prototype.premultiply = function() {
	    var a, rgb;
	    rgb = this.rgb();
	    a = this.alpha();
	    return chroma(rgb[0] * a, rgb[1] * a, rgb[2] * a, a);
	  };
	
	  blend = function(bottom, top, mode) {
	    if (!blend[mode]) {
	      throw 'unknown blend mode ' + mode;
	    }
	    return blend[mode](bottom, top);
	  };
	
	  blend_f = function(f) {
	    return function(bottom, top) {
	      var c0, c1;
	      c0 = chroma(top).rgb();
	      c1 = chroma(bottom).rgb();
	      return chroma(f(c0, c1), 'rgb');
	    };
	  };
	
	  each = function(f) {
	    return function(c0, c1) {
	      var i, o, out;
	      out = [];
	      for (i = o = 0; o <= 3; i = ++o) {
	        out[i] = f(c0[i], c1[i]);
	      }
	      return out;
	    };
	  };
	
	  normal = function(a, b) {
	    return a;
	  };
	
	  multiply = function(a, b) {
	    return a * b / 255;
	  };
	
	  darken = function(a, b) {
	    if (a > b) {
	      return b;
	    } else {
	      return a;
	    }
	  };
	
	  lighten = function(a, b) {
	    if (a > b) {
	      return a;
	    } else {
	      return b;
	    }
	  };
	
	  screen = function(a, b) {
	    return 255 * (1 - (1 - a / 255) * (1 - b / 255));
	  };
	
	  overlay = function(a, b) {
	    if (b < 128) {
	      return 2 * a * b / 255;
	    } else {
	      return 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
	    }
	  };
	
	  burn = function(a, b) {
	    return 255 * (1 - (1 - b / 255) / (a / 255));
	  };
	
	  dodge = function(a, b) {
	    if (a === 255) {
	      return 255;
	    }
	    a = 255 * (b / 255) / (1 - a / 255);
	    if (a > 255) {
	      return 255;
	    } else {
	      return a;
	    }
	  };
	
	  blend.normal = blend_f(each(normal));
	
	  blend.multiply = blend_f(each(multiply));
	
	  blend.screen = blend_f(each(screen));
	
	  blend.overlay = blend_f(each(overlay));
	
	  blend.darken = blend_f(each(darken));
	
	  blend.lighten = blend_f(each(lighten));
	
	  blend.dodge = blend_f(each(dodge));
	
	  blend.burn = blend_f(each(burn));
	
	  chroma.blend = blend;
	
	  chroma.analyze = function(data) {
	    var len, o, r, val;
	    r = {
	      min: Number.MAX_VALUE,
	      max: Number.MAX_VALUE * -1,
	      sum: 0,
	      values: [],
	      count: 0
	    };
	    for (o = 0, len = data.length; o < len; o++) {
	      val = data[o];
	      if ((val != null) && !isNaN(val)) {
	        r.values.push(val);
	        r.sum += val;
	        if (val < r.min) {
	          r.min = val;
	        }
	        if (val > r.max) {
	          r.max = val;
	        }
	        r.count += 1;
	      }
	    }
	    r.domain = [r.min, r.max];
	    r.limits = function(mode, num) {
	      return chroma.limits(r, mode, num);
	    };
	    return r;
	  };
	
	  chroma.scale = function(colors, positions) {
	    var _classes, _colorCache, _colors, _correctLightness, _domain, _fixed, _max, _min, _mode, _nacol, _out, _padding, _pos, _spread, classifyValue, f, getClass, getColor, resetCache, setColors, tmap;
	    _mode = 'rgb';
	    _nacol = chroma('#ccc');
	    _spread = 0;
	    _fixed = false;
	    _domain = [0, 1];
	    _pos = [];
	    _padding = [0, 0];
	    _classes = false;
	    _colors = [];
	    _out = false;
	    _min = 0;
	    _max = 1;
	    _correctLightness = false;
	    _colorCache = {};
	    setColors = function(colors) {
	      var c, col, o, ref, ref1, ref2, w;
	      if (colors == null) {
	        colors = ['#fff', '#000'];
	      }
	      if ((colors != null) && type(colors) === 'string' && (((ref = chroma.brewer) != null ? ref[colors] : void 0) != null)) {
	        colors = chroma.brewer[colors];
	      }
	      if (type(colors) === 'array') {
	        colors = colors.slice(0);
	        for (c = o = 0, ref1 = colors.length - 1; 0 <= ref1 ? o <= ref1 : o >= ref1; c = 0 <= ref1 ? ++o : --o) {
	          col = colors[c];
	          if (type(col) === "string") {
	            colors[c] = chroma(col);
	          }
	        }
	        _pos.length = 0;
	        for (c = w = 0, ref2 = colors.length - 1; 0 <= ref2 ? w <= ref2 : w >= ref2; c = 0 <= ref2 ? ++w : --w) {
	          _pos.push(c / (colors.length - 1));
	        }
	      }
	      resetCache();
	      return _colors = colors;
	    };
	    getClass = function(value) {
	      var i, n;
	      if (_classes != null) {
	        n = _classes.length - 1;
	        i = 0;
	        while (i < n && value >= _classes[i]) {
	          i++;
	        }
	        return i - 1;
	      }
	      return 0;
	    };
	    tmap = function(t) {
	      return t;
	    };
	    classifyValue = function(value) {
	      var i, maxc, minc, n, val;
	      val = value;
	      if (_classes.length > 2) {
	        n = _classes.length - 1;
	        i = getClass(value);
	        minc = _classes[0] + (_classes[1] - _classes[0]) * (0 + _spread * 0.5);
	        maxc = _classes[n - 1] + (_classes[n] - _classes[n - 1]) * (1 - _spread * 0.5);
	        val = _min + ((_classes[i] + (_classes[i + 1] - _classes[i]) * 0.5 - minc) / (maxc - minc)) * (_max - _min);
	      }
	      return val;
	    };
	    getColor = function(val, bypassMap) {
	      var c, col, i, k, o, p, ref, t;
	      if (bypassMap == null) {
	        bypassMap = false;
	      }
	      if (isNaN(val)) {
	        return _nacol;
	      }
	      if (!bypassMap) {
	        if (_classes && _classes.length > 2) {
	          c = getClass(val);
	          t = c / (_classes.length - 2);
	          t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));
	        } else if (_max !== _min) {
	          t = (val - _min) / (_max - _min);
	          t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));
	          t = Math.min(1, Math.max(0, t));
	        } else {
	          t = 1;
	        }
	      } else {
	        t = val;
	      }
	      if (!bypassMap) {
	        t = tmap(t);
	      }
	      k = Math.floor(t * 10000);
	      if (_colorCache[k]) {
	        col = _colorCache[k];
	      } else {
	        if (type(_colors) === 'array') {
	          for (i = o = 0, ref = _pos.length - 1; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {
	            p = _pos[i];
	            if (t <= p) {
	              col = _colors[i];
	              break;
	            }
	            if (t >= p && i === _pos.length - 1) {
	              col = _colors[i];
	              break;
	            }
	            if (t > p && t < _pos[i + 1]) {
	              t = (t - p) / (_pos[i + 1] - p);
	              col = chroma.interpolate(_colors[i], _colors[i + 1], t, _mode);
	              break;
	            }
	          }
	        } else if (type(_colors) === 'function') {
	          col = _colors(t);
	        }
	        _colorCache[k] = col;
	      }
	      return col;
	    };
	    resetCache = function() {
	      return _colorCache = {};
	    };
	    setColors(colors);
	    f = function(v) {
	      var c;
	      c = chroma(getColor(v));
	      if (_out && c[_out]) {
	        return c[_out]();
	      } else {
	        return c;
	      }
	    };
	    f.classes = function(classes) {
	      var d;
	      if (classes != null) {
	        if (type(classes) === 'array') {
	          _classes = classes;
	          _domain = [classes[0], classes[classes.length - 1]];
	        } else {
	          d = chroma.analyze(_domain);
	          if (classes === 0) {
	            _classes = [d.min, d.max];
	          } else {
	            _classes = chroma.limits(d, 'e', classes);
	          }
	        }
	        return f;
	      }
	      return _classes;
	    };
	    f.domain = function(domain) {
	      var c, d, k, len, o, ref, w;
	      if (!arguments.length) {
	        return _domain;
	      }
	      _min = domain[0];
	      _max = domain[domain.length - 1];
	      _pos = [];
	      k = _colors.length;
	      if (domain.length === k && _min !== _max) {
	        for (o = 0, len = domain.length; o < len; o++) {
	          d = domain[o];
	          _pos.push((d - _min) / (_max - _min));
	        }
	      } else {
	        for (c = w = 0, ref = k - 1; 0 <= ref ? w <= ref : w >= ref; c = 0 <= ref ? ++w : --w) {
	          _pos.push(c / (k - 1));
	        }
	      }
	      _domain = [_min, _max];
	      return f;
	    };
	    f.mode = function(_m) {
	      if (!arguments.length) {
	        return _mode;
	      }
	      _mode = _m;
	      resetCache();
	      return f;
	    };
	    f.range = function(colors, _pos) {
	      setColors(colors, _pos);
	      return f;
	    };
	    f.out = function(_o) {
	      _out = _o;
	      return f;
	    };
	    f.spread = function(val) {
	      if (!arguments.length) {
	        return _spread;
	      }
	      _spread = val;
	      return f;
	    };
	    f.correctLightness = function(v) {
	      if (v == null) {
	        v = true;
	      }
	      _correctLightness = v;
	      resetCache();
	      if (_correctLightness) {
	        tmap = function(t) {
	          var L0, L1, L_actual, L_diff, L_ideal, max_iter, pol, t0, t1;
	          L0 = getColor(0, true).lab()[0];
	          L1 = getColor(1, true).lab()[0];
	          pol = L0 > L1;
	          L_actual = getColor(t, true).lab()[0];
	          L_ideal = L0 + (L1 - L0) * t;
	          L_diff = L_actual - L_ideal;
	          t0 = 0;
	          t1 = 1;
	          max_iter = 20;
	          while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {
	            (function() {
	              if (pol) {
	                L_diff *= -1;
	              }
	              if (L_diff < 0) {
	                t0 = t;
	                t += (t1 - t) * 0.5;
	              } else {
	                t1 = t;
	                t += (t0 - t) * 0.5;
	              }
	              L_actual = getColor(t, true).lab()[0];
	              return L_diff = L_actual - L_ideal;
	            })();
	          }
	          return t;
	        };
	      } else {
	        tmap = function(t) {
	          return t;
	        };
	      }
	      return f;
	    };
	    f.padding = function(p) {
	      if (p != null) {
	        if (type(p) === 'number') {
	          p = [p, p];
	        }
	        _padding = p;
	        return f;
	      } else {
	        return _padding;
	      }
	    };
	    f.colors = function() {
	      var dd, dm, i, numColors, o, out, ref, results, samples, w;
	      numColors = 0;
	      out = 'hex';
	      if (arguments.length === 1) {
	        if (type(arguments[0]) === 'string') {
	          out = arguments[0];
	        } else {
	          numColors = arguments[0];
	        }
	      }
	      if (arguments.length === 2) {
	        numColors = arguments[0], out = arguments[1];
	      }
	      if (numColors) {
	        dm = _domain[0];
	        dd = _domain[1] - dm;
	        return (function() {
	          results = [];
	          for (var o = 0; 0 <= numColors ? o < numColors : o > numColors; 0 <= numColors ? o++ : o--){ results.push(o); }
	          return results;
	        }).apply(this).map(function(i) {
	          return f(dm + i / (numColors - 1) * dd)[out]();
	        });
	      }
	      colors = [];
	      samples = [];
	      if (_classes && _classes.length > 2) {
	        for (i = w = 1, ref = _classes.length; 1 <= ref ? w < ref : w > ref; i = 1 <= ref ? ++w : --w) {
	          samples.push((_classes[i - 1] + _classes[i]) * 0.5);
	        }
	      } else {
	        samples = _domain;
	      }
	      return samples.map(function(v) {
	        return f(v)[out]();
	      });
	    };
	    return f;
	  };
	
	  if (chroma.scales == null) {
	    chroma.scales = {};
	  }
	
	  chroma.scales.cool = function() {
	    return chroma.scale([chroma.hsl(180, 1, .9), chroma.hsl(250, .7, .4)]);
	  };
	
	  chroma.scales.hot = function() {
	    return chroma.scale(['#000', '#f00', '#ff0', '#fff'], [0, .25, .75, 1]).mode('rgb');
	  };
	
	  chroma.analyze = function(data, key, filter) {
	    var add, k, len, o, r, val, visit;
	    r = {
	      min: Number.MAX_VALUE,
	      max: Number.MAX_VALUE * -1,
	      sum: 0,
	      values: [],
	      count: 0
	    };
	    if (filter == null) {
	      filter = function() {
	        return true;
	      };
	    }
	    add = function(val) {
	      if ((val != null) && !isNaN(val)) {
	        r.values.push(val);
	        r.sum += val;
	        if (val < r.min) {
	          r.min = val;
	        }
	        if (val > r.max) {
	          r.max = val;
	        }
	        r.count += 1;
	      }
	    };
	    visit = function(val, k) {
	      if (filter(val, k)) {
	        if ((key != null) && type(key) === 'function') {
	          return add(key(val));
	        } else if ((key != null) && type(key) === 'string' || type(key) === 'number') {
	          return add(val[key]);
	        } else {
	          return add(val);
	        }
	      }
	    };
	    if (type(data) === 'array') {
	      for (o = 0, len = data.length; o < len; o++) {
	        val = data[o];
	        visit(val);
	      }
	    } else {
	      for (k in data) {
	        val = data[k];
	        visit(val, k);
	      }
	    }
	    r.domain = [r.min, r.max];
	    r.limits = function(mode, num) {
	      return chroma.limits(r, mode, num);
	    };
	    return r;
	  };
	
	  chroma.limits = function(data, mode, num) {
	    var aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, assignments, best, centroids, cluster, clusterSizes, dist, i, j, kClusters, limits, max_log, min, min_log, mindist, n, nb_iters, newCentroids, o, p, pb, pr, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, repeat, sum, tmpKMeansBreaks, value, values, w;
	    if (mode == null) {
	      mode = 'equal';
	    }
	    if (num == null) {
	      num = 7;
	    }
	    if (type(data) === 'array') {
	      data = chroma.analyze(data);
	    }
	    min = data.min;
	    max = data.max;
	    sum = data.sum;
	    values = data.values.sort(function(a, b) {
	      return a - b;
	    });
	    limits = [];
	    if (mode.substr(0, 1) === 'c') {
	      limits.push(min);
	      limits.push(max);
	    }
	    if (mode.substr(0, 1) === 'e') {
	      limits.push(min);
	      for (i = o = 1, ref = num - 1; 1 <= ref ? o <= ref : o >= ref; i = 1 <= ref ? ++o : --o) {
	        limits.push(min + (i / num) * (max - min));
	      }
	      limits.push(max);
	    } else if (mode.substr(0, 1) === 'l') {
	      if (min <= 0) {
	        throw 'Logarithmic scales are only possible for values > 0';
	      }
	      min_log = Math.LOG10E * log(min);
	      max_log = Math.LOG10E * log(max);
	      limits.push(min);
	      for (i = w = 1, ref1 = num - 1; 1 <= ref1 ? w <= ref1 : w >= ref1; i = 1 <= ref1 ? ++w : --w) {
	        limits.push(pow(10, min_log + (i / num) * (max_log - min_log)));
	      }
	      limits.push(max);
	    } else if (mode.substr(0, 1) === 'q') {
	      limits.push(min);
	      for (i = aa = 1, ref2 = num - 1; 1 <= ref2 ? aa <= ref2 : aa >= ref2; i = 1 <= ref2 ? ++aa : --aa) {
	        p = values.length * i / num;
	        pb = floor(p);
	        if (pb === p) {
	          limits.push(values[pb]);
	        } else {
	          pr = p - pb;
	          limits.push(values[pb] * pr + values[pb + 1] * (1 - pr));
	        }
	      }
	      limits.push(max);
	    } else if (mode.substr(0, 1) === 'k') {
	
	      /*
	      implementation based on
	      http://code.google.com/p/figue/source/browse/trunk/figue.js#336
	      simplified for 1-d input values
	       */
	      n = values.length;
	      assignments = new Array(n);
	      clusterSizes = new Array(num);
	      repeat = true;
	      nb_iters = 0;
	      centroids = null;
	      centroids = [];
	      centroids.push(min);
	      for (i = ab = 1, ref3 = num - 1; 1 <= ref3 ? ab <= ref3 : ab >= ref3; i = 1 <= ref3 ? ++ab : --ab) {
	        centroids.push(min + (i / num) * (max - min));
	      }
	      centroids.push(max);
	      while (repeat) {
	        for (j = ac = 0, ref4 = num - 1; 0 <= ref4 ? ac <= ref4 : ac >= ref4; j = 0 <= ref4 ? ++ac : --ac) {
	          clusterSizes[j] = 0;
	        }
	        for (i = ad = 0, ref5 = n - 1; 0 <= ref5 ? ad <= ref5 : ad >= ref5; i = 0 <= ref5 ? ++ad : --ad) {
	          value = values[i];
	          mindist = Number.MAX_VALUE;
	          for (j = ae = 0, ref6 = num - 1; 0 <= ref6 ? ae <= ref6 : ae >= ref6; j = 0 <= ref6 ? ++ae : --ae) {
	            dist = abs(centroids[j] - value);
	            if (dist < mindist) {
	              mindist = dist;
	              best = j;
	            }
	          }
	          clusterSizes[best]++;
	          assignments[i] = best;
	        }
	        newCentroids = new Array(num);
	        for (j = af = 0, ref7 = num - 1; 0 <= ref7 ? af <= ref7 : af >= ref7; j = 0 <= ref7 ? ++af : --af) {
	          newCentroids[j] = null;
	        }
	        for (i = ag = 0, ref8 = n - 1; 0 <= ref8 ? ag <= ref8 : ag >= ref8; i = 0 <= ref8 ? ++ag : --ag) {
	          cluster = assignments[i];
	          if (newCentroids[cluster] === null) {
	            newCentroids[cluster] = values[i];
	          } else {
	            newCentroids[cluster] += values[i];
	          }
	        }
	        for (j = ah = 0, ref9 = num - 1; 0 <= ref9 ? ah <= ref9 : ah >= ref9; j = 0 <= ref9 ? ++ah : --ah) {
	          newCentroids[j] *= 1 / clusterSizes[j];
	        }
	        repeat = false;
	        for (j = ai = 0, ref10 = num - 1; 0 <= ref10 ? ai <= ref10 : ai >= ref10; j = 0 <= ref10 ? ++ai : --ai) {
	          if (newCentroids[j] !== centroids[i]) {
	            repeat = true;
	            break;
	          }
	        }
	        centroids = newCentroids;
	        nb_iters++;
	        if (nb_iters > 200) {
	          repeat = false;
	        }
	      }
	      kClusters = {};
	      for (j = aj = 0, ref11 = num - 1; 0 <= ref11 ? aj <= ref11 : aj >= ref11; j = 0 <= ref11 ? ++aj : --aj) {
	        kClusters[j] = [];
	      }
	      for (i = ak = 0, ref12 = n - 1; 0 <= ref12 ? ak <= ref12 : ak >= ref12; i = 0 <= ref12 ? ++ak : --ak) {
	        cluster = assignments[i];
	        kClusters[cluster].push(values[i]);
	      }
	      tmpKMeansBreaks = [];
	      for (j = al = 0, ref13 = num - 1; 0 <= ref13 ? al <= ref13 : al >= ref13; j = 0 <= ref13 ? ++al : --al) {
	        tmpKMeansBreaks.push(kClusters[j][0]);
	        tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);
	      }
	      tmpKMeansBreaks = tmpKMeansBreaks.sort(function(a, b) {
	        return a - b;
	      });
	      limits.push(tmpKMeansBreaks[0]);
	      for (i = am = 1, ref14 = tmpKMeansBreaks.length - 1; am <= ref14; i = am += 2) {
	        if (!isNaN(tmpKMeansBreaks[i])) {
	          limits.push(tmpKMeansBreaks[i]);
	        }
	      }
	    }
	    return limits;
	  };
	
	  hsi2rgb = function(h, s, i) {
	
	    /*
	    borrowed from here:
	    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
	     */
	    var args, b, g, r;
	    args = unpack(arguments);
	    h = args[0], s = args[1], i = args[2];
	    h /= 360;
	    if (h < 1 / 3) {
	      b = (1 - s) / 3;
	      r = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
	      g = 1 - (b + r);
	    } else if (h < 2 / 3) {
	      h -= 1 / 3;
	      r = (1 - s) / 3;
	      g = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
	      b = 1 - (r + g);
	    } else {
	      h -= 2 / 3;
	      g = (1 - s) / 3;
	      b = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
	      r = 1 - (g + b);
	    }
	    r = limit(i * r * 3);
	    g = limit(i * g * 3);
	    b = limit(i * b * 3);
	    return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];
	  };
	
	  rgb2hsi = function() {
	
	    /*
	    borrowed from here:
	    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
	     */
	    var b, g, h, i, min, r, ref, s;
	    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
	    TWOPI = Math.PI * 2;
	    r /= 255;
	    g /= 255;
	    b /= 255;
	    min = Math.min(r, g, b);
	    i = (r + g + b) / 3;
	    s = 1 - min / i;
	    if (s === 0) {
	      h = 0;
	    } else {
	      h = ((r - g) + (r - b)) / 2;
	      h /= Math.sqrt((r - g) * (r - g) + (r - b) * (g - b));
	      h = Math.acos(h);
	      if (b > g) {
	        h = TWOPI - h;
	      }
	      h /= TWOPI;
	    }
	    return [h * 360, s, i];
	  };
	
	  chroma.hsi = function() {
	    return (function(func, args, ctor) {
	      ctor.prototype = func.prototype;
	      var child = new ctor, result = func.apply(child, args);
	      return Object(result) === result ? result : child;
	    })(Color, slice.call(arguments).concat(['hsi']), function(){});
	  };
	
	  _input.hsi = hsi2rgb;
	
	  Color.prototype.hsi = function() {
	    return rgb2hsi(this._rgb);
	  };
	
	  interpolate_hsx = function(col1, col2, f, m) {
	    var dh, hue, hue0, hue1, lbv, lbv0, lbv1, res, sat, sat0, sat1, xyz0, xyz1;
	    if (m === 'hsl') {
	      xyz0 = col1.hsl();
	      xyz1 = col2.hsl();
	    } else if (m === 'hsv') {
	      xyz0 = col1.hsv();
	      xyz1 = col2.hsv();
	    } else if (m === 'hsi') {
	      xyz0 = col1.hsi();
	      xyz1 = col2.hsi();
	    } else if (m === 'lch' || m === 'hcl') {
	      m = 'hcl';
	      xyz0 = col1.hcl();
	      xyz1 = col2.hcl();
	    }
	    if (m.substr(0, 1) === 'h') {
	      hue0 = xyz0[0], sat0 = xyz0[1], lbv0 = xyz0[2];
	      hue1 = xyz1[0], sat1 = xyz1[1], lbv1 = xyz1[2];
	    }
	    if (!isNaN(hue0) && !isNaN(hue1)) {
	      if (hue1 > hue0 && hue1 - hue0 > 180) {
	        dh = hue1 - (hue0 + 360);
	      } else if (hue1 < hue0 && hue0 - hue1 > 180) {
	        dh = hue1 + 360 - hue0;
	      } else {
	        dh = hue1 - hue0;
	      }
	      hue = hue0 + f * dh;
	    } else if (!isNaN(hue0)) {
	      hue = hue0;
	      if ((lbv1 === 1 || lbv1 === 0) && m !== 'hsv') {
	        sat = sat0;
	      }
	    } else if (!isNaN(hue1)) {
	      hue = hue1;
	      if ((lbv0 === 1 || lbv0 === 0) && m !== 'hsv') {
	        sat = sat1;
	      }
	    } else {
	      hue = Number.NaN;
	    }
	    if (sat == null) {
	      sat = sat0 + f * (sat1 - sat0);
	    }
	    lbv = lbv0 + f * (lbv1 - lbv0);
	    return res = chroma[m](hue, sat, lbv);
	  };
	
	  _interpolators = _interpolators.concat((function() {
	    var len, o, ref, results;
	    ref = ['hsv', 'hsl', 'hsi', 'hcl', 'lch'];
	    results = [];
	    for (o = 0, len = ref.length; o < len; o++) {
	      m = ref[o];
	      results.push([m, interpolate_hsx]);
	    }
	    return results;
	  })());
	
	  interpolate_num = function(col1, col2, f, m) {
	    var n1, n2;
	    n1 = col1.num();
	    n2 = col2.num();
	    return chroma.num(n1 + (n2 - n1) * f, 'num');
	  };
	
	  _interpolators.push(['num', interpolate_num]);
	
	  interpolate_lab = function(col1, col2, f, m) {
	    var res, xyz0, xyz1;
	    xyz0 = col1.lab();
	    xyz1 = col2.lab();
	    return res = new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
	  };
	
	  _interpolators.push(['lab', interpolate_lab]);
	
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(149)(module)))

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(280);
	module.exports = __webpack_require__(5).Array.isArray;

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(282);
	module.exports = __webpack_require__(5).Array.reduceRight;

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(284);
	module.exports = __webpack_require__(5).Array.some;

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(286);
	var $Object = __webpack_require__(5).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(85)
	  , isArray  = __webpack_require__(175)
	  , SPECIES  = __webpack_require__(276)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(260);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 262 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(114)
	  , createDesc = __webpack_require__(273);
	module.exports = __webpack_require__(56) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(58).document && document.documentElement;

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(56) && !__webpack_require__(57)(function(){
	  return Object.defineProperty(__webpack_require__(173)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(115)
	  , gOPS     = __webpack_require__(269)
	  , pIE      = __webpack_require__(271)
	  , toObject = __webpack_require__(86)
	  , IObject  = __webpack_require__(84)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(57)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(113)
	  , dPs         = __webpack_require__(268)
	  , enumBugKeys = __webpack_require__(174)
	  , IE_PROTO    = __webpack_require__(176)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(173)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(264).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(114)
	  , anObject = __webpack_require__(113)
	  , getKeys  = __webpack_require__(115);
	
	module.exports = __webpack_require__(56) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 269 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(262)
	  , toIObject    = __webpack_require__(179)
	  , arrayIndexOf = __webpack_require__(168)(false)
	  , IE_PROTO     = __webpack_require__(176)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 271 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(8)
	  , core    = __webpack_require__(5)
	  , fails   = __webpack_require__(57);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 273 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(178)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(85);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(177)('wks')
	  , uid        = __webpack_require__(180)
	  , Symbol     = __webpack_require__(58).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $filter = __webpack_require__(83)(2);
	
	$export($export.P + $export.F * !__webpack_require__(28)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */){
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export  = __webpack_require__(8)
	  , $forEach = __webpack_require__(83)(0)
	  , STRICT   = __webpack_require__(28)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */){
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(8)
	  , $indexOf      = __webpack_require__(168)(false)
	  , $native       = [].indexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(28)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Array', {isArray: __webpack_require__(175)});

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $map    = __webpack_require__(83)(1);
	
	$export($export.P + $export.F * !__webpack_require__(28)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */){
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(169);
	
	$export($export.P + $export.F * !__webpack_require__(28)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(169);
	
	$export($export.P + $export.F * !__webpack_require__(28)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $some   = __webpack_require__(83)(3);
	
	$export($export.P + $export.F * !__webpack_require__(28)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */){
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(8);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(266)});

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(267)});

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(56), 'Object', {defineProperty: __webpack_require__(114).f});

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(86)
	  , $keys    = __webpack_require__(115);
	
	__webpack_require__(272)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var keys = __webpack_require__(211);
	var foreach = __webpack_require__(332);
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';
	
	var toStr = Object.prototype.toString;
	
	var isFunction = function (fn) {
		return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
	};
	
	var arePropertyDescriptorsSupported = function () {
		var obj = {};
		try {
			Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
	        /* eslint-disable no-unused-vars, no-restricted-syntax */
	        for (var _ in obj) { return false; }
	        /* eslint-enable no-unused-vars, no-restricted-syntax */
			return obj.x === obj;
		} catch (e) { /* this is IE 8. */
			return false;
		}
	};
	var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();
	
	var defineProperty = function (object, name, value, predicate) {
		if (name in object && (!isFunction(predicate) || !predicate())) {
			return;
		}
		if (supportsDescriptors) {
			Object.defineProperty(object, name, {
				configurable: true,
				enumerable: false,
				value: value,
				writable: true
			});
		} else {
			object[name] = value;
		}
	};
	
	var defineProperties = function (object, map) {
		var predicates = arguments.length > 2 ? arguments[2] : {};
		var props = keys(map);
		if (hasSymbols) {
			props = props.concat(Object.getOwnPropertySymbols(map));
		}
		foreach(props, function (name) {
			defineProperty(object, name, map[name], predicates[name]);
		});
	};
	
	defineProperties.supportsDescriptors = !!supportsDescriptors;
	
	module.exports = defineProperties;


/***/ },
/* 316 */
/***/ function(module, exports) {

	'use strict'
	
	/**
	 * Diff Match and Patch
	 *
	 * Copyright 2006 Google Inc.
	 * http://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/**
	 * @fileoverview Computes the difference between two texts to create a patch.
	 * Applies the patch onto another text, allowing for errors.
	 * @author fraser@google.com (Neil Fraser)
	 */
	
	/**
	 * Class containing the diff, match and patch methods.
	 * @constructor
	 */
	function diff_match_patch() {
	
	  // Defaults.
	  // Redefine these in your program to override the defaults.
	
	  // Number of seconds to map a diff before giving up (0 for infinity).
	  this.Diff_Timeout = 1.0;
	  // Cost of an empty edit operation in terms of edit characters.
	  this.Diff_EditCost = 4;
	  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
	  this.Match_Threshold = 0.5;
	  // How far to search for a match (0 = exact location, 1000+ = broad match).
	  // A match this many characters away from the expected location will add
	  // 1.0 to the score (0.0 is a perfect match).
	  this.Match_Distance = 1000;
	  // When deleting a large block of text (over ~64 characters), how close do
	  // the contents have to be to match the expected contents. (0.0 = perfection,
	  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
	  // end points of a delete need to match.
	  this.Patch_DeleteThreshold = 0.5;
	  // Chunk size for context length.
	  this.Patch_Margin = 4;
	
	  // The number of bits in an int.
	  this.Match_MaxBits = 32;
	}
	
	
	//  DIFF FUNCTIONS
	
	
	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE = -1;
	var DIFF_INSERT = 1;
	var DIFF_EQUAL = 0;
	
	/** @typedef {{0: number, 1: string}} */
	diff_match_patch.Diff;
	
	
	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
	 *     then don't run a line-level diff first to identify the changed areas.
	 *     Defaults to true, which does a faster, slightly less optimal diff.
	 * @param {number} opt_deadline Optional time when the diff should be complete
	 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
	 *     instead.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
	    opt_deadline) {
	  // Set a deadline by which time the diff must be complete.
	  if (typeof opt_deadline == 'undefined') {
	    if (this.Diff_Timeout <= 0) {
	      opt_deadline = Number.MAX_VALUE;
	    } else {
	      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
	    }
	  }
	  var deadline = opt_deadline;
	
	  // Check for null inputs.
	  if (text1 == null || text2 == null) {
	    throw new Error('Null input. (diff_main)');
	  }
	
	  // Check for equality (speedup).
	  if (text1 == text2) {
	    if (text1) {
	      return [[DIFF_EQUAL, text1]];
	    }
	    return [];
	  }
	
	  if (typeof opt_checklines == 'undefined') {
	    opt_checklines = true;
	  }
	  var checklines = opt_checklines;
	
	  // Trim off common prefix (speedup).
	  var commonlength = this.diff_commonPrefix(text1, text2);
	  var commonprefix = text1.substring(0, commonlength);
	  text1 = text1.substring(commonlength);
	  text2 = text2.substring(commonlength);
	
	  // Trim off common suffix (speedup).
	  commonlength = this.diff_commonSuffix(text1, text2);
	  var commonsuffix = text1.substring(text1.length - commonlength);
	  text1 = text1.substring(0, text1.length - commonlength);
	  text2 = text2.substring(0, text2.length - commonlength);
	
	  // Compute the diff on the middle block.
	  var diffs = this.diff_compute_(text1, text2, checklines, deadline);
	
	  // Restore the prefix and suffix.
	  if (commonprefix) {
	    diffs.unshift([DIFF_EQUAL, commonprefix]);
	  }
	  if (commonsuffix) {
	    diffs.push([DIFF_EQUAL, commonsuffix]);
	  }
	  this.diff_cleanupMerge(diffs);
	  return diffs;
	};
	
	
	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {boolean} checklines Speedup flag.  If false, then don't run a
	 *     line-level diff first to identify the changed areas.
	 *     If true, then run a faster, slightly less optimal diff.
	 * @param {number} deadline Time when the diff should be complete by.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
	    deadline) {
	  var diffs;
	
	  if (!text1) {
	    // Just add some text (speedup).
	    return [[DIFF_INSERT, text2]];
	  }
	
	  if (!text2) {
	    // Just delete some text (speedup).
	    return [[DIFF_DELETE, text1]];
	  }
	
	  var longtext = text1.length > text2.length ? text1 : text2;
	  var shorttext = text1.length > text2.length ? text2 : text1;
	  var i = longtext.indexOf(shorttext);
	  if (i != -1) {
	    // Shorter text is inside the longer text (speedup).
	    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
	             [DIFF_EQUAL, shorttext],
	             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
	    // Swap insertions for deletions if diff is reversed.
	    if (text1.length > text2.length) {
	      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
	    }
	    return diffs;
	  }
	
	  if (shorttext.length == 1) {
	    // Single character string.
	    // After the previous speedup, the character can't be an equality.
	    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
	  }
	
	  // Check to see if the problem can be split in two.
	  var hm = this.diff_halfMatch_(text1, text2);
	  if (hm) {
	    // A half-match was found, sort out the return data.
	    var text1_a = hm[0];
	    var text1_b = hm[1];
	    var text2_a = hm[2];
	    var text2_b = hm[3];
	    var mid_common = hm[4];
	    // Send both pairs off for separate processing.
	    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
	    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
	    // Merge the results.
	    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
	  }
	
	  if (checklines && text1.length > 100 && text2.length > 100) {
	    return this.diff_lineMode_(text1, text2, deadline);
	  }
	
	  return this.diff_bisect_(text1, text2, deadline);
	};
	
	
	/**
	 * Do a quick line-level diff on both strings, then rediff the parts for
	 * greater accuracy.
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} deadline Time when the diff should be complete by.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
	  // Scan the text on a line-by-line basis first.
	  var a = this.diff_linesToChars_(text1, text2);
	  text1 = a.chars1;
	  text2 = a.chars2;
	  var linearray = a.lineArray;
	
	  var diffs = this.diff_main(text1, text2, false, deadline);
	
	  // Convert the diff back to original text.
	  this.diff_charsToLines_(diffs, linearray);
	  // Eliminate freak matches (e.g. blank lines)
	  this.diff_cleanupSemantic(diffs);
	
	  // Rediff any replacement blocks, this time character-by-character.
	  // Add a dummy entry at the end.
	  diffs.push([DIFF_EQUAL, '']);
	  var pointer = 0;
	  var count_delete = 0;
	  var count_insert = 0;
	  var text_delete = '';
	  var text_insert = '';
	  while (pointer < diffs.length) {
	    switch (diffs[pointer][0]) {
	      case DIFF_INSERT:
	        count_insert++;
	        text_insert += diffs[pointer][1];
	        break;
	      case DIFF_DELETE:
	        count_delete++;
	        text_delete += diffs[pointer][1];
	        break;
	      case DIFF_EQUAL:
	        // Upon reaching an equality, check for prior redundancies.
	        if (count_delete >= 1 && count_insert >= 1) {
	          // Delete the offending records and add the merged ones.
	          diffs.splice(pointer - count_delete - count_insert,
	                       count_delete + count_insert);
	          pointer = pointer - count_delete - count_insert;
	          var a = this.diff_main(text_delete, text_insert, false, deadline);
	          for (var j = a.length - 1; j >= 0; j--) {
	            diffs.splice(pointer, 0, a[j]);
	          }
	          pointer = pointer + a.length;
	        }
	        count_insert = 0;
	        count_delete = 0;
	        text_delete = '';
	        text_insert = '';
	        break;
	    }
	    pointer++;
	  }
	  diffs.pop();  // Remove the dummy entry at the end.
	
	  return diffs;
	};
	
	
	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} deadline Time at which to bail if not yet complete.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
	  // Cache the text lengths to prevent multiple calls.
	  var text1_length = text1.length;
	  var text2_length = text2.length;
	  var max_d = Math.ceil((text1_length + text2_length) / 2);
	  var v_offset = max_d;
	  var v_length = 2 * max_d;
	  var v1 = new Array(v_length);
	  var v2 = new Array(v_length);
	  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	  // integers and undefined.
	  for (var x = 0; x < v_length; x++) {
	    v1[x] = -1;
	    v2[x] = -1;
	  }
	  v1[v_offset + 1] = 0;
	  v2[v_offset + 1] = 0;
	  var delta = text1_length - text2_length;
	  // If the total number of characters is odd, then the front path will collide
	  // with the reverse path.
	  var front = (delta % 2 != 0);
	  // Offsets for start and end of k loop.
	  // Prevents mapping of space beyond the grid.
	  var k1start = 0;
	  var k1end = 0;
	  var k2start = 0;
	  var k2end = 0;
	  for (var d = 0; d < max_d; d++) {
	    // Bail out if deadline is reached.
	    if ((new Date()).getTime() > deadline) {
	      break;
	    }
	
	    // Walk the front path one step.
	    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	      var k1_offset = v_offset + k1;
	      var x1;
	      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	        x1 = v1[k1_offset + 1];
	      } else {
	        x1 = v1[k1_offset - 1] + 1;
	      }
	      var y1 = x1 - k1;
	      while (x1 < text1_length && y1 < text2_length &&
	             text1.charAt(x1) == text2.charAt(y1)) {
	        x1++;
	        y1++;
	      }
	      v1[k1_offset] = x1;
	      if (x1 > text1_length) {
	        // Ran off the right of the graph.
	        k1end += 2;
	      } else if (y1 > text2_length) {
	        // Ran off the bottom of the graph.
	        k1start += 2;
	      } else if (front) {
	        var k2_offset = v_offset + delta - k1;
	        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	          // Mirror x2 onto top-left coordinate system.
	          var x2 = text1_length - v2[k2_offset];
	          if (x1 >= x2) {
	            // Overlap detected.
	            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
	          }
	        }
	      }
	    }
	
	    // Walk the reverse path one step.
	    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	      var k2_offset = v_offset + k2;
	      var x2;
	      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	        x2 = v2[k2_offset + 1];
	      } else {
	        x2 = v2[k2_offset - 1] + 1;
	      }
	      var y2 = x2 - k2;
	      while (x2 < text1_length && y2 < text2_length &&
	             text1.charAt(text1_length - x2 - 1) ==
	             text2.charAt(text2_length - y2 - 1)) {
	        x2++;
	        y2++;
	      }
	      v2[k2_offset] = x2;
	      if (x2 > text1_length) {
	        // Ran off the left of the graph.
	        k2end += 2;
	      } else if (y2 > text2_length) {
	        // Ran off the top of the graph.
	        k2start += 2;
	      } else if (!front) {
	        var k1_offset = v_offset + delta - k2;
	        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	          var x1 = v1[k1_offset];
	          var y1 = v_offset + x1 - k1_offset;
	          // Mirror x2 onto top-left coordinate system.
	          x2 = text1_length - x2;
	          if (x1 >= x2) {
	            // Overlap detected.
	            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
	          }
	        }
	      }
	    }
	  }
	  // Diff took too long and hit the deadline or
	  // number of diffs equals number of characters, no commonality at all.
	  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
	};
	
	
	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @param {number} deadline Time at which to bail if not yet complete.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
	    deadline) {
	  var text1a = text1.substring(0, x);
	  var text2a = text2.substring(0, y);
	  var text1b = text1.substring(x);
	  var text2b = text2.substring(y);
	
	  // Compute both diffs serially.
	  var diffs = this.diff_main(text1a, text2a, false, deadline);
	  var diffsb = this.diff_main(text1b, text2b, false, deadline);
	
	  return diffs.concat(diffsb);
	};
	
	
	/**
	 * Split two texts into an array of strings.  Reduce the texts to a string of
	 * hashes where each Unicode character represents one line.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
	 *     An object containing the encoded text1, the encoded text2 and
	 *     the array of unique strings.
	 *     The zeroth element of the array of unique strings is intentionally blank.
	 * @private
	 */
	diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
	  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
	  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4
	
	  // '\x00' is a valid character, but various debuggers don't like it.
	  // So we'll insert a junk entry to avoid generating a null character.
	  lineArray[0] = '';
	
	  /**
	   * Split a text into an array of strings.  Reduce the texts to a string of
	   * hashes where each Unicode character represents one line.
	   * Modifies linearray and linehash through being a closure.
	   * @param {string} text String to encode.
	   * @return {string} Encoded string.
	   * @private
	   */
	  function diff_linesToCharsMunge_(text) {
	    var chars = '';
	    // Walk the text, pulling out a substring for each line.
	    // text.split('\n') would would temporarily double our memory footprint.
	    // Modifying text would create many large strings to garbage collect.
	    var lineStart = 0;
	    var lineEnd = -1;
	    // Keeping our own length variable is faster than looking it up.
	    var lineArrayLength = lineArray.length;
	    while (lineEnd < text.length - 1) {
	      lineEnd = text.indexOf('\n', lineStart);
	      if (lineEnd == -1) {
	        lineEnd = text.length - 1;
	      }
	      var line = text.substring(lineStart, lineEnd + 1);
	      lineStart = lineEnd + 1;
	
	      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
	          (lineHash[line] !== undefined)) {
	        chars += String.fromCharCode(lineHash[line]);
	      } else {
	        chars += String.fromCharCode(lineArrayLength);
	        lineHash[line] = lineArrayLength;
	        lineArray[lineArrayLength++] = line;
	      }
	    }
	    return chars;
	  }
	
	  var chars1 = diff_linesToCharsMunge_(text1);
	  var chars2 = diff_linesToCharsMunge_(text2);
	  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
	};
	
	
	/**
	 * Rehydrate the text in a diff from a string of line hashes to real lines of
	 * text.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @param {!Array.<string>} lineArray Array of unique strings.
	 * @private
	 */
	diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
	  for (var x = 0; x < diffs.length; x++) {
	    var chars = diffs[x][1];
	    var text = [];
	    for (var y = 0; y < chars.length; y++) {
	      text[y] = lineArray[chars.charCodeAt(y)];
	    }
	    diffs[x][1] = text.join('');
	  }
	};
	
	
	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
	  // Quick check for common null cases.
	  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	    return 0;
	  }
	  // Binary search.
	  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	  var pointermin = 0;
	  var pointermax = Math.min(text1.length, text2.length);
	  var pointermid = pointermax;
	  var pointerstart = 0;
	  while (pointermin < pointermid) {
	    if (text1.substring(pointerstart, pointermid) ==
	        text2.substring(pointerstart, pointermid)) {
	      pointermin = pointermid;
	      pointerstart = pointermin;
	    } else {
	      pointermax = pointermid;
	    }
	    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	  }
	  return pointermid;
	};
	
	
	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
	  // Quick check for common null cases.
	  if (!text1 || !text2 ||
	      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	    return 0;
	  }
	  // Binary search.
	  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	  var pointermin = 0;
	  var pointermax = Math.min(text1.length, text2.length);
	  var pointermid = pointermax;
	  var pointerend = 0;
	  while (pointermin < pointermid) {
	    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	      pointermin = pointermid;
	      pointerend = pointermin;
	    } else {
	      pointermax = pointermid;
	    }
	    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	  }
	  return pointermid;
	};
	
	
	/**
	 * Determine if the suffix of one string is the prefix of another.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of the first
	 *     string and the start of the second string.
	 * @private
	 */
	diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
	  // Cache the text lengths to prevent multiple calls.
	  var text1_length = text1.length;
	  var text2_length = text2.length;
	  // Eliminate the null case.
	  if (text1_length == 0 || text2_length == 0) {
	    return 0;
	  }
	  // Truncate the longer string.
	  if (text1_length > text2_length) {
	    text1 = text1.substring(text1_length - text2_length);
	  } else if (text1_length < text2_length) {
	    text2 = text2.substring(0, text1_length);
	  }
	  var text_length = Math.min(text1_length, text2_length);
	  // Quick check for the worst case.
	  if (text1 == text2) {
	    return text_length;
	  }
	
	  // Start by looking for a single character match
	  // and increase length until no match is found.
	  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
	  var best = 0;
	  var length = 1;
	  while (true) {
	    var pattern = text1.substring(text_length - length);
	    var found = text2.indexOf(pattern);
	    if (found == -1) {
	      return best;
	    }
	    length += found;
	    if (found == 0 || text1.substring(text_length - length) ==
	        text2.substring(0, length)) {
	      best = length;
	      length++;
	    }
	  }
	};
	
	
	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 * @private
	 */
	diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
	  if (this.Diff_Timeout <= 0) {
	    // Don't risk returning a non-optimal diff if we have unlimited time.
	    return null;
	  }
	  var longtext = text1.length > text2.length ? text1 : text2;
	  var shorttext = text1.length > text2.length ? text2 : text1;
	  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	    return null;  // Pointless.
	  }
	  var dmp = this;  // 'this' becomes 'window' in a closure.
	
	  /**
	   * Does a substring of shorttext exist within longtext such that the substring
	   * is at least half the length of longtext?
	   * Closure, but does not reference any external variables.
	   * @param {string} longtext Longer string.
	   * @param {string} shorttext Shorter string.
	   * @param {number} i Start index of quarter length substring within longtext.
	   * @return {Array.<string>} Five element Array, containing the prefix of
	   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	   *     of shorttext and the common middle.  Or null if there was no match.
	   * @private
	   */
	  function diff_halfMatchI_(longtext, shorttext, i) {
	    // Start with a 1/4 length substring at position i as a seed.
	    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	    var j = -1;
	    var best_common = '';
	    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
	                                               shorttext.substring(j));
	      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
	                                               shorttext.substring(0, j));
	      if (best_common.length < suffixLength + prefixLength) {
	        best_common = shorttext.substring(j - suffixLength, j) +
	            shorttext.substring(j, j + prefixLength);
	        best_longtext_a = longtext.substring(0, i - suffixLength);
	        best_longtext_b = longtext.substring(i + prefixLength);
	        best_shorttext_a = shorttext.substring(0, j - suffixLength);
	        best_shorttext_b = shorttext.substring(j + prefixLength);
	      }
	    }
	    if (best_common.length * 2 >= longtext.length) {
	      return [best_longtext_a, best_longtext_b,
	              best_shorttext_a, best_shorttext_b, best_common];
	    } else {
	      return null;
	    }
	  }
	
	  // First check if the second quarter is the seed for a half-match.
	  var hm1 = diff_halfMatchI_(longtext, shorttext,
	                             Math.ceil(longtext.length / 4));
	  // Check again based on the third quarter.
	  var hm2 = diff_halfMatchI_(longtext, shorttext,
	                             Math.ceil(longtext.length / 2));
	  var hm;
	  if (!hm1 && !hm2) {
	    return null;
	  } else if (!hm2) {
	    hm = hm1;
	  } else if (!hm1) {
	    hm = hm2;
	  } else {
	    // Both matched.  Select the longest.
	    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	  }
	
	  // A half-match was found, sort out the return data.
	  var text1_a, text1_b, text2_a, text2_b;
	  if (text1.length > text2.length) {
	    text1_a = hm[0];
	    text1_b = hm[1];
	    text2_a = hm[2];
	    text2_b = hm[3];
	  } else {
	    text2_a = hm[0];
	    text2_b = hm[1];
	    text1_a = hm[2];
	    text1_b = hm[3];
	  }
	  var mid_common = hm[4];
	  return [text1_a, text1_b, text2_a, text2_b, mid_common];
	};
	
	
	/**
	 * Reduce the number of edits by eliminating semantically trivial equalities.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
	  var changes = false;
	  var equalities = [];  // Stack of indices where equalities are found.
	  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
	  /** @type {?string} */
	  var lastequality = null;
	  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
	  var pointer = 0;  // Index of current position.
	  // Number of characters that changed prior to the equality.
	  var length_insertions1 = 0;
	  var length_deletions1 = 0;
	  // Number of characters that changed after the equality.
	  var length_insertions2 = 0;
	  var length_deletions2 = 0;
	  while (pointer < diffs.length) {
	    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
	      equalities[equalitiesLength++] = pointer;
	      length_insertions1 = length_insertions2;
	      length_deletions1 = length_deletions2;
	      length_insertions2 = 0;
	      length_deletions2 = 0;
	      lastequality = diffs[pointer][1];
	    } else {  // An insertion or deletion.
	      if (diffs[pointer][0] == DIFF_INSERT) {
	        length_insertions2 += diffs[pointer][1].length;
	      } else {
	        length_deletions2 += diffs[pointer][1].length;
	      }
	      // Eliminate an equality that is smaller or equal to the edits on both
	      // sides of it.
	      if (lastequality && (lastequality.length <=
	          Math.max(length_insertions1, length_deletions1)) &&
	          (lastequality.length <= Math.max(length_insertions2,
	                                           length_deletions2))) {
	        // Duplicate record.
	        diffs.splice(equalities[equalitiesLength - 1], 0,
	                     [DIFF_DELETE, lastequality]);
	        // Change second copy to insert.
	        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
	        // Throw away the equality we just deleted.
	        equalitiesLength--;
	        // Throw away the previous equality (it needs to be reevaluated).
	        equalitiesLength--;
	        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
	        length_insertions1 = 0;  // Reset the counters.
	        length_deletions1 = 0;
	        length_insertions2 = 0;
	        length_deletions2 = 0;
	        lastequality = null;
	        changes = true;
	      }
	    }
	    pointer++;
	  }
	
	  // Normalize the diff.
	  if (changes) {
	    this.diff_cleanupMerge(diffs);
	  }
	  this.diff_cleanupSemanticLossless(diffs);
	
	  // Find any overlaps between deletions and insertions.
	  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
	  //   -> <del>abc</del>xxx<ins>def</ins>
	  // e.g: <del>xxxabc</del><ins>defxxx</ins>
	  //   -> <ins>def</ins>xxx<del>abc</del>
	  // Only extract an overlap if it is as big as the edit ahead or behind it.
	  pointer = 1;
	  while (pointer < diffs.length) {
	    if (diffs[pointer - 1][0] == DIFF_DELETE &&
	        diffs[pointer][0] == DIFF_INSERT) {
	      var deletion = diffs[pointer - 1][1];
	      var insertion = diffs[pointer][1];
	      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
	      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
	      if (overlap_length1 >= overlap_length2) {
	        if (overlap_length1 >= deletion.length / 2 ||
	            overlap_length1 >= insertion.length / 2) {
	          // Overlap found.  Insert an equality and trim the surrounding edits.
	          diffs.splice(pointer, 0,
	              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
	          diffs[pointer - 1][1] =
	              deletion.substring(0, deletion.length - overlap_length1);
	          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
	          pointer++;
	        }
	      } else {
	        if (overlap_length2 >= deletion.length / 2 ||
	            overlap_length2 >= insertion.length / 2) {
	          // Reverse overlap found.
	          // Insert an equality and swap and trim the surrounding edits.
	          diffs.splice(pointer, 0,
	              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
	          diffs[pointer - 1][0] = DIFF_INSERT;
	          diffs[pointer - 1][1] =
	              insertion.substring(0, insertion.length - overlap_length2);
	          diffs[pointer + 1][0] = DIFF_DELETE;
	          diffs[pointer + 1][1] =
	              deletion.substring(overlap_length2);
	          pointer++;
	        }
	      }
	      pointer++;
	    }
	    pointer++;
	  }
	};
	
	
	/**
	 * Look for single edits surrounded on both sides by equalities
	 * which can be shifted sideways to align the edit to a word boundary.
	 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
	  /**
	   * Given two strings, compute a score representing whether the internal
	   * boundary falls on logical boundaries.
	   * Scores range from 6 (best) to 0 (worst).
	   * Closure, but does not reference any external variables.
	   * @param {string} one First string.
	   * @param {string} two Second string.
	   * @return {number} The score.
	   * @private
	   */
	  function diff_cleanupSemanticScore_(one, two) {
	    if (!one || !two) {
	      // Edges are the best.
	      return 6;
	    }
	
	    // Each port of this function behaves slightly differently due to
	    // subtle differences in each language's definition of things like
	    // 'whitespace'.  Since this function's purpose is largely cosmetic,
	    // the choice has been made to use each language's native features
	    // rather than force total conformity.
	    var char1 = one.charAt(one.length - 1);
	    var char2 = two.charAt(0);
	    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
	    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
	    var whitespace1 = nonAlphaNumeric1 &&
	        char1.match(diff_match_patch.whitespaceRegex_);
	    var whitespace2 = nonAlphaNumeric2 &&
	        char2.match(diff_match_patch.whitespaceRegex_);
	    var lineBreak1 = whitespace1 &&
	        char1.match(diff_match_patch.linebreakRegex_);
	    var lineBreak2 = whitespace2 &&
	        char2.match(diff_match_patch.linebreakRegex_);
	    var blankLine1 = lineBreak1 &&
	        one.match(diff_match_patch.blanklineEndRegex_);
	    var blankLine2 = lineBreak2 &&
	        two.match(diff_match_patch.blanklineStartRegex_);
	
	    if (blankLine1 || blankLine2) {
	      // Five points for blank lines.
	      return 5;
	    } else if (lineBreak1 || lineBreak2) {
	      // Four points for line breaks.
	      return 4;
	    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
	      // Three points for end of sentences.
	      return 3;
	    } else if (whitespace1 || whitespace2) {
	      // Two points for whitespace.
	      return 2;
	    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
	      // One point for non-alphanumeric.
	      return 1;
	    }
	    return 0;
	  }
	
	  var pointer = 1;
	  // Intentionally ignore the first and last element (don't need checking).
	  while (pointer < diffs.length - 1) {
	    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
	        diffs[pointer + 1][0] == DIFF_EQUAL) {
	      // This is a single edit surrounded by equalities.
	      var equality1 = diffs[pointer - 1][1];
	      var edit = diffs[pointer][1];
	      var equality2 = diffs[pointer + 1][1];
	
	      // First, shift the edit as far left as possible.
	      var commonOffset = this.diff_commonSuffix(equality1, edit);
	      if (commonOffset) {
	        var commonString = edit.substring(edit.length - commonOffset);
	        equality1 = equality1.substring(0, equality1.length - commonOffset);
	        edit = commonString + edit.substring(0, edit.length - commonOffset);
	        equality2 = commonString + equality2;
	      }
	
	      // Second, step character by character right, looking for the best fit.
	      var bestEquality1 = equality1;
	      var bestEdit = edit;
	      var bestEquality2 = equality2;
	      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
	          diff_cleanupSemanticScore_(edit, equality2);
	      while (edit.charAt(0) === equality2.charAt(0)) {
	        equality1 += edit.charAt(0);
	        edit = edit.substring(1) + equality2.charAt(0);
	        equality2 = equality2.substring(1);
	        var score = diff_cleanupSemanticScore_(equality1, edit) +
	            diff_cleanupSemanticScore_(edit, equality2);
	        // The >= encourages trailing rather than leading whitespace on edits.
	        if (score >= bestScore) {
	          bestScore = score;
	          bestEquality1 = equality1;
	          bestEdit = edit;
	          bestEquality2 = equality2;
	        }
	      }
	
	      if (diffs[pointer - 1][1] != bestEquality1) {
	        // We have an improvement, save it back to the diff.
	        if (bestEquality1) {
	          diffs[pointer - 1][1] = bestEquality1;
	        } else {
	          diffs.splice(pointer - 1, 1);
	          pointer--;
	        }
	        diffs[pointer][1] = bestEdit;
	        if (bestEquality2) {
	          diffs[pointer + 1][1] = bestEquality2;
	        } else {
	          diffs.splice(pointer + 1, 1);
	          pointer--;
	        }
	      }
	    }
	    pointer++;
	  }
	};
	
	// Define some regex patterns for matching boundaries.
	diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
	diff_match_patch.whitespaceRegex_ = /\s/;
	diff_match_patch.linebreakRegex_ = /[\r\n]/;
	diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
	diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
	
	/**
	 * Reduce the number of edits by eliminating operationally trivial equalities.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
	  var changes = false;
	  var equalities = [];  // Stack of indices where equalities are found.
	  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
	  /** @type {?string} */
	  var lastequality = null;
	  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
	  var pointer = 0;  // Index of current position.
	  // Is there an insertion operation before the last equality.
	  var pre_ins = false;
	  // Is there a deletion operation before the last equality.
	  var pre_del = false;
	  // Is there an insertion operation after the last equality.
	  var post_ins = false;
	  // Is there a deletion operation after the last equality.
	  var post_del = false;
	  while (pointer < diffs.length) {
	    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
	      if (diffs[pointer][1].length < this.Diff_EditCost &&
	          (post_ins || post_del)) {
	        // Candidate found.
	        equalities[equalitiesLength++] = pointer;
	        pre_ins = post_ins;
	        pre_del = post_del;
	        lastequality = diffs[pointer][1];
	      } else {
	        // Not a candidate, and can never become one.
	        equalitiesLength = 0;
	        lastequality = null;
	      }
	      post_ins = post_del = false;
	    } else {  // An insertion or deletion.
	      if (diffs[pointer][0] == DIFF_DELETE) {
	        post_del = true;
	      } else {
	        post_ins = true;
	      }
	      /*
	       * Five types to be split:
	       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
	       * <ins>A</ins>X<ins>C</ins><del>D</del>
	       * <ins>A</ins><del>B</del>X<ins>C</ins>
	       * <ins>A</del>X<ins>C</ins><del>D</del>
	       * <ins>A</ins><del>B</del>X<del>C</del>
	       */
	      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
	                           ((lastequality.length < this.Diff_EditCost / 2) &&
	                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
	        // Duplicate record.
	        diffs.splice(equalities[equalitiesLength - 1], 0,
	                     [DIFF_DELETE, lastequality]);
	        // Change second copy to insert.
	        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
	        equalitiesLength--;  // Throw away the equality we just deleted;
	        lastequality = null;
	        if (pre_ins && pre_del) {
	          // No changes made which could affect previous entry, keep going.
	          post_ins = post_del = true;
	          equalitiesLength = 0;
	        } else {
	          equalitiesLength--;  // Throw away the previous equality.
	          pointer = equalitiesLength > 0 ?
	              equalities[equalitiesLength - 1] : -1;
	          post_ins = post_del = false;
	        }
	        changes = true;
	      }
	    }
	    pointer++;
	  }
	
	  if (changes) {
	    this.diff_cleanupMerge(diffs);
	  }
	};
	
	
	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
	  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
	  var pointer = 0;
	  var count_delete = 0;
	  var count_insert = 0;
	  var text_delete = '';
	  var text_insert = '';
	  var commonlength;
	  while (pointer < diffs.length) {
	    switch (diffs[pointer][0]) {
	      case DIFF_INSERT:
	        count_insert++;
	        text_insert += diffs[pointer][1];
	        pointer++;
	        break;
	      case DIFF_DELETE:
	        count_delete++;
	        text_delete += diffs[pointer][1];
	        pointer++;
	        break;
	      case DIFF_EQUAL:
	        // Upon reaching an equality, check for prior redundancies.
	        if (count_delete + count_insert > 1) {
	          if (count_delete !== 0 && count_insert !== 0) {
	            // Factor out any common prefixies.
	            commonlength = this.diff_commonPrefix(text_insert, text_delete);
	            if (commonlength !== 0) {
	              if ((pointer - count_delete - count_insert) > 0 &&
	                  diffs[pointer - count_delete - count_insert - 1][0] ==
	                  DIFF_EQUAL) {
	                diffs[pointer - count_delete - count_insert - 1][1] +=
	                    text_insert.substring(0, commonlength);
	              } else {
	                diffs.splice(0, 0, [DIFF_EQUAL,
	                                    text_insert.substring(0, commonlength)]);
	                pointer++;
	              }
	              text_insert = text_insert.substring(commonlength);
	              text_delete = text_delete.substring(commonlength);
	            }
	            // Factor out any common suffixies.
	            commonlength = this.diff_commonSuffix(text_insert, text_delete);
	            if (commonlength !== 0) {
	              diffs[pointer][1] = text_insert.substring(text_insert.length -
	                  commonlength) + diffs[pointer][1];
	              text_insert = text_insert.substring(0, text_insert.length -
	                  commonlength);
	              text_delete = text_delete.substring(0, text_delete.length -
	                  commonlength);
	            }
	          }
	          // Delete the offending records and add the merged ones.
	          if (count_delete === 0) {
	            diffs.splice(pointer - count_insert,
	                count_delete + count_insert, [DIFF_INSERT, text_insert]);
	          } else if (count_insert === 0) {
	            diffs.splice(pointer - count_delete,
	                count_delete + count_insert, [DIFF_DELETE, text_delete]);
	          } else {
	            diffs.splice(pointer - count_delete - count_insert,
	                count_delete + count_insert, [DIFF_DELETE, text_delete],
	                [DIFF_INSERT, text_insert]);
	          }
	          pointer = pointer - count_delete - count_insert +
	                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
	        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
	          // Merge this equality with the previous one.
	          diffs[pointer - 1][1] += diffs[pointer][1];
	          diffs.splice(pointer, 1);
	        } else {
	          pointer++;
	        }
	        count_insert = 0;
	        count_delete = 0;
	        text_delete = '';
	        text_insert = '';
	        break;
	    }
	  }
	  if (diffs[diffs.length - 1][1] === '') {
	    diffs.pop();  // Remove the dummy entry at the end.
	  }
	
	  // Second pass: look for single edits surrounded on both sides by equalities
	  // which can be shifted sideways to eliminate an equality.
	  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	  var changes = false;
	  pointer = 1;
	  // Intentionally ignore the first and last element (don't need checking).
	  while (pointer < diffs.length - 1) {
	    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
	        diffs[pointer + 1][0] == DIFF_EQUAL) {
	      // This is a single edit surrounded by equalities.
	      if (diffs[pointer][1].substring(diffs[pointer][1].length -
	          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	        // Shift the edit over the previous equality.
	        diffs[pointer][1] = diffs[pointer - 1][1] +
	            diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                                        diffs[pointer - 1][1].length);
	        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	        diffs.splice(pointer - 1, 1);
	        changes = true;
	      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	          diffs[pointer + 1][1]) {
	        // Shift the edit over the next equality.
	        diffs[pointer - 1][1] += diffs[pointer + 1][1];
	        diffs[pointer][1] =
	            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	            diffs[pointer + 1][1];
	        diffs.splice(pointer + 1, 1);
	        changes = true;
	      }
	    }
	    pointer++;
	  }
	  // If shifts were made, the diff needs reordering and another shift sweep.
	  if (changes) {
	    this.diff_cleanupMerge(diffs);
	  }
	};
	
	
	/**
	 * loc is a location in text1, compute and return the equivalent location in
	 * text2.
	 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @param {number} loc Location within text1.
	 * @return {number} Location within text2.
	 */
	diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
	  var chars1 = 0;
	  var chars2 = 0;
	  var last_chars1 = 0;
	  var last_chars2 = 0;
	  var x;
	  for (x = 0; x < diffs.length; x++) {
	    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
	      chars1 += diffs[x][1].length;
	    }
	    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
	      chars2 += diffs[x][1].length;
	    }
	    if (chars1 > loc) {  // Overshot the location.
	      break;
	    }
	    last_chars1 = chars1;
	    last_chars2 = chars2;
	  }
	  // Was the location was deleted?
	  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
	    return last_chars2;
	  }
	  // Add the remaining character length.
	  return last_chars2 + (loc - last_chars1);
	};
	
	
	/**
	 * Convert a diff array into a pretty HTML report.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} HTML representation.
	 */
	diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
	  var html = [];
	  var pattern_amp = /&/g;
	  var pattern_lt = /</g;
	  var pattern_gt = />/g;
	  var pattern_para = /\n/g;
	  for (var x = 0; x < diffs.length; x++) {
	    var op = diffs[x][0];    // Operation (insert, delete, equal)
	    var data = diffs[x][1];  // Text of change.
	    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
	        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
	    switch (op) {
	      case DIFF_INSERT:
	        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
	        break;
	      case DIFF_DELETE:
	        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
	        break;
	      case DIFF_EQUAL:
	        html[x] = '<span>' + text + '</span>';
	        break;
	    }
	  }
	  return html.join('');
	};
	
	
	/**
	 * Compute and return the source text (all equalities and deletions).
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} Source text.
	 */
	diff_match_patch.prototype.diff_text1 = function(diffs) {
	  var text = [];
	  for (var x = 0; x < diffs.length; x++) {
	    if (diffs[x][0] !== DIFF_INSERT) {
	      text[x] = diffs[x][1];
	    }
	  }
	  return text.join('');
	};
	
	
	/**
	 * Compute and return the destination text (all equalities and insertions).
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} Destination text.
	 */
	diff_match_patch.prototype.diff_text2 = function(diffs) {
	  var text = [];
	  for (var x = 0; x < diffs.length; x++) {
	    if (diffs[x][0] !== DIFF_DELETE) {
	      text[x] = diffs[x][1];
	    }
	  }
	  return text.join('');
	};
	
	
	/**
	 * Compute the Levenshtein distance; the number of inserted, deleted or
	 * substituted characters.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {number} Number of changes.
	 */
	diff_match_patch.prototype.diff_levenshtein = function(diffs) {
	  var levenshtein = 0;
	  var insertions = 0;
	  var deletions = 0;
	  for (var x = 0; x < diffs.length; x++) {
	    var op = diffs[x][0];
	    var data = diffs[x][1];
	    switch (op) {
	      case DIFF_INSERT:
	        insertions += data.length;
	        break;
	      case DIFF_DELETE:
	        deletions += data.length;
	        break;
	      case DIFF_EQUAL:
	        // A deletion and an insertion is one substitution.
	        levenshtein += Math.max(insertions, deletions);
	        insertions = 0;
	        deletions = 0;
	        break;
	    }
	  }
	  levenshtein += Math.max(insertions, deletions);
	  return levenshtein;
	};
	
	
	/**
	 * Crush the diff into an encoded string which describes the operations
	 * required to transform text1 into text2.
	 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
	 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} Delta text.
	 */
	diff_match_patch.prototype.diff_toDelta = function(diffs) {
	  var text = [];
	  for (var x = 0; x < diffs.length; x++) {
	    switch (diffs[x][0]) {
	      case DIFF_INSERT:
	        text[x] = '+' + encodeURI(diffs[x][1]);
	        break;
	      case DIFF_DELETE:
	        text[x] = '-' + diffs[x][1].length;
	        break;
	      case DIFF_EQUAL:
	        text[x] = '=' + diffs[x][1].length;
	        break;
	    }
	  }
	  return text.join('\t').replace(/%20/g, ' ');
	};
	
	
	/**
	 * Given the original text1, and an encoded string which describes the
	 * operations required to transform text1 into text2, compute the full diff.
	 * @param {string} text1 Source string for the diff.
	 * @param {string} delta Delta text.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @throws {!Error} If invalid input.
	 */
	diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
	  var diffs = [];
	  var diffsLength = 0;  // Keeping our own length var is faster in JS.
	  var pointer = 0;  // Cursor in text1
	  var tokens = delta.split(/\t/g);
	  for (var x = 0; x < tokens.length; x++) {
	    // Each token begins with a one character parameter which specifies the
	    // operation of this token (delete, insert, equality).
	    var param = tokens[x].substring(1);
	    switch (tokens[x].charAt(0)) {
	      case '+':
	        try {
	          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
	        } catch (ex) {
	          // Malformed URI sequence.
	          throw new Error('Illegal escape in diff_fromDelta: ' + param);
	        }
	        break;
	      case '-':
	        // Fall through.
	      case '=':
	        var n = parseInt(param, 10);
	        if (isNaN(n) || n < 0) {
	          throw new Error('Invalid number in diff_fromDelta: ' + param);
	        }
	        var text = text1.substring(pointer, pointer += n);
	        if (tokens[x].charAt(0) == '=') {
	          diffs[diffsLength++] = [DIFF_EQUAL, text];
	        } else {
	          diffs[diffsLength++] = [DIFF_DELETE, text];
	        }
	        break;
	      default:
	        // Blank tokens are ok (from a trailing \t).
	        // Anything else is an error.
	        if (tokens[x]) {
	          throw new Error('Invalid diff operation in diff_fromDelta: ' +
	                          tokens[x]);
	        }
	    }
	  }
	  if (pointer != text1.length) {
	    throw new Error('Delta length (' + pointer +
	        ') does not equal source text length (' + text1.length + ').');
	  }
	  return diffs;
	};
	
	
	//  MATCH FUNCTIONS
	
	
	/**
	 * Locate the best instance of 'pattern' in 'text' near 'loc'.
	 * @param {string} text The text to search.
	 * @param {string} pattern The pattern to search for.
	 * @param {number} loc The location to search around.
	 * @return {number} Best match index or -1.
	 */
	diff_match_patch.prototype.match_main = function(text, pattern, loc) {
	  // Check for null inputs.
	  if (text == null || pattern == null || loc == null) {
	    throw new Error('Null input. (match_main)');
	  }
	
	  loc = Math.max(0, Math.min(loc, text.length));
	  if (text == pattern) {
	    // Shortcut (potentially not guaranteed by the algorithm)
	    return 0;
	  } else if (!text.length) {
	    // Nothing to match.
	    return -1;
	  } else if (text.substring(loc, loc + pattern.length) == pattern) {
	    // Perfect match at the perfect spot!  (Includes case of null pattern)
	    return loc;
	  } else {
	    // Do a fuzzy compare.
	    return this.match_bitap_(text, pattern, loc);
	  }
	};
	
	
	/**
	 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
	 * Bitap algorithm.
	 * @param {string} text The text to search.
	 * @param {string} pattern The pattern to search for.
	 * @param {number} loc The location to search around.
	 * @return {number} Best match index or -1.
	 * @private
	 */
	diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
	  if (pattern.length > this.Match_MaxBits) {
	    throw new Error('Pattern too long for this browser.');
	  }
	
	  // Initialise the alphabet.
	  var s = this.match_alphabet_(pattern);
	
	  var dmp = this;  // 'this' becomes 'window' in a closure.
	
	  /**
	   * Compute and return the score for a match with e errors and x location.
	   * Accesses loc and pattern through being a closure.
	   * @param {number} e Number of errors in match.
	   * @param {number} x Location of match.
	   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
	   * @private
	   */
	  function match_bitapScore_(e, x) {
	    var accuracy = e / pattern.length;
	    var proximity = Math.abs(loc - x);
	    if (!dmp.Match_Distance) {
	      // Dodge divide by zero error.
	      return proximity ? 1.0 : accuracy;
	    }
	    return accuracy + (proximity / dmp.Match_Distance);
	  }
	
	  // Highest score beyond which we give up.
	  var score_threshold = this.Match_Threshold;
	  // Is there a nearby exact match? (speedup)
	  var best_loc = text.indexOf(pattern, loc);
	  if (best_loc != -1) {
	    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
	    // What about in the other direction? (speedup)
	    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
	    if (best_loc != -1) {
	      score_threshold =
	          Math.min(match_bitapScore_(0, best_loc), score_threshold);
	    }
	  }
	
	  // Initialise the bit arrays.
	  var matchmask = 1 << (pattern.length - 1);
	  best_loc = -1;
	
	  var bin_min, bin_mid;
	  var bin_max = pattern.length + text.length;
	  var last_rd;
	  for (var d = 0; d < pattern.length; d++) {
	    // Scan for the best match; each iteration allows for one more error.
	    // Run a binary search to determine how far from 'loc' we can stray at this
	    // error level.
	    bin_min = 0;
	    bin_mid = bin_max;
	    while (bin_min < bin_mid) {
	      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
	        bin_min = bin_mid;
	      } else {
	        bin_max = bin_mid;
	      }
	      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
	    }
	    // Use the result from this iteration as the maximum for the next.
	    bin_max = bin_mid;
	    var start = Math.max(1, loc - bin_mid + 1);
	    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;
	
	    var rd = Array(finish + 2);
	    rd[finish + 1] = (1 << d) - 1;
	    for (var j = finish; j >= start; j--) {
	      // The alphabet (s) is a sparse hash, so the following line generates
	      // warnings.
	      var charMatch = s[text.charAt(j - 1)];
	      if (d === 0) {  // First pass: exact match.
	        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
	      } else {  // Subsequent passes: fuzzy match.
	        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
	                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
	                last_rd[j + 1];
	      }
	      if (rd[j] & matchmask) {
	        var score = match_bitapScore_(d, j - 1);
	        // This match will almost certainly be better than any existing match.
	        // But check anyway.
	        if (score <= score_threshold) {
	          // Told you so.
	          score_threshold = score;
	          best_loc = j - 1;
	          if (best_loc > loc) {
	            // When passing loc, don't exceed our current distance from loc.
	            start = Math.max(1, 2 * loc - best_loc);
	          } else {
	            // Already passed loc, downhill from here on in.
	            break;
	          }
	        }
	      }
	    }
	    // No hope for a (better) match at greater error levels.
	    if (match_bitapScore_(d + 1, loc) > score_threshold) {
	      break;
	    }
	    last_rd = rd;
	  }
	  return best_loc;
	};
	
	
	/**
	 * Initialise the alphabet for the Bitap algorithm.
	 * @param {string} pattern The text to encode.
	 * @return {!Object} Hash of character locations.
	 * @private
	 */
	diff_match_patch.prototype.match_alphabet_ = function(pattern) {
	  var s = {};
	  for (var i = 0; i < pattern.length; i++) {
	    s[pattern.charAt(i)] = 0;
	  }
	  for (var i = 0; i < pattern.length; i++) {
	    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
	  }
	  return s;
	};
	
	
	//  PATCH FUNCTIONS
	
	
	/**
	 * Increase the context until it is unique,
	 * but don't let the pattern expand beyond Match_MaxBits.
	 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
	 * @param {string} text Source text.
	 * @private
	 */
	diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
	  if (text.length == 0) {
	    return;
	  }
	  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
	  var padding = 0;
	
	  // Look for the first and last matches of pattern in text.  If two different
	  // matches are found, increase the pattern length.
	  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
	         pattern.length < this.Match_MaxBits - this.Patch_Margin -
	         this.Patch_Margin) {
	    padding += this.Patch_Margin;
	    pattern = text.substring(patch.start2 - padding,
	                             patch.start2 + patch.length1 + padding);
	  }
	  // Add one chunk for good luck.
	  padding += this.Patch_Margin;
	
	  // Add the prefix.
	  var prefix = text.substring(patch.start2 - padding, patch.start2);
	  if (prefix) {
	    patch.diffs.unshift([DIFF_EQUAL, prefix]);
	  }
	  // Add the suffix.
	  var suffix = text.substring(patch.start2 + patch.length1,
	                              patch.start2 + patch.length1 + padding);
	  if (suffix) {
	    patch.diffs.push([DIFF_EQUAL, suffix]);
	  }
	
	  // Roll back the start points.
	  patch.start1 -= prefix.length;
	  patch.start2 -= prefix.length;
	  // Extend the lengths.
	  patch.length1 += prefix.length + suffix.length;
	  patch.length2 += prefix.length + suffix.length;
	};
	
	
	/**
	 * Compute a list of patches to turn text1 into text2.
	 * Use diffs if provided, otherwise compute it ourselves.
	 * There are four ways to call this function, depending on what data is
	 * available to the caller:
	 * Method 1:
	 * a = text1, b = text2
	 * Method 2:
	 * a = diffs
	 * Method 3 (optimal):
	 * a = text1, b = diffs
	 * Method 4 (deprecated, use method 3):
	 * a = text1, b = text2, c = diffs
	 *
	 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
	 * Array of diff tuples for text1 to text2 (method 2).
	 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
	 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
	 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
	 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
	 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
	 */
	diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
	  var text1, diffs;
	  if (typeof a == 'string' && typeof opt_b == 'string' &&
	      typeof opt_c == 'undefined') {
	    // Method 1: text1, text2
	    // Compute diffs from text1 and text2.
	    text1 = /** @type {string} */(a);
	    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
	    if (diffs.length > 2) {
	      this.diff_cleanupSemantic(diffs);
	      this.diff_cleanupEfficiency(diffs);
	    }
	  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
	      typeof opt_c == 'undefined') {
	    // Method 2: diffs
	    // Compute text1 from diffs.
	    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
	    text1 = this.diff_text1(diffs);
	  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
	      typeof opt_c == 'undefined') {
	    // Method 3: text1, diffs
	    text1 = /** @type {string} */(a);
	    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
	  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
	      opt_c && typeof opt_c == 'object') {
	    // Method 4: text1, text2, diffs
	    // text2 is not used.
	    text1 = /** @type {string} */(a);
	    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
	  } else {
	    throw new Error('Unknown call format to patch_make.');
	  }
	
	  if (diffs.length === 0) {
	    return [];  // Get rid of the null case.
	  }
	  var patches = [];
	  var patch = new diff_match_patch.patch_obj();
	  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
	  var char_count1 = 0;  // Number of characters into the text1 string.
	  var char_count2 = 0;  // Number of characters into the text2 string.
	  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
	  // text2 (postpatch_text).  We recreate the patches one by one to determine
	  // context info.
	  var prepatch_text = text1;
	  var postpatch_text = text1;
	  for (var x = 0; x < diffs.length; x++) {
	    var diff_type = diffs[x][0];
	    var diff_text = diffs[x][1];
	
	    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
	      // A new patch starts here.
	      patch.start1 = char_count1;
	      patch.start2 = char_count2;
	    }
	
	    switch (diff_type) {
	      case DIFF_INSERT:
	        patch.diffs[patchDiffLength++] = diffs[x];
	        patch.length2 += diff_text.length;
	        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
	                         postpatch_text.substring(char_count2);
	        break;
	      case DIFF_DELETE:
	        patch.length1 += diff_text.length;
	        patch.diffs[patchDiffLength++] = diffs[x];
	        postpatch_text = postpatch_text.substring(0, char_count2) +
	                         postpatch_text.substring(char_count2 +
	                             diff_text.length);
	        break;
	      case DIFF_EQUAL:
	        if (diff_text.length <= 2 * this.Patch_Margin &&
	            patchDiffLength && diffs.length != x + 1) {
	          // Small equality inside a patch.
	          patch.diffs[patchDiffLength++] = diffs[x];
	          patch.length1 += diff_text.length;
	          patch.length2 += diff_text.length;
	        } else if (diff_text.length >= 2 * this.Patch_Margin) {
	          // Time for a new patch.
	          if (patchDiffLength) {
	            this.patch_addContext_(patch, prepatch_text);
	            patches.push(patch);
	            patch = new diff_match_patch.patch_obj();
	            patchDiffLength = 0;
	            // Unlike Unidiff, our patch lists have a rolling context.
	            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
	            // Update prepatch text & pos to reflect the application of the
	            // just completed patch.
	            prepatch_text = postpatch_text;
	            char_count1 = char_count2;
	          }
	        }
	        break;
	    }
	
	    // Update the current character count.
	    if (diff_type !== DIFF_INSERT) {
	      char_count1 += diff_text.length;
	    }
	    if (diff_type !== DIFF_DELETE) {
	      char_count2 += diff_text.length;
	    }
	  }
	  // Pick up the leftover patch if not empty.
	  if (patchDiffLength) {
	    this.patch_addContext_(patch, prepatch_text);
	    patches.push(patch);
	  }
	
	  return patches;
	};
	
	
	/**
	 * Given an array of patches, return another array that is identical.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
	 */
	diff_match_patch.prototype.patch_deepCopy = function(patches) {
	  // Making deep copies is hard in JavaScript.
	  var patchesCopy = [];
	  for (var x = 0; x < patches.length; x++) {
	    var patch = patches[x];
	    var patchCopy = new diff_match_patch.patch_obj();
	    patchCopy.diffs = [];
	    for (var y = 0; y < patch.diffs.length; y++) {
	      patchCopy.diffs[y] = patch.diffs[y].slice();
	    }
	    patchCopy.start1 = patch.start1;
	    patchCopy.start2 = patch.start2;
	    patchCopy.length1 = patch.length1;
	    patchCopy.length2 = patch.length2;
	    patchesCopy[x] = patchCopy;
	  }
	  return patchesCopy;
	};
	
	
	/**
	 * Merge a set of patches onto the text.  Return a patched text, as well
	 * as a list of true/false values indicating which patches were applied.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @param {string} text Old text.
	 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
	 *      new text and an array of boolean values.
	 */
	diff_match_patch.prototype.patch_apply = function(patches, text) {
	  if (patches.length == 0) {
	    return [text, []];
	  }
	
	  // Deep copy the patches so that no changes are made to originals.
	  patches = this.patch_deepCopy(patches);
	
	  var nullPadding = this.patch_addPadding(patches);
	  text = nullPadding + text + nullPadding;
	
	  this.patch_splitMax(patches);
	  // delta keeps track of the offset between the expected and actual location
	  // of the previous patch.  If there are patches expected at positions 10 and
	  // 20, but the first patch was found at 12, delta is 2 and the second patch
	  // has an effective expected position of 22.
	  var delta = 0;
	  var results = [];
	  for (var x = 0; x < patches.length; x++) {
	    var expected_loc = patches[x].start2 + delta;
	    var text1 = this.diff_text1(patches[x].diffs);
	    var start_loc;
	    var end_loc = -1;
	    if (text1.length > this.Match_MaxBits) {
	      // patch_splitMax will only provide an oversized pattern in the case of
	      // a monster delete.
	      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
	                                  expected_loc);
	      if (start_loc != -1) {
	        end_loc = this.match_main(text,
	            text1.substring(text1.length - this.Match_MaxBits),
	            expected_loc + text1.length - this.Match_MaxBits);
	        if (end_loc == -1 || start_loc >= end_loc) {
	          // Can't find valid trailing context.  Drop this patch.
	          start_loc = -1;
	        }
	      }
	    } else {
	      start_loc = this.match_main(text, text1, expected_loc);
	    }
	    if (start_loc == -1) {
	      // No match found.  :(
	      results[x] = false;
	      // Subtract the delta for this failed patch from subsequent patches.
	      delta -= patches[x].length2 - patches[x].length1;
	    } else {
	      // Found a match.  :)
	      results[x] = true;
	      delta = start_loc - expected_loc;
	      var text2;
	      if (end_loc == -1) {
	        text2 = text.substring(start_loc, start_loc + text1.length);
	      } else {
	        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
	      }
	      if (text1 == text2) {
	        // Perfect match, just shove the replacement text in.
	        text = text.substring(0, start_loc) +
	               this.diff_text2(patches[x].diffs) +
	               text.substring(start_loc + text1.length);
	      } else {
	        // Imperfect match.  Run a diff to get a framework of equivalent
	        // indices.
	        var diffs = this.diff_main(text1, text2, false);
	        if (text1.length > this.Match_MaxBits &&
	            this.diff_levenshtein(diffs) / text1.length >
	            this.Patch_DeleteThreshold) {
	          // The end points match, but the content is unacceptably bad.
	          results[x] = false;
	        } else {
	          this.diff_cleanupSemanticLossless(diffs);
	          var index1 = 0;
	          var index2;
	          for (var y = 0; y < patches[x].diffs.length; y++) {
	            var mod = patches[x].diffs[y];
	            if (mod[0] !== DIFF_EQUAL) {
	              index2 = this.diff_xIndex(diffs, index1);
	            }
	            if (mod[0] === DIFF_INSERT) {  // Insertion
	              text = text.substring(0, start_loc + index2) + mod[1] +
	                     text.substring(start_loc + index2);
	            } else if (mod[0] === DIFF_DELETE) {  // Deletion
	              text = text.substring(0, start_loc + index2) +
	                     text.substring(start_loc + this.diff_xIndex(diffs,
	                         index1 + mod[1].length));
	            }
	            if (mod[0] !== DIFF_DELETE) {
	              index1 += mod[1].length;
	            }
	          }
	        }
	      }
	    }
	  }
	  // Strip the padding off.
	  text = text.substring(nullPadding.length, text.length - nullPadding.length);
	  return [text, results];
	};
	
	
	/**
	 * Add some padding on text start and end so that edges can match something.
	 * Intended to be called only from within patch_apply.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @return {string} The padding string added to each side.
	 */
	diff_match_patch.prototype.patch_addPadding = function(patches) {
	  var paddingLength = this.Patch_Margin;
	  var nullPadding = '';
	  for (var x = 1; x <= paddingLength; x++) {
	    nullPadding += String.fromCharCode(x);
	  }
	
	  // Bump all the patches forward.
	  for (var x = 0; x < patches.length; x++) {
	    patches[x].start1 += paddingLength;
	    patches[x].start2 += paddingLength;
	  }
	
	  // Add some padding on start of first diff.
	  var patch = patches[0];
	  var diffs = patch.diffs;
	  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
	    // Add nullPadding equality.
	    diffs.unshift([DIFF_EQUAL, nullPadding]);
	    patch.start1 -= paddingLength;  // Should be 0.
	    patch.start2 -= paddingLength;  // Should be 0.
	    patch.length1 += paddingLength;
	    patch.length2 += paddingLength;
	  } else if (paddingLength > diffs[0][1].length) {
	    // Grow first equality.
	    var extraLength = paddingLength - diffs[0][1].length;
	    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
	    patch.start1 -= extraLength;
	    patch.start2 -= extraLength;
	    patch.length1 += extraLength;
	    patch.length2 += extraLength;
	  }
	
	  // Add some padding on end of last diff.
	  patch = patches[patches.length - 1];
	  diffs = patch.diffs;
	  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
	    // Add nullPadding equality.
	    diffs.push([DIFF_EQUAL, nullPadding]);
	    patch.length1 += paddingLength;
	    patch.length2 += paddingLength;
	  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
	    // Grow last equality.
	    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
	    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
	    patch.length1 += extraLength;
	    patch.length2 += extraLength;
	  }
	
	  return nullPadding;
	};
	
	
	/**
	 * Look through the patches and break up any which are longer than the maximum
	 * limit of the match algorithm.
	 * Intended to be called only from within patch_apply.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 */
	diff_match_patch.prototype.patch_splitMax = function(patches) {
	  var patch_size = this.Match_MaxBits;
	  for (var x = 0; x < patches.length; x++) {
	    if (patches[x].length1 <= patch_size) {
	      continue;
	    }
	    var bigpatch = patches[x];
	    // Remove the big old patch.
	    patches.splice(x--, 1);
	    var start1 = bigpatch.start1;
	    var start2 = bigpatch.start2;
	    var precontext = '';
	    while (bigpatch.diffs.length !== 0) {
	      // Create one of several smaller patches.
	      var patch = new diff_match_patch.patch_obj();
	      var empty = true;
	      patch.start1 = start1 - precontext.length;
	      patch.start2 = start2 - precontext.length;
	      if (precontext !== '') {
	        patch.length1 = patch.length2 = precontext.length;
	        patch.diffs.push([DIFF_EQUAL, precontext]);
	      }
	      while (bigpatch.diffs.length !== 0 &&
	             patch.length1 < patch_size - this.Patch_Margin) {
	        var diff_type = bigpatch.diffs[0][0];
	        var diff_text = bigpatch.diffs[0][1];
	        if (diff_type === DIFF_INSERT) {
	          // Insertions are harmless.
	          patch.length2 += diff_text.length;
	          start2 += diff_text.length;
	          patch.diffs.push(bigpatch.diffs.shift());
	          empty = false;
	        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
	                   patch.diffs[0][0] == DIFF_EQUAL &&
	                   diff_text.length > 2 * patch_size) {
	          // This is a large deletion.  Let it pass in one chunk.
	          patch.length1 += diff_text.length;
	          start1 += diff_text.length;
	          empty = false;
	          patch.diffs.push([diff_type, diff_text]);
	          bigpatch.diffs.shift();
	        } else {
	          // Deletion or equality.  Only take as much as we can stomach.
	          diff_text = diff_text.substring(0,
	              patch_size - patch.length1 - this.Patch_Margin);
	          patch.length1 += diff_text.length;
	          start1 += diff_text.length;
	          if (diff_type === DIFF_EQUAL) {
	            patch.length2 += diff_text.length;
	            start2 += diff_text.length;
	          } else {
	            empty = false;
	          }
	          patch.diffs.push([diff_type, diff_text]);
	          if (diff_text == bigpatch.diffs[0][1]) {
	            bigpatch.diffs.shift();
	          } else {
	            bigpatch.diffs[0][1] =
	                bigpatch.diffs[0][1].substring(diff_text.length);
	          }
	        }
	      }
	      // Compute the head context for the next patch.
	      precontext = this.diff_text2(patch.diffs);
	      precontext =
	          precontext.substring(precontext.length - this.Patch_Margin);
	      // Append the end context for this patch.
	      var postcontext = this.diff_text1(bigpatch.diffs)
	                            .substring(0, this.Patch_Margin);
	      if (postcontext !== '') {
	        patch.length1 += postcontext.length;
	        patch.length2 += postcontext.length;
	        if (patch.diffs.length !== 0 &&
	            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
	          patch.diffs[patch.diffs.length - 1][1] += postcontext;
	        } else {
	          patch.diffs.push([DIFF_EQUAL, postcontext]);
	        }
	      }
	      if (!empty) {
	        patches.splice(++x, 0, patch);
	      }
	    }
	  }
	};
	
	
	/**
	 * Take a list of patches and return a textual representation.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @return {string} Text representation of patches.
	 */
	diff_match_patch.prototype.patch_toText = function(patches) {
	  var text = [];
	  for (var x = 0; x < patches.length; x++) {
	    text[x] = patches[x];
	  }
	  return text.join('');
	};
	
	
	/**
	 * Parse a textual representation of patches and return a list of Patch objects.
	 * @param {string} textline Text representation of patches.
	 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
	 * @throws {!Error} If invalid input.
	 */
	diff_match_patch.prototype.patch_fromText = function(textline) {
	  var patches = [];
	  if (!textline) {
	    return patches;
	  }
	  var text = textline.split('\n');
	  var textPointer = 0;
	  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
	  while (textPointer < text.length) {
	    var m = text[textPointer].match(patchHeader);
	    if (!m) {
	      throw new Error('Invalid patch string: ' + text[textPointer]);
	    }
	    var patch = new diff_match_patch.patch_obj();
	    patches.push(patch);
	    patch.start1 = parseInt(m[1], 10);
	    if (m[2] === '') {
	      patch.start1--;
	      patch.length1 = 1;
	    } else if (m[2] == '0') {
	      patch.length1 = 0;
	    } else {
	      patch.start1--;
	      patch.length1 = parseInt(m[2], 10);
	    }
	
	    patch.start2 = parseInt(m[3], 10);
	    if (m[4] === '') {
	      patch.start2--;
	      patch.length2 = 1;
	    } else if (m[4] == '0') {
	      patch.length2 = 0;
	    } else {
	      patch.start2--;
	      patch.length2 = parseInt(m[4], 10);
	    }
	    textPointer++;
	
	    while (textPointer < text.length) {
	      var sign = text[textPointer].charAt(0);
	      try {
	        var line = decodeURI(text[textPointer].substring(1));
	      } catch (ex) {
	        // Malformed URI sequence.
	        throw new Error('Illegal escape in patch_fromText: ' + line);
	      }
	      if (sign == '-') {
	        // Deletion.
	        patch.diffs.push([DIFF_DELETE, line]);
	      } else if (sign == '+') {
	        // Insertion.
	        patch.diffs.push([DIFF_INSERT, line]);
	      } else if (sign == ' ') {
	        // Minor equality.
	        patch.diffs.push([DIFF_EQUAL, line]);
	      } else if (sign == '@') {
	        // Start of next patch.
	        break;
	      } else if (sign === '') {
	        // Blank line?  Whatever.
	      } else {
	        // WTF?
	        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
	      }
	      textPointer++;
	    }
	  }
	  return patches;
	};
	
	
	/**
	 * Class representing one patch operation.
	 * @constructor
	 */
	diff_match_patch.patch_obj = function() {
	  /** @type {!Array.<!diff_match_patch.Diff>} */
	  this.diffs = [];
	  /** @type {?number} */
	  this.start1 = null;
	  /** @type {?number} */
	  this.start2 = null;
	  /** @type {number} */
	  this.length1 = 0;
	  /** @type {number} */
	  this.length2 = 0;
	};
	
	
	/**
	 * Emmulate GNU diff's format.
	 * Header: @@ -382,8 +481,9 @@
	 * Indicies are printed as 1-based, not 0-based.
	 * @return {string} The GNU diff string.
	 */
	diff_match_patch.patch_obj.prototype.toString = function() {
	  var coords1, coords2;
	  if (this.length1 === 0) {
	    coords1 = this.start1 + ',0';
	  } else if (this.length1 == 1) {
	    coords1 = this.start1 + 1;
	  } else {
	    coords1 = (this.start1 + 1) + ',' + this.length1;
	  }
	  if (this.length2 === 0) {
	    coords2 = this.start2 + ',0';
	  } else if (this.length2 == 1) {
	    coords2 = this.start2 + 1;
	  } else {
	    coords2 = (this.start2 + 1) + ',' + this.length2;
	  }
	  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
	  var op;
	  // Escape the body of the patch with %xx notation.
	  for (var x = 0; x < this.diffs.length; x++) {
	    switch (this.diffs[x][0]) {
	      case DIFF_INSERT:
	        op = '+';
	        break;
	      case DIFF_DELETE:
	        op = '-';
	        break;
	      case DIFF_EQUAL:
	        op = ' ';
	        break;
	    }
	    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
	  }
	  return text.join('').replace(/%20/g, ' ');
	};
	
	
	// The following export code was added by @ForbesLindesay
	module.exports = diff_match_patch;
	module.exports['diff_match_patch'] = diff_match_patch;
	module.exports['DIFF_DELETE'] = DIFF_DELETE;
	module.exports['DIFF_INSERT'] = DIFF_INSERT;
	module.exports['DIFF_EQUAL'] = DIFF_EQUAL;


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	var eaw = {};
	
	if (false) {
	  window.eastasianwidth = eaw;
	} else {
	  module.exports = eaw;
	}
	
	eaw.eastAsianWidth = function(character) {
	  var x = character.charCodeAt(0);
	  var y = (character.length == 2) ? character.charCodeAt(1) : 0;
	  var codePoint = x;
	  if ((0xD800 <= x && x <= 0xDBFF) && (0xDC00 <= y && y <= 0xDFFF)) {
	    x &= 0x3FF;
	    y &= 0x3FF;
	    codePoint = (x << 10) | y;
	    codePoint += 0x10000;
	  }
	
	  if ((0x3000 == codePoint) ||
	      (0xFF01 <= codePoint && codePoint <= 0xFF60) ||
	      (0xFFE0 <= codePoint && codePoint <= 0xFFE6)) {
	    return 'F';
	  }
	  if ((0x20A9 == codePoint) ||
	      (0xFF61 <= codePoint && codePoint <= 0xFFBE) ||
	      (0xFFC2 <= codePoint && codePoint <= 0xFFC7) ||
	      (0xFFCA <= codePoint && codePoint <= 0xFFCF) ||
	      (0xFFD2 <= codePoint && codePoint <= 0xFFD7) ||
	      (0xFFDA <= codePoint && codePoint <= 0xFFDC) ||
	      (0xFFE8 <= codePoint && codePoint <= 0xFFEE)) {
	    return 'H';
	  }
	  if ((0x1100 <= codePoint && codePoint <= 0x115F) ||
	      (0x11A3 <= codePoint && codePoint <= 0x11A7) ||
	      (0x11FA <= codePoint && codePoint <= 0x11FF) ||
	      (0x2329 <= codePoint && codePoint <= 0x232A) ||
	      (0x2E80 <= codePoint && codePoint <= 0x2E99) ||
	      (0x2E9B <= codePoint && codePoint <= 0x2EF3) ||
	      (0x2F00 <= codePoint && codePoint <= 0x2FD5) ||
	      (0x2FF0 <= codePoint && codePoint <= 0x2FFB) ||
	      (0x3001 <= codePoint && codePoint <= 0x303E) ||
	      (0x3041 <= codePoint && codePoint <= 0x3096) ||
	      (0x3099 <= codePoint && codePoint <= 0x30FF) ||
	      (0x3105 <= codePoint && codePoint <= 0x312D) ||
	      (0x3131 <= codePoint && codePoint <= 0x318E) ||
	      (0x3190 <= codePoint && codePoint <= 0x31BA) ||
	      (0x31C0 <= codePoint && codePoint <= 0x31E3) ||
	      (0x31F0 <= codePoint && codePoint <= 0x321E) ||
	      (0x3220 <= codePoint && codePoint <= 0x3247) ||
	      (0x3250 <= codePoint && codePoint <= 0x32FE) ||
	      (0x3300 <= codePoint && codePoint <= 0x4DBF) ||
	      (0x4E00 <= codePoint && codePoint <= 0xA48C) ||
	      (0xA490 <= codePoint && codePoint <= 0xA4C6) ||
	      (0xA960 <= codePoint && codePoint <= 0xA97C) ||
	      (0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
	      (0xD7B0 <= codePoint && codePoint <= 0xD7C6) ||
	      (0xD7CB <= codePoint && codePoint <= 0xD7FB) ||
	      (0xF900 <= codePoint && codePoint <= 0xFAFF) ||
	      (0xFE10 <= codePoint && codePoint <= 0xFE19) ||
	      (0xFE30 <= codePoint && codePoint <= 0xFE52) ||
	      (0xFE54 <= codePoint && codePoint <= 0xFE66) ||
	      (0xFE68 <= codePoint && codePoint <= 0xFE6B) ||
	      (0x1B000 <= codePoint && codePoint <= 0x1B001) ||
	      (0x1F200 <= codePoint && codePoint <= 0x1F202) ||
	      (0x1F210 <= codePoint && codePoint <= 0x1F23A) ||
	      (0x1F240 <= codePoint && codePoint <= 0x1F248) ||
	      (0x1F250 <= codePoint && codePoint <= 0x1F251) ||
	      (0x20000 <= codePoint && codePoint <= 0x2F73F) ||
	      (0x2B740 <= codePoint && codePoint <= 0x2FFFD) ||
	      (0x30000 <= codePoint && codePoint <= 0x3FFFD)) {
	    return 'W';
	  }
	  if ((0x0020 <= codePoint && codePoint <= 0x007E) ||
	      (0x00A2 <= codePoint && codePoint <= 0x00A3) ||
	      (0x00A5 <= codePoint && codePoint <= 0x00A6) ||
	      (0x00AC == codePoint) ||
	      (0x00AF == codePoint) ||
	      (0x27E6 <= codePoint && codePoint <= 0x27ED) ||
	      (0x2985 <= codePoint && codePoint <= 0x2986)) {
	    return 'Na';
	  }
	  if ((0x00A1 == codePoint) ||
	      (0x00A4 == codePoint) ||
	      (0x00A7 <= codePoint && codePoint <= 0x00A8) ||
	      (0x00AA == codePoint) ||
	      (0x00AD <= codePoint && codePoint <= 0x00AE) ||
	      (0x00B0 <= codePoint && codePoint <= 0x00B4) ||
	      (0x00B6 <= codePoint && codePoint <= 0x00BA) ||
	      (0x00BC <= codePoint && codePoint <= 0x00BF) ||
	      (0x00C6 == codePoint) ||
	      (0x00D0 == codePoint) ||
	      (0x00D7 <= codePoint && codePoint <= 0x00D8) ||
	      (0x00DE <= codePoint && codePoint <= 0x00E1) ||
	      (0x00E6 == codePoint) ||
	      (0x00E8 <= codePoint && codePoint <= 0x00EA) ||
	      (0x00EC <= codePoint && codePoint <= 0x00ED) ||
	      (0x00F0 == codePoint) ||
	      (0x00F2 <= codePoint && codePoint <= 0x00F3) ||
	      (0x00F7 <= codePoint && codePoint <= 0x00FA) ||
	      (0x00FC == codePoint) ||
	      (0x00FE == codePoint) ||
	      (0x0101 == codePoint) ||
	      (0x0111 == codePoint) ||
	      (0x0113 == codePoint) ||
	      (0x011B == codePoint) ||
	      (0x0126 <= codePoint && codePoint <= 0x0127) ||
	      (0x012B == codePoint) ||
	      (0x0131 <= codePoint && codePoint <= 0x0133) ||
	      (0x0138 == codePoint) ||
	      (0x013F <= codePoint && codePoint <= 0x0142) ||
	      (0x0144 == codePoint) ||
	      (0x0148 <= codePoint && codePoint <= 0x014B) ||
	      (0x014D == codePoint) ||
	      (0x0152 <= codePoint && codePoint <= 0x0153) ||
	      (0x0166 <= codePoint && codePoint <= 0x0167) ||
	      (0x016B == codePoint) ||
	      (0x01CE == codePoint) ||
	      (0x01D0 == codePoint) ||
	      (0x01D2 == codePoint) ||
	      (0x01D4 == codePoint) ||
	      (0x01D6 == codePoint) ||
	      (0x01D8 == codePoint) ||
	      (0x01DA == codePoint) ||
	      (0x01DC == codePoint) ||
	      (0x0251 == codePoint) ||
	      (0x0261 == codePoint) ||
	      (0x02C4 == codePoint) ||
	      (0x02C7 == codePoint) ||
	      (0x02C9 <= codePoint && codePoint <= 0x02CB) ||
	      (0x02CD == codePoint) ||
	      (0x02D0 == codePoint) ||
	      (0x02D8 <= codePoint && codePoint <= 0x02DB) ||
	      (0x02DD == codePoint) ||
	      (0x02DF == codePoint) ||
	      (0x0300 <= codePoint && codePoint <= 0x036F) ||
	      (0x0391 <= codePoint && codePoint <= 0x03A1) ||
	      (0x03A3 <= codePoint && codePoint <= 0x03A9) ||
	      (0x03B1 <= codePoint && codePoint <= 0x03C1) ||
	      (0x03C3 <= codePoint && codePoint <= 0x03C9) ||
	      (0x0401 == codePoint) ||
	      (0x0410 <= codePoint && codePoint <= 0x044F) ||
	      (0x0451 == codePoint) ||
	      (0x2010 == codePoint) ||
	      (0x2013 <= codePoint && codePoint <= 0x2016) ||
	      (0x2018 <= codePoint && codePoint <= 0x2019) ||
	      (0x201C <= codePoint && codePoint <= 0x201D) ||
	      (0x2020 <= codePoint && codePoint <= 0x2022) ||
	      (0x2024 <= codePoint && codePoint <= 0x2027) ||
	      (0x2030 == codePoint) ||
	      (0x2032 <= codePoint && codePoint <= 0x2033) ||
	      (0x2035 == codePoint) ||
	      (0x203B == codePoint) ||
	      (0x203E == codePoint) ||
	      (0x2074 == codePoint) ||
	      (0x207F == codePoint) ||
	      (0x2081 <= codePoint && codePoint <= 0x2084) ||
	      (0x20AC == codePoint) ||
	      (0x2103 == codePoint) ||
	      (0x2105 == codePoint) ||
	      (0x2109 == codePoint) ||
	      (0x2113 == codePoint) ||
	      (0x2116 == codePoint) ||
	      (0x2121 <= codePoint && codePoint <= 0x2122) ||
	      (0x2126 == codePoint) ||
	      (0x212B == codePoint) ||
	      (0x2153 <= codePoint && codePoint <= 0x2154) ||
	      (0x215B <= codePoint && codePoint <= 0x215E) ||
	      (0x2160 <= codePoint && codePoint <= 0x216B) ||
	      (0x2170 <= codePoint && codePoint <= 0x2179) ||
	      (0x2189 == codePoint) ||
	      (0x2190 <= codePoint && codePoint <= 0x2199) ||
	      (0x21B8 <= codePoint && codePoint <= 0x21B9) ||
	      (0x21D2 == codePoint) ||
	      (0x21D4 == codePoint) ||
	      (0x21E7 == codePoint) ||
	      (0x2200 == codePoint) ||
	      (0x2202 <= codePoint && codePoint <= 0x2203) ||
	      (0x2207 <= codePoint && codePoint <= 0x2208) ||
	      (0x220B == codePoint) ||
	      (0x220F == codePoint) ||
	      (0x2211 == codePoint) ||
	      (0x2215 == codePoint) ||
	      (0x221A == codePoint) ||
	      (0x221D <= codePoint && codePoint <= 0x2220) ||
	      (0x2223 == codePoint) ||
	      (0x2225 == codePoint) ||
	      (0x2227 <= codePoint && codePoint <= 0x222C) ||
	      (0x222E == codePoint) ||
	      (0x2234 <= codePoint && codePoint <= 0x2237) ||
	      (0x223C <= codePoint && codePoint <= 0x223D) ||
	      (0x2248 == codePoint) ||
	      (0x224C == codePoint) ||
	      (0x2252 == codePoint) ||
	      (0x2260 <= codePoint && codePoint <= 0x2261) ||
	      (0x2264 <= codePoint && codePoint <= 0x2267) ||
	      (0x226A <= codePoint && codePoint <= 0x226B) ||
	      (0x226E <= codePoint && codePoint <= 0x226F) ||
	      (0x2282 <= codePoint && codePoint <= 0x2283) ||
	      (0x2286 <= codePoint && codePoint <= 0x2287) ||
	      (0x2295 == codePoint) ||
	      (0x2299 == codePoint) ||
	      (0x22A5 == codePoint) ||
	      (0x22BF == codePoint) ||
	      (0x2312 == codePoint) ||
	      (0x2460 <= codePoint && codePoint <= 0x24E9) ||
	      (0x24EB <= codePoint && codePoint <= 0x254B) ||
	      (0x2550 <= codePoint && codePoint <= 0x2573) ||
	      (0x2580 <= codePoint && codePoint <= 0x258F) ||
	      (0x2592 <= codePoint && codePoint <= 0x2595) ||
	      (0x25A0 <= codePoint && codePoint <= 0x25A1) ||
	      (0x25A3 <= codePoint && codePoint <= 0x25A9) ||
	      (0x25B2 <= codePoint && codePoint <= 0x25B3) ||
	      (0x25B6 <= codePoint && codePoint <= 0x25B7) ||
	      (0x25BC <= codePoint && codePoint <= 0x25BD) ||
	      (0x25C0 <= codePoint && codePoint <= 0x25C1) ||
	      (0x25C6 <= codePoint && codePoint <= 0x25C8) ||
	      (0x25CB == codePoint) ||
	      (0x25CE <= codePoint && codePoint <= 0x25D1) ||
	      (0x25E2 <= codePoint && codePoint <= 0x25E5) ||
	      (0x25EF == codePoint) ||
	      (0x2605 <= codePoint && codePoint <= 0x2606) ||
	      (0x2609 == codePoint) ||
	      (0x260E <= codePoint && codePoint <= 0x260F) ||
	      (0x2614 <= codePoint && codePoint <= 0x2615) ||
	      (0x261C == codePoint) ||
	      (0x261E == codePoint) ||
	      (0x2640 == codePoint) ||
	      (0x2642 == codePoint) ||
	      (0x2660 <= codePoint && codePoint <= 0x2661) ||
	      (0x2663 <= codePoint && codePoint <= 0x2665) ||
	      (0x2667 <= codePoint && codePoint <= 0x266A) ||
	      (0x266C <= codePoint && codePoint <= 0x266D) ||
	      (0x266F == codePoint) ||
	      (0x269E <= codePoint && codePoint <= 0x269F) ||
	      (0x26BE <= codePoint && codePoint <= 0x26BF) ||
	      (0x26C4 <= codePoint && codePoint <= 0x26CD) ||
	      (0x26CF <= codePoint && codePoint <= 0x26E1) ||
	      (0x26E3 == codePoint) ||
	      (0x26E8 <= codePoint && codePoint <= 0x26FF) ||
	      (0x273D == codePoint) ||
	      (0x2757 == codePoint) ||
	      (0x2776 <= codePoint && codePoint <= 0x277F) ||
	      (0x2B55 <= codePoint && codePoint <= 0x2B59) ||
	      (0x3248 <= codePoint && codePoint <= 0x324F) ||
	      (0xE000 <= codePoint && codePoint <= 0xF8FF) ||
	      (0xFE00 <= codePoint && codePoint <= 0xFE0F) ||
	      (0xFFFD == codePoint) ||
	      (0x1F100 <= codePoint && codePoint <= 0x1F10A) ||
	      (0x1F110 <= codePoint && codePoint <= 0x1F12D) ||
	      (0x1F130 <= codePoint && codePoint <= 0x1F169) ||
	      (0x1F170 <= codePoint && codePoint <= 0x1F19A) ||
	      (0xE0100 <= codePoint && codePoint <= 0xE01EF) ||
	      (0xF0000 <= codePoint && codePoint <= 0xFFFFD) ||
	      (0x100000 <= codePoint && codePoint <= 0x10FFFD)) {
	    return 'A';
	  }
	
	  return 'N';
	};
	
	eaw.characterLength = function(character) {
	  var code = this.eastAsianWidth(character);
	  if (code == 'F' || code == 'W' || code == 'A') {
	    return 2;
	  } else {
	    return 1;
	  }
	};
	
	eaw.length = function(string) {
	  var len = 0;
	  for (var i = 0; i < string.length; i++) {
	    len = len + this.characterLength(string.charAt(i));
	  }
	  return len;
	};
	
	eaw.slice = function(text, start, end) {
	  start = start ? start : 0;
	  end = end ? end : 1;
	  var result = '';
	  for (var i = 0; i < text.length; i++) {
	    var char = text.charAt(i);
	    var eawLen = eaw.length(result + char);
	    if (eawLen >= 1 + start && eawLen < 1 + end) {
	      result += char
	    }
	  }
	  return result;
	};


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var some = __webpack_require__(258);
	var map = __webpack_require__(111);
	
	function decorate (callSpec, decorator) {
	    var numArgsToCapture = callSpec.numArgsToCapture;
	
	    return function decoratedAssert () {
	        var context, message, hasMessage = false;
	
	        // see: https://github.com/twada/empower-core/pull/8#issue-127859465
	        // see: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
	        var args = new Array(arguments.length);
	        for(var i = 0; i < args.length; ++i) {
	            args[i] = arguments[i];
	        }
	
	        if (numArgsToCapture === (args.length - 1)) {
	            message = args.pop();
	            hasMessage = true;
	        }
	
	        var invocation = {
	            thisObj: this,
	            values: args,
	            message: message,
	            hasMessage: hasMessage
	        };
	
	        if (some(args, isCaptured)) {
	            invocation.values = map(args.slice(0, numArgsToCapture), function (arg) {
	                if (isNotCaptured(arg)) {
	                    return arg;
	                }
	                if (!context) {
	                    context = {
	                        source: arg.source,
	                        args: []
	                    };
	                }
	                context.args.push({
	                    value: arg.powerAssertContext.value,
	                    events: arg.powerAssertContext.events
	                });
	                return arg.powerAssertContext.value;
	            });
	
	            return decorator.concreteAssert(callSpec, invocation, context);
	        } else {
	            return decorator.concreteAssert(callSpec, invocation);
	        }
	    };
	}
	
	function isNotCaptured (value) {
	    return !isCaptured(value);
	}
	
	function isCaptured (value) {
	    return (typeof value === 'object') &&
	        (value !== null) &&
	        (typeof value.powerAssertContext !== 'undefined');
	}
	
	module.exports = decorate;


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var forEach = __webpack_require__(27);
	var filter = __webpack_require__(164);
	var map = __webpack_require__(111);
	var signature = __webpack_require__(254);
	var decorate = __webpack_require__(318);
	var keys = __webpack_require__(34);
	
	
	function Decorator (receiver, config) {
	    this.receiver = receiver;
	    this.config = config;
	    this.onError = config.onError;
	    this.onSuccess = config.onSuccess;
	    this.signatures = map(config.patterns, parse);
	    this.wrapOnlySignatures = map(config.wrapOnlyPatterns, parse);
	}
	
	Decorator.prototype.enhancement = function () {
	    var that = this;
	    var container = this.container();
	    var wrappedMethods = [];
	
	    function attach(matcherSpec, enhanced) {
	        var matcher = matcherSpec.parsed;
	        var methodName = detectMethodName(matcher.callee);
	        if (typeof that.receiver[methodName] !== 'function' || wrappedMethods.indexOf(methodName) !== -1) {
	            return;
	        }
	        var callSpec = {
	            thisObj: that.receiver,
	            func: that.receiver[methodName],
	            numArgsToCapture: numberOfArgumentsToCapture(matcherSpec),
	            matcherSpec: matcherSpec,
	            enhanced: enhanced
	        };
	        container[methodName] = callSpec.enhancedFunc = decorate(callSpec, that);
	        wrappedMethods.push(methodName);
	    }
	
	    forEach(filter(this.signatures, methodCall), function (matcher) {
	        attach(matcher, true);
	    });
	
	    forEach(filter(this.wrapOnlySignatures, methodCall), function (matcher) {
	        attach(matcher, false);
	    });
	
	    return container;
	};
	
	Decorator.prototype.container = function () {
	    var basement = {};
	    if (typeof this.receiver === 'function') {
	        var candidates = filter(this.signatures, functionCall);
	        var enhanced = true;
	        if (candidates.length === 0) {
	            enhanced = false;
	            candidates = filter(this.wrapOnlySignatures, functionCall);
	        }
	        if (candidates.length === 1) {
	            var callSpec = {
	                thisObj: null,
	                func: this.receiver,
	                numArgsToCapture: numberOfArgumentsToCapture(candidates[0]),
	                matcherSpec: candidates[0],
	                enhanced: enhanced
	            };
	            basement = callSpec.enhancedFunc = decorate(callSpec, this);
	        }
	    }
	    return basement;
	};
	
	Decorator.prototype.concreteAssert = function (callSpec, invocation, context) {
	    var func = callSpec.func;
	    var thisObj = this.config.bindReceiver ? callSpec.thisObj : invocation.thisObj;
	    var enhanced = callSpec.enhanced;
	    var args = invocation.values;
	    var message = invocation.message;
	    var matcherSpec = callSpec.matcherSpec;
	
	    if (context && typeof this.config.modifyMessageBeforeAssert === 'function') {
	        message = this.config.modifyMessageBeforeAssert({originalMessage: message, powerAssertContext: context});
	    }
	    args = args.concat(message);
	
	    var data = {
	        thisObj: invocation.thisObj,
	        assertionFunction: callSpec.enhancedFunc,
	        originalMessage: message,
	        defaultMessage: matcherSpec.defaultMessage,
	        matcherSpec: matcherSpec,
	        enhanced: enhanced,
	        args: args
	    };
	
	    if (context) {
	        data.powerAssertContext = context;
	    }
	
	    return this._callFunc(func, thisObj, args, data);
	};
	
	// see: https://github.com/twada/empower-core/pull/8#issuecomment-173480982
	Decorator.prototype._callFunc = function (func, thisObj, args, data) {
	    var ret;
	    try {
	        ret = func.apply(thisObj, args);
	    } catch (e) {
	        data.assertionThrew = true;
	        data.error = e;
	        return this.onError.call(thisObj, data);
	    }
	    data.assertionThrew = false;
	    data.returnValue = ret;
	    return this.onSuccess.call(thisObj, data);
	};
	
	function numberOfArgumentsToCapture (matcherSpec) {
	    var matcher = matcherSpec.parsed;
	    var len = matcher.args.length;
	    var lastArg;
	    if (0 < len) {
	        lastArg = matcher.args[len - 1];
	        if (lastArg.name === 'message' && lastArg.optional) {
	            len -= 1;
	        }
	    }
	    return len;
	}
	
	
	function detectMethodName (callee) {
	    if (callee.type === 'MemberExpression') {
	        return callee.member;
	    }
	    return null;
	}
	
	
	function functionCall (matcherSpec) {
	    return matcherSpec.parsed.callee.type === 'Identifier';
	}
	
	
	function methodCall (matcherSpec) {
	    return matcherSpec.parsed.callee.type === 'MemberExpression';
	}
	
	function parse(matcherSpec) {
	    if (typeof matcherSpec === 'string') {
	        matcherSpec = {pattern: matcherSpec};
	    }
	    var ret = {};
	    forEach(keys(matcherSpec), function (key) {
	        ret[key] = matcherSpec[key];
	    });
	    ret.parsed = signature.parse(matcherSpec.pattern);
	    return ret;
	}
	
	
	module.exports = Decorator;


/***/ },
/* 320 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function defaultOptions () {
	    return {
	        destructive: false,
	        bindReceiver: true,
	        onError: onError,
	        onSuccess: onSuccess,
	        patterns: [
	            'assert(value, [message])',
	            'assert.ok(value, [message])',
	            'assert.equal(actual, expected, [message])',
	            'assert.notEqual(actual, expected, [message])',
	            'assert.strictEqual(actual, expected, [message])',
	            'assert.notStrictEqual(actual, expected, [message])',
	            'assert.deepEqual(actual, expected, [message])',
	            'assert.notDeepEqual(actual, expected, [message])',
	            'assert.deepStrictEqual(actual, expected, [message])',
	            'assert.notDeepStrictEqual(actual, expected, [message])'
	        ],
	        wrapOnlyPatterns: []
	    };
	};
	
	function onError (errorEvent) {
	    var e = errorEvent.error;
	    if (errorEvent.powerAssertContext && e.name === 'AssertionError') {
	        e.powerAssertContext = errorEvent.powerAssertContext;
	    }
	    throw e;
	}
	
	function onSuccess(successEvent) {
	    return successEvent.returnValue;
	}


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defineProperty = __webpack_require__(166);
	var forEach = __webpack_require__(27);
	var keys = __webpack_require__(34);
	
	module.exports = function defineProperties (obj, map) {
	    forEach(keys(map), function (name) {
	        defineProperty(obj, name, {
	            configurable: true,
	            enumerable: false,
	            value: map[name],
	            writable: true
	        });
	    });
	};


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * empower - Power Assert feature enhancer for assert function/object.
	 *
	 * https://github.com/power-assert-js/empower
	 *
	 * Copyright (c) 2013-2016 Takuto Wada
	 * Licensed under the MIT license.
	 *   https://github.com/power-assert-js/empower/blob/master/MIT-LICENSE.txt
	 */
	var empowerCore = __webpack_require__(184);
	var defaultOptions = __webpack_require__(324);
	var capturable = __webpack_require__(323);
	var assign = __webpack_require__(11);
	var define = __webpack_require__(325);
	
	/**
	 * Enhance Power Assert feature to assert function/object.
	 * @param assert target assert function or object to enhance
	 * @param formatter power assert format function
	 * @param options enhancement options
	 * @return enhanced assert function/object
	 */
	function empower (assert, formatter, options) {
	    var config = assign(defaultOptions(), options);
	    var eagerEvaluation = !(config.modifyMessageOnRethrow || config.saveContextOnRethrow);
	    var empowerCoreConfig = assign(config, {
	        modifyMessageBeforeAssert: function (beforeAssertEvent) {
	            var message = beforeAssertEvent.originalMessage;
	            if (!eagerEvaluation) {
	                return message;
	            }
	            return buildPowerAssertText(formatter, message, beforeAssertEvent.powerAssertContext);
	        },
	        onError: function (errorEvent) {
	            var e = errorEvent.error;
	            if (e.name !== 'AssertionError') {
	                throw e;
	            }
	            if (!errorEvent.powerAssertContext) {
	                throw e;
	            }
	            // console.log(JSON.stringify(errorEvent, null, 2));
	            if (config.modifyMessageOnRethrow) {
	                e.message = buildPowerAssertText(formatter, errorEvent.originalMessage, errorEvent.powerAssertContext);
	            }
	            if (config.saveContextOnRethrow) {
	                e.powerAssertContext = errorEvent.powerAssertContext;
	            }
	            throw e;
	        }
	    });
	    var enhancedAssert = empowerCore(assert, empowerCoreConfig);
	    define(enhancedAssert, capturable());
	    return enhancedAssert;
	}
	
	function buildPowerAssertText (formatter, message, context) {
	    // console.log(message);
	    var powerAssertText = formatter(context);
	    return message ? message + ' ' + powerAssertText : powerAssertText;
	};
	
	empower.defaultOptions = defaultOptions;
	module.exports = empower;


/***/ },
/* 323 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function capturable () {
	    var events = [];
	
	    function _capt (value, espath) {
	        events.push({value: value, espath: espath});
	        return value;
	    }
	
	    function _expr (value, args) {
	        var captured = events;
	        events = [];
	        var source = {
	            content: args.content,
	            filepath: args.filepath,
	            line: args.line
	        };
	        if (args.generator) {
	            source.generator = true;
	        }
	        if (args.async) {
	            source.async = true;
	        }
	        return {
	            powerAssertContext: {
	                value: value,
	                events: captured
	            },
	            source: source
	        };
	    }
	
	    return {
	        _capt: _capt,
	        _expr: _expr
	    };
	};


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var empowerCore = __webpack_require__(184);
	var assign = __webpack_require__(11);
	
	module.exports = function defaultOptions () {
	    return assign(empowerCore.defaultOptions(), {
	        modifyMessageOnRethrow: false,
	        saveContextOnRethrow: false
	    });
	};


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defineProperty = __webpack_require__(166);
	var forEach = __webpack_require__(27);
	var keys = __webpack_require__(34);
	
	module.exports = function defineProperties (obj, map) {
	    forEach(keys(map), function (name) {
	        defineProperty(obj, name, {
	            configurable: true,
	            enumerable: false,
	            value: map[name],
	            writable: true
	        });
	    });
	};


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * espurify - Clone new AST without extra properties
	 * 
	 * https://github.com/estools/espurify
	 *
	 * Copyright (c) 2014-2016 Takuto Wada
	 * Licensed under the MIT license.
	 *   https://github.com/estools/espurify/blob/master/MIT-LICENSE.txt
	 */
	'use strict';
	
	var createWhitelist = __webpack_require__(329);
	var cloneWithWhitelist = __webpack_require__(328);
	
	function createCloneFunction (options) {
	    return cloneWithWhitelist(createWhitelist(options));
	}
	
	var espurify = createCloneFunction();
	espurify.customize = createCloneFunction;
	espurify.cloneWithWhitelist = cloneWithWhitelist;
	module.exports = espurify;


/***/ },
/* 327 */
/***/ function(module, exports) {

	module.exports = {
	    ArrayExpression: ['type', 'elements'],
	    ArrayPattern: ['type', 'elements'],
	    ArrowFunctionExpression: ['type', 'id', 'params', 'body', 'generator', 'expression'],
	    AssignmentExpression: ['type', 'operator', 'left', 'right'],
	    AssignmentPattern: ['type', 'left', 'right'],
	    BinaryExpression: ['type', 'operator', 'left', 'right'],
	    BlockStatement: ['type', 'body'],
	    BreakStatement: ['type', 'label'],
	    CallExpression: ['type', 'callee', 'arguments'],
	    CatchClause: ['type', 'param', 'guard', 'body'],
	    ClassBody: ['type', 'body'],
	    ClassDeclaration: ['type', 'id', 'superClass', 'body'],
	    ClassExpression: ['type', 'id', 'superClass', 'body'],
	    ConditionalExpression: ['type', 'test', 'alternate', 'consequent'],
	    ContinueStatement: ['type', 'label'],
	    DebuggerStatement: ['type'],
	    DoWhileStatement: ['type', 'body', 'test'],
	    EmptyStatement: ['type'],
	    ExportAllDeclaration: ['type', 'source'],
	    ExportDefaultDeclaration: ['type', 'declaration'],
	    ExportNamedDeclaration: ['type', 'declaration', 'specifiers', 'source'],
	    ExportSpecifier: ['type', 'exported', 'local'],
	    ExpressionStatement: ['type', 'expression'],
	    ForInStatement: ['type', 'left', 'right', 'body'],
	    ForOfStatement: ['type', 'left', 'right', 'body'],
	    ForStatement: ['type', 'init', 'test', 'update', 'body'],
	    FunctionDeclaration: ['type', 'id', 'params', 'body', 'generator'],
	    FunctionExpression: ['type', 'id', 'params', 'body', 'generator'],
	    Identifier: ['type', 'name'],
	    IfStatement: ['type', 'test', 'consequent', 'alternate'],
	    ImportDeclaration: ['type', 'specifiers', 'source'],
	    ImportDefaultSpecifier: ['type', 'local'],
	    ImportNamespaceSpecifier: ['type', 'local'],
	    ImportSpecifier: ['type', 'imported', 'local'],
	    LabeledStatement: ['type', 'label', 'body'],
	    Literal: ['type', 'value', 'regex'],
	    LogicalExpression: ['type', 'operator', 'left', 'right'],
	    MemberExpression: ['type', 'object', 'property', 'computed'],
	    MetaProperty: ['type', 'meta', 'property'],
	    MethodDefinition: ['type', 'key', 'value', 'kind', 'computed', 'static'],
	    NewExpression: ['type', 'callee', 'arguments'],
	    ObjectExpression: ['type', 'properties'],
	    ObjectPattern: ['type', 'properties'],
	    Program: ['type', 'body', 'sourceType'],
	    Property: ['type', 'key', 'value', 'kind', 'method', 'shorthand', 'computed'],
	    RestElement: ['type', 'argument'],
	    ReturnStatement: ['type', 'argument'],
	    SequenceExpression: ['type', 'expressions'],
	    SpreadElement: ['type', 'argument'],
	    Super: ['type'],
	    SwitchCase: ['type', 'test', 'consequent'],
	    SwitchStatement: ['type', 'discriminant', 'cases', 'lexical'],
	    TaggedTemplateExpression: ['type', 'tag', 'quasi'],
	    TemplateElement: ['type', 'tail', 'value'],
	    TemplateLiteral: ['type', 'quasis', 'expressions'],
	    ThisExpression: ['type'],
	    ThrowStatement: ['type', 'argument'],
	    TryStatement: ['type', 'block', 'handler', 'finalizer'],
	    UnaryExpression: ['type', 'operator', 'prefix', 'argument'],
	    UpdateExpression: ['type', 'operator', 'argument', 'prefix'],
	    VariableDeclaration: ['type', 'declarations', 'kind'],
	    VariableDeclarator: ['type', 'id', 'init'],
	    WhileStatement: ['type', 'test', 'body'],
	    WithStatement: ['type', 'object', 'body'],
	    YieldExpression: ['type', 'argument', 'delegate']
	};


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var isArray = __webpack_require__(256);
	var objectKeys = __webpack_require__(34);
	var indexOf = __webpack_require__(165);
	var reduce = __webpack_require__(112);
	
	module.exports = function cloneWithWhitelist (astWhiteList) {
	    var whitelist = reduce(objectKeys(astWhiteList), function (props, key) {
	        var propNames = astWhiteList[key];
	        var prepend = (indexOf(propNames, 'type') === -1) ? ['type'] : [];
	        props[key] = prepend.concat(propNames);
	        return props;
	    }, {});
	
	    function cloneNodeOrObject (obj) {
	        var props = obj.type ? whitelist[obj.type] : null;
	        if (props) {
	            return cloneNode(obj, props);
	        } else {
	            return cloneObject(obj);
	        }
	    }
	
	    function cloneArray (ary) {
	        var i = ary.length, clone = [];
	        while (i--) {
	            clone[i] = cloneOf(ary[i]);
	        }
	        return clone;
	    }
	
	    function cloneNode (node, props) {
	        var i, len, key, clone = {};
	        for (i = 0, len = props.length; i < len; i += 1) {
	            key = props[i];
	            if (node.hasOwnProperty(key)) {
	                clone[key] = cloneOf(node[key]);
	            }
	        }
	        return clone;
	    }
	
	    function cloneObject (obj) {
	        var props = objectKeys(obj);
	        var i, len, key, clone = {};
	        for (i = 0, len = props.length; i < len; i += 1) {
	            key = props[i];
	            clone[key] = cloneOf(obj[key]);
	        }
	        return clone;
	    }
	
	    function cloneOf (val) {
	        if (typeof val === 'object' && val !== null) {
	            if (val instanceof RegExp) {
	                return new RegExp(val);
	            } else if (isArray(val)) {
	                return cloneArray(val);
	            } else {
	                return cloneNodeOrObject(val);
	            }
	        } else {
	            return val;
	        }
	    }
	
	    return cloneNodeOrObject;
	};


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defaultProps = __webpack_require__(327);
	var objectKeys = __webpack_require__(34);
	var assign = __webpack_require__(11);
	
	module.exports = function createWhitelist (options) {
	    var opts = assign({}, options);
	    var typeName, i, len;
	    var keys = objectKeys(defaultProps);
	    var result = {};
	    for (i = 0, len = keys.length; i < len; i += 1) {
	        typeName = keys[i];
	        result[typeName] = defaultProps[typeName].concat(opts.extra);
	    }
	    return result;
	};


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	// ┌────────────────────────────────────────────────────────────┐ \\
	// │ Eve 0.4.2 - JavaScript Events Library                      │ \\
	// ├────────────────────────────────────────────────────────────┤ \\
	// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
	// └────────────────────────────────────────────────────────────┘ \\
	
	(function (glob) {
	    var version = "0.4.2",
	        has = "hasOwnProperty",
	        separator = /[\.\/]/,
	        comaseparator = /\s*,\s*/,
	        wildcard = "*",
	        fun = function () {},
	        numsort = function (a, b) {
	            return a - b;
	        },
	        current_event,
	        stop,
	        events = {n: {}},
	        firstDefined = function () {
	            for (var i = 0, ii = this.length; i < ii; i++) {
	                if (typeof this[i] != "undefined") {
	                    return this[i];
	                }
	            }
	        },
	        lastDefined = function () {
	            var i = this.length;
	            while (--i) {
	                if (typeof this[i] != "undefined") {
	                    return this[i];
	                }
	            }
	        },
	    /*\
	     * eve
	     [ method ]
	
	     * Fires event with given `name`, given scope and other parameters.
	
	     > Arguments
	
	     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
	     - scope (object) context for the event handlers
	     - varargs (...) the rest of arguments will be sent to event handlers
	
	     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
	    \*/
	        eve = function (name, scope) {
	            name = String(name);
	            var e = events,
	                oldstop = stop,
	                args = Array.prototype.slice.call(arguments, 2),
	                listeners = eve.listeners(name),
	                z = 0,
	                f = false,
	                l,
	                indexed = [],
	                queue = {},
	                out = [],
	                ce = current_event,
	                errors = [];
	            out.firstDefined = firstDefined;
	            out.lastDefined = lastDefined;
	            current_event = name;
	            stop = 0;
	            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
	                indexed.push(listeners[i].zIndex);
	                if (listeners[i].zIndex < 0) {
	                    queue[listeners[i].zIndex] = listeners[i];
	                }
	            }
	            indexed.sort(numsort);
	            while (indexed[z] < 0) {
	                l = queue[indexed[z++]];
	                out.push(l.apply(scope, args));
	                if (stop) {
	                    stop = oldstop;
	                    return out;
	                }
	            }
	            for (i = 0; i < ii; i++) {
	                l = listeners[i];
	                if ("zIndex" in l) {
	                    if (l.zIndex == indexed[z]) {
	                        out.push(l.apply(scope, args));
	                        if (stop) {
	                            break;
	                        }
	                        do {
	                            z++;
	                            l = queue[indexed[z]];
	                            l && out.push(l.apply(scope, args));
	                            if (stop) {
	                                break;
	                            }
	                        } while (l)
	                    } else {
	                        queue[l.zIndex] = l;
	                    }
	                } else {
	                    out.push(l.apply(scope, args));
	                    if (stop) {
	                        break;
	                    }
	                }
	            }
	            stop = oldstop;
	            current_event = ce;
	            return out;
	        };
	        // Undocumented. Debug only.
	        eve._events = events;
	    /*\
	     * eve.listeners
	     [ method ]
	
	     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.
	
	     > Arguments
	
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated
	
	     = (array) array of event handlers
	    \*/
	    eve.listeners = function (name) {
	        var names = name.split(separator),
	            e = events,
	            item,
	            items,
	            k,
	            i,
	            ii,
	            j,
	            jj,
	            nes,
	            es = [e],
	            out = [];
	        for (i = 0, ii = names.length; i < ii; i++) {
	            nes = [];
	            for (j = 0, jj = es.length; j < jj; j++) {
	                e = es[j].n;
	                items = [e[names[i]], e[wildcard]];
	                k = 2;
	                while (k--) {
	                    item = items[k];
	                    if (item) {
	                        nes.push(item);
	                        out = out.concat(item.f || []);
	                    }
	                }
	            }
	            es = nes;
	        }
	        return out;
	    };
	    
	    /*\
	     * eve.on
	     [ method ]
	     **
	     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
	     | eve.on("*.under.*", f);
	     | eve("mouse.under.floor"); // triggers f
	     * Use @eve to trigger the listener.
	     **
	     > Arguments
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	     **
	     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
	     > Example:
	     | eve.on("mouse", eatIt)(2);
	     | eve.on("mouse", scream);
	     | eve.on("mouse", catchIt)(1);
	     * This will ensure that `catchIt` function will be called before `eatIt`.
	     *
	     * If you want to put your handler before non-indexed handlers, specify a negative value.
	     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
	    \*/
	    eve.on = function (name, f) {
	        name = String(name);
	        if (typeof f != "function") {
	            return function () {};
	        }
	        var names = name.split(comaseparator);
	        for (var i = 0, ii = names.length; i < ii; i++) {
	            (function (name) {
	                var names = name.split(separator),
	                    e = events,
	                    exist;
	                for (var i = 0, ii = names.length; i < ii; i++) {
	                    e = e.n;
	                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
	                }
	                e.f = e.f || [];
	                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
	                    exist = true;
	                    break;
	                }
	                !exist && e.f.push(f);
	            }(names[i]));
	        }
	        return function (zIndex) {
	            if (+zIndex == +zIndex) {
	                f.zIndex = +zIndex;
	            }
	        };
	    };
	    /*\
	     * eve.f
	     [ method ]
	     **
	     * Returns function that will fire given event with optional arguments.
	     * Arguments that will be passed to the result function will be also
	     * concated to the list of final arguments.
	     | el.onclick = eve.f("click", 1, 2);
	     | eve.on("click", function (a, b, c) {
	     |     console.log(a, b, c); // 1, 2, [event object]
	     | });
	     > Arguments
	     - event (string) event name
	     - varargs (…) and any other arguments
	     = (function) possible event handler function
	    \*/
	    eve.f = function (event) {
	        var attrs = [].slice.call(arguments, 1);
	        return function () {
	            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
	        };
	    };
	    /*\
	     * eve.stop
	     [ method ]
	     **
	     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
	    \*/
	    eve.stop = function () {
	        stop = 1;
	    };
	    /*\
	     * eve.nt
	     [ method ]
	     **
	     * Could be used inside event handler to figure out actual name of the event.
	     **
	     > Arguments
	     **
	     - subname (string) #optional subname of the event
	     **
	     = (string) name of the event, if `subname` is not specified
	     * or
	     = (boolean) `true`, if current event’s name contains `subname`
	    \*/
	    eve.nt = function (subname) {
	        if (subname) {
	            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
	        }
	        return current_event;
	    };
	    /*\
	     * eve.nts
	     [ method ]
	     **
	     * Could be used inside event handler to figure out actual name of the event.
	     **
	     **
	     = (array) names of the event
	    \*/
	    eve.nts = function () {
	        return current_event.split(separator);
	    };
	    /*\
	     * eve.off
	     [ method ]
	     **
	     * Removes given function from the list of event listeners assigned to given name.
	     * If no arguments specified all the events will be cleared.
	     **
	     > Arguments
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	    \*/
	    /*\
	     * eve.unbind
	     [ method ]
	     **
	     * See @eve.off
	    \*/
	    eve.off = eve.unbind = function (name, f) {
	        if (!name) {
	            eve._events = events = {n: {}};
	            return;
	        }
	        var names = name.split(comaseparator);
	        if (names.length > 1) {
	            for (var i = 0, ii = names.length; i < ii; i++) {
	                eve.off(names[i], f);
	            }
	            return;
	        }
	        names = name.split(separator);
	        var e,
	            key,
	            splice,
	            i, ii, j, jj,
	            cur = [events];
	        for (i = 0, ii = names.length; i < ii; i++) {
	            for (j = 0; j < cur.length; j += splice.length - 2) {
	                splice = [j, 1];
	                e = cur[j].n;
	                if (names[i] != wildcard) {
	                    if (e[names[i]]) {
	                        splice.push(e[names[i]]);
	                    }
	                } else {
	                    for (key in e) if (e[has](key)) {
	                        splice.push(e[key]);
	                    }
	                }
	                cur.splice.apply(cur, splice);
	            }
	        }
	        for (i = 0, ii = cur.length; i < ii; i++) {
	            e = cur[i];
	            while (e.n) {
	                if (f) {
	                    if (e.f) {
	                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
	                            e.f.splice(j, 1);
	                            break;
	                        }
	                        !e.f.length && delete e.f;
	                    }
	                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
	                        var funcs = e.n[key].f;
	                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
	                            funcs.splice(j, 1);
	                            break;
	                        }
	                        !funcs.length && delete e.n[key].f;
	                    }
	                } else {
	                    delete e.f;
	                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
	                        delete e.n[key].f;
	                    }
	                }
	                e = e.n;
	            }
	        }
	    };
	    /*\
	     * eve.once
	     [ method ]
	     **
	     * Binds given event handler with a given name to only run once then unbind itself.
	     | eve.once("login", f);
	     | eve("login"); // triggers f
	     | eve("login"); // no listeners
	     * Use @eve to trigger the listener.
	     **
	     > Arguments
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	     **
	     = (function) same return function as @eve.on
	    \*/
	    eve.once = function (name, f) {
	        var f2 = function () {
	            eve.unbind(name, f2);
	            return f.apply(this, arguments);
	        };
	        return eve.on(name, f2);
	    };
	    /*\
	     * eve.version
	     [ property (string) ]
	     **
	     * Current version of the library.
	    \*/
	    eve.version = version;
	    eve.toString = function () {
	        return "You are running Eve " + version;
	    };
	    (typeof module != "undefined" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (glob.eve = eve));
	})(this);


/***/ },
/* 331 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 332 */
/***/ function(module, exports) {

	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	
	module.exports = function forEach (obj, fn, ctx) {
	    if (toString.call(fn) !== '[object Function]') {
	        throw new TypeError('iterator must be a function');
	    }
	    var l = obj.length;
	    if (l === +l) {
	        for (var i = 0; i < l; i++) {
	            fn.call(ctx, obj[i], i, obj);
	        }
	    } else {
	        for (var k in obj) {
	            if (hasOwn.call(obj, k)) {
	                fn.call(ctx, obj[k], k, obj);
	            }
	        }
	    }
	};
	


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * golden-colors - Generate random colors using Golden ratio conjugate
	 * @version v2.0.0
	 * @author Alexey Komarov <alex7kom@gmail.com>
	 * @link https://alex7kom.github.io/golden-colors
	 * @license MIT
	 */
	;(function(root, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    module.exports = factory();
	  } else {
	    root.goldenColors = factory();
	  }
	}(this, function() {
	var goldenColors = {};
	
	(function () {
	  var goldenRatioConjugate = 0.618033988749895;
	
	  function getRandom255 () {
	    return Math.round(Math.random() * 255);
	  }
	
	  function convertDecToHex (number) {
	    var result = number.toString(16);
	    if (result.length === 1) {
	      result = '0' + result;
	    }
	    return result;
	  }
	
	  function convertHsvToRgb (h, s, v) {
	    var r, g, b;
	
	    var i = Math.floor(h * 6);
	    var f = h * 6 - i;
	    var p = v * (1 - s);
	    var q = v * (1 - f * s);
	    var t = v * (1 - (1 - f) * s);
	
	    switch(i % 6){
	      case 0: r = v; g = t; b = p; break;
	      case 1: r = q; g = v; b = p; break;
	      case 2: r = p; g = v; b = t; break;
	      case 3: r = p; g = q; b = v; break;
	      case 4: r = t; g = p; b = v; break;
	      case 5: r = v; g = p; b = q; break;
	    }
	
	    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
	  }
	
	  function WebColor (r, g, b) {
	    this.r = r;
	    this.g = g;
	    this.b = b;
	  }
	
	  WebColor.prototype.toRgb = function () {
	    return [this.r, this.g, this.b];
	  };
	
	  WebColor.prototype.toRgbString = function () {
	    return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
	  };
	
	  WebColor.prototype.toHexString = function () {
	    return '#' +
	      convertDecToHex(this.r) +
	      convertDecToHex(this.g) +
	      convertDecToHex(this.b);
	  };
	
	  WebColor.prototype.toString = function () {
	    return this.toHexString();
	  };
	
	  WebColor.prototype.toJSON = function () {
	    return this.toHexString();
	  };
	
	  goldenColors.getNaive = function () {
	    return new WebColor(getRandom255(), getRandom255(), getRandom255());
	  };
	
	  goldenColors.getHsvSimple = function (s, v) {
	    var color = convertHsvToRgb(Math.random(), s, v);
	    return new WebColor(color[0], color[1], color[2]);
	  };
	
	  goldenColors.getHsvGolden = function (s, v) {
	    var h = Math.random();
	    h += goldenRatioConjugate;
	    h %= 1;
	    var color = convertHsvToRgb(h, s, v);
	    return new WebColor(color[0], color[1], color[2]);
	  };
	})();
	
	return goldenColors;
	}));


/***/ },
/* 334 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 335 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;
	
	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 336 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 337 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery Mousewheel 3.1.13
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 */
	
	(function (factory) {
	    if ( true ) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(62)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node/CommonJS style for Browserify
	        module.exports = factory;
	    } else {
	        // Browser globals
	        factory(jQuery);
	    }
	}(function ($) {
	
	    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
	        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
	                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
	        slice  = Array.prototype.slice,
	        nullLowestDeltaTimeout, lowestDelta;
	
	    if ( $.event.fixHooks ) {
	        for ( var i = toFix.length; i; ) {
	            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
	        }
	    }
	
	    var special = $.event.special.mousewheel = {
	        version: '3.1.12',
	
	        setup: function() {
	            if ( this.addEventListener ) {
	                for ( var i = toBind.length; i; ) {
	                    this.addEventListener( toBind[--i], handler, false );
	                }
	            } else {
	                this.onmousewheel = handler;
	            }
	            // Store the line height and page height for this particular element
	            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
	            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
	        },
	
	        teardown: function() {
	            if ( this.removeEventListener ) {
	                for ( var i = toBind.length; i; ) {
	                    this.removeEventListener( toBind[--i], handler, false );
	                }
	            } else {
	                this.onmousewheel = null;
	            }
	            // Clean up the data we added to the element
	            $.removeData(this, 'mousewheel-line-height');
	            $.removeData(this, 'mousewheel-page-height');
	        },
	
	        getLineHeight: function(elem) {
	            var $elem = $(elem),
	                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
	            if (!$parent.length) {
	                $parent = $('body');
	            }
	            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
	        },
	
	        getPageHeight: function(elem) {
	            return $(elem).height();
	        },
	
	        settings: {
	            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
	            normalizeOffset: true  // calls getBoundingClientRect for each event
	        }
	    };
	
	    $.fn.extend({
	        mousewheel: function(fn) {
	            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
	        },
	
	        unmousewheel: function(fn) {
	            return this.unbind('mousewheel', fn);
	        }
	    });
	
	
	    function handler(event) {
	        var orgEvent   = event || window.event,
	            args       = slice.call(arguments, 1),
	            delta      = 0,
	            deltaX     = 0,
	            deltaY     = 0,
	            absDelta   = 0,
	            offsetX    = 0,
	            offsetY    = 0;
	        event = $.event.fix(orgEvent);
	        event.type = 'mousewheel';
	
	        // Old school scrollwheel delta
	        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
	        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
	        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
	        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }
	
	        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
	        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
	            deltaX = deltaY * -1;
	            deltaY = 0;
	        }
	
	        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
	        delta = deltaY === 0 ? deltaX : deltaY;
	
	        // New school wheel delta (wheel event)
	        if ( 'deltaY' in orgEvent ) {
	            deltaY = orgEvent.deltaY * -1;
	            delta  = deltaY;
	        }
	        if ( 'deltaX' in orgEvent ) {
	            deltaX = orgEvent.deltaX;
	            if ( deltaY === 0 ) { delta  = deltaX * -1; }
	        }
	
	        // No change actually happened, no reason to go any further
	        if ( deltaY === 0 && deltaX === 0 ) { return; }
	
	        // Need to convert lines and pages to pixels if we aren't already in pixels
	        // There are three delta modes:
	        //   * deltaMode 0 is by pixels, nothing to do
	        //   * deltaMode 1 is by lines
	        //   * deltaMode 2 is by pages
	        if ( orgEvent.deltaMode === 1 ) {
	            var lineHeight = $.data(this, 'mousewheel-line-height');
	            delta  *= lineHeight;
	            deltaY *= lineHeight;
	            deltaX *= lineHeight;
	        } else if ( orgEvent.deltaMode === 2 ) {
	            var pageHeight = $.data(this, 'mousewheel-page-height');
	            delta  *= pageHeight;
	            deltaY *= pageHeight;
	            deltaX *= pageHeight;
	        }
	
	        // Store lowest absolute delta to normalize the delta values
	        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );
	
	        if ( !lowestDelta || absDelta < lowestDelta ) {
	            lowestDelta = absDelta;
	
	            // Adjust older deltas if necessary
	            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
	                lowestDelta /= 40;
	            }
	        }
	
	        // Adjust older deltas if necessary
	        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
	            // Divide all the things by 40!
	            delta  /= 40;
	            deltaX /= 40;
	            deltaY /= 40;
	        }
	
	        // Get a whole, normalized value for the deltas
	        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
	        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
	        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);
	
	        // Normalise offsetX and offsetY properties
	        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
	            var boundingRect = this.getBoundingClientRect();
	            offsetX = event.clientX - boundingRect.left;
	            offsetY = event.clientY - boundingRect.top;
	        }
	
	        // Add information to the event object
	        event.deltaX = deltaX;
	        event.deltaY = deltaY;
	        event.deltaFactor = lowestDelta;
	        event.offsetX = offsetX;
	        event.offsetY = offsetY;
	        // Go ahead and set deltaMode to 0 since we converted to pixels
	        // Although this is a little odd since we overwrite the deltaX/Y
	        // properties with normalized deltas.
	        event.deltaMode = 0;
	
	        // Add event and delta to the front of the arguments
	        args.unshift(event, delta, deltaX, deltaY);
	
	        // Clearout lowestDelta after sometime to better
	        // handle multiple device types that give different
	        // a different lowestDelta
	        // Ex: trackpad = 3 and mouse wheel = 120
	        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
	        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
	
	        return ($.event.dispatch || $.event.handle).apply(this, args);
	    }
	
	    function nullLowestDelta() {
	        lowestDelta = null;
	    }
	
	    function shouldAdjustOldDeltas(orgEvent, absDelta) {
	        // If this is an older event and the delta is divisable by 120,
	        // then we are assuming that the browser is treating this as an
	        // older mouse wheel event and that we should divide the deltas
	        // by 40 to try and get a more usable deltaFactor.
	        // Side note, this actually impacts the reported scroll distance
	        // in older browsers and can cause scrolling to be slower than native.
	        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
	        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
	    }
	
	}));


/***/ },
/* 339 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				"estraverse@^4.1.1",
				"/home/mhelvens/Projects/lyph-edit-widget/node_modules/babel-plugin-espower"
			]
		],
		"_from": "estraverse@>=4.1.1 <5.0.0",
		"_id": "estraverse@4.2.0",
		"_inCache": true,
		"_installable": true,
		"_location": "/estraverse",
		"_nodeVersion": "0.12.9",
		"_npmOperationalInternal": {
			"host": "packages-12-west.internal.npmjs.com",
			"tmp": "tmp/estraverse-4.2.0.tgz_1457646738925_0.7118953282479197"
		},
		"_npmUser": {
			"email": "nicholas@nczconsulting.com",
			"name": "nzakas"
		},
		"_npmVersion": "2.14.9",
		"_phantomChildren": {},
		"_requested": {
			"name": "estraverse",
			"raw": "estraverse@^4.1.1",
			"rawSpec": "^4.1.1",
			"scope": null,
			"spec": ">=4.1.1 <5.0.0",
			"type": "range"
		},
		"_requiredBy": [
			"/babel-plugin-espower",
			"/call-matcher",
			"/power-assert-context-reducer-ast",
			"/power-assert-context-traversal"
		],
		"_resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz",
		"_shasum": "0dee3fed31fcd469618ce7342099fc1afa0bdb13",
		"_shrinkwrap": null,
		"_spec": "estraverse@^4.1.1",
		"_where": "/home/mhelvens/Projects/lyph-edit-widget/node_modules/babel-plugin-espower",
		"bugs": {
			"url": "https://github.com/estools/estraverse/issues"
		},
		"dependencies": {},
		"description": "ECMAScript JS AST traversal functions",
		"devDependencies": {
			"babel-preset-es2015": "^6.3.13",
			"babel-register": "^6.3.13",
			"chai": "^2.1.1",
			"espree": "^1.11.0",
			"gulp": "^3.8.10",
			"gulp-bump": "^0.2.2",
			"gulp-filter": "^2.0.0",
			"gulp-git": "^1.0.1",
			"gulp-tag-version": "^1.2.1",
			"jshint": "^2.5.6",
			"mocha": "^2.1.0"
		},
		"directories": {},
		"dist": {
			"shasum": "0dee3fed31fcd469618ce7342099fc1afa0bdb13",
			"tarball": "https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz"
		},
		"engines": {
			"node": ">=0.10.0"
		},
		"gitHead": "6f6a4e99653908e859c7c10d04d9518bf4844ede",
		"homepage": "https://github.com/estools/estraverse",
		"license": "BSD-2-Clause",
		"main": "estraverse.js",
		"maintainers": [
			{
				"name": "constellation",
				"email": "utatane.tea@gmail.com"
			},
			{
				"name": "michaelficarra",
				"email": "npm@michael.ficarra.me"
			},
			{
				"name": "nzakas",
				"email": "nicholas@nczconsulting.com"
			}
		],
		"name": "estraverse",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+ssh://git@github.com/estools/estraverse.git"
		},
		"scripts": {
			"lint": "jshint estraverse.js",
			"test": "npm run-script lint && npm run-script unit-test",
			"unit-test": "mocha --compilers js:babel-register"
		},
		"version": "4.2.0"
	};

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(444);
	
	module.exports = function includes() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(24);
	
	module.exports = function isObject() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(446);
	
	module.exports = function isPlainObject() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(447);
	
	module.exports = function isSet() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(449);
	
	module.exports = function isUndefined() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(450);
	
	module.exports = function isWeakSet() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(455);
	
	module.exports = function set() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(457);
	
	module.exports = function sortBy() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fn = __webpack_require__(460);
	
	module.exports = function trim() {
	  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
	};


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(41),
	    root = __webpack_require__(18);
	
	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');
	
	module.exports = DataView;


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(406),
	    hashDelete = __webpack_require__(407),
	    hashGet = __webpack_require__(408),
	    hashHas = __webpack_require__(409),
	    hashSet = __webpack_require__(410);
	
	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	
	module.exports = Hash;


/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(41),
	    root = __webpack_require__(18);
	
	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');
	
	module.exports = Promise;


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(18);
	
	/** Built-in value references. */
	var Reflect = root.Reflect;
	
	module.exports = Reflect;


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(41),
	    root = __webpack_require__(18);
	
	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');
	
	module.exports = Set;


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(128),
	    setCacheAdd = __webpack_require__(426),
	    setCacheHas = __webpack_require__(427);
	
	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;
	
	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}
	
	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;
	
	module.exports = SetCache;


/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(18);
	
	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;
	
	module.exports = Uint8Array;


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(41),
	    root = __webpack_require__(18);
	
	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');
	
	module.exports = WeakMap;


/***/ },
/* 357 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0,
	      resIndex = 0,
	      result = [];
	
	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}
	
	module.exports = arrayFilter;


/***/ },
/* 358 */
/***/ function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;
	
	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}
	
	module.exports = arrayPush;


/***/ },
/* 359 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0;
	
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	module.exports = arraySome;


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(67);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used by `_.defaults` to customize its `_.assignIn` use.
	 *
	 * @private
	 * @param {*} objValue The destination value.
	 * @param {*} srcValue The source value.
	 * @param {string} key The key of the property to assign.
	 * @param {Object} object The parent object of `objValue`.
	 * @returns {*} Returns the value to assign.
	 */
	function assignInDefaults(objValue, srcValue, key, object) {
	  if (objValue === undefined ||
	      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	    return srcValue;
	  }
	  return objValue;
	}
	
	module.exports = assignInDefaults;


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	var get = __webpack_require__(207);
	
	/**
	 * The base implementation of `_.at` without support for individual paths.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {string[]} paths The property paths of elements to pick.
	 * @returns {Array} Returns the picked elements.
	 */
	function baseAt(object, paths) {
	  var index = -1,
	      isNil = object == null,
	      length = paths.length,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = isNil ? undefined : get(object, paths[index]);
	  }
	  return result;
	}
	
	module.exports = baseAt;


/***/ },
/* 362 */
/***/ function(module, exports) {

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/**
	 * The base implementation of `_.delay` and `_.defer` which accepts `args`
	 * to provide to `func`.
	 *
	 * @private
	 * @param {Function} func The function to delay.
	 * @param {number} wait The number of milliseconds to delay invocation.
	 * @param {Array} args The arguments to provide to `func`.
	 * @returns {number} Returns the timer id.
	 */
	function baseDelay(func, wait, args) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  return setTimeout(function() { func.apply(undefined, args); }, wait);
	}
	
	module.exports = baseDelay;


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	var baseForOwn = __webpack_require__(366),
	    createBaseEach = __webpack_require__(396);
	
	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);
	
	module.exports = baseEach;


/***/ },
/* 364 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);
	
	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	module.exports = baseFindIndex;


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(397);
	
	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();
	
	module.exports = baseFor;


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(365),
	    keys = __webpack_require__(25);
	
	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}
	
	module.exports = baseForOwn;


/***/ },
/* 367 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * The base implementation of `getTag`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  return objectToString.call(value);
	}
	
	module.exports = baseGetTag;


/***/ },
/* 368 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}
	
	module.exports = baseHasIn;


/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(189),
	    equalArrays = __webpack_require__(196),
	    equalByTag = __webpack_require__(400),
	    equalObjects = __webpack_require__(401),
	    getTag = __webpack_require__(96),
	    isArray = __webpack_require__(19),
	    isHostObject = __webpack_require__(138),
	    isTypedArray = __webpack_require__(448);
	
	/** Used to compose bitmasks for comparison styles. */
	var PARTIAL_COMPARE_FLAG = 2;
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;
	
	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag && !isHostObject(object),
	      othIsObj = othTag == objectTag && !isHostObject(other),
	      isSameTag = objTag == othTag;
	
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	  }
	  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;
	
	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	}
	
	module.exports = baseIsEqualDeep;


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(189),
	    baseIsEqual = __webpack_require__(133);
	
	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;
	
	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;
	
	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];
	
	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	
	module.exports = baseIsMatch;


/***/ },
/* 371 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}
	
	module.exports = baseIsNaN;


/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(99),
	    isHostObject = __webpack_require__(138),
	    isMasked = __webpack_require__(413),
	    isObject = __webpack_require__(24),
	    toSource = __webpack_require__(206);
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	module.exports = baseIsNative;


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	var getTag = __webpack_require__(96),
	    isObjectLike = __webpack_require__(12);
	
	/** `Object#toString` result references. */
	var setTag = '[object Set]';
	
	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike(value) && getTag(value) == setTag;
	}
	
	module.exports = baseIsSet;


/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	var isLength = __webpack_require__(100),
	    isObjectLike = __webpack_require__(12);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}
	
	module.exports = baseIsTypedArray;


/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(379),
	    baseMatchesProperty = __webpack_require__(380),
	    identity = __webpack_require__(208),
	    isArray = __webpack_require__(19),
	    property = __webpack_require__(454);
	
	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}
	
	module.exports = baseIteratee;


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(205);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = Object.keys;
	
	/**
	 * The base implementation of `_.keys` which doesn't skip the constructor
	 * property of prototypes or treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	var baseKeys = overArg(nativeKeys, Object);
	
	module.exports = baseKeys;


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	var Reflect = __webpack_require__(352),
	    iteratorToArray = __webpack_require__(414);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Built-in value references. */
	var enumerate = Reflect ? Reflect.enumerate : undefined,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
	/**
	 * The base implementation of `_.keysIn` which doesn't skip the constructor
	 * property of prototypes or treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  object = object == null ? object : Object(object);
	
	  var result = [];
	  for (var key in object) {
	    result.push(key);
	  }
	  return result;
	}
	
	// Fallback for IE < 9 with es6-shim.
	if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
	  baseKeysIn = function(object) {
	    return iteratorToArray(enumerate(object));
	  };
	}
	
	module.exports = baseKeysIn;


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(363),
	    isArrayLike = __webpack_require__(23);
	
	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];
	
	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}
	
	module.exports = baseMap;


/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(370),
	    getMatchData = __webpack_require__(403),
	    matchesStrictComparable = __webpack_require__(203);
	
	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}
	
	module.exports = baseMatches;


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(133),
	    get = __webpack_require__(207),
	    hasIn = __webpack_require__(443),
	    isKey = __webpack_require__(66),
	    isStrictComparable = __webpack_require__(201),
	    matchesStrictComparable = __webpack_require__(203),
	    toKey = __webpack_require__(42);
	
	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;
	
	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
	  };
	}
	
	module.exports = baseMatchesProperty;


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(64),
	    baseIteratee = __webpack_require__(375),
	    baseMap = __webpack_require__(378),
	    baseSortBy = __webpack_require__(386),
	    baseUnary = __webpack_require__(136),
	    compareMultiple = __webpack_require__(394),
	    identity = __webpack_require__(208);
	
	/**
	 * The base implementation of `_.orderBy` without param guards.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	 * @param {string[]} orders The sort orders of `iteratees`.
	 * @returns {Array} Returns the new sorted array.
	 */
	function baseOrderBy(collection, iteratees, orders) {
	  var index = -1;
	  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
	
	  var result = baseMap(collection, function(value, key, collection) {
	    var criteria = arrayMap(iteratees, function(iteratee) {
	      return iteratee(value);
	    });
	    return { 'criteria': criteria, 'index': ++index, 'value': value };
	  });
	
	  return baseSortBy(result, function(object, other) {
	    return compareMultiple(object, other, orders);
	  });
	}
	
	module.exports = baseOrderBy;


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	var basePickBy = __webpack_require__(383);
	
	/**
	 * The base implementation of `_.pick` without support for individual
	 * property identifiers.
	 *
	 * @private
	 * @param {Object} object The source object.
	 * @param {string[]} props The property identifiers to pick.
	 * @returns {Object} Returns the new object.
	 */
	function basePick(object, props) {
	  object = Object(object);
	  return basePickBy(object, props, function(value, key) {
	    return key in object;
	  });
	}
	
	module.exports = basePick;


/***/ },
/* 383 */
/***/ function(module, exports) {

	/**
	 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The source object.
	 * @param {string[]} props The property identifiers to pick from.
	 * @param {Function} predicate The function invoked per property.
	 * @returns {Object} Returns the new object.
	 */
	function basePickBy(object, props, predicate) {
	  var index = -1,
	      length = props.length,
	      result = {};
	
	  while (++index < length) {
	    var key = props[index],
	        value = object[key];
	
	    if (predicate(value, key)) {
	      result[key] = value;
	    }
	  }
	  return result;
	}
	
	module.exports = basePickBy;


/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(191);
	
	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}
	
	module.exports = basePropertyDeep;


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(130),
	    castPath = __webpack_require__(137),
	    isIndex = __webpack_require__(65),
	    isKey = __webpack_require__(66),
	    isObject = __webpack_require__(24),
	    toKey = __webpack_require__(42);
	
	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  path = isKey(path, object) ? [path] : castPath(path);
	
	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;
	
	  while (nested != null && ++index < length) {
	    var key = toKey(path[index]);
	    if (isObject(nested)) {
	      var newValue = value;
	      if (index != lastIndex) {
	        var objValue = nested[key];
	        newValue = customizer ? customizer(objValue, key, nested) : undefined;
	        if (newValue === undefined) {
	          newValue = objValue == null
	            ? (isIndex(path[index + 1]) ? [] : {})
	            : objValue;
	        }
	      }
	      assignValue(nested, key, newValue);
	    }
	    nested = nested[key];
	  }
	  return object;
	}
	
	module.exports = baseSet;


/***/ },
/* 386 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.sortBy` which uses `comparer` to define the
	 * sort order of `array` and replaces criteria objects with their corresponding
	 * values.
	 *
	 * @private
	 * @param {Array} array The array to sort.
	 * @param {Function} comparer The function to define sort order.
	 * @returns {Array} Returns `array`.
	 */
	function baseSortBy(array, comparer) {
	  var length = array.length;
	
	  array.sort(comparer);
	  while (length--) {
	    array[length] = array[length].value;
	  }
	  return array;
	}
	
	module.exports = baseSortBy;


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(45);
	
	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;
	
	/**
	 * The base implementation of `_.toNumber` which doesn't ensure correct
	 * conversions of binary, hexadecimal, or octal string values.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 */
	function baseToNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  return +value;
	}
	
	module.exports = baseToNumber;


/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(64);
	
	/**
	 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	 * of key-value pairs for `object` corresponding to the property names of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the key-value pairs.
	 */
	function baseToPairs(object, props) {
	  return arrayMap(props, function(key) {
	    return [key, object[key]];
	  });
	}
	
	module.exports = baseToPairs;


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(64);
	
	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  return arrayMap(props, function(key) {
	    return object[key];
	  });
	}
	
	module.exports = baseValues;


/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	var baseSlice = __webpack_require__(233);
	
	/**
	 * Casts `array` to a slice if it's needed.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {number} start The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the cast slice.
	 */
	function castSlice(array, start, end) {
	  var length = array.length;
	  end = end === undefined ? length : end;
	  return (!start && end >= length) ? array : baseSlice(array, start, end);
	}
	
	module.exports = castSlice;


/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(132);
	
	/**
	 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	 * that is not found in the character symbols.
	 *
	 * @private
	 * @param {Array} strSymbols The string symbols to inspect.
	 * @param {Array} chrSymbols The character symbols to find.
	 * @returns {number} Returns the index of the last unmatched string symbol.
	 */
	function charsEndIndex(strSymbols, chrSymbols) {
	  var index = strSymbols.length;
	
	  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	  return index;
	}
	
	module.exports = charsEndIndex;


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(132);
	
	/**
	 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	 * that is not found in the character symbols.
	 *
	 * @private
	 * @param {Array} strSymbols The string symbols to inspect.
	 * @param {Array} chrSymbols The character symbols to find.
	 * @returns {number} Returns the index of the first unmatched string symbol.
	 */
	function charsStartIndex(strSymbols, chrSymbols) {
	  var index = -1,
	      length = strSymbols.length;
	
	  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	  return index;
	}
	
	module.exports = charsStartIndex;


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(45);
	
	/**
	 * Compares values to sort them in ascending order.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {number} Returns the sort order indicator for `value`.
	 */
	function compareAscending(value, other) {
	  if (value !== other) {
	    var valIsDefined = value !== undefined,
	        valIsNull = value === null,
	        valIsReflexive = value === value,
	        valIsSymbol = isSymbol(value);
	
	    var othIsDefined = other !== undefined,
	        othIsNull = other === null,
	        othIsReflexive = other === other,
	        othIsSymbol = isSymbol(other);
	
	    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	        (valIsNull && othIsDefined && othIsReflexive) ||
	        (!valIsDefined && othIsReflexive) ||
	        !valIsReflexive) {
	      return 1;
	    }
	    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	        (othIsNull && valIsDefined && valIsReflexive) ||
	        (!othIsDefined && valIsReflexive) ||
	        !othIsReflexive) {
	      return -1;
	    }
	  }
	  return 0;
	}
	
	module.exports = compareAscending;


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	var compareAscending = __webpack_require__(393);
	
	/**
	 * Used by `_.orderBy` to compare multiple properties of a value to another
	 * and stable sort them.
	 *
	 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	 * specify an order of "desc" for descending or "asc" for ascending sort order
	 * of corresponding values.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {boolean[]|string[]} orders The order to sort by for each property.
	 * @returns {number} Returns the sort order indicator for `object`.
	 */
	function compareMultiple(object, other, orders) {
	  var index = -1,
	      objCriteria = object.criteria,
	      othCriteria = other.criteria,
	      length = objCriteria.length,
	      ordersLength = orders.length;
	
	  while (++index < length) {
	    var result = compareAscending(objCriteria[index], othCriteria[index]);
	    if (result) {
	      if (index >= ordersLength) {
	        return result;
	      }
	      var order = orders[index];
	      return result * (order == 'desc' ? -1 : 1);
	    }
	  }
	  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	  // that causes it, under certain circumstances, to provide the same value for
	  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	  // for more details.
	  //
	  // This also ensures a stable sort in V8 and other engines.
	  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	  return object.index - other.index;
	}
	
	module.exports = compareMultiple;


/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(18);
	
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];
	
	module.exports = coreJsData;


/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(23);
	
	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);
	
	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}
	
	module.exports = createBaseEach;


/***/ },
/* 397 */
/***/ function(module, exports) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;
	
	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}
	
	module.exports = createBaseFor;


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	var baseToNumber = __webpack_require__(387),
	    baseToString = __webpack_require__(135);
	
	/**
	 * Creates a function that performs a mathematical operation on two values.
	 *
	 * @private
	 * @param {Function} operator The function to perform the operation.
	 * @param {number} [defaultValue] The value used for `undefined` arguments.
	 * @returns {Function} Returns the new mathematical operation function.
	 */
	function createMathOperation(operator, defaultValue) {
	  return function(value, other) {
	    var result;
	    if (value === undefined && other === undefined) {
	      return defaultValue;
	    }
	    if (value !== undefined) {
	      result = value;
	    }
	    if (other !== undefined) {
	      if (result === undefined) {
	        return other;
	      }
	      if (typeof value == 'string' || typeof other == 'string') {
	        value = baseToString(value);
	        other = baseToString(other);
	      } else {
	        value = baseToNumber(value);
	        other = baseToNumber(other);
	      }
	      result = operator(value, other);
	    }
	    return result;
	  };
	}
	
	module.exports = createMathOperation;


/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	var baseToPairs = __webpack_require__(388),
	    getTag = __webpack_require__(96),
	    mapToArray = __webpack_require__(202),
	    setToPairs = __webpack_require__(429);
	
	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';
	
	/**
	 * Creates a `_.toPairs` or `_.toPairsIn` function.
	 *
	 * @private
	 * @param {Function} keysFunc The function to get the keys of a given object.
	 * @returns {Function} Returns the new pairs function.
	 */
	function createToPairs(keysFunc) {
	  return function(object) {
	    var tag = getTag(object);
	    if (tag == mapTag) {
	      return mapToArray(object);
	    }
	    if (tag == setTag) {
	      return setToPairs(object);
	    }
	    return baseToPairs(object, keysFunc(object));
	  };
	}
	
	module.exports = createToPairs;


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(129),
	    Uint8Array = __webpack_require__(355),
	    eq = __webpack_require__(67),
	    equalArrays = __webpack_require__(196),
	    mapToArray = __webpack_require__(202),
	    setToArray = __webpack_require__(428);
	
	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;
	
	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
	
	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;
	
	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;
	
	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);
	
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	
	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');
	
	    case mapTag:
	      var convert = mapToArray;
	
	    case setTag:
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      convert || (convert = setToArray);
	
	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= UNORDERED_COMPARE_FLAG;
	
	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
	      stack['delete'](object);
	      return result;
	
	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}
	
	module.exports = equalByTag;


/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	var baseHas = __webpack_require__(192),
	    keys = __webpack_require__(25);
	
	/** Used to compose bitmasks for comparison styles. */
	var PARTIAL_COMPARE_FLAG = 2;
	
	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;
	
	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : baseHas(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);
	
	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];
	
	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;
	
	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}
	
	module.exports = equalObjects;


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(134);
	
	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a
	 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
	 * Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');
	
	module.exports = getLength;


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	var isStrictComparable = __webpack_require__(201),
	    keys = __webpack_require__(25);
	
	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;
	
	  while (length--) {
	    var key = result[length],
	        value = object[key];
	
	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}
	
	module.exports = getMatchData;


/***/ },
/* 404 */
/***/ function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}
	
	module.exports = getValue;


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(137),
	    isArguments = __webpack_require__(140),
	    isArray = __webpack_require__(19),
	    isIndex = __webpack_require__(65),
	    isKey = __webpack_require__(66),
	    isLength = __webpack_require__(100),
	    isString = __webpack_require__(68),
	    toKey = __webpack_require__(42);
	
	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = isKey(path, object) ? [path] : castPath(path);
	
	  var result,
	      index = -1,
	      length = path.length;
	
	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result) {
	    return result;
	  }
	  var length = object ? object.length : 0;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isString(object) || isArguments(object));
	}
	
	module.exports = hasPath;


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(97);
	
	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}
	
	module.exports = hashClear;


/***/ },
/* 407 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}
	
	module.exports = hashDelete;


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(97);
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	
	module.exports = hashGet;


/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(97);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	
	module.exports = hashHas;


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(97);
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}
	
	module.exports = hashSet;


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(129),
	    isArguments = __webpack_require__(140),
	    isArray = __webpack_require__(19);
	
	/** Built-in value references. */
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
	
	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}
	
	module.exports = isFlattenable;


/***/ },
/* 412 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}
	
	module.exports = isKeyable;


/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(395);
	
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());
	
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}
	
	module.exports = isMasked;


/***/ },
/* 414 */
/***/ function(module, exports) {

	/**
	 * Converts `iterator` to an array.
	 *
	 * @private
	 * @param {Object} iterator The iterator to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function iteratorToArray(iterator) {
	  var data,
	      result = [];
	
	  while (!(data = iterator.next()).done) {
	    result.push(data.value);
	  }
	  return result;
	}
	
	module.exports = iteratorToArray;


/***/ },
/* 415 */
/***/ function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}
	
	module.exports = listCacheClear;


/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(94);
	
	/** Used for built-in method references. */
	var arrayProto = Array.prototype;
	
	/** Built-in value references. */
	var splice = arrayProto.splice;
	
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}
	
	module.exports = listCacheDelete;


/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(94);
	
	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  return index < 0 ? undefined : data[index][1];
	}
	
	module.exports = listCacheGet;


/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(94);
	
	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}
	
	module.exports = listCacheHas;


/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(94);
	
	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	
	module.exports = listCacheSet;


/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(350),
	    ListCache = __webpack_require__(93),
	    Map = __webpack_require__(127);
	
	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}
	
	module.exports = mapCacheClear;


/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(95);
	
	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}
	
	module.exports = mapCacheDelete;


/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(95);
	
	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}
	
	module.exports = mapCacheGet;


/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(95);
	
	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}
	
	module.exports = mapCacheHas;


/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(95);
	
	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}
	
	module.exports = mapCacheSet;


/***/ },
/* 425 */
/***/ function(module, exports) {

	/** Used to compose unicode character classes. */
	var rsAstralRange = '\\ud800-\\udfff',
	    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
	    rsComboSymbolsRange = '\\u20d0-\\u20f0',
	    rsVarRange = '\\ufe0e\\ufe0f';
	
	/** Used to compose unicode capture groups. */
	var rsZWJ = '\\u200d';
	
	/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
	
	module.exports = reHasComplexSymbol;


/***/ },
/* 426 */
/***/ function(module, exports) {

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}
	
	module.exports = setCacheAdd;


/***/ },
/* 427 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}
	
	module.exports = setCacheHas;


/***/ },
/* 428 */
/***/ function(module, exports) {

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);
	
	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}
	
	module.exports = setToArray;


/***/ },
/* 429 */
/***/ function(module, exports) {

	/**
	 * Converts `set` to its value-value pairs.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the value-value pairs.
	 */
	function setToPairs(set) {
	  var index = -1,
	      result = Array(set.size);
	
	  set.forEach(function(value) {
	    result[++index] = [value, value];
	  });
	  return result;
	}
	
	module.exports = setToPairs;


/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(93);
	
	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	}
	
	module.exports = stackClear;


/***/ },
/* 431 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  return this.__data__['delete'](key);
	}
	
	module.exports = stackDelete;


/***/ },
/* 432 */
/***/ function(module, exports) {

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}
	
	module.exports = stackGet;


/***/ },
/* 433 */
/***/ function(module, exports) {

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}
	
	module.exports = stackHas;


/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(93),
	    Map = __webpack_require__(127),
	    MapCache = __webpack_require__(128);
	
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	
	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var cache = this.__data__;
	  if (cache instanceof ListCache) {
	    var pairs = cache.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      return this;
	    }
	    cache = this.__data__ = new MapCache(pairs);
	  }
	  cache.set(key, value);
	  return this;
	}
	
	module.exports = stackSet;


/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	var reHasComplexSymbol = __webpack_require__(425);
	
	/** Used to compose unicode character classes. */
	var rsAstralRange = '\\ud800-\\udfff',
	    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
	    rsComboSymbolsRange = '\\u20d0-\\u20f0',
	    rsVarRange = '\\ufe0e\\ufe0f';
	
	/** Used to compose unicode capture groups. */
	var rsAstral = '[' + rsAstralRange + ']',
	    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
	    rsFitz = '\\ud83c[\\udffb-\\udfff]',
	    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	    rsNonAstral = '[^' + rsAstralRange + ']',
	    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	    rsZWJ = '\\u200d';
	
	/** Used to compose unicode regexes. */
	var reOptMod = rsModifier + '?',
	    rsOptVar = '[' + rsVarRange + ']?',
	    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	    rsSeq = rsOptVar + reOptMod + rsOptJoin,
	    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	
	/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	
	/**
	 * Gets the number of symbols in `string`.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {number} Returns the string size.
	 */
	function stringSize(string) {
	  if (!(string && reHasComplexSymbol.test(string))) {
	    return string.length;
	  }
	  var result = reComplexSymbol.lastIndex = 0;
	  while (reComplexSymbol.test(string)) {
	    result++;
	  }
	  return result;
	}
	
	module.exports = stringSize;


/***/ },
/* 436 */
/***/ function(module, exports) {

	/** Used to compose unicode character classes. */
	var rsAstralRange = '\\ud800-\\udfff',
	    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
	    rsComboSymbolsRange = '\\u20d0-\\u20f0',
	    rsVarRange = '\\ufe0e\\ufe0f';
	
	/** Used to compose unicode capture groups. */
	var rsAstral = '[' + rsAstralRange + ']',
	    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
	    rsFitz = '\\ud83c[\\udffb-\\udfff]',
	    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	    rsNonAstral = '[^' + rsAstralRange + ']',
	    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	    rsZWJ = '\\u200d';
	
	/** Used to compose unicode regexes. */
	var reOptMod = rsModifier + '?',
	    rsOptVar = '[' + rsVarRange + ']?',
	    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	    rsSeq = rsOptVar + reOptMod + rsOptJoin,
	    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	
	/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	
	/**
	 * Converts `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function stringToArray(string) {
	  return string.match(reComplexSymbol);
	}
	
	module.exports = stringToArray;


/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(452),
	    toString = __webpack_require__(141);
	
	/** Used to match property names within property paths. */
	var reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	
	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;
	
	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoize(function(string) {
	  string = toString(string);
	
	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});
	
	module.exports = stringToPath;


/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(130),
	    copyObject = __webpack_require__(194),
	    createAssigner = __webpack_require__(195),
	    isArrayLike = __webpack_require__(23),
	    isPrototype = __webpack_require__(139),
	    keys = __webpack_require__(25);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
	/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
	var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');
	
	/**
	 * Assigns own enumerable string keyed properties of source objects to the
	 * destination object. Source objects are applied from left to right.
	 * Subsequent sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object` and is loosely based on
	 * [`Object.assign`](https://mdn.io/Object/assign).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.10.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.assignIn
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * function Bar() {
	 *   this.c = 3;
	 * }
	 *
	 * Foo.prototype.b = 2;
	 * Bar.prototype.d = 4;
	 *
	 * _.assign({ 'a': 0 }, new Foo, new Bar);
	 * // => { 'a': 1, 'c': 3 }
	 */
	var assign = createAssigner(function(object, source) {
	  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
	    copyObject(source, keys(source), object);
	    return;
	  }
	  for (var key in source) {
	    if (hasOwnProperty.call(source, key)) {
	      assignValue(object, key, source[key]);
	    }
	  }
	});
	
	module.exports = assign;


/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(194),
	    createAssigner = __webpack_require__(195),
	    keysIn = __webpack_require__(451);
	
	/**
	 * This method is like `_.assignIn` except that it accepts `customizer`
	 * which is invoked to produce the assigned values. If `customizer` returns
	 * `undefined`, assignment is handled by the method instead. The `customizer`
	 * is invoked with five arguments: (objValue, srcValue, key, object, source).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias extendWith
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @see _.assignWith
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   return _.isUndefined(objValue) ? srcValue : objValue;
	 * }
	 *
	 * var defaults = _.partialRight(_.assignInWith, customizer);
	 *
	 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	  copyObject(source, keysIn(source), object, customizer);
	});
	
	module.exports = assignInWith;


/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	var baseAt = __webpack_require__(361),
	    baseFlatten = __webpack_require__(131),
	    baseRest = __webpack_require__(29);
	
	/**
	 * Creates an array of values corresponding to `paths` of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {...(string|string[])} [paths] The property paths of elements to pick.
	 * @returns {Array} Returns the picked values.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	 *
	 * _.at(object, ['a[0].b.c', 'a[1]']);
	 * // => [3, 4]
	 */
	var at = baseRest(function(object, paths) {
	  return baseAt(object, baseFlatten(paths, 1));
	});
	
	module.exports = at;


/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(190),
	    assignInDefaults = __webpack_require__(360),
	    assignInWith = __webpack_require__(439),
	    baseRest = __webpack_require__(29);
	
	/**
	 * Assigns own and inherited enumerable string keyed properties of source
	 * objects to the destination object for all destination properties that
	 * resolve to `undefined`. Source objects are applied from left to right.
	 * Once a property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaultsDeep
	 * @example
	 *
	 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var defaults = baseRest(function(args) {
	  args.push(undefined, assignInDefaults);
	  return apply(assignInWith, undefined, args);
	});
	
	module.exports = defaults;


/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(459);


/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	var baseHasIn = __webpack_require__(368),
	    hasPath = __webpack_require__(405);
	
	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}
	
	module.exports = hasIn;


/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(132),
	    isArrayLike = __webpack_require__(23),
	    isString = __webpack_require__(68),
	    toInteger = __webpack_require__(234),
	    values = __webpack_require__(462);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * Checks if `value` is in `collection`. If `collection` is a string, it's
	 * checked for a substring of `value`, otherwise
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	 * is used for equality comparisons. If `fromIndex` is negative, it's used as
	 * the offset from the end of `collection`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to search.
	 * @param {*} value The value to search for.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	 * @returns {boolean} Returns `true` if `value` is found, else `false`.
	 * @example
	 *
	 * _.includes([1, 2, 3], 1);
	 * // => true
	 *
	 * _.includes([1, 2, 3], 1, 2);
	 * // => false
	 *
	 * _.includes({ 'a': 1, 'b': 2 }, 1);
	 * // => true
	 *
	 * _.includes('abcd', 'bc');
	 * // => true
	 */
	function includes(collection, value, fromIndex, guard) {
	  collection = isArrayLike(collection) ? collection : values(collection);
	  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
	
	  var length = collection.length;
	  if (fromIndex < 0) {
	    fromIndex = nativeMax(length + fromIndex, 0);
	  }
	  return isString(collection)
	    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	}
	
	module.exports = includes;


/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(133);
	
	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are **not** supported.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent,
	 *  else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}
	
	module.exports = isEqual;


/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	var getPrototype = __webpack_require__(198),
	    isHostObject = __webpack_require__(138),
	    isObjectLike = __webpack_require__(12);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object,
	 *  else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsSet = __webpack_require__(373),
	    baseUnary = __webpack_require__(136),
	    nodeUtil = __webpack_require__(204);
	
	/* Node.js helper references. */
	var nodeIsSet = nodeUtil && nodeUtil.isSet;
	
	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
	
	module.exports = isSet;


/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(374),
	    baseUnary = __webpack_require__(136),
	    nodeUtil = __webpack_require__(204);
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	module.exports = isTypedArray;


/***/ },
/* 449 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is `undefined`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	 * @example
	 *
	 * _.isUndefined(void 0);
	 * // => true
	 *
	 * _.isUndefined(null);
	 * // => false
	 */
	function isUndefined(value) {
	  return value === undefined;
	}
	
	module.exports = isUndefined;


/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(12);
	
	/** `Object#toString` result references. */
	var weakSetTag = '[object WeakSet]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as a `WeakSet` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	 * @example
	 *
	 * _.isWeakSet(new WeakSet);
	 * // => true
	 *
	 * _.isWeakSet(new Set);
	 * // => false
	 */
	function isWeakSet(value) {
	  return isObjectLike(value) && objectToString.call(value) == weakSetTag;
	}
	
	module.exports = isWeakSet;


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	var baseKeysIn = __webpack_require__(377),
	    indexKeys = __webpack_require__(199),
	    isIndex = __webpack_require__(65),
	    isPrototype = __webpack_require__(139);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  var index = -1,
	      isProto = isPrototype(object),
	      props = baseKeysIn(object),
	      propsLength = props.length,
	      indexes = indexKeys(object),
	      skipIndexes = !!indexes,
	      result = indexes || [],
	      length = result.length;
	
	  while (++index < propsLength) {
	    var key = props[index];
	    if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
	        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = keysIn;


/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(128);
	
	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;
	
	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result);
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}
	
	// Assign cache to `_.memoize`.
	memoize.Cache = MapCache;
	
	module.exports = memoize;


/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(64),
	    baseFlatten = __webpack_require__(131),
	    basePick = __webpack_require__(382),
	    baseRest = __webpack_require__(29),
	    toKey = __webpack_require__(42);
	
	/**
	 * Creates an object composed of the picked `object` properties.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {...(string|string[])} [props] The property identifiers to pick.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.pick(object, ['a', 'c']);
	 * // => { 'a': 1, 'c': 3 }
	 */
	var pick = baseRest(function(object, props) {
	  return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
	});
	
	module.exports = pick;


/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(134),
	    basePropertyDeep = __webpack_require__(384),
	    isKey = __webpack_require__(66),
	    toKey = __webpack_require__(42);
	
	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}
	
	module.exports = property;


/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	var baseSet = __webpack_require__(385);
	
	/**
	 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	 * it's created. Arrays are created for missing index properties while objects
	 * are created for all other missing properties. Use `_.setWith` to customize
	 * `path` creation.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.set(object, 'a[0].b.c', 4);
	 * console.log(object.a[0].b.c);
	 * // => 4
	 *
	 * _.set(object, ['x', '0', 'y', 'z'], 5);
	 * console.log(object.x[0].y.z);
	 * // => 5
	 */
	function set(object, path, value) {
	  return object == null ? object : baseSet(object, path, value);
	}
	
	module.exports = set;


/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	var getTag = __webpack_require__(96),
	    isArrayLike = __webpack_require__(23),
	    isObjectLike = __webpack_require__(12),
	    isString = __webpack_require__(68),
	    keys = __webpack_require__(25),
	    stringSize = __webpack_require__(435);
	
	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';
	
	/**
	 * Gets the size of `collection` by returning its length for array-like
	 * values or the number of own enumerable string keyed properties for objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to inspect.
	 * @returns {number} Returns the collection size.
	 * @example
	 *
	 * _.size([1, 2, 3]);
	 * // => 3
	 *
	 * _.size({ 'a': 1, 'b': 2 });
	 * // => 2
	 *
	 * _.size('pebbles');
	 * // => 7
	 */
	function size(collection) {
	  if (collection == null) {
	    return 0;
	  }
	  if (isArrayLike(collection)) {
	    var result = collection.length;
	    return (result && isString(collection)) ? stringSize(collection) : result;
	  }
	  if (isObjectLike(collection)) {
	    var tag = getTag(collection);
	    if (tag == mapTag || tag == setTag) {
	      return collection.size;
	    }
	  }
	  return keys(collection).length;
	}
	
	module.exports = size;


/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	var baseFlatten = __webpack_require__(131),
	    baseOrderBy = __webpack_require__(381),
	    baseRest = __webpack_require__(29),
	    isIterateeCall = __webpack_require__(200);
	
	/**
	 * Creates an array of elements, sorted in ascending order by the results of
	 * running each element in a collection thru each iteratee. This method
	 * performs a stable sort, that is, it preserves the original sort order of
	 * equal elements. The iteratees are invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {...(Function|Function[])} [iteratees=[_.identity]]
	 *  The iteratees to sort by.
	 * @returns {Array} Returns the new sorted array.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'fred',   'age': 48 },
	 *   { 'user': 'barney', 'age': 36 },
	 *   { 'user': 'fred',   'age': 40 },
	 *   { 'user': 'barney', 'age': 34 }
	 * ];
	 *
	 * _.sortBy(users, function(o) { return o.user; });
	 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	 *
	 * _.sortBy(users, ['user', 'age']);
	 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
	 *
	 * _.sortBy(users, 'user', function(o) {
	 *   return Math.floor(o.age / 10);
	 * });
	 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	 */
	var sortBy = baseRest(function(collection, iteratees) {
	  if (collection == null) {
	    return [];
	  }
	  var length = iteratees.length;
	  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	    iteratees = [];
	  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	    iteratees = [iteratees[0]];
	  }
	  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	});
	
	module.exports = sortBy;


/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	var toNumber = __webpack_require__(235);
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;
	
	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}
	
	module.exports = toFinite;


/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	var createToPairs = __webpack_require__(399),
	    keys = __webpack_require__(25);
	
	/**
	 * Creates an array of own enumerable string keyed-value pairs for `object`
	 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	 * entries are returned.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias entries
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the key-value pairs.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.toPairs(new Foo);
	 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	 */
	var toPairs = createToPairs(keys);
	
	module.exports = toPairs;


/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(135),
	    castSlice = __webpack_require__(390),
	    charsEndIndex = __webpack_require__(391),
	    charsStartIndex = __webpack_require__(392),
	    stringToArray = __webpack_require__(436),
	    toString = __webpack_require__(141);
	
	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;
	
	/**
	 * Removes leading and trailing whitespace or specified characters from `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to trim.
	 * @param {string} [chars=whitespace] The characters to trim.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {string} Returns the trimmed string.
	 * @example
	 *
	 * _.trim('  abc  ');
	 * // => 'abc'
	 *
	 * _.trim('-_-abc-_-', '_-');
	 * // => 'abc'
	 *
	 * _.map(['  foo  ', '  bar  '], _.trim);
	 * // => ['foo', 'bar']
	 */
	function trim(string, chars, guard) {
	  string = toString(string);
	  if (string && (guard || chars === undefined)) {
	    return string.replace(reTrim, '');
	  }
	  if (!string || !(chars = baseToString(chars))) {
	    return string;
	  }
	  var strSymbols = stringToArray(string),
	      chrSymbols = stringToArray(chars),
	      start = charsStartIndex(strSymbols, chrSymbols),
	      end = charsEndIndex(strSymbols, chrSymbols) + 1;
	
	  return castSlice(strSymbols, start, end).join('');
	}
	
	module.exports = trim;


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(357),
	    arrayMap = __webpack_require__(64),
	    baseProperty = __webpack_require__(134),
	    baseTimes = __webpack_require__(193),
	    isArrayLikeObject = __webpack_require__(209);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * This method is like `_.zip` except that it accepts an array of grouped
	 * elements and creates an array regrouping the elements to their pre-zip
	 * configuration.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.2.0
	 * @category Array
	 * @param {Array} array The array of grouped elements to process.
	 * @returns {Array} Returns the new array of regrouped elements.
	 * @example
	 *
	 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	 * // => [['a', 1, true], ['b', 2, false]]
	 *
	 * _.unzip(zipped);
	 * // => [['a', 'b'], [1, 2], [true, false]]
	 */
	function unzip(array) {
	  if (!(array && array.length)) {
	    return [];
	  }
	  var length = 0;
	  array = arrayFilter(array, function(group) {
	    if (isArrayLikeObject(group)) {
	      length = nativeMax(group.length, length);
	      return true;
	    }
	  });
	  return baseTimes(length, function(index) {
	    return arrayMap(array, baseProperty(index));
	  });
	}
	
	module.exports = unzip;


/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	var baseValues = __webpack_require__(389),
	    keys = __webpack_require__(25);
	
	/**
	 * Creates an array of the own enumerable string keyed property values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.values(new Foo);
	 * // => [1, 2] (iteration order is not guaranteed)
	 *
	 * _.values('hi');
	 * // => ['h', 'i']
	 */
	function values(object) {
	  return object ? baseValues(object, keys(object)) : [];
	}
	
	module.exports = values;


/***/ },
/* 463 */
/***/ function(module, exports) {

	'use strict';
	
	var toStr = Object.prototype.toString;
	
	module.exports = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' &&
				value !== null &&
				typeof value === 'object' &&
				typeof value.length === 'number' &&
				value.length >= 0 &&
				toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};


/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["OpenPhysiologyModel"] = factory();
		else
			root["OpenPhysiologyModel"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = __webpack_require__(212);
	
	
	/***/ },
	/* 1 */,
	/* 2 */,
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.sw = exports.humanMsg = exports.simpleSpaced = exports.arrayContainsValue = undefined;
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); ////////////////////////////////////////////////////////////////////////////////
		// Schema Data Types                                                          //
		////////////////////////////////////////////////////////////////////////////////
		
		exports.mapOptionalArray = mapOptionalArray;
		exports.wrapInArray = wrapInArray;
		exports.parseCardinality = parseCardinality;
		exports.stringifyCardinality = stringifyCardinality;
		exports.normalizeToRange = normalizeToRange;
		exports.setDefault = setDefault;
		exports.definePropertyByValue = definePropertyByValue;
		exports.definePropertiesByValue = definePropertiesByValue;
		exports.callOrReturn = callOrReturn;
		exports.constraint = constraint;
		
		var _isUndefined = __webpack_require__(37);
		
		var _isUndefined2 = _interopRequireDefault(_isUndefined);
		
		var _trim = __webpack_require__(268);
		
		var _trim2 = _interopRequireDefault(_trim);
		
		var _isString = __webpack_require__(148);
		
		var _isString2 = _interopRequireDefault(_isString);
		
		var _isArray = __webpack_require__(146);
		
		var _isArray2 = _interopRequireDefault(_isArray);
		
		var _isNumber = __webpack_require__(259);
		
		var _isNumber2 = _interopRequireDefault(_isNumber);
		
		var _isObject = __webpack_require__(72);
		
		var _isObject2 = _interopRequireDefault(_isObject);
		
		var _isFunction = __webpack_require__(105);
		
		var _isFunction2 = _interopRequireDefault(_isFunction);
		
		var _isSet = __webpack_require__(260);
		
		var _isSet2 = _interopRequireDefault(_isSet);
		
		var _isWeakSet = __webpack_require__(261);
		
		var _isWeakSet2 = _interopRequireDefault(_isWeakSet);
		
		var _entries = __webpack_require__(17);
		
		var _entries2 = _interopRequireDefault(_entries);
		
		var _boundNativeMethods = __webpack_require__(10);
		
		var _zip2 = __webpack_require__(412);
		
		var _zip3 = _interopRequireDefault(_zip2);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		////////////////////////////////////////////////////////////////////////////////
		
		var arrayContainsValue = exports.arrayContainsValue = function arrayContainsValue(array, value) {
			return array.includes(value);
		};
		
		var simpleSpaced = exports.simpleSpaced = function simpleSpaced(str) {
			return str.replace(/\s+/mg, ' ');
		};
		
		var humanMsg = exports.humanMsg = function humanMsg(strings) {
			var _context;
		
			for (var _len = arguments.length, vals = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				vals[_key - 1] = arguments[_key];
			}
		
			var result = strings[0];
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;
		
			try {
				for (var _iterator = (0, _zip3.default)(vals, strings.slice(1))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _step$value = _slicedToArray(_step.value, 2);
		
					var val = _step$value[0];
					var str = _step$value[1];
		
					result += val + simpleSpaced(str);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		
			return (_context = result, _trim2.default).call(_context);
		};
		
		function mapOptionalArray(val, fn) {
			var _context2;
		
			if ((_context2 = val, _isUndefined2.default).call(_context2)) {
				return [];
			}
			var isArr = (_context2 = val, _isArray2.default).call(_context2);
			val = (isArr ? val : [val]).map(fn);
			return isArr ? val : val[0];
		}
		
		function wrapInArray(val) {
			if (_isUndefined2.default.call(val)) {
				return [];
			}
			if (_isArray2.default.call(val) || _isSet2.default.call(val) || _isWeakSet2.default.call(val)) {
				return [].concat(_toConsumableArray(val));
			}
			return [val];
		}
		
		function parseCardinality(val) {
			var match = val.match(/^(\d+)\.\.(\d+|\*)$/);
		
			var _match = _slicedToArray(match, 3);
		
			var min = _match[1];
			var max = _match[2];
		
			if (max === '*') {
				max = Infinity;
			} else {
				max = parseInt(max, 10);
			}
			min = parseInt(min, 10);
			return { min: min, max: max };
		}
		
		function stringifyCardinality(cardinality) {
			var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		
			var abbreviate = _ref.abbreviate;
		
			return cardinality.min === cardinality.max && abbreviate ? '   ' + cardinality.min : cardinality.min + '..' + (cardinality.max === Infinity ? '*' : cardinality.max);
		}
		
		function normalizeToRange(val) {
			var _context3;
		
			if ((_context3 = val, _isNumber2.default).call(_context3)) {
				val = { min: val, max: val };
			} else if (!(_context3 = val, _isObject2.default).call(_context3)) {
				val = {};
			}
			if (!(_context3 = val.min, _isNumber2.default).call(_context3)) {
				val.min = -Infinity;
			}
			if (!(_context3 = val.max, _isNumber2.default).call(_context3)) {
				val.max = Infinity;
			}
			return val;
		}
		
		function setDefault(obj, key, val) {
			var _context4;
		
			if ((_context4 = obj[key], _isUndefined2.default).call(_context4)) {
				obj[key] = val;
			}
		}
		
		var sw = exports.sw = function sw(val) {
			var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		
			var _ref2$autoInvoke = _ref2.autoInvoke;
			var autoInvoke = _ref2$autoInvoke === undefined ? true : _ref2$autoInvoke;
			return function (map) {
				var _context5;
		
				var result = val in map ? map[val] : map.default;
				if (autoInvoke && (_context5 = result, _isFunction2.default).call(_context5)) {
					result = result();
				}
				return result;
			};
		};
		
		function definePropertyByValue(key, value) {
			var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
		
			_boundNativeMethods.defineProperty.call(this, key, _extends({}, options, { value: value }));
		}
		
		function definePropertiesByValue(obj) {
			var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;
		
			try {
				for (var _iterator2 = _entries2.default.call(obj)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var _step2$value = _slicedToArray(_step2.value, 2);
		
					var key = _step2$value[0];
					var value = _step2$value[1];
		
					definePropertyByValue.call(this, key, value, options);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}
		
		function callOrReturn(context) {
			return _isFunction2.default.call(this) ? this.call(context) : this;
		}
		
		function constraint(constraint, message) {
			if (!constraint) {
				throw new Error('Constraint Failure: ' + (message || '(no message)'));
			}
		}
	
	/***/ },
	/* 4 */,
	/* 5 */,
	/* 6 */,
	/* 7 */,
	/* 8 */
	/***/ function(module, exports) {
	
		/**
		 * Checks if `value` is classified as an `Array` object.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
		 * @example
		 *
		 * _.isArray([1, 2, 3]);
		 * // => true
		 *
		 * _.isArray(document.body.children);
		 * // => false
		 *
		 * _.isArray('abc');
		 * // => false
		 *
		 * _.isArray(_.noop);
		 * // => false
		 */
		var isArray = Array.isArray;
		
		module.exports = isArray;
	
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseHas = __webpack_require__(158),
		    baseKeys = __webpack_require__(301),
		    indexKeys = __webpack_require__(166),
		    isArrayLike = __webpack_require__(21),
		    isIndex = __webpack_require__(54),
		    isPrototype = __webpack_require__(81);
		
		/**
		 * Creates an array of the own enumerable property names of `object`.
		 *
		 * **Note:** Non-object values are coerced to objects. See the
		 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
		 * for more details.
		 *
		 * @static
		 * @since 0.1.0
		 * @memberOf _
		 * @category Object
		 * @param {Object} object The object to query.
		 * @returns {Array} Returns the array of property names.
		 * @example
		 *
		 * function Foo() {
		 *   this.a = 1;
		 *   this.b = 2;
		 * }
		 *
		 * Foo.prototype.c = 3;
		 *
		 * _.keys(new Foo);
		 * // => ['a', 'b'] (iteration order is not guaranteed)
		 *
		 * _.keys('hi');
		 * // => ['0', '1']
		 */
		function keys(object) {
		  var isProto = isPrototype(object);
		  if (!(isProto || isArrayLike(object))) {
		    return baseKeys(object);
		  }
		  var indexes = indexKeys(object),
		      skipIndexes = !!indexes,
		      result = indexes || [],
		      length = result.length;
		
		  for (var key in object) {
		    if (baseHas(object, key) &&
		        !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
		        !(isProto && key == 'constructor')) {
		      result.push(key);
		    }
		  }
		  return result;
		}
		
		module.exports = keys;
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		exports.__esModule = true;
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
		
		function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }
		
		var _object = __webpack_require__(223);
		
		_defaults(exports, _interopRequireWildcard(_object));
		
		var _symbolJs = __webpack_require__(224);
		
		_defaults(exports, _interopRequireWildcard(_symbolJs));
		
		var _numberJs = __webpack_require__(222);
		
		_defaults(exports, _interopRequireWildcard(_numberJs));
		
		var _mathJs = __webpack_require__(221);
		
		_defaults(exports, _interopRequireWildcard(_mathJs));
		
		var _dateJs = __webpack_require__(219);
		
		_defaults(exports, _interopRequireWildcard(_dateJs));
		
		var _arrayJs = __webpack_require__(218);
		
		_defaults(exports, _interopRequireWildcard(_arrayJs));
		
		var _arrayBufferJs = __webpack_require__(217);
		
		_defaults(exports, _interopRequireWildcard(_arrayBufferJs));
		
		var _jsonJs = __webpack_require__(220);
		
		_defaults(exports, _interopRequireWildcard(_jsonJs));
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
		var freeGlobal = __webpack_require__(165);
		
		/** Detect free variable `self`. */
		var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
		
		/** Used as a reference to the global object. */
		var root = freeGlobal || freeSelf || Function('return this')();
		
		module.exports = root;
	
	
	/***/ },
	/* 12 */
	/***/ function(module, exports) {
	
		/**
		 * Checks if `value` is the
		 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
		 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
		 * @example
		 *
		 * _.isObject({});
		 * // => true
		 *
		 * _.isObject([1, 2, 3]);
		 * // => true
		 *
		 * _.isObject(_.noop);
		 * // => true
		 *
		 * _.isObject(null);
		 * // => false
		 */
		function isObject(value) {
		  var type = typeof value;
		  return !!value && (type == 'object' || type == 'function');
		}
		
		module.exports = isObject;
	
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var isFunction_1 = __webpack_require__(189);
		var Subscription_1 = __webpack_require__(127);
		var Observer_1 = __webpack_require__(414);
		var rxSubscriber_1 = __webpack_require__(130);
		/**
		 * Implements the {@link Observer} interface and extends the
		 * {@link Subscription} class. While the {@link Observer} is the public API for
		 * consuming the values of an {@link Observable}, all Observers get converted to
		 * a Subscriber, in order to provide Subscription-like capabilities such as
		 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
		 * implementing operators, but it is rarely used as a public API.
		 *
		 * @class Subscriber<T>
		 */
		var Subscriber = (function (_super) {
		    __extends(Subscriber, _super);
		    /**
		     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
		     * defined Observer or a `next` callback function.
		     * @param {function(e: ?any): void} [error] The `error` callback of an
		     * Observer.
		     * @param {function(): void} [complete] The `complete` callback of an
		     * Observer.
		     */
		    function Subscriber(destinationOrNext, error, complete) {
		        _super.call(this);
		        this.syncErrorValue = null;
		        this.syncErrorThrown = false;
		        this.syncErrorThrowable = false;
		        this.isStopped = false;
		        switch (arguments.length) {
		            case 0:
		                this.destination = Observer_1.empty;
		                break;
		            case 1:
		                if (!destinationOrNext) {
		                    this.destination = Observer_1.empty;
		                    break;
		                }
		                if (typeof destinationOrNext === 'object') {
		                    if (destinationOrNext instanceof Subscriber) {
		                        this.destination = destinationOrNext;
		                        this.destination.add(this);
		                    }
		                    else {
		                        this.syncErrorThrowable = true;
		                        this.destination = new SafeSubscriber(this, destinationOrNext);
		                    }
		                    break;
		                }
		            default:
		                this.syncErrorThrowable = true;
		                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
		                break;
		        }
		    }
		    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
		    /**
		     * A static factory for a Subscriber, given a (potentially partial) definition
		     * of an Observer.
		     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
		     * @param {function(e: ?any): void} [error] The `error` callback of an
		     * Observer.
		     * @param {function(): void} [complete] The `complete` callback of an
		     * Observer.
		     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
		     * Observer represented by the given arguments.
		     */
		    Subscriber.create = function (next, error, complete) {
		        var subscriber = new Subscriber(next, error, complete);
		        subscriber.syncErrorThrowable = false;
		        return subscriber;
		    };
		    /**
		     * The {@link Observer} callback to receive notifications of type `next` from
		     * the Observable, with a value. The Observable may call this method 0 or more
		     * times.
		     * @param {T} [value] The `next` value.
		     * @return {void}
		     */
		    Subscriber.prototype.next = function (value) {
		        if (!this.isStopped) {
		            this._next(value);
		        }
		    };
		    /**
		     * The {@link Observer} callback to receive notifications of type `error` from
		     * the Observable, with an attached {@link Error}. Notifies the Observer that
		     * the Observable has experienced an error condition.
		     * @param {any} [err] The `error` exception.
		     * @return {void}
		     */
		    Subscriber.prototype.error = function (err) {
		        if (!this.isStopped) {
		            this.isStopped = true;
		            this._error(err);
		        }
		    };
		    /**
		     * The {@link Observer} callback to receive a valueless notification of type
		     * `complete` from the Observable. Notifies the Observer that the Observable
		     * has finished sending push-based notifications.
		     * @return {void}
		     */
		    Subscriber.prototype.complete = function () {
		        if (!this.isStopped) {
		            this.isStopped = true;
		            this._complete();
		        }
		    };
		    Subscriber.prototype.unsubscribe = function () {
		        if (this.isUnsubscribed) {
		            return;
		        }
		        this.isStopped = true;
		        _super.prototype.unsubscribe.call(this);
		    };
		    Subscriber.prototype._next = function (value) {
		        this.destination.next(value);
		    };
		    Subscriber.prototype._error = function (err) {
		        this.destination.error(err);
		        this.unsubscribe();
		    };
		    Subscriber.prototype._complete = function () {
		        this.destination.complete();
		        this.unsubscribe();
		    };
		    return Subscriber;
		}(Subscription_1.Subscription));
		exports.Subscriber = Subscriber;
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var SafeSubscriber = (function (_super) {
		    __extends(SafeSubscriber, _super);
		    function SafeSubscriber(_parent, observerOrNext, error, complete) {
		        _super.call(this);
		        this._parent = _parent;
		        var next;
		        var context = this;
		        if (isFunction_1.isFunction(observerOrNext)) {
		            next = observerOrNext;
		        }
		        else if (observerOrNext) {
		            context = observerOrNext;
		            next = observerOrNext.next;
		            error = observerOrNext.error;
		            complete = observerOrNext.complete;
		            if (isFunction_1.isFunction(context.unsubscribe)) {
		                this.add(context.unsubscribe.bind(context));
		            }
		            context.unsubscribe = this.unsubscribe.bind(this);
		        }
		        this._context = context;
		        this._next = next;
		        this._error = error;
		        this._complete = complete;
		    }
		    SafeSubscriber.prototype.next = function (value) {
		        if (!this.isStopped && this._next) {
		            var _parent = this._parent;
		            if (!_parent.syncErrorThrowable) {
		                this.__tryOrUnsub(this._next, value);
		            }
		            else if (this.__tryOrSetError(_parent, this._next, value)) {
		                this.unsubscribe();
		            }
		        }
		    };
		    SafeSubscriber.prototype.error = function (err) {
		        if (!this.isStopped) {
		            var _parent = this._parent;
		            if (this._error) {
		                if (!_parent.syncErrorThrowable) {
		                    this.__tryOrUnsub(this._error, err);
		                    this.unsubscribe();
		                }
		                else {
		                    this.__tryOrSetError(_parent, this._error, err);
		                    this.unsubscribe();
		                }
		            }
		            else if (!_parent.syncErrorThrowable) {
		                this.unsubscribe();
		                throw err;
		            }
		            else {
		                _parent.syncErrorValue = err;
		                _parent.syncErrorThrown = true;
		                this.unsubscribe();
		            }
		        }
		    };
		    SafeSubscriber.prototype.complete = function () {
		        if (!this.isStopped) {
		            var _parent = this._parent;
		            if (this._complete) {
		                if (!_parent.syncErrorThrowable) {
		                    this.__tryOrUnsub(this._complete);
		                    this.unsubscribe();
		                }
		                else {
		                    this.__tryOrSetError(_parent, this._complete);
		                    this.unsubscribe();
		                }
		            }
		            else {
		                this.unsubscribe();
		            }
		        }
		    };
		    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
		        try {
		            fn.call(this._context, value);
		        }
		        catch (err) {
		            this.unsubscribe();
		            throw err;
		        }
		    };
		    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
		        try {
		            fn.call(this._context, value);
		        }
		        catch (err) {
		            parent.syncErrorValue = err;
		            parent.syncErrorThrown = true;
		            return true;
		        }
		        return false;
		    };
		    SafeSubscriber.prototype._unsubscribe = function () {
		        var _parent = this._parent;
		        this._context = null;
		        this._parent = null;
		        _parent.unsubscribe();
		    };
		    return SafeSubscriber;
		}(Subscriber));
		//# sourceMappingURL=Subscriber.js.map
	
	/***/ },
	/* 14 */,
	/* 15 */,
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _schemas = __webpack_require__(32);
		
		var _Module = __webpack_require__(46);
		
		var _Module2 = _interopRequireDefault(_Module);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _Module2.default.create('resources', [], function (M) {
		
			var Resource = M.RESOURCE({ /////////////////////////////////////////////////////////////////
		
				name: 'Resource',
		
				abstract: true,
		
				properties: {
					'id': _extends({}, _schemas.idSchema, { readonly: true }),
					'href': _extends({}, _schemas.uriSchema, { readonly: true }),
					'class': _extends({}, _schemas.identifierSchema, { readonly: true }),
					'name': { type: 'string' }
				}
		
			}); //////////////////////////////////////////////////////////////////////////
		
		
			var IsRelatedTo = M.RELATIONSHIP({
		
				name: 'IsRelatedTo',
		
				abstract: true,
		
				singular: "is related to",
		
				1: [Resource, '0..*'],
				2: [Resource, '0..*'],
		
				properties: {
					'id': _extends({}, _schemas.idSchema, { readonly: true }),
					'href': _extends({}, _schemas.uriSchema, { readonly: true }),
					'class': _extends({}, _schemas.identifierSchema, { readonly: true })
				}
		
			});
		
			var ExternalResource = M.RESOURCE({ ///////////////////////////////////////
		
				name: 'ExternalResource',
		
				extends: Resource,
		
				singular: "external resource",
		
				properties: {
					'uri': _extends({}, _schemas.uriSchema, { required: true }),
					'type': { type: 'string' } // "fma" or "cocomac", etc.
				}
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var IsExternallyRelatedTo = M.RELATIONSHIP({
		
				name: 'IsExternallyRelatedTo',
		
				extends: IsRelatedTo,
		
				singular: "is externally related to",
		
				1: [ExternalResource, '0..*'],
				2: [ExternalResource, '0..*'],
		
				properties: {
					'type': { type: 'string', required: true }
				}
		
			});
		
			var CorrespondsTo = M.RELATIONSHIP({
		
				name: 'CorrespondsTo',
		
				extends: IsRelatedTo,
		
				singular: "corresponds to",
		
				1: [Resource, '0..*', { anchors: true, key: 'externals' }],
				2: [ExternalResource, '0..*', { key: 'locals' }]
		
			});
		});
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(380);
		
		module.exports = function entries() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 18 */
	/***/ function(module, exports) {
	
		/**
		 * Checks if `value` is object-like. A value is object-like if it's not `null`
		 * and has a `typeof` result of "object".
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
		 * @example
		 *
		 * _.isObjectLike({});
		 * // => true
		 *
		 * _.isObjectLike([1, 2, 3]);
		 * // => true
		 *
		 * _.isObjectLike(_.noop);
		 * // => false
		 *
		 * _.isObjectLike(null);
		 * // => false
		 */
		function isObjectLike(value) {
		  return !!value && typeof value == 'object';
		}
		
		module.exports = isObjectLike;
	
	
	/***/ },
	/* 19 */
	/***/ function(module, exports) {
	
		"use strict";
		
		exports.__esModule = true;
		
		exports["default"] = function (object, names) {
		  var rename = arguments[2] === undefined ? {} : arguments[2];
		  return names.reduce(function (m, name) {
		    m[rename[name] || name] = function () {
		      for (var _len = arguments.length, s = Array(_len), _key = 0; _key < _len; _key++) {
		        s[_key] = arguments[_key];
		      }
		
		      return this.constructor === Array && object === Math ? object[name].apply(object, this.concat(s)) : object[name].apply(object, [this].concat(s));
		    };
		
		    return m;
		  }, {});
		};
		
		module.exports = exports["default"];
	
	/***/ },
	/* 20 */,
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getLength = __webpack_require__(334),
		    isFunction = __webpack_require__(84),
		    isLength = __webpack_require__(85);
		
		/**
		 * Checks if `value` is array-like. A value is considered array-like if it's
		 * not a function and has a `value.length` that's an integer greater than or
		 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
		 * @example
		 *
		 * _.isArrayLike([1, 2, 3]);
		 * // => true
		 *
		 * _.isArrayLike(document.body.children);
		 * // => true
		 *
		 * _.isArrayLike('abc');
		 * // => true
		 *
		 * _.isArrayLike(_.noop);
		 * // => false
		 */
		function isArrayLike(value) {
		  return value != null && isLength(getLength(value)) && !isFunction(value);
		}
		
		module.exports = isArrayLike;
	
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var root_1 = __webpack_require__(89);
		var toSubscriber_1 = __webpack_require__(434);
		var symbol_observable_1 = __webpack_require__(191);
		/**
		 * A representation of any set of values over any amount of time. This the most basic building block
		 * of RxJS.
		 *
		 * @class Observable<T>
		 */
		var Observable = (function () {
		    /**
		     * @constructor
		     * @param {Function} subscribe the function that is  called when the Observable is
		     * initially subscribed to. This function is given a Subscriber, to which new values
		     * can be `next`ed, or an `error` method can be called to raise an error, or
		     * `complete` can be called to notify of a successful completion.
		     */
		    function Observable(subscribe) {
		        this._isScalar = false;
		        if (subscribe) {
		            this._subscribe = subscribe;
		        }
		    }
		    /**
		     * Creates a new Observable, with this Observable as the source, and the passed
		     * operator defined as the new observable's operator.
		     * @method lift
		     * @param {Operator} operator the operator defining the operation to take on the observable
		     * @return {Observable} a new observable with the Operator applied
		     */
		    Observable.prototype.lift = function (operator) {
		        var observable = new Observable();
		        observable.source = this;
		        observable.operator = operator;
		        return observable;
		    };
		    /**
		     * Registers handlers for handling emitted values, error and completions from the observable, and
		     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
		     * @method subscribe
		     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
		     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
		     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
		     *  the error will be thrown as unhandled
		     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
		     * @return {ISubscription} a subscription reference to the registered handlers
		     */
		    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
		        var operator = this.operator;
		        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
		        if (operator) {
		            operator.call(sink, this);
		        }
		        else {
		            sink.add(this._subscribe(sink));
		        }
		        if (sink.syncErrorThrowable) {
		            sink.syncErrorThrowable = false;
		            if (sink.syncErrorThrown) {
		                throw sink.syncErrorValue;
		            }
		        }
		        return sink;
		    };
		    /**
		     * @method forEach
		     * @param {Function} next a handler for each value emitted by the observable
		     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
		     * @return {Promise} a promise that either resolves on observable completion or
		     *  rejects with the handled error
		     */
		    Observable.prototype.forEach = function (next, PromiseCtor) {
		        var _this = this;
		        if (!PromiseCtor) {
		            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
		                PromiseCtor = root_1.root.Rx.config.Promise;
		            }
		            else if (root_1.root.Promise) {
		                PromiseCtor = root_1.root.Promise;
		            }
		        }
		        if (!PromiseCtor) {
		            throw new Error('no Promise impl found');
		        }
		        return new PromiseCtor(function (resolve, reject) {
		            var subscription = _this.subscribe(function (value) {
		                if (subscription) {
		                    // if there is a subscription, then we can surmise
		                    // the next handling is asynchronous. Any errors thrown
		                    // need to be rejected explicitly and unsubscribe must be
		                    // called manually
		                    try {
		                        next(value);
		                    }
		                    catch (err) {
		                        reject(err);
		                        subscription.unsubscribe();
		                    }
		                }
		                else {
		                    // if there is NO subscription, then we're getting a nexted
		                    // value synchronously during subscription. We can just call it.
		                    // If it errors, Observable's `subscribe` imple will ensure the
		                    // unsubscription logic is called, then synchronously rethrow the error.
		                    // After that, Promise will trap the error and send it
		                    // down the rejection path.
		                    next(value);
		                }
		            }, reject, resolve);
		        });
		    };
		    Observable.prototype._subscribe = function (subscriber) {
		        return this.source.subscribe(subscriber);
		    };
		    /**
		     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
		     * @method Symbol.observable
		     * @return {Observable} this instance of the observable
		     */
		    Observable.prototype[symbol_observable_1.default] = function () {
		        return this;
		    };
		    // HACK: Since TypeScript inherits static properties too, we have to
		    // fight against TypeScript here so Subject can have a different static create signature
		    /**
		     * Creates a new cold Observable by calling the Observable constructor
		     * @static true
		     * @owner Observable
		     * @method create
		     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
		     * @return {Observable} a new cold observable
		     */
		    Observable.create = function (subscribe) {
		        return new Observable(subscribe);
		    };
		    return Observable;
		}());
		exports.Observable = Observable;
		//# sourceMappingURL=Observable.js.map
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var Observable_1 = __webpack_require__(22);
		var do_1 = __webpack_require__(423);
		Observable_1.Observable.prototype.do = do_1._do;
		//# sourceMappingURL=do.js.map
	
	/***/ },
	/* 24 */,
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.RelField = exports.Field = undefined;
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _dec, _dec2, _dec3, _dec4, _desc, _value, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _dec5, _desc2, _value2, _class3, _descriptor5;
		
		var _templateObject = _taggedTemplateLiteral(['\n\t\t\t\tTried to set the readonly field\n\t\t\t\t\'', '#', '\'.\n\t\t\t'], ['\n\t\t\t\tTried to set the readonly field\n\t\t\t\t\'', '#', '\'.\n\t\t\t']);
		
		var _Subject = __webpack_require__(59);
		
		var _map = __webpack_require__(42);
		
		var _concat = __webpack_require__(183);
		
		__webpack_require__(23);
		
		var _pick = __webpack_require__(266);
		
		var _pick2 = _interopRequireDefault(_pick);
		
		var _isFunction = __webpack_require__(105);
		
		var _isFunction2 = _interopRequireDefault(_isFunction);
		
		var _isUndefined = __webpack_require__(37);
		
		var _isUndefined2 = _interopRequireDefault(_isUndefined);
		
		var _values = __webpack_require__(108);
		
		var _values2 = _interopRequireDefault(_values);
		
		var _boundNativeMethods = __webpack_require__(10);
		
		var _ValueTracker2 = __webpack_require__(140);
		
		var _ValueTracker3 = _interopRequireDefault(_ValueTracker2);
		
		var _misc = __webpack_require__(3);
		
		var _symbols = __webpack_require__(26);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		function _initDefineProp(target, property, descriptor, context) {
			if (!descriptor) return;
			Object.defineProperty(target, property, {
				enumerable: descriptor.enumerable,
				configurable: descriptor.configurable,
				writable: descriptor.writable,
				value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
			});
		}
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
			var desc = {};
			Object['ke' + 'ys'](descriptor).forEach(function (key) {
				desc[key] = descriptor[key];
			});
			desc.enumerable = !!desc.enumerable;
			desc.configurable = !!desc.configurable;
		
			if ('value' in desc || desc.initializer) {
				desc.writable = true;
			}
		
			desc = decorators.slice().reverse().reduce(function (desc, decorator) {
				return decorator(target, property, desc) || desc;
			}, desc);
		
			if (context && desc.initializer !== void 0) {
				desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
				desc.initializer = undefined;
			}
		
			if (desc.initializer === void 0) {
				Object['define' + 'Property'](target, property, desc);
				desc = null;
			}
		
			return desc;
		}
		
		function _initializerWarningHelper(descriptor, context) {
			throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
		}
		
		var Field = exports.Field = (_dec = (0, _ValueTracker2.event)(), _dec2 = (0, _ValueTracker2.event)(), _dec3 = (0, _ValueTracker2.property)({ initial: true, readonly: true }), _dec4 = (0, _ValueTracker2.property)(), (_class = function (_ValueTracker) {
			_inherits(Field, _ValueTracker);
		
			_createClass(Field, [{
				key: Symbol.toStringTag,
		
		
				//////////////
				// instance //
				//////////////
		
				//noinspection JSDuplicatedDeclaration // (to suppress Webstorm bug)
				get: function get() {
					return 'Field: ' + this[_symbols.$$owner].constructor.name + '#' + this[_symbols.$$key];
				}
			}], [{
				key: _symbols.$$registerFieldClass,
		
		
				////////////
				// static //
				////////////
		
				value: function value(FieldClass) {
					if (!this[_symbols.$$fieldClasses]) {
						this[_symbols.$$fieldClasses] = new Set();
					}
					this[_symbols.$$fieldClasses].add(FieldClass);
				}
			}, {
				key: 'augmentClass',
				value: function augmentClass(cls, onlyForKey) {
					if (!this[_symbols.$$fieldClasses]) {
						this[_symbols.$$fieldClasses] = new Set();
					}
		
					/* allow each kind of field to perform its initializations */
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;
		
					try {
						for (var _iterator = this[_symbols.$$fieldClasses][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var FieldClass = _step.value;
							var _iteratorNormalCompletion2 = true;
							var _didIteratorError2 = false;
							var _iteratorError2 = undefined;
		
							try {
								for (var _iterator2 = FieldClass[_symbols.$$entriesIn](cls)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
									var _step2$value = _step2.value;
									var key = _step2$value.key;
									var desc = _step2$value.desc;
		
									if (!onlyForKey || onlyForKey === key) {
										FieldClass.initClass({ cls: cls, key: key, desc: desc });
									}
								}
							} catch (err) {
								_didIteratorError2 = true;
								_iteratorError2 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion2 && _iterator2.return) {
										_iterator2.return();
									}
								} finally {
									if (_didIteratorError2) {
										throw _iteratorError2;
									}
								}
							}
						}
		
						/* only initialize a class once */
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
		
					if (cls[_symbols.$$initialized]) {
						return;
					}
					cls[_symbols.$$initialized] = true;
				}
			}, {
				key: 'initializeEntity',
				value: function initializeEntity(owner, initialValues) {
					if (owner.fields) {
						return;
					}
					_boundNativeMethods.defineProperty.call(owner, 'fields', { value: {} });
		
					/* allow specific field-init code to wait until all fields are initialized */
					var constructingOwner = new _Subject.Subject();
					var waitUntilConstructed = function waitUntilConstructed() {
						return (0, _concat.concat)(constructingOwner, this);
					};
		
					/* initialize all fields */
					var keyDescs = {};
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;
		
					try {
						for (var _iterator3 = this[_symbols.$$fieldClasses][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var FieldClass = _step3.value;
							var _iteratorNormalCompletion6 = true;
							var _didIteratorError6 = false;
							var _iteratorError6 = undefined;
		
							try {
								for (var _iterator6 = FieldClass[_symbols.$$entriesIn](owner.constructor)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
									var entry = _step6.value;
									var key = entry.key;
		
									keyDescs[key] = _extends({}, entry, {
										waitUntilConstructed: waitUntilConstructed,
										constructingOwner: constructingOwner,
										owner: owner,
										key: key,
										initialValue: initialValues[key],
										FieldClass: FieldClass
									});
								}
							} catch (err) {
								_didIteratorError6 = true;
								_iteratorError6 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion6 && _iterator6.return) {
										_iterator6.return();
									}
								} finally {
									if (_didIteratorError6) {
										throw _iteratorError6;
									}
								}
							}
						}
		
						/* add related descriptions to each description */
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
		
					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;
		
					try {
						for (var _iterator4 = _values2.default.call(keyDescs)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var _entry = _step4.value;
		
							_entry.related = _pick2.default.call(keyDescs, _entry.relatedKeys);
						}
		
						/* create a field for each description */
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}
		
					var _iteratorNormalCompletion5 = true;
					var _didIteratorError5 = false;
					var _iteratorError5 = undefined;
		
					try {
						for (var _iterator5 = _values2.default.call(keyDescs)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
							var _entry2 = _step5.value;
							var _FieldClass = _entry2.FieldClass;
		
							delete _entry2.FieldClass;
							delete _entry2.relatedKeys;
							new _FieldClass(_entry2);
						}
		
						/* notify completion of field initialization */
					} catch (err) {
						_didIteratorError5 = true;
						_iteratorError5 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion5 && _iterator5.return) {
								_iterator5.return();
							}
						} finally {
							if (_didIteratorError5) {
								throw _iteratorError5;
							}
						}
					}
		
					constructingOwner.complete();
				}
			}, {
				key: 'isEqual',
				value: function isEqual(a, b) {
					return a === b;
				}
		
				/////////////////////////
				// events & properties //
				/////////////////////////
		
			}]);
		
			function Field(_ref) {
				var _context;
		
				var owner = _ref.owner;
				var key = _ref.key;
				var desc = _ref.desc;
				var _ref$setValueThroughS = _ref.setValueThroughSignal;
				var setValueThroughSignal = _ref$setValueThroughS === undefined ? true : _ref$setValueThroughS;
		
				_classCallCheck(this, Field);
		
				var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Field).call(this));
		
				_initDefineProp(_this, 'commitEvent', _descriptor, _this);
		
				_initDefineProp(_this, 'rollbackEvent', _descriptor2, _this);
		
				_initDefineProp(_this, 'isPristine', _descriptor3, _this);
		
				_initDefineProp(_this, 'value', _descriptor4, _this);
		
				owner.fields[key] = _this;
				_this[_symbols.$$owner] = owner;
				_this[_symbols.$$key] = key;
				_this[_symbols.$$desc] = desc;
				if (setValueThroughSignal) {
					// allow signal-push to change value
					_this.p('value').subscribe(_this.set.bind(_this));
				}
				(_context = _this.p('value'), _map.map).call(_context, function (v) {
					return _this.constructor.isEqual(v, _this[_symbols.$$pristine]);
				}).subscribe(_this.pSubject('isPristine'));
				return _this;
			}
		
			//noinspection JSDuplicatedDeclaration // (to suppress warning due to Webstorm bug)
		
		
			_createClass(Field, [{
				key: 'get',
				value: function get() {
					return this[_symbols.$$value];
				}
			}, {
				key: 'set',
				value: function set(val) {
					var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		
					var _ref2$ignoreReadonly = _ref2.ignoreReadonly;
					var ignoreReadonly = _ref2$ignoreReadonly === undefined ? false : _ref2$ignoreReadonly;
					var _ref2$ignoreValidatio = _ref2.ignoreValidation;
					var ignoreValidation = _ref2$ignoreValidatio === undefined ? false : _ref2$ignoreValidatio;
					var _ref2$updatePristine = _ref2.updatePristine;
					var updatePristine = _ref2$updatePristine === undefined ? false : _ref2$updatePristine;
		
					if (!this.constructor.isEqual(this[_symbols.$$value], val)) {
						(0, _misc.constraint)(ignoreReadonly || !this[_symbols.$$desc].readonly, (0, _misc.humanMsg)(_templateObject, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
						if (!ignoreValidation) {
							this.validate(val, ['set']);
						}
						if (updatePristine) {
							this[_symbols.$$pristine] = val;
						}
						this[_symbols.$$value] = val;
						this.pSubject('value').next(val);
					}
				}
			}, {
				key: _symbols.$$initSet,
				value: function value() {
					for (var _len = arguments.length, alternatives = Array(_len), _key = 0; _key < _len; _key++) {
						alternatives[_key] = arguments[_key];
					}
		
					var _iteratorNormalCompletion7 = true;
					var _didIteratorError7 = false;
					var _iteratorError7 = undefined;
		
					try {
		
						for (var _iterator7 = alternatives[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
							var _step7$value = _slicedToArray(_step7.value, 2);
		
							var guard = _step7$value[0];
							var value = _step7$value[1];
		
							if (_isFunction2.default.call(guard) ? guard() : guard) {
								if (_isUndefined2.default.call(value)) {
									return;
								}
								var val = _isFunction2.default.call(value) ? value() : value;
								if (this.constructor.isEqual(this[_symbols.$$value], val)) {
									return;
								}
								this.validate(val, ['initialize', 'set']);
								this.set(val, {
									ignoreReadonly: true,
									ignoreValidation: true,
									updatePristine: true
								});
								return;
							}
						}
					} catch (err) {
						_didIteratorError7 = true;
						_iteratorError7 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion7 && _iterator7.return) {
								_iterator7.return();
							}
						} finally {
							if (_didIteratorError7) {
								throw _iteratorError7;
							}
						}
					}
				}
			}, {
				key: 'isInvalid',
				value: function isInvalid(val) {
					try {
						var valueToValidate = _isUndefined2.default.call(val) ? this[_symbols.$$value] : val;
						this.validate(valueToValidate, ['set', 'commit']);
						return false;
					} catch (err) {
						return err;
					}
				}
			}, {
				key: 'validate',
				value: function validate(val) {
					var stages = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
				}
			}, {
				key: 'commit',
				value: function () {
					var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
						return regeneratorRuntime.wrap(function _callee$(_context2) {
							while (1) {
								switch (_context2.prev = _context2.next) {
									case 0:
										this.validate(this[_symbols.$$value], ['commit']);
										this[_symbols.$$pristine] = this[_symbols.$$value];
										this.pSubject('isPristine').next(true);
		
									case 3:
									case 'end':
										return _context2.stop();
								}
							}
						}, _callee, this);
					}));
		
					function commit() {
						return _ref3.apply(this, arguments);
					}
		
					return commit;
				}()
			}, {
				key: 'rollback',
				value: function rollback() {
					this.set(this[_symbols.$$pristine]);
				}
			}]);
		
			return Field;
		}(_ValueTracker3.default), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'commitEvent', [_dec], {
			enumerable: true,
			initializer: null
		}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'rollbackEvent', [_dec2], {
			enumerable: true,
			initializer: null
		}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, 'isPristine', [_dec3], {
			enumerable: true,
			initializer: null
		}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, 'value', [_dec4], {
			enumerable: true,
			initializer: null
		})), _class));
		var RelField = exports.RelField = (_dec5 = (0, _ValueTracker2.property)({ readonly: true }), (_class3 = function (_Field) {
			_inherits(RelField, _Field);
		
			//////////////
			// instance //
			//////////////
		
			function RelField(options) {
				_classCallCheck(this, RelField);
		
				var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(RelField).call(this, options));
		
				_initDefineProp(_this2, 'possibleValues', _descriptor5, _this2);
		
				var desc = options.desc;
		
				/* manage the 'possibleValues' property */
		
				desc.codomain.resourceClass.p('all').subscribe(_this2.pSubject('possibleValues'));
				return _this2;
			}
		
			return RelField;
		}(Field), (_descriptor5 = _applyDecoratedDescriptor(_class3.prototype, 'possibleValues', [_dec5], {
			enumerable: true,
			initializer: null
		})), _class3));
	
	/***/ },
	/* 26 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		var $$registerFieldClass = exports.$$registerFieldClass = Symbol('$$registerFieldClass');
		var $$fieldClasses = exports.$$fieldClasses = Symbol('$$fieldClasses');
		var $$owner = exports.$$owner = Symbol('$$owner');
		var $$key = exports.$$key = Symbol('$$key');
		var $$desc = exports.$$desc = Symbol('$$key');
		var $$value = exports.$$value = Symbol('$$value');
		var $$pristine = exports.$$pristine = Symbol('$$pristine');
		var $$initSet = exports.$$initSet = Symbol('$$initSet');
		var $$entriesIn = exports.$$entriesIn = Symbol('$$entriesIn');
		var $$initialized = exports.$$initialized = Symbol('$$initialized');
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _templateObject = _taggedTemplateLiteral(['\n\t\t\t\t\tA type must be created with its definition\n\t\t\t\t\timmediately.\n\t\t\t\t'], ['\n\t\t\t\t\tA type must be created with its definition\n\t\t\t\t\timmediately.\n\t\t\t\t']);
		
		var _schemas = __webpack_require__(32);
		
		var _Module = __webpack_require__(46);
		
		var _Module2 = _interopRequireDefault(_Module);
		
		var _resources = __webpack_require__(16);
		
		var _resources2 = _interopRequireDefault(_resources);
		
		var _misc = __webpack_require__(3);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		exports.default = _Module2.default.create('typed', [_resources2.default], function (M, _ref) {
			var Resource = _ref.Resource;
			var IsRelatedTo = _ref.IsRelatedTo;
		
		
			var Type = M.RESOURCE({ ///////////////////////////////////////////////////
		
				name: 'Type',
		
				extends: Resource,
		
				singular: "type",
		
				behavior: {
					new: function _new(vals, options) {
						var sc = vals.definition;
						var rel = vals['<--DefinesType'];
		
						(0, _misc.constraint)(Template.hasInstance(sc) || DefinesType.hasInstance(rel), (0, _misc.humanMsg)(_templateObject));
						if (rel) {
							sc = rel[1];
						}
						return sc.constructor.Type.new(vals, options);
					}
				}
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var IsSubtypeOf = M.RELATIONSHIP({
		
				name: 'IsSubtypeOf',
		
				extends: IsRelatedTo,
		
				singular: "is subtype of",
		
				1: [Type, '0..*', { key: 'subtypes' }],
				2: [Type, '0..*', { anchors: true, key: 'supertypes' }],
		
				noCycles: true
		
			});
		
			var Template = M.RESOURCE({ ///////////////////////////////////////////////
		
				name: 'Template',
		
				abstract: true,
		
				extends: Resource,
		
				singular: "template",
		
				properties: {
					'cardinalityBase': {
						oneOf: [_extends({}, _schemas.distributionSchema), { type: 'integer', minimum: 1 }],
						default: 1
					},
					'species': {
						type: 'string',
						isRefinement: function isRefinement(a, b) {
							return !a || a === b;
						}
					}
				}
		
			}); /////////////////////////////////////////////////////////////////////////
		
			_misc.definePropertyByValue.call(Template, 'Type', Type);
			_misc.definePropertyByValue.call(Type, 'Template', Template);
		
			var HasCardinalityMultipliedByThatOf = M.RELATIONSHIP({
		
				name: 'HasCardinalityMultipliedByThatOf',
		
				extends: IsRelatedTo,
		
				singular: "has cardinality multiplied by that of",
		
				1: [Template, '0..*', { anchors: true, key: 'cardinalityMultipliers' }],
				2: [Template, '0..*'],
		
				noCycles: true
		
			});
		
			var HasType = M.RELATIONSHIP({
		
				name: 'HasType',
		
				extends: IsRelatedTo,
		
				singular: "has type",
		
				1: [Template, '0..*', { anchors: true, key: 'types' }],
				2: [Type, '0..*']
		
			});
		
			var DefinesType = M.RELATIONSHIP({
		
				name: 'DefinesType',
		
				extends: HasType,
		
				singular: "defines type",
		
				1: [Template, '0..1', { anchors: true }],
				2: [Type, '1..1', { anchors: true, key: 'definition' }]
		
			});
		
			var PullsIntoTypeDefinition = M.RELATIONSHIP({
		
				name: 'PullsIntoTypeDefinition',
		
				abstract: true,
		
				extends: IsRelatedTo,
		
				singular: "pulls into type definition",
				plural: "pull into type definition",
		
				1: [Template, '0..*'],
				2: [Template, '0..*']
		
			});
		
			var Has = M.RELATIONSHIP({
		
				name: 'Has',
		
				abstract: true,
		
				extends: PullsIntoTypeDefinition,
		
				singular: "has",
				plural: "have",
		
				1: [Template, '0..*', { anchors: true, key: 'children' }],
				2: [Template, '0..1', { key: 'parent' }],
		
				noCycles: true
		
			});
		});
	
	/***/ },
	/* 28 */,
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Subscriber_1 = __webpack_require__(13);
		/**
		 * Filter items emitted by the source Observable by only emitting those that
		 * satisfy a specified predicate.
		 *
		 * <span class="informal">Like
		 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
		 * it only emits a value from the source if it passes a criterion function.</span>
		 *
		 * <img src="./img/filter.png" width="100%">
		 *
		 * Similar to the well-known `Array.prototype.filter` method, this operator
		 * takes values from the source Observable, passes them through a `predicate`
		 * function and only emits those values that yielded `true`.
		 *
		 * @example <caption>Emit only click events whose target was a DIV element</caption>
		 * var clicks = Rx.Observable.fromEvent(document, 'click');
		 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
		 * clicksOnDivs.subscribe(x => console.log(x));
		 *
		 * @see {@link distinct}
		 * @see {@link distinctKey}
		 * @see {@link distinctUntilChanged}
		 * @see {@link distinctUntilKeyChanged}
		 * @see {@link ignoreElements}
		 * @see {@link partition}
		 * @see {@link skip}
		 *
		 * @param {function(value: T, index: number): boolean} predicate A function that
		 * evaluates each value emitted by the source Observable. If it returns `true`,
		 * the value is emitted, if `false` the value is not passed to the output
		 * Observable. The `index` parameter is the number `i` for the i-th source
		 * emission that has happened since the subscription, starting from the number
		 * `0`.
		 * @param {any} [thisArg] An optional argument to determine the value of `this`
		 * in the `predicate` function.
		 * @return {Observable} An Observable of values from the source that were
		 * allowed by the `predicate` function.
		 * @method filter
		 * @owner Observable
		 */
		function filter(predicate, thisArg) {
		    return this.lift(new FilterOperator(predicate, thisArg));
		}
		exports.filter = filter;
		var FilterOperator = (function () {
		    function FilterOperator(predicate, thisArg) {
		        this.predicate = predicate;
		        this.thisArg = thisArg;
		    }
		    FilterOperator.prototype.call = function (subscriber, source) {
		        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
		    };
		    return FilterOperator;
		}());
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var FilterSubscriber = (function (_super) {
		    __extends(FilterSubscriber, _super);
		    function FilterSubscriber(destination, predicate, thisArg) {
		        _super.call(this, destination);
		        this.predicate = predicate;
		        this.thisArg = thisArg;
		        this.count = 0;
		        this.predicate = predicate;
		    }
		    // the try catch block below is left specifically for
		    // optimization and perf reasons. a tryCatcher is not necessary here.
		    FilterSubscriber.prototype._next = function (value) {
		        var result;
		        try {
		            result = this.predicate.call(this.thisArg, value, this.count++);
		        }
		        catch (err) {
		            this.destination.error(err);
		            return;
		        }
		        if (result) {
		            this.destination.next(value);
		        }
		    };
		    return FilterSubscriber;
		}(Subscriber_1.Subscriber));
		//# sourceMappingURL=filter.js.map
	
	/***/ },
	/* 30 */,
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.default = undefined;
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _Module2 = __webpack_require__(46);
		
		var _Module3 = _interopRequireDefault(_Module2);
		
		var _misc = __webpack_require__(3);
		
		var _defaults = __webpack_require__(71);
		
		var _defaults2 = _interopRequireDefault(_defaults);
		
		var _mapValues = __webpack_require__(262);
		
		var _mapValues2 = _interopRequireDefault(_mapValues);
		
		var _omitBy = __webpack_require__(264);
		
		var _omitBy2 = _interopRequireDefault(_omitBy);
		
		var _map = __webpack_require__(106);
		
		var _map2 = _interopRequireDefault(_map);
		
		var _memoize = __webpack_require__(174);
		
		var _memoize2 = _interopRequireDefault(_memoize);
		
		var _boundNativeMethods = __webpack_require__(10);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		/**
		 * Typed Modules allow to more easily create related
		 * Type, Template and HasType classes. For example,
		 * to create LyphType and LyphTemplate resources and
		 * their HasType relationship from one description.
		 **/
		var TypedModule = function (_Module) {
			_inherits(TypedModule, _Module);
		
			function TypedModule() {
				_classCallCheck(this, TypedModule);
		
				return _possibleConstructorReturn(this, Object.getPrototypeOf(TypedModule).apply(this, arguments));
			}
		
			_createClass(TypedModule, [{
				key: 'TYPED_RESOURCE',
				value: function TYPED_RESOURCE(config) {
					var _this2 = this;
		
					return (0, _misc.mapOptionalArray)(config, function (conf) {
		
						_this2.basicNormalization(conf);
		
						var superClasses = (0, _misc.wrapInArray)(conf.extends || [_this2.classes.vertexValue('Template')]);
						var subClasses = (0, _misc.wrapInArray)(conf.extendedBy || []);
		
						/* handling properties */
						_defaults2.default.call(conf, {
							properties: {},
							patternProperties: {}
						});
		
						/* Template class */
						var NewTemplateClass = _this2.RESOURCE({
		
							name: conf.name,
		
							extends: superClasses,
							extendedBy: subClasses,
		
							singular: conf.singular,
		
							properties: conf.properties,
							patternProperties: conf.patternProperties,
		
							behavior: conf.behavior
		
						});
		
						/* Type class */
						var NewTypeClass = _this2.RESOURCE({
		
							name: conf.name + 'Type',
		
							extends: _map2.default.call(superClasses, function (c) {
								return c.Type;
							}),
							extendedBy: _map2.default.call(subClasses, function (c) {
								return c.Type;
							}),
		
							singular: conf.singular + ' type',
		
							notExported: true
		
						});
		
						_misc.definePropertyByValue.call(NewTemplateClass, 'Type', NewTypeClass);
						_misc.definePropertyByValue.call(NewTypeClass, 'Template', NewTemplateClass);
		
						_this2.RELATIONSHIP({
		
							name: 'HasType',
		
							1: [NewTemplateClass, '0..*', { anchors: true, key: 'types' }],
							2: [NewTypeClass, '0..*']
		
						});
		
						_this2.RELATIONSHIP({
		
							name: 'DefinesType',
		
							1: [NewTemplateClass, '0..1', { anchors: true }],
							2: [NewTypeClass, '1..1', { anchors: true, key: 'definition' }]
		
						});
		
						/* register and return */
						return NewTemplateClass;
					});
				}
			}]);
		
			return TypedModule;
		}(_Module3.default);
		
		exports.default = TypedModule;
	
	/***/ },
	/* 32 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		var identifierRegex = exports.identifierRegex = '^[a-zA-Z_][a-zA-Z0-9_]*$';
		
		var qualitySchema = exports.qualitySchema = {
			type: 'string'
		};
		
		var identifierSchema = exports.identifierSchema = {
			type: 'string',
			pattern: '^[a-zA-Z_][a-zA-Z0-9_]*$'
		};
		
		var uriSchema = exports.uriSchema = {
			type: 'string',
			format: 'uri'
		};
		
		var idSchema = exports.idSchema = {
			type: 'integer'
		};
		
		var enumSchema = exports.enumSchema = function enumSchema() {
			for (var _len = arguments.length, candidates = Array(_len), _key = 0; _key < _len; _key++) {
				candidates[_key] = arguments[_key];
			}
		
			return {
				type: 'string',
				enum: candidates
			};
		};
		
		var enumArraySchema = exports.enumArraySchema = function enumArraySchema() {
			return {
				type: 'array',
				items: _extends({}, enumSchema.apply(undefined, arguments)),
				uniqueItems: true,
				maxItems: arguments.length
			};
		};
		
		var minusPlusSchema = exports.minusPlusSchema = enumSchema('minus', 'plus');
		
		var innerOuterSchema = exports.innerOuterSchema = enumSchema('inner', 'outer');
		
		var lyphDirectionSchema = exports.lyphDirectionSchema = enumSchema.apply(undefined, _toConsumableArray(minusPlusSchema.enum).concat(_toConsumableArray(innerOuterSchema.enum)));
		
		var oneOf = exports.oneOf = function oneOf() {
			for (var _len2 = arguments.length, schemas = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				schemas[_key2] = arguments[_key2];
			}
		
			return { oneOf: schemas };
		};
		
		var rationalNumberSchema = exports.rationalNumberSchema = oneOf({
			// TODO: specify format (https://github.com/infusion/Fraction.js)
			type: 'object',
			properties: {
				'n': { type: 'integer', minimum: 0, required: true }, // numerator
				'd': { type: 'integer', minimum: 1, default: 1, required: true }, // denominator
				's': { type: 'integer', enum: [-1, 1], default: 1, required: true } // sign
			}
		}, { type: 'number' }, { type: 'string' });
		
		var angleSchema = exports.angleSchema = {
			type: 'number',
			minimum: 0, exclusiveMinimum: false,
			maximum: 360, exclusiveMaximum: true
		};
		
		var rangeSchema = exports.rangeSchema = {
			type: 'object',
			properties: {
				'min': { type: 'number', required: true },
				'max': { type: 'number', required: true }
			}
		};
		
		var universalDistanceRange = exports.universalDistanceRange = {
			'min': 0,
			'max': Infinity
		};
		
		var normalDistributionSchema = exports.normalDistributionSchema = {
			type: 'object',
			properties: {
				'distribution': { value: 'normal' },
				'mean': { type: 'number', required: true },
				'std': { type: 'number', required: true }
			}
		};
		
		var boundedNormalDistributionSchema = exports.boundedNormalDistributionSchema = {
			type: 'object',
			properties: {
				'distribution': { value: 'bounded-normal' },
				'mean': { type: 'number', required: true },
				'std': { type: 'number', required: true },
				'min': { type: 'number', required: true },
				'max': { type: 'number', required: true }
			}
		};
		
		var uniformDistributionSchema = exports.uniformDistributionSchema = {
			type: 'object',
			properties: {
				'distribution': { value: 'uniform' },
				'min': { type: 'number', required: true },
				'max': { type: 'number', required: true }
			}
		};
		
		var distributionSchema = exports.distributionSchema = {
			oneOf: [_extends({}, normalDistributionSchema), _extends({}, boundedNormalDistributionSchema), _extends({}, uniformDistributionSchema)]
		};
		
		var distributionSchemaOr = exports.distributionSchemaOr = function distributionSchemaOr(otherSchema) {
			return {
				oneOf: [boundedNormalDistributionSchema, uniformDistributionSchema, otherSchema]
			};
		};
		
		var dimensionalitySchema = exports.dimensionalitySchema = {
			type: 'object',
			patternProperties: {
				'[a-zA-Z0-9 ]+': { type: 'integer' }
			}
		};
	
	/***/ },
	/* 33 */,
	/* 34 */,
	/* 35 */,
	/* 36 */,
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(392);
		
		module.exports = function isUndefined() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {
	
		var apply = __webpack_require__(153);
		
		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeMax = Math.max;
		
		/**
		 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
		 *
		 * @private
		 * @param {Function} func The function to apply a rest parameter to.
		 * @param {number} [start=func.length-1] The start position of the rest parameter.
		 * @returns {Function} Returns the new function.
		 */
		function baseRest(func, start) {
		  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
		  return function() {
		    var args = arguments,
		        index = -1,
		        length = nativeMax(args.length - start, 0),
		        array = Array(length);
		
		    while (++index < length) {
		      array[index] = args[start + index];
		    }
		    index = -1;
		    var otherArgs = Array(start + 1);
		    while (++index < start) {
		      otherArgs[index] = args[index];
		    }
		    otherArgs[start] = array;
		    return apply(func, this, otherArgs);
		  };
		}
		
		module.exports = baseRest;
	
	
	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIsNative = __webpack_require__(298),
		    getValue = __webpack_require__(337);
		
		/**
		 * Gets the native function at `key` of `object`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @param {string} key The key of the method to get.
		 * @returns {*} Returns the function if it's native, else `undefined`.
		 */
		function getNative(object, key) {
		  var value = getValue(object, key);
		  return baseIsNative(value) ? value : undefined;
		}
		
		module.exports = getNative;
	
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isSymbol = __webpack_require__(58);
		
		/** Used as references for various `Number` constants. */
		var INFINITY = 1 / 0;
		
		/**
		 * Converts `value` to a string key if it's not a string or symbol.
		 *
		 * @private
		 * @param {*} value The value to inspect.
		 * @returns {string|symbol} Returns the key.
		 */
		function toKey(value) {
		  if (typeof value == 'string' || isSymbol(value)) {
		    return value;
		  }
		  var result = (value + '');
		  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		}
		
		module.exports = toKey;
	
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Subscriber_1 = __webpack_require__(13);
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var OuterSubscriber = (function (_super) {
		    __extends(OuterSubscriber, _super);
		    function OuterSubscriber() {
		        _super.apply(this, arguments);
		    }
		    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
		        this.destination.next(innerValue);
		    };
		    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
		        this.destination.error(error);
		    };
		    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
		        this.destination.complete();
		    };
		    return OuterSubscriber;
		}(Subscriber_1.Subscriber));
		exports.OuterSubscriber = OuterSubscriber;
		//# sourceMappingURL=OuterSubscriber.js.map
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Subscriber_1 = __webpack_require__(13);
		/**
		 * Applies a given `project` function to each value emitted by the source
		 * Observable, and emits the resulting values as an Observable.
		 *
		 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
		 * it passes each source value through a transformation function to get
		 * corresponding output values.</span>
		 *
		 * <img src="./img/map.png" width="100%">
		 *
		 * Similar to the well known `Array.prototype.map` function, this operator
		 * applies a projection to each value and emits that projection in the output
		 * Observable.
		 *
		 * @example <caption>Map every every click to the clientX position of that click</caption>
		 * var clicks = Rx.Observable.fromEvent(document, 'click');
		 * var positions = clicks.map(ev => ev.clientX);
		 * positions.subscribe(x => console.log(x));
		 *
		 * @see {@link mapTo}
		 * @see {@link pluck}
		 *
		 * @param {function(value: T, index: number): R} project The function to apply
		 * to each `value` emitted by the source Observable. The `index` parameter is
		 * the number `i` for the i-th emission that has happened since the
		 * subscription, starting from the number `0`.
		 * @param {any} [thisArg] An optional argument to define what `this` is in the
		 * `project` function.
		 * @return {Observable<R>} An Observable that emits the values from the source
		 * Observable transformed by the given `project` function.
		 * @method map
		 * @owner Observable
		 */
		function map(project, thisArg) {
		    if (typeof project !== 'function') {
		        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
		    }
		    return this.lift(new MapOperator(project, thisArg));
		}
		exports.map = map;
		var MapOperator = (function () {
		    function MapOperator(project, thisArg) {
		        this.project = project;
		        this.thisArg = thisArg;
		    }
		    MapOperator.prototype.call = function (subscriber, source) {
		        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
		    };
		    return MapOperator;
		}());
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var MapSubscriber = (function (_super) {
		    __extends(MapSubscriber, _super);
		    function MapSubscriber(destination, project, thisArg) {
		        _super.call(this, destination);
		        this.project = project;
		        this.count = 0;
		        this.thisArg = thisArg || this;
		    }
		    // NOTE: This looks unoptimized, but it's actually purposefully NOT
		    // using try/catch optimizations.
		    MapSubscriber.prototype._next = function (value) {
		        var result;
		        try {
		            result = this.project.call(this.thisArg, value, this.count++);
		        }
		        catch (err) {
		            this.destination.error(err);
		            return;
		        }
		        this.destination.next(result);
		    };
		    return MapSubscriber;
		}(Subscriber_1.Subscriber));
		//# sourceMappingURL=map.js.map
	
	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var root_1 = __webpack_require__(89);
		var isArray_1 = __webpack_require__(88);
		var isPromise_1 = __webpack_require__(431);
		var Observable_1 = __webpack_require__(22);
		var iterator_1 = __webpack_require__(427);
		var InnerSubscriber_1 = __webpack_require__(413);
		var symbol_observable_1 = __webpack_require__(191);
		function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
		    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
		    if (destination.isUnsubscribed) {
		        return;
		    }
		    if (result instanceof Observable_1.Observable) {
		        if (result._isScalar) {
		            destination.next(result.value);
		            destination.complete();
		            return;
		        }
		        else {
		            return result.subscribe(destination);
		        }
		    }
		    if (isArray_1.isArray(result)) {
		        for (var i = 0, len = result.length; i < len && !destination.isUnsubscribed; i++) {
		            destination.next(result[i]);
		        }
		        if (!destination.isUnsubscribed) {
		            destination.complete();
		        }
		    }
		    else if (isPromise_1.isPromise(result)) {
		        result.then(function (value) {
		            if (!destination.isUnsubscribed) {
		                destination.next(value);
		                destination.complete();
		            }
		        }, function (err) { return destination.error(err); })
		            .then(null, function (err) {
		            // Escaping the Promise trap: globally throw unhandled errors
		            root_1.root.setTimeout(function () { throw err; });
		        });
		        return destination;
		    }
		    else if (typeof result[iterator_1.$$iterator] === 'function') {
		        for (var _i = 0, _a = result; _i < _a.length; _i++) {
		            var item = _a[_i];
		            destination.next(item);
		            if (destination.isUnsubscribed) {
		                break;
		            }
		        }
		        if (!destination.isUnsubscribed) {
		            destination.complete();
		        }
		    }
		    else if (typeof result[symbol_observable_1.default] === 'function') {
		        var obs = result[symbol_observable_1.default]();
		        if (typeof obs.subscribe !== 'function') {
		            destination.error('invalid observable');
		        }
		        else {
		            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
		        }
		    }
		    else {
		        destination.error(new TypeError('unknown type returned'));
		    }
		}
		exports.subscribeToResult = subscribeToResult;
		//# sourceMappingURL=subscribeToResult.js.map
	
	/***/ },
	/* 44 */,
	/* 45 */,
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.default = undefined;
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _templateObject = _taggedTemplateLiteral(['\n\t\t\t\t\t\t\t', '\n\t\t\t\t\t\t\t(', ')\n\t\t\t\t\t\t\t', '\n\t\t\t\t\t\t'], ['\n\t\t\t\t\t\t\t', '\n\t\t\t\t\t\t\t(', ')\n\t\t\t\t\t\t\t', '\n\t\t\t\t\t\t']),
		    _templateObject2 = _taggedTemplateLiteral(['\n\t\t\t\tA subclass cycle has been introduced while registering\n\t\t\t\tthe ', ' class:\n\t\t\t\t', '.\n\t\t\t'], ['\n\t\t\t\tA subclass cycle has been introduced while registering\n\t\t\t\tthe ', ' class:\n\t\t\t\t', '.\n\t\t\t']),
		    _templateObject3 = _taggedTemplateLiteral(['\n\t\t\t\t\t\t\tCannot merge ', '.', ' = ', '\n\t\t\t\t\t\t\t        with ', '.\n\t\t\t\t\t\t'], ['\n\t\t\t\t\t\t\tCannot merge ', '.', ' = ', '\n\t\t\t\t\t\t\t        with ', '.\n\t\t\t\t\t\t']);
		
		var _isUndefined = __webpack_require__(37);
		
		var _isUndefined2 = _interopRequireDefault(_isUndefined);
		
		var _isInteger = __webpack_require__(258);
		
		var _isInteger2 = _interopRequireDefault(_isInteger);
		
		var _defaults = __webpack_require__(71);
		
		var _defaults2 = _interopRequireDefault(_defaults);
		
		var _assignWith = __webpack_require__(252);
		
		var _assignWith2 = _interopRequireDefault(_assignWith);
		
		var _keys = __webpack_require__(149);
		
		var _keys2 = _interopRequireDefault(_keys);
		
		var _values = __webpack_require__(108);
		
		var _values2 = _interopRequireDefault(_values);
		
		var _entries = __webpack_require__(17);
		
		var _entries2 = _interopRequireDefault(_entries);
		
		var _fromPairs = __webpack_require__(256);
		
		var _fromPairs2 = _interopRequireDefault(_fromPairs);
		
		var _map = __webpack_require__(106);
		
		var _map2 = _interopRequireDefault(_map);
		
		var _at = __webpack_require__(253);
		
		var _at2 = _interopRequireDefault(_at);
		
		var _uniq = __webpack_require__(269);
		
		var _uniq2 = _interopRequireDefault(_uniq);
		
		var _flatten = __webpack_require__(255);
		
		var _flatten2 = _interopRequireDefault(_flatten);
		
		var _isEqual2 = __webpack_require__(172);
		
		var _isEqual3 = _interopRequireDefault(_isEqual2);
		
		var _graph = __webpack_require__(143);
		
		var _graph2 = _interopRequireDefault(_graph);
		
		var _boundNativeMethods = __webpack_require__(10);
		
		var _misc = __webpack_require__(3);
		
		var _Entity = __webpack_require__(204);
		
		var _Entity2 = _interopRequireDefault(_Entity);
		
		var _fields = __webpack_require__(138);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var $$processedFor = Symbol('$$processedFor');
		var $$relationshipSpecs = Symbol('$$relationshipSpecs');
		var $$relevantDomains = Symbol('$$relevantDomains');
		var $$processRelationshipDomain = Symbol('$$processRelationshipDomain');
		
		////////////////////////////////////////////////////////////////////////////////
		// Module / Resource / Relationship Factory                                   //
		////////////////////////////////////////////////////////////////////////////////
		
		// TODO: folding same-name classes
		// TODO: folding properties into subclasses
		// TODO: folding multiple 1,2 pairs into same-name relationships and subclass relationships
		
		
		var Module = function () {
			_createClass(Module, null, [{
				key: 'create',
				value: function create(name, dependencies, fn) {
					var _this = this;
		
					var moduleFactory = function moduleFactory() {
						var memory = arguments.length <= 0 || arguments[0] === undefined ? {
							modules: new Map(),
							classes: new _graph2.default()
						} : arguments[0];
		
						if (!memory.modules.has(name)) {
							var module = new _this(name, dependencies.map(function (m) {
								return m(memory);
							}), memory.classes);
							memory.modules.set(name, module);
							if (fn) {
								var _context;
		
								fn(module, (_context = [].concat(_toConsumableArray(module.classes.vertices())), _fromPairs2.default).call(_context));
							}
						}
						return memory.modules.get(name);
					};
					return moduleFactory;
				}
			}]);
		
			// vertices: name                   -> class
			// edges:    [superclass, subclass] -> undefined
		
			function Module(name) {
				var dependencies = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
				var graph = arguments.length <= 2 || arguments[2] === undefined ? new _graph2.default() : arguments[2];
		
				_classCallCheck(this, Module);
		
				/* set storage graph */
				this.classes = graph;
		
				/* store the module name */
				this.name = name;
			}
		
			_createClass(Module, [{
				key: 'OBJECT',
				value: function OBJECT(config) {
					var _this2 = this;
		
					return (0, _misc.mapOptionalArray)(config, function (conf) {
						conf.module = _this2;
						_this2.basicNormalization(conf);
						_this2.register(conf);
						return conf;
					});
				}
			}, {
				key: 'RESOURCE',
				value: function RESOURCE(config) {
					var _this3 = this;
		
					return (0, _misc.mapOptionalArray)(config, function (conf) {
						conf.isResource = true;
						conf.module = _this3;
						_this3.basicNormalization(conf);
						var constructor = _this3.mergeSameNameResources(_Entity2.default.createClass(conf));
						_this3.register(constructor);
						_this3.mergeSuperclassFields(constructor);
						// jsonSchemaConfig                          (constructor             ); // TODO
						_fields.Field.augmentClass(constructor);
						return constructor;
					});
				}
			}, {
				key: 'RELATIONSHIP',
				value: function RELATIONSHIP(config) {
					var _this4 = this;
		
					return (0, _misc.mapOptionalArray)(config, function (conf) {
						conf.isRelationship = true;
						conf.module = _this4;
						_this4.basicNormalization(conf);
						var constructor = _Entity2.default.createClass(conf);
						_this4.normalizeRelationshipSides(constructor);
						constructor = _this4.mergeSameNameRelationships(constructor);
						_this4.register(constructor);
						_this4.mergeSuperclassFields(constructor);
						// jsonSchemaConfig                          (constructor); // TODO
						_this4.resolveRelationshipDomains(constructor);
						_fields.Field.augmentClass(constructor);
						return constructor;
					});
				}
		
				////////////////////////////////////////////////////////////////////////////
		
			}, {
				key: 'basicNormalization',
				value: function basicNormalization(config) {
					/* normalizing grammar stuff */
					if (config.singular && !config.plural) {
						if (config.isResource) {
							config.plural = config.singular + 's';
						} else {
							var match = config.singular.match(/^(.+)s$/);
							if (match) {
								config.plural = match[1];
							}
						}
					}
		
					_defaults2.default.call(config, {
						behavior: {}
					});
		
					if (config.isResource) {
						_defaults2.default.call(config, {
							relationships: {},
							relationshipShortcuts: {}
						});
					}
		
					/* normalizing extends/extendedBy */
					var _arr = ['extends', 'extendedBy'];
					for (var _i = 0; _i < _arr.length; _i++) {
						var key = _arr[_i];
						_defaults2.default.call(config, _defineProperty({}, key, []));
						config[key] = new Set((0, _misc.wrapInArray)(config[key]));
					}
		
					/* normalize properties */
					var _arr2 = [['properties', 'key'], ['patternProperties', 'pattern']];
					for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
						var _arr2$_i = _slicedToArray(_arr2[_i2], 2);
		
						var pKey = _arr2$_i[0];
						var kKey = _arr2$_i[1];
		
						_defaults2.default.call(config, _defineProperty({}, pKey, {}));
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;
		
						try {
							for (var _iterator = (_context2 = config[pKey], _entries2.default).call(_context2)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var _context2;
		
								var _step$value = _slicedToArray(_step.value, 2);
		
								var k = _step$value[0];
								var desc = _step$value[1];
		
								desc[kKey] = k;
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator.return) {
									_iterator.return();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
					}
		
					/* sanity checks */
					var _arr3 = ['extends', 'extendedBy'];
					for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
						var _key = _arr3[_i3];var _iteratorNormalCompletion2 = true;
						var _didIteratorError2 = false;
						var _iteratorError2 = undefined;
		
						try {
							for (var _iterator2 = config[_key][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
								var other = _step2.value;
							}
						} catch (err) {
							_didIteratorError2 = true;
							_iteratorError2 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion2 && _iterator2.return) {
									_iterator2.return();
								}
							} finally {
								if (_didIteratorError2) {
									throw _iteratorError2;
								}
							}
						}
					}
				}
			}, {
				key: 'normalizeRelationshipSides',
				value: function normalizeRelationshipSides(cls) {
		
					/* normalize domainPairs array */
					if (!cls.domainPairs) {
						cls.domainPairs = [];
					}
					// - 1 is left-hand side, and
					// - 2 is right-hand side of the relationship;
					// these can be given directly, or multiple
					// can be grouped in a 'domainPairs' array;
					// here, we'll normalize them into a 'domainPairs' array
		
					if (cls[1] && cls[2]) {
						var _cls$domainPairs$push;
		
						cls.domainPairs.push((_cls$domainPairs$push = {}, _defineProperty(_cls$domainPairs$push, 1, cls[1]), _defineProperty(_cls$domainPairs$push, 2, cls[2]), _cls$domainPairs$push));
					}
		
					/* indices for shorthand array notation and side keys */
					var CLASS = 0,
					    CARDINALITY = 1,
					    OPTIONS = 2;
		
					/* normalizing all domainPairs */
					cls.keyInResource = {
						1: '-->' + cls.name,
						2: '<--' + cls.name
					};
					cls.domainPairs = cls.domainPairs.map(function (givenDomainPair) {
						var _pair;
		
						var pair = (_pair = {}, _defineProperty(_pair, 1, {}), _defineProperty(_pair, 2, {}), _pair);
						var _arr4 = [[[1, pair[1]], [2, pair[2]]], [[2, pair[2]], [1, pair[1]]]];
						for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
							var _arr4$_i = _slicedToArray(_arr4[_i4], 2);
		
							var _arr4$_i$ = _slicedToArray(_arr4$_i[0], 2);
		
							var domainKey = _arr4$_i$[0];
							var domain = _arr4$_i$[1];
		
							var _arr4$_i$2 = _slicedToArray(_arr4$_i[1], 2);
		
							var codomainKey = _arr4$_i$2[0];
							var codomain = _arr4$_i$2[1];
		
							var _givenDomainPair$doma = _slicedToArray(givenDomainPair[domainKey], 3);
		
							var resourceClass = _givenDomainPair$doma[0];
							var cardinality = _givenDomainPair$doma[1];
							var _givenDomainPair$doma2 = _givenDomainPair$doma[2];
							var options = _givenDomainPair$doma2 === undefined ? {} : _givenDomainPair$doma2;
		
							_misc.definePropertiesByValue.call(domain, {
								codomain: codomain,
		
								relationshipClass: cls,
								keyInRelationship: domainKey,
		
								resourceClass: resourceClass,
								keyInResource: cls.keyInResource[domainKey],
		
								cardinality: (0, _misc.parseCardinality)(cardinality),
								options: options,
		
								shortcutKey: options.key
							});
							_boundNativeMethods.defineProperty.call(domain, Symbol.toStringTag, {
								get: function get() {
									return (0, _misc.humanMsg)(_templateObject, this.resourceClass.name, this.keyInResource, this.codomain.resourceClass.name);
								}
							});
						}
						return pair;
					});
					delete cls[1];
					delete cls[2];
				}
			}, {
				key: 'resolveRelationshipDomains',
				value: function resolveRelationshipDomains(cls) {
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;
		
					try {
						for (var _iterator3 = cls.domainPairs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var domainPair = _step3.value;
							var _iteratorNormalCompletion4 = true;
							var _didIteratorError4 = false;
							var _iteratorError4 = undefined;
		
							try {
								for (var _iterator4 = _values2.default.call(domainPair)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
									var domain = _step4.value;
		
									this[$$processRelationshipDomain](domain);
								}
							} catch (err) {
								_didIteratorError4 = true;
								_iteratorError4 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion4 && _iterator4.return) {
										_iterator4.return();
									}
								} finally {
									if (_didIteratorError4) {
										throw _iteratorError4;
									}
								}
							}
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
				}
			}, {
				key: $$processRelationshipDomain,
				value: function value(referenceDomain) {
					var resourceClass = referenceDomain.resourceClass;
					var relationshipClass = referenceDomain.relationshipClass;
					var keyInRelationship = referenceDomain.keyInRelationship;
					var keyInResource = referenceDomain.keyInResource;
					var shortcutKey = referenceDomain.shortcutKey;
		
					// const relSinks = relationshipClass::(function findSinks() {
					// 	if (this.extendedBy::size() === 0) { return [this] }
					// 	return union(...[...this.extendedBy].map(c => c::findSinks()));
					// })();
					//
					// let hierarchy = new Graph();
					// // ^ In this graph: super --> sub
					//
					// const process = (CurrentRelClass, RelSubclass) => {
					// 	/* find all domains relevant to this resource class + field key combo */
					// 	const relevantDomains = CurrentRelClass[$$relevantDomains] = CurrentRelClass.domainPairs
					// 		::map(keyInRelationship)
					//        ::filter(d => (d.resourceClass).hasSubclass(resourceClass)       ||
					//                      (resourceClass)       .hasSubclass(d.resourceClass) )
					// 		::groupBy('resourceClass.name')
					// 		::_values()
					// 		::map(0); // for now, only using one domain-pair per ResourceClass+RelationshipClass combination
					// 	// TODO: ^ don't use only a[0]; this is just for now, to simplify
					// 	//     :   we still manually have to manually create common superclasses
					// 	//     :   for stuff (examples: MeasurableLocation, NodeLocation)
					//
					// 	/* register domain */
					// 	for (let domain of relevantDomains) {
					// 		hierarchy.addVertex(domain, domain);
					// 	}
					// 	/* register domain ordering by (sub/super) relationship class */
					// 	for (let domain of relevantDomains) {
					// 		if (RelSubclass) {
					// 			for (let subDomain of RelSubclass[$$relevantDomains]) {
					// 				hierarchy.spanEdge(domain, subDomain);
					// 			}
					// 		}
					// 	}
					// 	/* register domain ordering by (sub/super) resource class */
					// 	for (let domain of relevantDomains) {
					// 		for (let otherDomain of relevantDomains::without(domain)) {
					// 			assert(domain.resourceClass !== otherDomain.resourceClass);
					// 			// ^ (because `::groupBy('resourceClass.name')` above)
					// 			if (otherDomain.resourceClass.hasSubclass(domain.resourceClass)) {
					// 				hierarchy.spanEdge(otherDomain, domain);
					// 			}
					// 		}
					// 	}
					// 	/* recurse to relationship superclass */
					// 	for (let RelSuperclass of CurrentRelClass.extends) {
					// 		process(RelSuperclass, CurrentRelClass);
					// 	}
					// };
					// relSinks.forEach(process);
					//
					// hierarchy = hierarchy.transitiveReduction();
		
		
					// TODO: fix bug in the code below (the commented code above already works)
					/* from the graph of relevant domains for this field (domain), craft one specifically for each ResourceClass */
					// let resourceHasField = (resCls) => (!!resCls.properties[referenceDomain.keyInResource]);
					// console.log(this.classes.hasVertex(referenceDomain.resourceClass.name), referenceDomain.resourceClass.name, [...this.classes.vertices()]::map(v=>v[1].name));
					// for (let referenceResource of union(
					// 	[...this.classes.verticesWithPathFrom(referenceDomain.resourceClass.name)]::map(([,r])=>r)::filter(resourceHasField),
					// 	[...this.classes.verticesWithPathTo  (referenceDomain.resourceClass.name)]::map(([,r])=>r)::filter(resourceHasField),
					// 	[referenceDomain.resourceClass]
					// )) {
					// 	let candidateDomains = [...hierarchy.sinks()]::map(([,d])=>d)::(function pinpoint() {
					// 		let result = new Set();
					// 		for (let domain of this) {
					// 			const relationshipFits = (referenceDomain.relationshipClass.hasSubclass(domain.relationshipClass));
					// 			const resourceFits     = (referenceResource                .hasSubclass(domain.resourceClass    ));
					// 			if (relationshipFits && resourceFits) {
					// 				result.add(domain);
					// 			} else {
					// 				for (let superDomain of [...hierarchy.verticesTo(domain)]::map(([,d])=>d)) {
					// 					[superDomain]::pinpoint().forEach(::result.add);
					// 				}
					// 			}
					// 		}
					// 		return result;
					// 	})();
					// }
		
					/* put back-reference in classes */
		
					resourceClass.relationships[keyInResource] = referenceDomain;
					_fields.Field.augmentClass(resourceClass, keyInResource);
					if (shortcutKey) {
						resourceClass.relationshipShortcuts[shortcutKey] = referenceDomain;
						_fields.Field.augmentClass(resourceClass, shortcutKey);
					}
				}
			}, {
				key: 'register',
				value: function register(cls) {
					/* register the class in this module */
					this.classes.ensureVertex(cls.name, cls);
					if (!cls.notExported) {
						this.classes[cls.name] = cls;
					}
		
					/* add subclassing edges and cross-register sub/superclasses */
					var _iteratorNormalCompletion5 = true;
					var _didIteratorError5 = false;
					var _iteratorError5 = undefined;
		
					try {
						for (var _iterator5 = (cls.extends || [])[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
							var extendee = _step5.value;
		
							this.classes.addEdge(extendee.name, cls.name);
							extendee.extendedBy.add(cls);
						}
					} catch (err) {
						_didIteratorError5 = true;
						_iteratorError5 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion5 && _iterator5.return) {
								_iterator5.return();
							}
						} finally {
							if (_didIteratorError5) {
								throw _iteratorError5;
							}
						}
					}
		
					var _iteratorNormalCompletion6 = true;
					var _didIteratorError6 = false;
					var _iteratorError6 = undefined;
		
					try {
						for (var _iterator6 = (cls.extendedBy || [])[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
							var extender = _step6.value;
		
							this.classes.addEdge(cls.name, extender.name);
							extender.extends.add(cls);
						}
		
						/* check for cycles */
					} catch (err) {
						_didIteratorError6 = true;
						_iteratorError6 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion6 && _iterator6.return) {
								_iterator6.return();
							}
						} finally {
							if (_didIteratorError6) {
								throw _iteratorError6;
							}
						}
					}
		
					var cycle = this.classes.cycle();
					if (cycle) {
						throw new Error((0, _misc.humanMsg)(_templateObject2, cls.name, [].concat(_toConsumableArray(cycle), [cycle[0]]).join(' --> ')));
					}
		
					return cls;
				}
			}, {
				key: 'mergeSuperclassFields',
				value: function mergeSuperclassFields(cls) {
					var mergeFieldKind = function mergeFieldKind(cls, newCls, kind, customMerge) {
						var _context3;
		
						if ((_context3 = cls[kind], _isUndefined2.default).call(_context3)) {
							return;
						}
		
						if (!cls[$$processedFor]) {
							cls[$$processedFor] = {};
						}
						if (!cls[$$processedFor][kind]) {
							cls[$$processedFor][kind] = new WeakSet();
						}
						if (cls[$$processedFor][kind].has(newCls)) {
							return;
						}
						cls[$$processedFor][kind].add(newCls);
		
						function mergeBetween(superCls, subCls) {
							var _iteratorNormalCompletion7 = true;
							var _didIteratorError7 = false;
							var _iteratorError7 = undefined;
		
							try {
								for (var _iterator7 = (_context4 = superCls[kind], _keys2.default).call(_context4)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
									var _context4;
		
									var key = _step7.value;
		
									var superDesc = superCls[kind][key];
									var subDesc = subCls[kind][key];
									if (_isUndefined2.default.call(subDesc)) {
										subCls[kind][key] = superDesc;
										_fields.Field.augmentClass(subCls, key);
									} else if ((0, _isEqual3.default)(subDesc, superDesc)) {
										continue;
									} else {
										subCls[kind][key] = customMerge(superDesc, subDesc);
									}
								}
							} catch (err) {
								_didIteratorError7 = true;
								_iteratorError7 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion7 && _iterator7.return) {
										_iterator7.return();
									}
								} finally {
									if (_didIteratorError7) {
										throw _iteratorError7;
									}
								}
							}
						}
		
						var _iteratorNormalCompletion8 = true;
						var _didIteratorError8 = false;
						var _iteratorError8 = undefined;
		
						try {
							for (var _iterator8 = cls.extends[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
								var superCls = _step8.value;
		
								mergeFieldKind(superCls, newCls, kind, customMerge);
								mergeBetween(superCls, cls);
							}
						} catch (err) {
							_didIteratorError8 = true;
							_iteratorError8 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion8 && _iterator8.return) {
									_iterator8.return();
								}
							} finally {
								if (_didIteratorError8) {
									throw _iteratorError8;
								}
							}
						}
		
						var _iteratorNormalCompletion9 = true;
						var _didIteratorError9 = false;
						var _iteratorError9 = undefined;
		
						try {
							for (var _iterator9 = cls.extendedBy[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
								var subCls = _step9.value;
		
								mergeBetween(cls, subCls);
								mergeFieldKind(subCls, newCls, kind, customMerge);
							}
						} catch (err) {
							_didIteratorError9 = true;
							_iteratorError9 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion9 && _iterator9.return) {
									_iterator9.return();
								}
							} finally {
								if (_didIteratorError9) {
									throw _iteratorError9;
								}
							}
						}
					};
		
					mergeFieldKind(cls, cls, 'properties', function (superDesc, subDesc) {
						var _context5;
		
						// We're assuming that the only kind of non-trivial merging
						// right now is to give a property a specific constant value
						// in the subclass, which has to be checked in the superclass.
						// TODO: use actual json-schema validation to validate value
						var singleSuperDesc = void 0;
						if ((_context5 = superDesc.type, _isUndefined2.default).call(_context5) && superDesc.oneOf) {
							var _iteratorNormalCompletion10 = true;
							var _didIteratorError10 = false;
							var _iteratorError10 = undefined;
		
							try {
								for (var _iterator10 = superDesc.oneOf[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
									var _context6;
		
									var disjunct = _step10.value;
		
									if (_typeof(subDesc.value) === disjunct.type || (_context6 = subDesc.value, _isInteger2.default).call(_context6) && disjunct.type === 'integer' || (0, _isEqual3.default)(subDesc.value, disjunct.value)) {
										singleSuperDesc = _extends({}, superDesc, disjunct);
										delete singleSuperDesc.oneOf;
										delete singleSuperDesc.default;
									}
								}
							} catch (err) {
								_didIteratorError10 = true;
								_iteratorError10 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion10 && _iterator10.return) {
										_iterator10.return();
									}
								} finally {
									if (_didIteratorError10) {
										throw _iteratorError10;
									}
								}
							}
						} else {
							singleSuperDesc = _extends({}, superDesc);
						}
						return singleSuperDesc;
					});
		
					mergeFieldKind(cls, cls, 'relationships', function (superDesc, subDesc) {
						return subDesc;
					});
		
					mergeFieldKind(cls, cls, 'relationshipShortcuts', function (superDesc, subDesc) {
						return subDesc;
					});
		
					// TODO: for sides of a relationship (after splitting / merging all relevant domainPairs)
				}
			}, {
				key: 'mergeSameNameResources',
				value: function mergeSameNameResources(NewClass) {
					var OldClass = this.classes.vertexValue(NewClass.name);
					if (!OldClass) {
						return NewClass;
					}
					return _assignWith2.default.call(OldClass, NewClass, function (vOld, vNew, key) {
						var _context7;
		
						switch (key) {
							case 'module':
								return vOld;
							case 'extends':
							case 'extendedBy':
								return new Set([].concat(_toConsumableArray(vOld), _toConsumableArray(vNew)));
							case 'properties':
							case 'patternProperties':
								return (_context7 = {}, _assignWith2.default).call(_context7, vOld, vNew, function (pOld, pNew, pKey) {
									return _isUndefined2.default.call(pOld) ? pNew : pOld;
								});
							default:
								{
									if (!_isUndefined2.default.call(vOld) && !_isUndefined2.default.call(vNew) && !(0, _isEqual3.default)(vOld, vNew)) {
										throw new Error((0, _misc.humanMsg)(_templateObject3, OldClass.name, key, JSON.stringify(vOld), JSON.stringify(vNew)));
									}
									return _isUndefined2.default.call(vOld) ? vNew : vOld;
								}
						}
					});
				}
			}, {
				key: 'mergeSameNameRelationships',
				value: function mergeSameNameRelationships(NewClass) {
					var OldClass = this.classes.vertexValue(NewClass.name);
					if (!OldClass) {
						return NewClass;
					}
					return _assignWith2.default.call(OldClass, NewClass, function (vOld, vNew, key) {
						var _context8;
		
						switch (key) {
							case 'module':
								return vOld;
							case 'extends':
							case 'extendedBy':
								return new Set([].concat(_toConsumableArray(vOld), _toConsumableArray(vNew)));
							case 'domainPairs':
								return [].concat(_toConsumableArray(vOld), _toConsumableArray(vNew));
							case 'properties':
							case 'patternProperties':
								return (_context8 = {}, _assignWith2.default).call(_context8, vOld, vNew, function (pOld, pNew, pKey) {
									return _isUndefined2.default.call(pOld) ? pNew : pOld;
								});
							default:
								{
									return _isUndefined2.default.call(vOld) ? vNew : vOld;
								}
						}
					});
				}
			}]);
		
			return Module;
		}();
		
		////////////////////////////////////////////////////////////
		// RESOURCE({
		//
		//     name: 'ResourceName',
		//
		//     extends: <superclass>,
		//     abstract: <true/false>,
		//
		//     singular: 'singular name',
		//     plural:   'plural names',
		//
		//     properties: {
		//         ...properties
		//     },
		//     patternProperties: {
		//         ...patternProperties
		//     },
		//     ...options
		// })
		////////////////////////////////////////////////////////////
		
		////////////////////////////////////////////////////////////
		// RELATIONSHIP({
		//
		//     name: 'RelationshipName',
		//
		//     extends: <superclass>,
		//     abstract: <true/false>,
		//
		//     1: [ ResourceType1, [c1min, c1max], { ...options1to2 } ],
		//     2: [ ResourceType2, [c2min, c2max], { ...options2to1 } ],
		//
		//     properties: {
		//         ...properties
		//     },
		//
		//     ...options
		// })
		//
		// This means that RelationshipName is a type of c1-to-c2 relationship
		// (c stands for cardinality: many-to-many, one-to-many, etc. both sides
		// have a min and max) between ResourceType1 resources and ResourceType2 resources.
		// So: "a ResourceType1 resource can be related to 'c1' ResourceType2 resource(s),
		//      exposed through through the key 'options1to2.key' in that resource"
		// and vice versa, if a key field is present, which is not mandatory.
		//
		// A couple of possible options:
		// - options1to2.sustains:     when the last related ResourceType1 instance is deleted,
		//                             the ResourceType2 instance that is being sustained by it is deleted automatically
		// - options1to2.anchors:      a ResourceType2 instance cannot be deleted
		//                             while there are still ResourceType1 instances related with it
		// - options1to2.implicit:     (only when c1min > 0) a new ResourceType2 instance, plus this kind of relationship,
		//                             is automatically created for a new ResourceType1 instance;
		// - options1to2.getSummary:   a human-readable explanation of the corresponding REST endpoint for HTTP GET
		// - options1to2.putSummary:   a human-readable explanation of the corresponding REST endpoint for HTTP PUT
		// - options1to2.deleteSummary:a human-readable explanation of the corresponding REST endpoint for HTTP DELETE
		// - options.readOnly:         this relationship type is managed programmatically, not to be exposed through the API directly
		// - options.noCycles:         no cycles of this relationship type are allowed
		// - options.symmetric:        this relationship type is bidirectional, 1->2 always implies 2->1; TODO: implement when needed
		// - options.antiReflexive:    a resource may not be related to itself with this type;            TODO: implement when needed
		////////////////////////////////////////////////////////////
		
		
		// TODO: reintroduce json schema processor
		//
		// function jsonSchemaConfig(config) {
		// 	let result = {
		// 		...config,
		// 		allProperties: { ...config.properties }
		// 	};
		//
		// 	if (isFunction(config.extends)) {
		// 		/* merge each property with properties of the same name in the superclass */
		// 		for (let key of Object.keys(config.extends.allProperties)) {
		// 			// TODO: check for conflicts
		// 			// TODO: merge certain sub-items (e.g., enums can be made narrower)
		// 			result.allProperties[key] = {
		// 				...config.extends.allProperties[key],
		// 				...result.allProperties[key]
		// 			};
		// 		}
		// 	}
		//
		// 	/* folding superclass properties into one object */
		// 	Object.assign(result.allProperties, config.extends && config.extends.allProperties);
		//
		// 	return result;
		//
		// 	// return {
		// 	// 	...config,
		// 	// 	schema: {
		// 	// 		$schema:             'http://json-schema.org/draft-04/schema#',
		// 	// 		type:                'Object',
		// 	// 		properties:           { ...(config.properties || {})         },
		// 	// 		patternProperties:    { ...(config.patternProperties || {})  },
		// 	// 		additionalProperties: ( config.additionalProperties === true )  // default: no additional properties allowed
		// 	//
		// 	// 		// TODO: have this object conform to json schema syntax
		// 	// 		//     : - add 'required' field?
		// 	// 		//     : - sanitize config.properties
		// 	// 		//     : - add properties '1' and '2' to it (if config.isRelationship)
		// 	//
		// 	// 		// TODO: fold superclass properties, patternProperties, etc. into this
		// 	// 		//     : - fold property flags into each other
		// 	// 	}
		// 	// };
		// }
		
		
		exports.default = Module;
	
	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _TypedModule = __webpack_require__(31);
		
		var _TypedModule2 = _interopRequireDefault(_TypedModule);
		
		var _misc = __webpack_require__(3);
		
		var _schemas = __webpack_require__(32);
		
		var _resources = __webpack_require__(16);
		
		var _resources2 = _interopRequireDefault(_resources);
		
		var _typed = __webpack_require__(27);
		
		var _typed2 = _interopRequireDefault(_typed);
		
		var _ObservableSet = __webpack_require__(67);
		
		var _union = __webpack_require__(409);
		
		var _union2 = _interopRequireDefault(_union);
		
		var _uniqueId = __webpack_require__(179);
		
		var _uniqueId2 = _interopRequireDefault(_uniqueId);
		
		var _defaults = __webpack_require__(71);
		
		var _defaults2 = _interopRequireDefault(_defaults);
		
		var _assign = __webpack_require__(251);
		
		var _assign2 = _interopRequireDefault(_assign);
		
		var _entries = __webpack_require__(17);
		
		var _entries2 = _interopRequireDefault(_entries);
		
		var _parseInt = __webpack_require__(265);
		
		var _parseInt2 = _interopRequireDefault(_parseInt);
		
		var _max = __webpack_require__(263);
		
		var _max2 = _interopRequireDefault(_max);
		
		var _map = __webpack_require__(106);
		
		var _map2 = _interopRequireDefault(_map);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		exports.default = _TypedModule2.default.create('lyphs', [_resources2.default, _typed2.default], function (M, _ref) {
			var Resource = _ref.Resource;
			var IsRelatedTo = _ref.IsRelatedTo;
			var Template = _ref.Template;
			var PullsIntoTypeDefinition = _ref.PullsIntoTypeDefinition;
			var Has = _ref.Has;
		
		
			var Material = M.TYPED_RESOURCE({ /////////////////////////////////////////
		
				name: 'Material',
		
				extends: Template,
		
				singular: "material"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var ContainsMaterial = M.RELATIONSHIP({
		
				name: 'ContainsMaterial',
		
				extends: IsRelatedTo,
		
				singular: "has material",
		
				1: [Material, '0..*', { anchors: true, key: 'materials' }],
				2: [Material.Type, '0..*'],
		
				noCycles: true
		
			});
		
			var Lyph = M.TYPED_RESOURCE({ /////////////////////////////////////////////
		
				name: 'Lyph',
		
				extends: Material,
		
				singular: "lyph",
		
				properties: {
					'thickness': _extends({}, (0, _schemas.oneOf)({ type: 'number' }, _extends({}, _schemas.rangeSchema), _extends({}, _schemas.distributionSchema)), {
						default: _schemas.universalDistanceRange,
						isRefinement: function isRefinement(a, b) {
							a = (0, _misc.normalizeToRange)(a);
							b = (0, _misc.normalizeToRange)(b);
							return a.min <= b.min && b.max <= a.max;
						}
					}),
					'length': _extends({}, (0, _schemas.oneOf)({ type: 'number' }, _extends({}, _schemas.rangeSchema), _extends({}, _schemas.distributionSchema)), {
						default: _schemas.universalDistanceRange,
						isRefinement: function isRefinement(a, b) {
							a = (0, _misc.normalizeToRange)(a);
							b = (0, _misc.normalizeToRange)(b);
							return a.min <= b.min && b.max <= a.max;
						}
					})
				},
		
				behavior: {
					new: function _new() {
						var _context;
		
						var vals = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
						var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		
						if (options.customLyphBehaviorDone) {
							return;
						}
		
						vals = _extends({}, vals);
						(_context = vals, _defaults2.default).call(_context, {
							longitudinalBorders: [],
							radialBorders: [],
							axis: null
						});
						if (options.createAxis) {
							var _context2;
		
							var axis = Border.new();
							(_context2 = vals, _assign2.default).call(_context2, { axis: axis });
						}
						if (vals.axis) {
							vals.longitudinalBorders = (0, _union2.default)([].concat(_toConsumableArray(vals.longitudinalBorders)), [vals.axis]);
						}
						if (options.createRadialBorders) {
							if (options.createRadialBorders === true) {
								options.createRadialBorders = 2;
							}
							var nr = Math.min(options.createRadialBorders, 2);
							for (var i = vals.radialBorders.length; i < nr; ++i) {
								vals.radialBorders.push(Border.new());
							}
						}
						return Lyph.new(vals, _extends({}, options, { customLyphBehaviorDone: true }));
					}
				}
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var HasPart = M.RELATIONSHIP({
		
				name: 'HasPart',
		
				extends: Has,
		
				singular: "has part",
		
				1: [Lyph, '0..*', { anchors: true, key: 'parts' }],
				2: [Lyph, '0..1'],
		
				noCycles: true
		
			});
		
			var HasLayer = M.RELATIONSHIP({
		
				name: 'HasLayer',
		
				extends: Has,
		
				singular: "has layer",
		
				1: [Lyph, '0..*', { anchors: true, key: 'layers' }],
				2: [Lyph, '0..1'],
		
				properties: {
					'relativePosition': {
						type: 'number',
						required: true,
						default: function _default() {
							var _context3;
		
							return (_context3 = (_context3 = [].concat(_toConsumableArray(this[1]['-->HasLayer'])), _map2.default).call(_context3, 'relativePosition').concat([0]), _max2.default).call(_context3) + 1;
						}
					}
					// TODO: CONSTRAINT - two layers of the same lyph cannot have the same relativePosition
				},
		
				noCycles: true
		
			});
		
			var HasPatch = M.RELATIONSHIP({
		
				name: 'HasPatch',
		
				extends: HasPart,
		
				singular: "has part",
		
				1: [Lyph, '0..*', { anchors: true, key: 'patches' }],
				2: [Lyph, '0..1'],
		
				properties: {
					'patchMap': { type: 'string' }
				},
		
				noCycles: true
		
			});
		
			var HasSegment = M.RELATIONSHIP({
		
				name: 'HasSegment',
		
				extends: HasPatch,
		
				singular: "has segment",
		
				1: [Lyph, '0..*', { anchors: true, key: 'segments' }],
				2: [Lyph, '0..1'],
		
				properties: {
					'relativePosition': {
						type: 'number',
						required: true,
						default: function _default() {
							var _context4;
		
							return (_context4 = (_context4 = [].concat(_toConsumableArray(this[1]['-->HasSegment'])), _map2.default).call(_context4, 'relativePosition').concat([0]), _max2.default).call(_context4) + 1;
						}
					}
					// TODO: CONSTRAINT - two segments of the same lyph cannot have the same relativePosition
				},
		
				noCycles: true
		
				// Note that two segments can only be formally adjacent if they share
				// a radial border (which must therefore exist; used to be enforced with the Cylindrical)
		
			});
		
			var Border = M.TYPED_RESOURCE({ ///////////////////////////////////////////
		
				name: 'Border',
		
				extends: Template,
		
				singular: "border",
		
				properties: {
					nature: _extends({}, (0, _schemas.oneOf)(_extends({}, (0, _schemas.enumArraySchema)('open', 'closed')), _extends({}, (0, _schemas.enumSchema)('open', 'closed'))), {
						default: ['open', 'closed'],
						required: true,
						isRefinement: function isRefinement(a, b) {
							a = new Set(a ? (0, _misc.wrapInArray)(a) : []);
							b = new Set(b ? (0, _misc.wrapInArray)(b) : []);
							return !(b.has('open') && !a.has('open')) && !(b.has('closed') && !a.has('closed'));
						}
					})
				}
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var borderRel = function borderRel(name, Superclass, c1, c2, key, singular) {
				var flags = arguments.length <= 6 || arguments[6] === undefined ? {} : arguments[6];
				var options = arguments.length <= 7 || arguments[7] === undefined ? {} : arguments[7];
				return M.RELATIONSHIP(_extends({
		
					name: name,
		
					extends: Superclass,
		
					singular: singular
		
				}, flags, {
		
					1: [Lyph, c1, _extends({}, options, { sustains: true, anchors: true, expand: true, key: key })],
					2: [Border, c2]
		
				}));
			};
		
			//// //// //// //// ////
			// We're using a cylindrical coordinate system:
			// + https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
			// + longitudinal dimension = 'length' dimension
			// +              borders   = inner & outer borders
			// + radial dimension       = 'thickness' dimension
			// +        borders         = minus & plus borders
			//// //// //// //// ////
		
			/* 4 borders maximum; at least two longitudinal borders; optionally one or two radial borders */
			var HasBorder = borderRel('HasBorder', Has, '0..4', '1..1', 'borders', 'has border', { abstract: true });
			var HasLongitudinalBorder = borderRel('HasLongitudinalBorder', HasBorder, '2..2', '0..1', 'longitudinalBorders', 'has longitudinal border', {}, { auto: true, readonly: true });
			var HasRadialBorder = borderRel('HasRadialBorder', HasBorder, '0..2', '0..1', 'radialBorders', 'has radial border');
		
			/* one of the longitudinal borders can be an axis */
			var HasAxis = borderRel('HasAxis', HasLongitudinalBorder, '0..1', '0..1', 'axis', 'has axis');
		
			var CoalescenceScenario = M.TYPED_RESOURCE({ //////////////////////////////
		
				name: 'CoalescenceScenario',
		
				extends: Template,
		
				singular: "coalescence scenario"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var JoinsLyph = M.RELATIONSHIP({
		
				name: 'JoinsLyph',
		
				extends: PullsIntoTypeDefinition,
		
				singular: "joins lyph",
		
				1: [CoalescenceScenario, '2..2', { anchors: true, key: 'lyphs' }],
				2: [Lyph, '0..*']
		
			});
		
			var Coalescence = M.RESOURCE({ ////////////////////////////////////////////
		
				name: 'Coalescence',
		
				extends: Resource,
		
				singular: "coalescence"
		
				// coalescence between two or more lyph templates means
				// that at least one lyph from each participating lyph template
				// shares its outer layer with the other participating lyphs
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var Coalesces = M.RELATIONSHIP({
		
				name: 'Coalesces',
		
				extends: IsRelatedTo,
		
				singular: "coalesces",
		
				1: [Coalescence, '2..2', { anchors: true, key: 'lyphs' }],
				2: [Lyph, '0..*', { key: 'coalescences' }]
		
			});
		
			var CoalescesLike = M.RELATIONSHIP({
		
				name: 'CoalescesLike',
		
				extends: IsRelatedTo,
		
				singular: "coalesces through",
		
				1: [Coalescence, '0..*', { anchors: true, key: 'scenarios' }],
				2: [CoalescenceScenario, '0..*']
		
			});
		
			var Node = M.TYPED_RESOURCE({ /////////////////////////////////////////////
		
				name: 'Node',
		
				extends: Template,
		
				singular: "node"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var NodeLocation = M.TYPED_RESOURCE({ /////////////////////////////////////
		
				name: 'NodeLocation',
		
				abstract: true,
		
				extends: Template,
				extendedBy: [Lyph, Border],
		
				singular: "node location"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var ContainsNode = M.RELATIONSHIP({
		
				name: 'ContainsNode',
		
				singular: "contains node",
		
				extends: PullsIntoTypeDefinition,
		
				1: [NodeLocation, '0..*'],
				2: [Node, '0..*', { anchors: true, key: 'locations' }]
		
			});
		});
	
	/***/ },
	/* 48 */,
	/* 49 */,
	/* 50 */,
	/* 51 */
	/***/ function(module, exports) {
	
		/**
		 * A specialized version of `_.map` for arrays without support for iteratee
		 * shorthands.
		 *
		 * @private
		 * @param {Array} [array] The array to iterate over.
		 * @param {Function} iteratee The function invoked per iteration.
		 * @returns {Array} Returns the new mapped array.
		 */
		function arrayMap(array, iteratee) {
		  var index = -1,
		      length = array ? array.length : 0,
		      result = Array(length);
		
		  while (++index < length) {
		    result[index] = iteratee(array[index], index, array);
		  }
		  return result;
		}
		
		module.exports = arrayMap;
	
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
		var assignValue = __webpack_require__(75);
		
		/**
		 * Copies properties of `source` to `object`.
		 *
		 * @private
		 * @param {Object} source The object to copy properties from.
		 * @param {Array} props The property identifiers to copy.
		 * @param {Object} [object={}] The object to copy properties to.
		 * @param {Function} [customizer] The function to customize copied values.
		 * @returns {Object} Returns `object`.
		 */
		function copyObject(source, props, object, customizer) {
		  object || (object = {});
		
		  var index = -1,
		      length = props.length;
		
		  while (++index < length) {
		    var key = props[index];
		
		    var newValue = customizer
		      ? customizer(object[key], source[key], key, object, source)
		      : undefined;
		
		    assignValue(object, key, newValue === undefined ? source[key] : newValue);
		  }
		  return object;
		}
		
		module.exports = copyObject;
	
	
	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {
	
		var DataView = __webpack_require__(270),
		    Map = __webpack_require__(109),
		    Promise = __webpack_require__(272),
		    Set = __webpack_require__(150),
		    WeakMap = __webpack_require__(274),
		    baseGetTag = __webpack_require__(291),
		    toSource = __webpack_require__(170);
		
		/** `Object#toString` result references. */
		var mapTag = '[object Map]',
		    objectTag = '[object Object]',
		    promiseTag = '[object Promise]',
		    setTag = '[object Set]',
		    weakMapTag = '[object WeakMap]';
		
		var dataViewTag = '[object DataView]';
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
		
		/** Used to detect maps, sets, and weakmaps. */
		var dataViewCtorString = toSource(DataView),
		    mapCtorString = toSource(Map),
		    promiseCtorString = toSource(Promise),
		    setCtorString = toSource(Set),
		    weakMapCtorString = toSource(WeakMap);
		
		/**
		 * Gets the `toStringTag` of `value`.
		 *
		 * @private
		 * @param {*} value The value to query.
		 * @returns {string} Returns the `toStringTag`.
		 */
		var getTag = baseGetTag;
		
		// Fallback for data views, maps, sets, and weak maps in IE 11,
		// for data views in Edge, and promises in Node.js.
		if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
		    (Map && getTag(new Map) != mapTag) ||
		    (Promise && getTag(Promise.resolve()) != promiseTag) ||
		    (Set && getTag(new Set) != setTag) ||
		    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
		  getTag = function(value) {
		    var result = objectToString.call(value),
		        Ctor = result == objectTag ? value.constructor : undefined,
		        ctorString = Ctor ? toSource(Ctor) : undefined;
		
		    if (ctorString) {
		      switch (ctorString) {
		        case dataViewCtorString: return dataViewTag;
		        case mapCtorString: return mapTag;
		        case promiseCtorString: return promiseTag;
		        case setCtorString: return setTag;
		        case weakMapCtorString: return weakMapTag;
		      }
		    }
		    return result;
		  };
		}
		
		module.exports = getTag;
	
	
	/***/ },
	/* 54 */
	/***/ function(module, exports) {
	
		/** Used as references for various `Number` constants. */
		var MAX_SAFE_INTEGER = 9007199254740991;
		
		/** Used to detect unsigned integer values. */
		var reIsUint = /^(?:0|[1-9]\d*)$/;
		
		/**
		 * Checks if `value` is a valid array-like index.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
		 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
		 */
		function isIndex(value, length) {
		  length = length == null ? MAX_SAFE_INTEGER : length;
		  return !!length &&
		    (typeof value == 'number' || reIsUint.test(value)) &&
		    (value > -1 && value % 1 == 0 && value < length);
		}
		
		module.exports = isIndex;
	
	
	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isArray = __webpack_require__(8),
		    isSymbol = __webpack_require__(58);
		
		/** Used to match property names within property paths. */
		var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
		    reIsPlainProp = /^\w*$/;
		
		/**
		 * Checks if `value` is a property name and not a property path.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @param {Object} [object] The object to query keys on.
		 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
		 */
		function isKey(value, object) {
		  if (isArray(value)) {
		    return false;
		  }
		  var type = typeof value;
		  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
		      value == null || isSymbol(value)) {
		    return true;
		  }
		  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
		    (object != null && value in Object(object));
		}
		
		module.exports = isKey;
	
	
	/***/ },
	/* 56 */
	/***/ function(module, exports) {
	
		/**
		 * Performs a
		 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		 * comparison between two values to determine if they are equivalent.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to compare.
		 * @param {*} other The other value to compare.
		 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		 * @example
		 *
		 * var object = { 'a': 1 };
		 * var other = { 'a': 1 };
		 *
		 * _.eq(object, object);
		 * // => true
		 *
		 * _.eq(object, other);
		 * // => false
		 *
		 * _.eq('a', 'a');
		 * // => true
		 *
		 * _.eq('a', Object('a'));
		 * // => false
		 *
		 * _.eq(NaN, NaN);
		 * // => true
		 */
		function eq(value, other) {
		  return value === other || (value !== value && other !== other);
		}
		
		module.exports = eq;
	
	
	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isArray = __webpack_require__(8),
		    isObjectLike = __webpack_require__(18);
		
		/** `Object#toString` result references. */
		var stringTag = '[object String]';
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
		
		/**
		 * Checks if `value` is classified as a `String` primitive or object.
		 *
		 * @static
		 * @since 0.1.0
		 * @memberOf _
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
		 * @example
		 *
		 * _.isString('abc');
		 * // => true
		 *
		 * _.isString(1);
		 * // => false
		 */
		function isString(value) {
		  return typeof value == 'string' ||
		    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
		}
		
		module.exports = isString;
	
	
	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isObjectLike = __webpack_require__(18);
		
		/** `Object#toString` result references. */
		var symbolTag = '[object Symbol]';
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
		
		/**
		 * Checks if `value` is classified as a `Symbol` primitive or object.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
		 * @example
		 *
		 * _.isSymbol(Symbol.iterator);
		 * // => true
		 *
		 * _.isSymbol('abc');
		 * // => false
		 */
		function isSymbol(value) {
		  return typeof value == 'symbol' ||
		    (isObjectLike(value) && objectToString.call(value) == symbolTag);
		}
		
		module.exports = isSymbol;
	
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Observable_1 = __webpack_require__(22);
		var Subscriber_1 = __webpack_require__(13);
		var Subscription_1 = __webpack_require__(127);
		var ObjectUnsubscribedError_1 = __webpack_require__(188);
		var SubjectSubscription_1 = __webpack_require__(415);
		var rxSubscriber_1 = __webpack_require__(130);
		/**
		 * @class SubjectSubscriber<T>
		 */
		var SubjectSubscriber = (function (_super) {
		    __extends(SubjectSubscriber, _super);
		    function SubjectSubscriber(destination) {
		        _super.call(this, destination);
		        this.destination = destination;
		    }
		    return SubjectSubscriber;
		}(Subscriber_1.Subscriber));
		exports.SubjectSubscriber = SubjectSubscriber;
		/**
		 * @class Subject<T>
		 */
		var Subject = (function (_super) {
		    __extends(Subject, _super);
		    function Subject() {
		        _super.call(this);
		        this.observers = [];
		        this.isUnsubscribed = false;
		        this.isStopped = false;
		        this.hasError = false;
		        this.thrownError = null;
		    }
		    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
		        return new SubjectSubscriber(this);
		    };
		    Subject.prototype.lift = function (operator) {
		        var subject = new AnonymousSubject(this, this);
		        subject.operator = operator;
		        return subject;
		    };
		    Subject.prototype.next = function (value) {
		        if (this.isUnsubscribed) {
		            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
		        }
		        if (!this.isStopped) {
		            var observers = this.observers;
		            var len = observers.length;
		            var copy = observers.slice();
		            for (var i = 0; i < len; i++) {
		                copy[i].next(value);
		            }
		        }
		    };
		    Subject.prototype.error = function (err) {
		        if (this.isUnsubscribed) {
		            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
		        }
		        this.hasError = true;
		        this.thrownError = err;
		        this.isStopped = true;
		        var observers = this.observers;
		        var len = observers.length;
		        var copy = observers.slice();
		        for (var i = 0; i < len; i++) {
		            copy[i].error(err);
		        }
		        this.observers.length = 0;
		    };
		    Subject.prototype.complete = function () {
		        if (this.isUnsubscribed) {
		            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
		        }
		        this.isStopped = true;
		        var observers = this.observers;
		        var len = observers.length;
		        var copy = observers.slice();
		        for (var i = 0; i < len; i++) {
		            copy[i].complete();
		        }
		        this.observers.length = 0;
		    };
		    Subject.prototype.unsubscribe = function () {
		        this.isStopped = true;
		        this.isUnsubscribed = true;
		        this.observers = null;
		    };
		    Subject.prototype._subscribe = function (subscriber) {
		        if (this.isUnsubscribed) {
		            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
		        }
		        else if (this.hasError) {
		            subscriber.error(this.thrownError);
		            return Subscription_1.Subscription.EMPTY;
		        }
		        else if (this.isStopped) {
		            subscriber.complete();
		            return Subscription_1.Subscription.EMPTY;
		        }
		        else {
		            this.observers.push(subscriber);
		            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
		        }
		    };
		    Subject.prototype.asObservable = function () {
		        var observable = new Observable_1.Observable();
		        observable.source = this;
		        return observable;
		    };
		    Subject.create = function (destination, source) {
		        return new AnonymousSubject(destination, source);
		    };
		    return Subject;
		}(Observable_1.Observable));
		exports.Subject = Subject;
		/**
		 * @class AnonymousSubject<T>
		 */
		var AnonymousSubject = (function (_super) {
		    __extends(AnonymousSubject, _super);
		    function AnonymousSubject(destination, source) {
		        _super.call(this);
		        this.destination = destination;
		        this.source = source;
		    }
		    AnonymousSubject.prototype.next = function (value) {
		        var destination = this.destination;
		        if (destination && destination.next) {
		            destination.next(value);
		        }
		    };
		    AnonymousSubject.prototype.error = function (err) {
		        var destination = this.destination;
		        if (destination && destination.error) {
		            this.destination.error(err);
		        }
		    };
		    AnonymousSubject.prototype.complete = function () {
		        var destination = this.destination;
		        if (destination && destination.complete) {
		            this.destination.complete();
		        }
		    };
		    AnonymousSubject.prototype._subscribe = function (subscriber) {
		        var source = this.source;
		        if (source) {
		            return this.source.subscribe(subscriber);
		        }
		        else {
		            return Subscription_1.Subscription.EMPTY;
		        }
		    };
		    return AnonymousSubject;
		}(Subject));
		exports.AnonymousSubject = AnonymousSubject;
		//# sourceMappingURL=Subject.js.map
	
	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Observable_1 = __webpack_require__(22);
		var ScalarObservable_1 = __webpack_require__(181);
		var EmptyObservable_1 = __webpack_require__(128);
		var isScheduler_1 = __webpack_require__(62);
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @extends {Ignored}
		 * @hide true
		 */
		var ArrayObservable = (function (_super) {
		    __extends(ArrayObservable, _super);
		    function ArrayObservable(array, scheduler) {
		        _super.call(this);
		        this.array = array;
		        this.scheduler = scheduler;
		        if (!scheduler && array.length === 1) {
		            this._isScalar = true;
		            this.value = array[0];
		        }
		    }
		    ArrayObservable.create = function (array, scheduler) {
		        return new ArrayObservable(array, scheduler);
		    };
		    /**
		     * Creates an Observable that emits some values you specify as arguments,
		     * immediately one after the other, and then emits a complete notification.
		     *
		     * <span class="informal">Emits the arguments you provide, then completes.
		     * </span>
		     *
		     * <img src="./img/of.png" width="100%">
		     *
		     * This static operator is useful for creating a simple Observable that only
		     * emits the arguments given, and the complete notification thereafter. It can
		     * be used for composing with other Observables, such as with {@link concat}.
		     * By default, it uses a `null` Scheduler, which means the `next`
		     * notifications are sent synchronously, although with a different Scheduler
		     * it is possible to determine when those notifications will be delivered.
		     *
		     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
		     * var numbers = Rx.Observable.of(10, 20, 30);
		     * var letters = Rx.Observable.of('a', 'b', 'c');
		     * var interval = Rx.Observable.interval(1000);
		     * var result = numbers.concat(letters).concat(interval);
		     * result.subscribe(x => console.log(x));
		     *
		     * @see {@link create}
		     * @see {@link empty}
		     * @see {@link never}
		     * @see {@link throw}
		     *
		     * @param {...T} values Arguments that represent `next` values to be emitted.
		     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
		     * the emissions of the `next` notifications.
		     * @return {Observable<T>} An Observable that emits each given input value.
		     * @static true
		     * @name of
		     * @owner Observable
		     */
		    ArrayObservable.of = function () {
		        var array = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            array[_i - 0] = arguments[_i];
		        }
		        var scheduler = array[array.length - 1];
		        if (isScheduler_1.isScheduler(scheduler)) {
		            array.pop();
		        }
		        else {
		            scheduler = null;
		        }
		        var len = array.length;
		        if (len > 1) {
		            return new ArrayObservable(array, scheduler);
		        }
		        else if (len === 1) {
		            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
		        }
		        else {
		            return new EmptyObservable_1.EmptyObservable(scheduler);
		        }
		    };
		    ArrayObservable.dispatch = function (state) {
		        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
		        if (index >= count) {
		            subscriber.complete();
		            return;
		        }
		        subscriber.next(array[index]);
		        if (subscriber.isUnsubscribed) {
		            return;
		        }
		        state.index = index + 1;
		        this.schedule(state);
		    };
		    ArrayObservable.prototype._subscribe = function (subscriber) {
		        var index = 0;
		        var array = this.array;
		        var count = array.length;
		        var scheduler = this.scheduler;
		        if (scheduler) {
		            return scheduler.schedule(ArrayObservable.dispatch, 0, {
		                array: array, index: index, count: count, subscriber: subscriber
		            });
		        }
		        else {
		            for (var i = 0; i < count && !subscriber.isUnsubscribed; i++) {
		                subscriber.next(array[i]);
		            }
		            subscriber.complete();
		        }
		    };
		    return ArrayObservable;
		}(Observable_1.Observable));
		exports.ArrayObservable = ArrayObservable;
		//# sourceMappingURL=ArrayObservable.js.map
	
	/***/ },
	/* 61 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var ArrayObservable_1 = __webpack_require__(60);
		var ScalarObservable_1 = __webpack_require__(181);
		var EmptyObservable_1 = __webpack_require__(128);
		var concat_1 = __webpack_require__(184);
		var isScheduler_1 = __webpack_require__(62);
		/**
		 * Returns an Observable that emits the items in a specified Iterable before it begins to emit items emitted by the
		 * source Observable.
		 *
		 * <img src="./img/startWith.png" width="100%">
		 *
		 * @param {Values} an Iterable that contains the items you want the modified Observable to emit first.
		 * @return {Observable} an Observable that emits the items in the specified Iterable and then emits the items
		 * emitted by the source Observable.
		 * @method startWith
		 * @owner Observable
		 */
		function startWith() {
		    var array = [];
		    for (var _i = 0; _i < arguments.length; _i++) {
		        array[_i - 0] = arguments[_i];
		    }
		    var scheduler = array[array.length - 1];
		    if (isScheduler_1.isScheduler(scheduler)) {
		        array.pop();
		    }
		    else {
		        scheduler = null;
		    }
		    var len = array.length;
		    if (len === 1) {
		        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
		    }
		    else if (len > 1) {
		        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
		    }
		    else {
		        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
		    }
		}
		exports.startWith = startWith;
		//# sourceMappingURL=startWith.js.map
	
	/***/ },
	/* 62 */
	/***/ function(module, exports) {
	
		"use strict";
		function isScheduler(value) {
		    return value && typeof value.schedule === 'function';
		}
		exports.isScheduler = isScheduler;
		//# sourceMappingURL=isScheduler.js.map
	
	/***/ },
	/* 63 */,
	/* 64 */,
	/* 65 */,
	/* 66 */,
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.default = undefined;
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _templateObject = _taggedTemplateLiteral(["\n\t\t\t\tThe ", " event does not exist.\n\t\t\t"], ["\n\t\t\t\tThe ", " event does not exist.\n\t\t\t"]),
		    _templateObject2 = _taggedTemplateLiteral(["\n\t\t\t\tThe ", " property does not exist.\n\t\t\t"], ["\n\t\t\t\tThe ", " property does not exist.\n\t\t\t"]);
		
		exports.setEquals = setEquals;
		exports.copySetContent = copySetContent;
		
		var _Subject2 = __webpack_require__(59);
		
		var _BehaviorSubject = __webpack_require__(126);
		
		var _merge = __webpack_require__(185);
		
		var _map = __webpack_require__(42);
		
		var _misc = __webpack_require__(3);
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		function _extendableBuiltin(cls) {
			function ExtendableBuiltin() {
				var instance = Reflect.construct(cls, Array.from(arguments));
				Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
				return instance;
			}
		
			ExtendableBuiltin.prototype = Object.create(cls.prototype, {
				constructor: {
					value: cls,
					enumerable: false,
					writable: true,
					configurable: true
				}
			});
		
			if (Object.setPrototypeOf) {
				Object.setPrototypeOf(ExtendableBuiltin, cls);
			} else {
				ExtendableBuiltin.__proto__ = cls;
			}
		
			return ExtendableBuiltin;
		}
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		var $$set = Symbol('$$set');
		var $$addSubject = Symbol('$$addSubject');
		var $$deleteSubject = Symbol('$$deleteSubject');
		var $$valueObservable = Symbol('$$valueObservable');
		var $$disableNextReplay = Symbol('$$disableNextReplay');
		
		var AddReplaySubject = function (_Subject) {
			_inherits(AddReplaySubject, _Subject);
		
			function AddReplaySubject(initialSet) {
				_classCallCheck(this, AddReplaySubject);
		
				var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AddReplaySubject).call(this));
		
				_this._setReference = initialSet;
				return _this;
			}
		
			_createClass(AddReplaySubject, [{
				key: "normalSubscribe",
				value: function normalSubscribe() {
					this[$$disableNextReplay] = true;
					return this.subscribe.apply(this, arguments);
				}
				// noinspection JSDuplicatedDeclaration
		
			}, {
				key: "_subscribe",
				value: function _subscribe(subscriber) {
					var subscription = _get(Object.getPrototypeOf(AddReplaySubject.prototype), "_subscribe", this).call(this, subscriber);
					if (subscription && !subscription.isUnsubscribed && !this[$$disableNextReplay]) {
						this._setReference.forEach(subscriber.next.bind(subscriber));
					}
					this[$$disableNextReplay] = false;
					return subscription;
				}
			}]);
		
			return AddReplaySubject;
		}(_Subject2.Subject);
		
		var ObservableSet = function (_extendableBuiltin2) {
			_inherits(ObservableSet, _extendableBuiltin2);
		
			function ObservableSet() {
				var initialContent = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
		
				_classCallCheck(this, ObservableSet);
		
				var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(ObservableSet).call(this));
		
				_this2[$$addSubject] = new AddReplaySubject(_this2);
				_this2[$$addSubject].normalSubscribe(_this2.add.bind(_this2));
		
				_this2[$$deleteSubject] = new _Subject2.Subject();
				_this2[$$deleteSubject].subscribe(_this2.delete.bind(_this2));
		
				initialContent.forEach(_this2.add.bind(_this2));
		
				var valueSubject = new _BehaviorSubject.BehaviorSubject(new Set(_this2));
				_this2[$$addSubject].normalSubscribe(function () {
					valueSubject.next(new Set(_this2));
				});
				_this2[$$deleteSubject].subscribe(function () {
					valueSubject.next(new Set(_this2));
				});
				_this2[$$valueObservable] = valueSubject.asObservable();
				return _this2;
			}
		
			_createClass(ObservableSet, [{
				key: "e",
				value: function e(op) {
					switch (op) {
						case 'add':
							{
								return this[$$addSubject];
							}
						case 'delete':
							{
								return this[$$deleteSubject];
							}
						default:
							(0, _misc.constraint)(false, (0, _misc.humanMsg)(_templateObject, op));
					}
				}
			}, {
				key: "p",
				value: function p(name) {
					switch (name) {
						case 'value':
							{
								return this[$$valueObservable];
							}
						default:
							(0, _misc.constraint)(false, (0, _misc.humanMsg)(_templateObject2, name));
					}
				}
			}, {
				key: "add",
				value: function add(obj) {
					if (!this.has(obj)) {
						_get(Object.getPrototypeOf(ObservableSet.prototype), "add", this).call(this, obj);
						this.e('add').next(obj);
					}
					return this;
				}
			}, {
				key: "delete",
				value: function _delete(obj) {
					if (this.has(obj)) {
						_get(Object.getPrototypeOf(ObservableSet.prototype), "delete", this).call(this, obj);
						this.e('delete').next(obj);
						return true;
					}
					return false;
				}
			}, {
				key: "clear",
				value: function clear() {
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;
		
					try {
						for (var _iterator = this[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var value = _step.value;
							this.delete(value);
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
		
					return this;
				}
			}]);
		
			return ObservableSet;
		}(_extendableBuiltin(Set));
		
		exports.default = ObservableSet;
		function setEquals(setA, setB) {
			setA = new Set(setA);
			setB = new Set(setB);
			if (setA.size !== setB.size) return false;
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;
		
			try {
				for (var _iterator2 = setA[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var a = _step2.value;
					if (!setB.has(a)) return false;
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		
			return true;
		}
		
		function copySetContent(reference, newContent) {
			newContent = new Set(newContent);
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;
		
			try {
				for (var _iterator3 = reference[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var e = _step3.value;
		
					if (!newContent.has(e)) {
						reference.delete(e);
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}
		
			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;
		
			try {
				for (var _iterator4 = newContent[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var _e = _step4.value;
		
					if (!reference.has(_e)) {
						reference.add(_e);
					}
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}
		}
	
	/***/ },
	/* 68 */,
	/* 69 */,
	/* 70 */,
	/* 71 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(379);
		
		module.exports = function defaults() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 72 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(12);
		
		module.exports = function isObject() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
		var listCacheClear = __webpack_require__(352),
		    listCacheDelete = __webpack_require__(353),
		    listCacheGet = __webpack_require__(354),
		    listCacheHas = __webpack_require__(355),
		    listCacheSet = __webpack_require__(356);
		
		/**
		 * Creates an list cache object.
		 *
		 * @private
		 * @constructor
		 * @param {Array} [entries] The key-value pairs to cache.
		 */
		function ListCache(entries) {
		  var index = -1,
		      length = entries ? entries.length : 0;
		
		  this.clear();
		  while (++index < length) {
		    var entry = entries[index];
		    this.set(entry[0], entry[1]);
		  }
		}
		
		// Add methods to `ListCache`.
		ListCache.prototype.clear = listCacheClear;
		ListCache.prototype['delete'] = listCacheDelete;
		ListCache.prototype.get = listCacheGet;
		ListCache.prototype.has = listCacheHas;
		ListCache.prototype.set = listCacheSet;
		
		module.exports = ListCache;
	
	
	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {
	
		var root = __webpack_require__(11);
		
		/** Built-in value references. */
		var Symbol = root.Symbol;
		
		module.exports = Symbol;
	
	
	/***/ },
	/* 75 */
	/***/ function(module, exports, __webpack_require__) {
	
		var eq = __webpack_require__(56);
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
		
		/**
		 * Assigns `value` to `key` of `object` if the existing value is not equivalent
		 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		 * for equality comparisons.
		 *
		 * @private
		 * @param {Object} object The object to modify.
		 * @param {string} key The key of the property to assign.
		 * @param {*} value The value to assign.
		 */
		function assignValue(object, key, value) {
		  var objValue = object[key];
		  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
		      (value === undefined && !(key in object))) {
		    object[key] = value;
		  }
		}
		
		module.exports = assignValue;
	
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
		var eq = __webpack_require__(56);
		
		/**
		 * Gets the index at which the `key` is found in `array` of key-value pairs.
		 *
		 * @private
		 * @param {Array} array The array to search.
		 * @param {*} key The key to search for.
		 * @returns {number} Returns the index of the matched value, else `-1`.
		 */
		function assocIndexOf(array, key) {
		  var length = array.length;
		  while (length--) {
		    if (eq(array[length][0], key)) {
		      return length;
		    }
		  }
		  return -1;
		}
		
		module.exports = assocIndexOf;
	
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
		var arrayPush = __webpack_require__(112),
		    isFlattenable = __webpack_require__(347);
		
		/**
		 * The base implementation of `_.flatten` with support for restricting flattening.
		 *
		 * @private
		 * @param {Array} array The array to flatten.
		 * @param {number} depth The maximum recursion depth.
		 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
		 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
		 * @param {Array} [result=[]] The initial result value.
		 * @returns {Array} Returns the new flattened array.
		 */
		function baseFlatten(array, depth, predicate, isStrict, result) {
		  var index = -1,
		      length = array.length;
		
		  predicate || (predicate = isFlattenable);
		  result || (result = []);
		
		  while (++index < length) {
		    var value = array[index];
		    if (depth > 0 && predicate(value)) {
		      if (depth > 1) {
		        // Recursively flatten arrays (susceptible to call stack limits).
		        baseFlatten(value, depth - 1, predicate, isStrict, result);
		      } else {
		        arrayPush(result, value);
		      }
		    } else if (!isStrict) {
		      result[result.length] = value;
		    }
		  }
		  return result;
		}
		
		module.exports = baseFlatten;
	
	
	/***/ },
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseFindIndex = __webpack_require__(289),
		    baseIsNaN = __webpack_require__(297);
		
		/**
		 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
		 *
		 * @private
		 * @param {Array} array The array to search.
		 * @param {*} value The value to search for.
		 * @param {number} fromIndex The index to search from.
		 * @returns {number} Returns the index of the matched value, else `-1`.
		 */
		function baseIndexOf(array, value, fromIndex) {
		  if (value !== value) {
		    return baseFindIndex(array, baseIsNaN, fromIndex);
		  }
		  var index = fromIndex - 1,
		      length = array.length;
		
		  while (++index < length) {
		    if (array[index] === value) {
		      return index;
		    }
		  }
		  return -1;
		}
		
		module.exports = baseIndexOf;
	
	
	/***/ },
	/* 79 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseMatches = __webpack_require__(304),
		    baseMatchesProperty = __webpack_require__(305),
		    identity = __webpack_require__(171),
		    isArray = __webpack_require__(8),
		    property = __webpack_require__(403);
		
		/**
		 * The base implementation of `_.iteratee`.
		 *
		 * @private
		 * @param {*} [value=_.identity] The value to convert to an iteratee.
		 * @returns {Function} Returns the iteratee.
		 */
		function baseIteratee(value) {
		  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
		  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
		  if (typeof value == 'function') {
		    return value;
		  }
		  if (value == null) {
		    return identity;
		  }
		  if (typeof value == 'object') {
		    return isArray(value)
		      ? baseMatchesProperty(value[0], value[1])
		      : baseMatches(value);
		  }
		  return property(value);
		}
		
		module.exports = baseIteratee;
	
	
	/***/ },
	/* 80 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isKeyable = __webpack_require__(349);
		
		/**
		 * Gets the data for `map`.
		 *
		 * @private
		 * @param {Object} map The map to query.
		 * @param {string} key The reference key.
		 * @returns {*} Returns the map data.
		 */
		function getMapData(map, key) {
		  var data = map.__data__;
		  return isKeyable(key)
		    ? data[typeof key == 'string' ? 'string' : 'hash']
		    : data.map;
		}
		
		module.exports = getMapData;
	
	
	/***/ },
	/* 81 */
	/***/ function(module, exports) {
	
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/**
		 * Checks if `value` is likely a prototype object.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
		 */
		function isPrototype(value) {
		  var Ctor = value && value.constructor,
		      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
		
		  return value === proto;
		}
		
		module.exports = isPrototype;
	
	
	/***/ },
	/* 82 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getNative = __webpack_require__(39);
		
		/* Built-in method references that are verified to be native. */
		var nativeCreate = getNative(Object, 'create');
		
		module.exports = nativeCreate;
	
	
	/***/ },
	/* 83 */
	/***/ function(module, exports) {
	
		/**
		 * Converts `set` to an array of its values.
		 *
		 * @private
		 * @param {Object} set The set to convert.
		 * @returns {Array} Returns the values.
		 */
		function setToArray(set) {
		  var index = -1,
		      result = Array(set.size);
		
		  set.forEach(function(value) {
		    result[++index] = value;
		  });
		  return result;
		}
		
		module.exports = setToArray;
	
	
	/***/ },
	/* 84 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isObject = __webpack_require__(12);
		
		/** `Object#toString` result references. */
		var funcTag = '[object Function]',
		    genTag = '[object GeneratorFunction]';
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
		
		/**
		 * Checks if `value` is classified as a `Function` object.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
		 * @example
		 *
		 * _.isFunction(_);
		 * // => true
		 *
		 * _.isFunction(/abc/);
		 * // => false
		 */
		function isFunction(value) {
		  // The use of `Object#toString` avoids issues with the `typeof` operator
		  // in Safari 8 which returns 'object' for typed array and weak map constructors,
		  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
		  var tag = isObject(value) ? objectToString.call(value) : '';
		  return tag == funcTag || tag == genTag;
		}
		
		module.exports = isFunction;
	
	
	/***/ },
	/* 85 */
	/***/ function(module, exports) {
	
		/** Used as references for various `Number` constants. */
		var MAX_SAFE_INTEGER = 9007199254740991;
		
		/**
		 * Checks if `value` is a valid array-like length.
		 *
		 * **Note:** This function is loosely based on
		 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a valid length,
		 *  else `false`.
		 * @example
		 *
		 * _.isLength(3);
		 * // => true
		 *
		 * _.isLength(Number.MIN_VALUE);
		 * // => false
		 *
		 * _.isLength(Infinity);
		 * // => false
		 *
		 * _.isLength('3');
		 * // => false
		 */
		function isLength(value) {
		  return typeof value == 'number' &&
		    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
		}
		
		module.exports = isLength;
	
	
	/***/ },
	/* 86 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseToString = __webpack_require__(161);
		
		/**
		 * Converts `value` to a string. An empty string is returned for `null`
		 * and `undefined` values. The sign of `-0` is preserved.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to process.
		 * @returns {string} Returns the string.
		 * @example
		 *
		 * _.toString(null);
		 * // => ''
		 *
		 * _.toString(-0);
		 * // => '-0'
		 *
		 * _.toString([1, 2, 3]);
		 * // => '1,2,3'
		 */
		function toString(value) {
		  return value == null ? '' : baseToString(value);
		}
		
		module.exports = toString;
	
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Subscriber_1 = __webpack_require__(13);
		/**
		 * Groups pairs of consecutive emissions together and emits them as an array of
		 * two values.
		 *
		 * <span class="informal">Puts the current value and previous value together as
		 * an array, and emits that.</span>
		 *
		 * <img src="./img/pairwise.png" width="100%">
		 *
		 * The Nth emission from the source Observable will cause the output Observable
		 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
		 * pair. For this reason, `pairwise` emits on the second and subsequent
		 * emissions from the source Observable, but not on the first emission, because
		 * there is no previous value in that case.
		 *
		 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
		 * var clicks = Rx.Observable.fromEvent(document, 'click');
		 * var pairs = clicks.pairwise();
		 * var distance = pairs.map(pair => {
		 *   var x0 = pair[0].clientX;
		 *   var y0 = pair[0].clientY;
		 *   var x1 = pair[1].clientX;
		 *   var y1 = pair[1].clientY;
		 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
		 * });
		 * distance.subscribe(x => console.log(x));
		 *
		 * @see {@link buffer}
		 * @see {@link bufferCount}
		 *
		 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
		 * consecutive values from the source Observable.
		 * @method pairwise
		 * @owner Observable
		 */
		function pairwise() {
		    return this.lift(new PairwiseOperator());
		}
		exports.pairwise = pairwise;
		var PairwiseOperator = (function () {
		    function PairwiseOperator() {
		    }
		    PairwiseOperator.prototype.call = function (subscriber, source) {
		        return source._subscribe(new PairwiseSubscriber(subscriber));
		    };
		    return PairwiseOperator;
		}());
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var PairwiseSubscriber = (function (_super) {
		    __extends(PairwiseSubscriber, _super);
		    function PairwiseSubscriber(destination) {
		        _super.call(this, destination);
		        this.hasPrev = false;
		    }
		    PairwiseSubscriber.prototype._next = function (value) {
		        if (this.hasPrev) {
		            this.destination.next([this.prev, value]);
		        }
		        else {
		            this.hasPrev = true;
		        }
		        this.prev = value;
		    };
		    return PairwiseSubscriber;
		}(Subscriber_1.Subscriber));
		//# sourceMappingURL=pairwise.js.map
	
	/***/ },
	/* 88 */
	/***/ function(module, exports) {
	
		"use strict";
		exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
		//# sourceMappingURL=isArray.js.map
	
	/***/ },
	/* 89 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(module, global) {"use strict";
		var objectTypes = {
		    'boolean': false,
		    'function': true,
		    'object': true,
		    'number': false,
		    'string': false,
		    'undefined': false
		};
		exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
		/* tslint:disable:no-unused-variable */
		var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
		var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
		var freeGlobal = objectTypes[typeof global] && global;
		if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
		    exports.root = freeGlobal;
		}
		//# sourceMappingURL=root.js.map
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(132)(module), (function() { return this; }())))
	
	/***/ },
	/* 90 */,
	/* 91 */,
	/* 92 */,
	/* 93 */,
	/* 94 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _schemas = __webpack_require__(32);
		
		var _TypedModule = __webpack_require__(31);
		
		var _TypedModule2 = _interopRequireDefault(_TypedModule);
		
		var _resources = __webpack_require__(16);
		
		var _resources2 = _interopRequireDefault(_resources);
		
		var _typed = __webpack_require__(27);
		
		var _typed2 = _interopRequireDefault(_typed);
		
		var _lyphs = __webpack_require__(47);
		
		var _lyphs2 = _interopRequireDefault(_lyphs);
		
		var _processes = __webpack_require__(95);
		
		var _processes2 = _interopRequireDefault(_processes);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _TypedModule2.default.create('measurables', [_resources2.default, _typed2.default, _lyphs2.default, _processes2.default], function (M, _ref) {
			var Resource = _ref.Resource;
			var IsRelatedTo = _ref.IsRelatedTo;
			var Template = _ref.Template;
			var Lyph = _ref.Lyph;
			var Material = _ref.Material;
			var Border = _ref.Border;
			var Node = _ref.Node;
			var Process = _ref.Process;
			var Has = _ref.Has;
			var PullsIntoTypeDefinition = _ref.PullsIntoTypeDefinition;
		
		
			var Measurable = M.TYPED_RESOURCE({ ///////////////////////////////////////
		
				name: 'Measurable',
		
				extends: Template,
		
				singular: "measurable",
		
				properties: {
					'quality': {
						type: 'string',
						isRefinement: function isRefinement(a, b) {
							return !a || a === b;
						}
					}
				}
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var MeasuresMaterial = M.RELATIONSHIP({
		
				name: 'MeasuresMaterial',
		
				extends: PullsIntoTypeDefinition,
		
				singular: "measures material",
		
				1: [Measurable, '0..*', { anchors: true, key: 'materials' }],
				2: [Material, '0..*'],
		
				properties: {
					'dimensionality': _extends({}, _schemas.dimensionalitySchema)
				}
		
			});
		
			var MeasurableLocation = M.TYPED_RESOURCE({ ///////////////////////////////
		
				name: 'MeasurableLocation',
		
				abstract: true,
		
				extends: Template,
		
				extendedBy: [Lyph, Border, Node, Process],
		
				singular: "measurable location"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var HasMeasurable = M.RELATIONSHIP({
		
				name: 'HasMeasurable',
		
				extends: Has,
		
				singular: "has measurable",
		
				1: [MeasurableLocation, '0..*', { anchors: true, sustains: true, key: 'measurables' }],
				2: [Measurable, '0..1', { key: 'location' }]
		
			});
		
			var Causality = M.TYPED_RESOURCE({ ////////////////////////////////////////
		
				name: 'Causality',
		
				extends: Template,
		
				singular: "causality",
				plural: "causalities"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var _M$RELATIONSHIP = M.RELATIONSHIP([{
		
				name: 'Causes',
		
				extends: PullsIntoTypeDefinition,
		
				singular: "causes",
		
				1: [Measurable, '0..*', { key: 'effects' }],
				2: [Causality, '1..1', { anchors: true, key: 'cause' }]
		
			}, {
		
				name: 'Causes',
		
				extends: PullsIntoTypeDefinition,
		
				1: [Causality, '1..1', { anchors: true, key: 'effect' }],
				2: [Measurable, '0..*', { key: 'causes' }]
		
			}]);
		
			var _M$RELATIONSHIP2 = _slicedToArray(_M$RELATIONSHIP, 1);
		
			var Causes = _M$RELATIONSHIP2[0];
		});
	
	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _TypedModule = __webpack_require__(31);
		
		var _TypedModule2 = _interopRequireDefault(_TypedModule);
		
		var _misc = __webpack_require__(3);
		
		var _schemas = __webpack_require__(32);
		
		var _resources = __webpack_require__(16);
		
		var _resources2 = _interopRequireDefault(_resources);
		
		var _typed = __webpack_require__(27);
		
		var _typed2 = _interopRequireDefault(_typed);
		
		var _lyphs = __webpack_require__(47);
		
		var _lyphs2 = _interopRequireDefault(_lyphs);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _TypedModule2.default.create('processes', [_resources2.default, _typed2.default, _lyphs2.default], function (M, _ref) {
			var IsRelatedTo = _ref.IsRelatedTo;
			var Template = _ref.Template;
			var Material = _ref.Material;
			var Lyph = _ref.Lyph;
			var Node = _ref.Node;
			var Has = _ref.Has;
			var PullsIntoTypeDefinition = _ref.PullsIntoTypeDefinition;
		
		
			var Process = M.TYPED_RESOURCE({ //////////////////////////////////////////
		
				name: 'Process',
		
				extends: Template,
		
				singular: "process",
				plural: "processes",
		
				properties: {
					'transportPhenomenon': _extends({}, (0, _schemas.oneOf)(_extends({}, (0, _schemas.enumArraySchema)('advection', 'diffusion')), _extends({}, (0, _schemas.enumSchema)('advection', 'diffusion'))), {
						default: ['advection', 'diffusion'],
						required: true,
						isRefinement: function isRefinement(a, b) {
							a = new Set(a ? (0, _misc.wrapInArray)(a) : []);
							b = new Set(b ? (0, _misc.wrapInArray)(b) : []);
							return !(b.has('advection') && !a.has('advection')) && !(b.has('diffusion') && !a.has('diffusion'));
						}
					})
				}
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var _M$RELATIONSHIP = M.RELATIONSHIP([{
		
				name: 'FlowsTo',
		
				extends: PullsIntoTypeDefinition,
		
				singular: "flows to",
		
				1: [Node, '0..*', { key: 'outgoingProcesses' }],
				2: [Process, '0..1', { anchors: true, key: 'source' }]
		
			}, {
		
				name: 'FlowsTo',
		
				extends: PullsIntoTypeDefinition,
		
				singular: "flows to",
		
				1: [Process, '0..1', { anchors: true, key: 'target' }],
				2: [Node, '0..*', { key: 'incomingProcesses' }]
		
			}]);
		
			var _M$RELATIONSHIP2 = _slicedToArray(_M$RELATIONSHIP, 1);
		
			var FlowsTo = _M$RELATIONSHIP2[0];
		
			var _M$RELATIONSHIP3 = M.RELATIONSHIP([{
		
				name: 'provisional_FlowsTo',
		
				extends: PullsIntoTypeDefinition,
		
				singular: "flows to",
		
				1: [Lyph, '0..*', { key: 'outgoingProcesses' }],
				2: [Process, '0..1', { anchors: true, key: 'sourceLyph' }]
		
			}, {
		
				name: 'provisional_FlowsTo',
		
				extends: PullsIntoTypeDefinition,
		
				singular: "flows to",
		
				1: [Process, '0..1', { anchors: true, key: 'targetLyph' }],
				2: [Lyph, '0..*', { key: 'incomingProcesses' }]
		
			}]);
		
			var _M$RELATIONSHIP4 = _slicedToArray(_M$RELATIONSHIP3, 1);
		
			var provisional_FlowsTo = _M$RELATIONSHIP4[0];
		
		
			var ConveysProcess = M.RELATIONSHIP({
		
				name: 'ConveysProcess',
		
				extends: Has,
		
				singular: "conveys process",
		
				1: [Lyph, '0..*', { anchors: true, key: 'processes' }],
				2: [Process, '0..1', { key: 'conveyingLyph' }]
		
			});
		
			var TransportsMaterial = M.RELATIONSHIP({
		
				name: 'TransportsMaterial',
		
				extends: Has,
		
				singular: "transports material",
		
				1: [Process, '0..*', { anchors: true, key: 'materials' }],
				2: [Material, '0..1']
		
			});
		
			var HasSegment = M.RELATIONSHIP({
		
				name: 'HasSegment',
		
				extends: Has,
		
				singular: "has segment",
		
				1: [Process, '0..*', { anchors: true, key: 'segments' }],
				2: [Process, '0..1']
		
			});
		
			var _M$RELATIONSHIP5 = M.RELATIONSHIP([Process, Node].map(function (Class) {
				return {
		
					name: 'HasChannel',
		
					extends: Has,
		
					singular: "has channel",
		
					1: [Class, '0..*', { anchors: true, key: 'channels' }],
					2: [Class, '0..1']
		
				};
			}));
		
			var _M$RELATIONSHIP6 = _slicedToArray(_M$RELATIONSHIP5, 1);
		
			var HasChannel = _M$RELATIONSHIP6[0];
		});
	
	/***/ },
	/* 96 */,
	/* 97 */,
	/* 98 */,
	/* 99 */,
	/* 100 */,
	/* 101 */,
	/* 102 */,
	/* 103 */,
	/* 104 */,
	/* 105 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(84);
		
		module.exports = function isFunction() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 106 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(394);
		
		module.exports = function map() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 107 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(405);
		
		module.exports = function size() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 108 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(180);
		
		module.exports = function values() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 109 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getNative = __webpack_require__(39),
		    root = __webpack_require__(11);
		
		/* Built-in method references that are verified to be native. */
		var Map = getNative(root, 'Map');
		
		module.exports = Map;
	
	
	/***/ },
	/* 110 */
	/***/ function(module, exports, __webpack_require__) {
	
		var mapCacheClear = __webpack_require__(357),
		    mapCacheDelete = __webpack_require__(358),
		    mapCacheGet = __webpack_require__(359),
		    mapCacheHas = __webpack_require__(360),
		    mapCacheSet = __webpack_require__(361);
		
		/**
		 * Creates a map cache object to store key-value pairs.
		 *
		 * @private
		 * @constructor
		 * @param {Array} [entries] The key-value pairs to cache.
		 */
		function MapCache(entries) {
		  var index = -1,
		      length = entries ? entries.length : 0;
		
		  this.clear();
		  while (++index < length) {
		    var entry = entries[index];
		    this.set(entry[0], entry[1]);
		  }
		}
		
		// Add methods to `MapCache`.
		MapCache.prototype.clear = mapCacheClear;
		MapCache.prototype['delete'] = mapCacheDelete;
		MapCache.prototype.get = mapCacheGet;
		MapCache.prototype.has = mapCacheHas;
		MapCache.prototype.set = mapCacheSet;
		
		module.exports = MapCache;
	
	
	/***/ },
	/* 111 */
	/***/ function(module, exports, __webpack_require__) {
	
		var ListCache = __webpack_require__(73),
		    stackClear = __webpack_require__(366),
		    stackDelete = __webpack_require__(367),
		    stackGet = __webpack_require__(368),
		    stackHas = __webpack_require__(369),
		    stackSet = __webpack_require__(370);
		
		/**
		 * Creates a stack cache object to store key-value pairs.
		 *
		 * @private
		 * @constructor
		 * @param {Array} [entries] The key-value pairs to cache.
		 */
		function Stack(entries) {
		  this.__data__ = new ListCache(entries);
		}
		
		// Add methods to `Stack`.
		Stack.prototype.clear = stackClear;
		Stack.prototype['delete'] = stackDelete;
		Stack.prototype.get = stackGet;
		Stack.prototype.has = stackHas;
		Stack.prototype.set = stackSet;
		
		module.exports = Stack;
	
	
	/***/ },
	/* 112 */
	/***/ function(module, exports) {
	
		/**
		 * Appends the elements of `values` to `array`.
		 *
		 * @private
		 * @param {Array} array The array to modify.
		 * @param {Array} values The values to append.
		 * @returns {Array} Returns `array`.
		 */
		function arrayPush(array, values) {
		  var index = -1,
		      length = values.length,
		      offset = array.length;
		
		  while (++index < length) {
		    array[offset + index] = values[index];
		  }
		  return array;
		}
		
		module.exports = arrayPush;
	
	
	/***/ },
	/* 113 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIsEqualDeep = __webpack_require__(295),
		    isObject = __webpack_require__(12),
		    isObjectLike = __webpack_require__(18);
		
		/**
		 * The base implementation of `_.isEqual` which supports partial comparisons
		 * and tracks traversed objects.
		 *
		 * @private
		 * @param {*} value The value to compare.
		 * @param {*} other The other value to compare.
		 * @param {Function} [customizer] The function to customize comparisons.
		 * @param {boolean} [bitmask] The bitmask of comparison flags.
		 *  The bitmask may be composed of the following flags:
		 *     1 - Unordered comparison
		 *     2 - Partial comparison
		 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
		 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		 */
		function baseIsEqual(value, other, customizer, bitmask, stack) {
		  if (value === other) {
		    return true;
		  }
		  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
		    return value !== value && other !== other;
		  }
		  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
		}
		
		module.exports = baseIsEqual;
	
	
	/***/ },
	/* 114 */
	/***/ function(module, exports) {
	
		/**
		 * The base implementation of `_.property` without support for deep paths.
		 *
		 * @private
		 * @param {string} key The key of the property to get.
		 * @returns {Function} Returns the new accessor function.
		 */
		function baseProperty(key) {
		  return function(object) {
		    return object == null ? undefined : object[key];
		  };
		}
		
		module.exports = baseProperty;
	
	
	/***/ },
	/* 115 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isArray = __webpack_require__(8),
		    stringToPath = __webpack_require__(373);
		
		/**
		 * Casts `value` to a path array if it's not one.
		 *
		 * @private
		 * @param {*} value The value to inspect.
		 * @returns {Array} Returns the cast property path array.
		 */
		function castPath(value) {
		  return isArray(value) ? value : stringToPath(value);
		}
		
		module.exports = castPath;
	
	
	/***/ },
	/* 116 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Uint8Array = __webpack_require__(152);
		
		/**
		 * Creates a clone of `arrayBuffer`.
		 *
		 * @private
		 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
		 * @returns {ArrayBuffer} Returns the cloned array buffer.
		 */
		function cloneArrayBuffer(arrayBuffer) {
		  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
		  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
		  return result;
		}
		
		module.exports = cloneArrayBuffer;
	
	
	/***/ },
	/* 117 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseRest = __webpack_require__(38),
		    isIterateeCall = __webpack_require__(348);
		
		/**
		 * Creates a function like `_.assign`.
		 *
		 * @private
		 * @param {Function} assigner The function to assign values.
		 * @returns {Function} Returns the new assigner function.
		 */
		function createAssigner(assigner) {
		  return baseRest(function(object, sources) {
		    var index = -1,
		        length = sources.length,
		        customizer = length > 1 ? sources[length - 1] : undefined,
		        guard = length > 2 ? sources[2] : undefined;
		
		    customizer = (assigner.length > 3 && typeof customizer == 'function')
		      ? (length--, customizer)
		      : undefined;
		
		    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		      customizer = length < 3 ? undefined : customizer;
		      length = 1;
		    }
		    object = Object(object);
		    while (++index < length) {
		      var source = sources[index];
		      if (source) {
		        assigner(object, source, index, customizer);
		      }
		    }
		    return object;
		  });
		}
		
		module.exports = createAssigner;
	
	
	/***/ },
	/* 118 */
	/***/ function(module, exports, __webpack_require__) {
	
		var overArg = __webpack_require__(122);
		
		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeGetPrototype = Object.getPrototypeOf;
		
		/**
		 * Gets the `[[Prototype]]` of `value`.
		 *
		 * @private
		 * @param {*} value The value to query.
		 * @returns {null|Object} Returns the `[[Prototype]]`.
		 */
		var getPrototype = overArg(nativeGetPrototype, Object);
		
		module.exports = getPrototype;
	
	
	/***/ },
	/* 119 */
	/***/ function(module, exports, __webpack_require__) {
	
		var overArg = __webpack_require__(122),
		    stubArray = __webpack_require__(175);
		
		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeGetSymbols = Object.getOwnPropertySymbols;
		
		/**
		 * Creates an array of the own enumerable symbol properties of `object`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @returns {Array} Returns the array of symbols.
		 */
		var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
		
		module.exports = getSymbols;
	
	
	/***/ },
	/* 120 */
	/***/ function(module, exports) {
	
		/**
		 * Checks if `value` is a host object in IE < 9.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
		 */
		function isHostObject(value) {
		  // Many host objects are `Object` objects that can coerce to strings
		  // despite having improperly defined `toString` methods.
		  var result = false;
		  if (value != null && typeof value.toString != 'function') {
		    try {
		      result = !!(value + '');
		    } catch (e) {}
		  }
		  return result;
		}
		
		module.exports = isHostObject;
	
	
	/***/ },
	/* 121 */
	/***/ function(module, exports) {
	
		/**
		 * Converts `map` to its key-value pairs.
		 *
		 * @private
		 * @param {Object} map The map to convert.
		 * @returns {Array} Returns the key-value pairs.
		 */
		function mapToArray(map) {
		  var index = -1,
		      result = Array(map.size);
		
		  map.forEach(function(value, key) {
		    result[++index] = [key, value];
		  });
		  return result;
		}
		
		module.exports = mapToArray;
	
	
	/***/ },
	/* 122 */
	/***/ function(module, exports) {
	
		/**
		 * Creates a function that invokes `func` with its first argument transformed.
		 *
		 * @private
		 * @param {Function} func The function to wrap.
		 * @param {Function} transform The argument transform.
		 * @returns {Function} Returns the new function.
		 */
		function overArg(func, transform) {
		  return function(arg) {
		    return func(transform(arg));
		  };
		}
		
		module.exports = overArg;
	
	
	/***/ },
	/* 123 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseGet = __webpack_require__(156);
		
		/**
		 * Gets the value at `path` of `object`. If the resolved value is
		 * `undefined`, the `defaultValue` is returned in its place.
		 *
		 * @static
		 * @memberOf _
		 * @since 3.7.0
		 * @category Object
		 * @param {Object} object The object to query.
		 * @param {Array|string} path The path of the property to get.
		 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		 * @returns {*} Returns the resolved value.
		 * @example
		 *
		 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		 *
		 * _.get(object, 'a[0].b.c');
		 * // => 3
		 *
		 * _.get(object, ['a', '0', 'b', 'c']);
		 * // => 3
		 *
		 * _.get(object, 'a.b.c', 'default');
		 * // => 'default'
		 */
		function get(object, path, defaultValue) {
		  var result = object == null ? undefined : baseGet(object, path);
		  return result === undefined ? defaultValue : result;
		}
		
		module.exports = get;
	
	
	/***/ },
	/* 124 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isArrayLikeObject = __webpack_require__(125);
		
		/** `Object#toString` result references. */
		var argsTag = '[object Arguments]';
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
		
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
		
		/** Built-in value references. */
		var propertyIsEnumerable = objectProto.propertyIsEnumerable;
		
		/**
		 * Checks if `value` is likely an `arguments` object.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		 *  else `false`.
		 * @example
		 *
		 * _.isArguments(function() { return arguments; }());
		 * // => true
		 *
		 * _.isArguments([1, 2, 3]);
		 * // => false
		 */
		function isArguments(value) {
		  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
		  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
		    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
		}
		
		module.exports = isArguments;
	
	
	/***/ },
	/* 125 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isArrayLike = __webpack_require__(21),
		    isObjectLike = __webpack_require__(18);
		
		/**
		 * This method is like `_.isArrayLike` except that it also checks if `value`
		 * is an object.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an array-like object,
		 *  else `false`.
		 * @example
		 *
		 * _.isArrayLikeObject([1, 2, 3]);
		 * // => true
		 *
		 * _.isArrayLikeObject(document.body.children);
		 * // => true
		 *
		 * _.isArrayLikeObject('abc');
		 * // => false
		 *
		 * _.isArrayLikeObject(_.noop);
		 * // => false
		 */
		function isArrayLikeObject(value) {
		  return isObjectLike(value) && isArrayLike(value);
		}
		
		module.exports = isArrayLikeObject;
	
	
	/***/ },
	/* 126 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Subject_1 = __webpack_require__(59);
		var throwError_1 = __webpack_require__(433);
		var ObjectUnsubscribedError_1 = __webpack_require__(188);
		/**
		 * @class BehaviorSubject<T>
		 */
		var BehaviorSubject = (function (_super) {
		    __extends(BehaviorSubject, _super);
		    function BehaviorSubject(_value) {
		        _super.call(this);
		        this._value = _value;
		    }
		    BehaviorSubject.prototype.getValue = function () {
		        if (this.hasError) {
		            throwError_1.throwError(this.thrownError);
		        }
		        else if (this.isUnsubscribed) {
		            throwError_1.throwError(new ObjectUnsubscribedError_1.ObjectUnsubscribedError());
		        }
		        else {
		            return this._value;
		        }
		    };
		    Object.defineProperty(BehaviorSubject.prototype, "value", {
		        get: function () {
		            return this.getValue();
		        },
		        enumerable: true,
		        configurable: true
		    });
		    BehaviorSubject.prototype._subscribe = function (subscriber) {
		        var subscription = _super.prototype._subscribe.call(this, subscriber);
		        if (subscription && !subscription.isUnsubscribed) {
		            subscriber.next(this._value);
		        }
		        return subscription;
		    };
		    BehaviorSubject.prototype.next = function (value) {
		        _super.prototype.next.call(this, this._value = value);
		    };
		    return BehaviorSubject;
		}(Subject_1.Subject));
		exports.BehaviorSubject = BehaviorSubject;
		//# sourceMappingURL=BehaviorSubject.js.map
	
	/***/ },
	/* 127 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var isArray_1 = __webpack_require__(88);
		var isObject_1 = __webpack_require__(430);
		var isFunction_1 = __webpack_require__(189);
		var tryCatch_1 = __webpack_require__(190);
		var errorObject_1 = __webpack_require__(131);
		var UnsubscriptionError_1 = __webpack_require__(429);
		/**
		 * Represents a disposable resource, such as the execution of an Observable. A
		 * Subscription has one important method, `unsubscribe`, that takes no argument
		 * and just disposes the resource held by the subscription.
		 *
		 * Additionally, subscriptions may be grouped together through the `add()`
		 * method, which will attach a child Subscription to the current Subscription.
		 * When a Subscription is unsubscribed, all its children (and its grandchildren)
		 * will be unsubscribed as well.
		 *
		 * @class Subscription
		 */
		var Subscription = (function () {
		    /**
		     * @param {function(): void} [unsubscribe] A function describing how to
		     * perform the disposal of resources when the `unsubscribe` method is called.
		     */
		    function Subscription(unsubscribe) {
		        /**
		         * A flag to indicate whether this Subscription has already been unsubscribed.
		         * @type {boolean}
		         */
		        this.isUnsubscribed = false;
		        if (unsubscribe) {
		            this._unsubscribe = unsubscribe;
		        }
		    }
		    /**
		     * Disposes the resources held by the subscription. May, for instance, cancel
		     * an ongoing Observable execution or cancel any other type of work that
		     * started when the Subscription was created.
		     * @return {void}
		     */
		    Subscription.prototype.unsubscribe = function () {
		        var hasErrors = false;
		        var errors;
		        if (this.isUnsubscribed) {
		            return;
		        }
		        this.isUnsubscribed = true;
		        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
		        this._subscriptions = null;
		        if (isFunction_1.isFunction(_unsubscribe)) {
		            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
		            if (trial === errorObject_1.errorObject) {
		                hasErrors = true;
		                (errors = errors || []).push(errorObject_1.errorObject.e);
		            }
		        }
		        if (isArray_1.isArray(_subscriptions)) {
		            var index = -1;
		            var len = _subscriptions.length;
		            while (++index < len) {
		                var sub = _subscriptions[index];
		                if (isObject_1.isObject(sub)) {
		                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
		                    if (trial === errorObject_1.errorObject) {
		                        hasErrors = true;
		                        errors = errors || [];
		                        var err = errorObject_1.errorObject.e;
		                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
		                            errors = errors.concat(err.errors);
		                        }
		                        else {
		                            errors.push(err);
		                        }
		                    }
		                }
		            }
		        }
		        if (hasErrors) {
		            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
		        }
		    };
		    /**
		     * Adds a tear down to be called during the unsubscribe() of this
		     * Subscription.
		     *
		     * If the tear down being added is a subscription that is already
		     * unsubscribed, is the same reference `add` is being called on, or is
		     * `Subscription.EMPTY`, it will not be added.
		     *
		     * If this subscription is already in an `isUnsubscribed` state, the passed
		     * tear down logic will be executed immediately.
		     *
		     * @param {TeardownLogic} teardown The additional logic to execute on
		     * teardown.
		     * @return {Subscription} Returns the Subscription used or created to be
		     * added to the inner subscriptions list. This Subscription can be used with
		     * `remove()` to remove the passed teardown logic from the inner subscriptions
		     * list.
		     */
		    Subscription.prototype.add = function (teardown) {
		        if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {
		            return;
		        }
		        var sub = teardown;
		        switch (typeof teardown) {
		            case 'function':
		                sub = new Subscription(teardown);
		            case 'object':
		                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {
		                    break;
		                }
		                else if (this.isUnsubscribed) {
		                    sub.unsubscribe();
		                }
		                else {
		                    (this._subscriptions || (this._subscriptions = [])).push(sub);
		                }
		                break;
		            default:
		                throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');
		        }
		        return sub;
		    };
		    /**
		     * Removes a Subscription from the internal list of subscriptions that will
		     * unsubscribe during the unsubscribe process of this Subscription.
		     * @param {Subscription} subscription The subscription to remove.
		     * @return {void}
		     */
		    Subscription.prototype.remove = function (subscription) {
		        // HACK: This might be redundant because of the logic in `add()`
		        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
		            return;
		        }
		        var subscriptions = this._subscriptions;
		        if (subscriptions) {
		            var subscriptionIndex = subscriptions.indexOf(subscription);
		            if (subscriptionIndex !== -1) {
		                subscriptions.splice(subscriptionIndex, 1);
		            }
		        }
		    };
		    Subscription.EMPTY = (function (empty) {
		        empty.isUnsubscribed = true;
		        return empty;
		    }(new Subscription()));
		    return Subscription;
		}());
		exports.Subscription = Subscription;
		//# sourceMappingURL=Subscription.js.map
	
	/***/ },
	/* 128 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Observable_1 = __webpack_require__(22);
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @extends {Ignored}
		 * @hide true
		 */
		var EmptyObservable = (function (_super) {
		    __extends(EmptyObservable, _super);
		    function EmptyObservable(scheduler) {
		        _super.call(this);
		        this.scheduler = scheduler;
		    }
		    /**
		     * Creates an Observable that emits no items to the Observer and immediately
		     * emits a complete notification.
		     *
		     * <span class="informal">Just emits 'complete', and nothing else.
		     * </span>
		     *
		     * <img src="./img/empty.png" width="100%">
		     *
		     * This static operator is useful for creating a simple Observable that only
		     * emits the complete notification. It can be used for composing with other
		     * Observables, such as in a {@link mergeMap}.
		     *
		     * @example <caption>Emit the number 7, then complete.</caption>
		     * var result = Rx.Observable.empty().startWith(7);
		     * result.subscribe(x => console.log(x));
		     *
		     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
		     * var interval = Rx.Observable.interval(1000);
		     * var result = interval.mergeMap(x =>
		     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
		     * );
		     * result.subscribe(x => console.log(x));
		     *
		     * @see {@link create}
		     * @see {@link never}
		     * @see {@link of}
		     * @see {@link throw}
		     *
		     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
		     * the emission of the complete notification.
		     * @return {Observable} An "empty" Observable: emits only the complete
		     * notification.
		     * @static true
		     * @name empty
		     * @owner Observable
		     */
		    EmptyObservable.create = function (scheduler) {
		        return new EmptyObservable(scheduler);
		    };
		    EmptyObservable.dispatch = function (arg) {
		        var subscriber = arg.subscriber;
		        subscriber.complete();
		    };
		    EmptyObservable.prototype._subscribe = function (subscriber) {
		        var scheduler = this.scheduler;
		        if (scheduler) {
		            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
		        }
		        else {
		            subscriber.complete();
		        }
		    };
		    return EmptyObservable;
		}(Observable_1.Observable));
		exports.EmptyObservable = EmptyObservable;
		//# sourceMappingURL=EmptyObservable.js.map
	
	/***/ },
	/* 129 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var OuterSubscriber_1 = __webpack_require__(41);
		var subscribeToResult_1 = __webpack_require__(43);
		/**
		 * Projects each source value to an Observable which is merged in the output
		 * Observable, emitting values only from the most recently projected Observable.
		 *
		 * <span class="informal">Maps each value to an Observable, then flattens all of
		 * these inner Observables using {@link switch}.</span>
		 *
		 * <img src="./img/switchMap.png" width="100%">
		 *
		 * Returns an Observable that emits items based on applying a function that you
		 * supply to each item emitted by the source Observable, where that function
		 * returns an (so-called "inner") Observable. Each time it observes one of these
		 * inner Observables, the output Observable begins emitting the items emitted by
		 * that inner Observable. When a new inner Observable is emitted, `switchMap`
		 * stops emitting items from the earlier-emitted inner Observable and begins
		 * emitting items from the new one. It continues to behave like this for
		 * subsequent inner Observables.
		 *
		 * @example <caption>Rerun an interval Observable on every click event</caption>
		 * var clicks = Rx.Observable.fromEvent(document, 'click');
		 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
		 * result.subscribe(x => console.log(x));
		 *
		 * @see {@link concatMap}
		 * @see {@link exhaustMap}
		 * @see {@link mergeMap}
		 * @see {@link switch}
		 * @see {@link switchMapTo}
		 *
		 * @param {function(value: T, ?index: number): Observable} project A function
		 * that, when applied to an item emitted by the source Observable, returns an
		 * Observable.
		 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
		 * A function to produce the value on the output Observable based on the values
		 * and the indices of the source (outer) emission and the inner Observable
		 * emission. The arguments passed to this function are:
		 * - `outerValue`: the value that came from the source
		 * - `innerValue`: the value that came from the projected Observable
		 * - `outerIndex`: the "index" of the value that came from the source
		 * - `innerIndex`: the "index" of the value from the projected Observable
		 * @return {Observable} An Observable that emits the result of applying the
		 * projection function (and the optional `resultSelector`) to each item emitted
		 * by the source Observable and taking only the values from the most recently
		 * projected inner Observable.
		 * @method switchMap
		 * @owner Observable
		 */
		function switchMap(project, resultSelector) {
		    return this.lift(new SwitchMapOperator(project, resultSelector));
		}
		exports.switchMap = switchMap;
		var SwitchMapOperator = (function () {
		    function SwitchMapOperator(project, resultSelector) {
		        this.project = project;
		        this.resultSelector = resultSelector;
		    }
		    SwitchMapOperator.prototype.call = function (subscriber, source) {
		        return source._subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
		    };
		    return SwitchMapOperator;
		}());
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var SwitchMapSubscriber = (function (_super) {
		    __extends(SwitchMapSubscriber, _super);
		    function SwitchMapSubscriber(destination, project, resultSelector) {
		        _super.call(this, destination);
		        this.project = project;
		        this.resultSelector = resultSelector;
		        this.index = 0;
		    }
		    SwitchMapSubscriber.prototype._next = function (value) {
		        var result;
		        var index = this.index++;
		        try {
		            result = this.project(value, index);
		        }
		        catch (error) {
		            this.destination.error(error);
		            return;
		        }
		        this._innerSub(result, value, index);
		    };
		    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
		        var innerSubscription = this.innerSubscription;
		        if (innerSubscription) {
		            innerSubscription.unsubscribe();
		        }
		        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
		    };
		    SwitchMapSubscriber.prototype._complete = function () {
		        var innerSubscription = this.innerSubscription;
		        if (!innerSubscription || innerSubscription.isUnsubscribed) {
		            _super.prototype._complete.call(this);
		        }
		    };
		    SwitchMapSubscriber.prototype._unsubscribe = function () {
		        this.innerSubscription = null;
		    };
		    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
		        this.remove(innerSub);
		        this.innerSubscription = null;
		        if (this.isStopped) {
		            _super.prototype._complete.call(this);
		        }
		    };
		    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
		        if (this.resultSelector) {
		            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
		        }
		        else {
		            this.destination.next(innerValue);
		        }
		    };
		    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
		        var result;
		        try {
		            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
		        }
		        catch (err) {
		            this.destination.error(err);
		            return;
		        }
		        this.destination.next(result);
		    };
		    return SwitchMapSubscriber;
		}(OuterSubscriber_1.OuterSubscriber));
		//# sourceMappingURL=switchMap.js.map
	
	/***/ },
	/* 130 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var root_1 = __webpack_require__(89);
		var Symbol = root_1.root.Symbol;
		exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
		    Symbol.for('rxSubscriber') : '@@rxSubscriber';
		//# sourceMappingURL=rxSubscriber.js.map
	
	/***/ },
	/* 131 */
	/***/ function(module, exports) {
	
		"use strict";
		// typeof any so that it we don't have to cast when comparing a result to the error object
		exports.errorObject = { e: {} };
		//# sourceMappingURL=errorObject.js.map
	
	/***/ },
	/* 132 */
	/***/ function(module, exports) {
	
		module.exports = function(module) {
			if(!module.webpackPolyfill) {
				module.deprecate = function() {};
				module.paths = [];
				// module.parent = undefined by default
				module.children = [];
				module.webpackPolyfill = 1;
			}
			return module;
		}
	
	
	/***/ },
	/* 133 */,
	/* 134 */,
	/* 135 */,
	/* 136 */,
	/* 137 */,
	/* 138 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.Field = undefined;
		
		var _Field = __webpack_require__(25);
		
		Object.defineProperty(exports, 'Field', {
		  enumerable: true,
		  get: function get() {
		    return _Field.Field;
		  }
		});
		
		__webpack_require__(206);
		
		__webpack_require__(211);
		
		__webpack_require__(208);
		
		__webpack_require__(210);
		
		__webpack_require__(207);
		
		__webpack_require__(209);
	
	/***/ },
	/* 139 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _TypedModule = __webpack_require__(31);
		
		var _TypedModule2 = _interopRequireDefault(_TypedModule);
		
		var _resources = __webpack_require__(16);
		
		var _resources2 = _interopRequireDefault(_resources);
		
		var _typed = __webpack_require__(27);
		
		var _typed2 = _interopRequireDefault(_typed);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _TypedModule2.default.create('groups', [_resources2.default, _typed2.default], function (M, _ref) {
			var IsRelatedTo = _ref.IsRelatedTo;
			var Template = _ref.Template;
			var PullsIntoTypeDefinition = _ref.PullsIntoTypeDefinition;
		
		
			var Group = M.TYPED_RESOURCE({ /////////////////////////////////////////
		
				name: 'Group',
		
				extends: Template,
		
				singular: "group"
		
			}); /////////////////////////////////////////////////////////////////////////////
		
		
			var IncludesElement = M.RELATIONSHIP({
		
				name: 'IncludesElement',
		
				extends: PullsIntoTypeDefinition,
		
				singular: "includes element",
		
				1: [Group, '0..*', { anchors: true, key: 'elements' }],
				2: [Template, '0..*']
		
			});
		});
	
	/***/ },
	/* 140 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.event = exports.property = exports.default = undefined;
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _templateObject = _taggedTemplateLiteral(['\n\t\t\t\t\tBut there is an event with that name, so\n\t\t\t\t\tyou could use .e(\'', '\')\n\t\t\t\t'], ['\n\t\t\t\t\tBut there is an event with that name, so\n\t\t\t\t\tyou could use .e(\'', '\')\n\t\t\t\t']),
		    _templateObject2 = _taggedTemplateLiteral(['\n\t\t\t\t\tNo property \'', '\' exists.\n\t\t\t\t\t', '\n\t\t\t\t'], ['\n\t\t\t\t\tNo property \'', '\' exists.\n\t\t\t\t\t', '\n\t\t\t\t']);
		
		var _includes = __webpack_require__(257);
		
		var _includes2 = _interopRequireDefault(_includes);
		
		var _isArray = __webpack_require__(146);
		
		var _isArray2 = _interopRequireDefault(_isArray);
		
		var _isString = __webpack_require__(148);
		
		var _isString2 = _interopRequireDefault(_isString);
		
		var _set = __webpack_require__(267);
		
		var _set2 = _interopRequireDefault(_set);
		
		var _entries = __webpack_require__(17);
		
		var _entries2 = _interopRequireDefault(_entries);
		
		var _isEqual2 = __webpack_require__(172);
		
		var _isEqual3 = _interopRequireDefault(_isEqual2);
		
		var _Subject = __webpack_require__(59);
		
		var _BehaviorSubject = __webpack_require__(126);
		
		var _never = __webpack_require__(420);
		
		var _combineLatest = __webpack_require__(182);
		
		var _distinctUntilChanged = __webpack_require__(422);
		
		var _filter = __webpack_require__(29);
		
		var _takeUntil = __webpack_require__(187);
		
		var _skip = __webpack_require__(424);
		
		var _map = __webpack_require__(42);
		
		var _withLatestFrom = __webpack_require__(426);
		
		__webpack_require__(23);
		
		var _misc = __webpack_require__(3);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		function _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var $$events = Symbol('$$events');
		var $$properties = Symbol('$$properties');
		var $$settableProperties = Symbol('$$settableProperties');
		var $$initialize = Symbol('$$initialize');
		var $$takeUntil = Symbol('$$takeUntil');
		var $$filterBy = Symbol('$$filterBy');
		var $$currentValues = Symbol('$$currentValues');
		
		/**
		 * Use this as a subclass (or just mix it in) to provide support for
		 * events and observable properties through Kefir.js.
		 *
		 * @export
		 * @class ValueTracker
		 */
		
		var ValueTracker = function () {
			_createClass(ValueTracker, [{
				key: $$initialize,
				value: function value() {
					if (this[$$events]) {
						return;
					}
					this[$$events] = {};
					this[$$properties] = {};
					this[$$settableProperties] = {};
					this[$$currentValues] = {};
		
					/* add the events and properties added with ES7 annotations */
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;
		
					try {
						for (var _iterator = (_context = this.constructor[$$events] || {}, _entries2.default).call(_context)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var _context;
		
							var _step$value = _slicedToArray(_step.value, 2);
		
							var key = _step$value[0];
							var options = _step$value[1];
		
							this.newEvent(key, options);
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
		
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;
		
					try {
						for (var _iterator2 = (_context2 = this.constructor[$$properties] || {}, _entries2.default).call(_context2)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var _context2;
		
							var _step2$value = _slicedToArray(_step2.value, 2);
		
							var key = _step2$value[0];
							var options = _step2$value[1];
		
							this.newProperty(key, options);
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
				}
			}]);
		
			function ValueTracker() {
				_classCallCheck(this, ValueTracker);
		
				this[$$takeUntil] = (0, _never.never)();
				this[$$filterBy] = function () {
					return true;
				};
			}
		
			_createClass(ValueTracker, [{
				key: 'setValueTrackerOptions',
				value: function setValueTrackerOptions(_ref) {
					var _ref$takeUntil = _ref.takeUntil;
					var takeUntil = _ref$takeUntil === undefined ? (0, _never.never)() : _ref$takeUntil;
					var _ref$filterBy = _ref.filterBy;
					var filterBy = _ref$filterBy === undefined ? function () {
						return true;
					} : _ref$filterBy;
		
					this[$$takeUntil] = takeUntil;
					this[$$filterBy] = filterBy;
					this[$$initialize]();
				}
		
				/**
		   * Declares a new event stream for this object.
		   *
		   * @public
		   * @method
		   * @param  {String} name - the name of the event, used to trigger or subscribe to it
		   * @return {Subject} - the created event stream
		   */
		
			}, {
				key: 'newEvent',
				value: function newEvent(name) {
					var _context3;
		
					var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		
					_objectDestructuringEmpty(_ref2);
		
					this[$$initialize]();
		
					/* is the event name already taken? */
					(0, _misc.constraint)(!this[$$events][name], 'There is already an event \'' + name + '\' on this object.');
					(0, _misc.constraint)(!this[$$properties][name], 'There is already a property \'' + name + '\' on this object.');
		
					this[$$events][name] = (_context3 = (_context3 = new _Subject.Subject(), _takeUntil.takeUntil).call(_context3, this[$$takeUntil]), _filter.filter).call(_context3, this[$$filterBy]);
		
					return this[$$events][name];
				}
		
				/**
		   * This method defines a new property on this object.
		   *
		   * @public
		   * @method
		   * @param  {String}                   name            - the name of the new property
		   * @param  {Boolean}                 [readonly=false] - whether the value can be manually set
		   * @param  {function(*,*):Boolean}   [isEqual]        - a predicate function by which to test for duplicate values
		   * @param  {function(*):Boolean}     [isValid]        - a predicate function to validate a given value
		   * @param  {*}                       [initial]        - the initial value of this property
		   *
		   * @return {BehaviorSubject} - the property associated with the given name
		   */
		
			}, {
				key: 'newProperty',
				value: function newProperty(name) {
					var _context4,
					    _this = this;
		
					var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		
					var _ref3$readonly = _ref3.readonly;
					var readonly = _ref3$readonly === undefined ? false : _ref3$readonly;
					var _ref3$isEqual = _ref3.isEqual;
					var isEqual = _ref3$isEqual === undefined ? _isEqual3.default : _ref3$isEqual;
					var _ref3$isValid = _ref3.isValid;
					var isValid = _ref3$isValid === undefined ? function () {
						return true;
					} : _ref3$isValid;
					var initial = _ref3.initial;
		
					this[$$initialize]();
		
					/* is the property name already taken? */
					(0, _misc.constraint)(!this[$$events][name], 'There is already an event \'' + name + '\' on this object.');
					(0, _misc.constraint)(!this[$$properties][name], 'There is already a property \'' + name + '\' on this object.');
		
					/* if isValid is an array, check for inclusion */
					if ((_context4 = isValid, _isArray2.default).call(_context4)) {
						var _context5;
		
						isValid = (_context5 = isValid, _includes2.default).bind(_context5);
					}
		
					/* define the bus which manages the property */
					var subject = this[$$settableProperties][name] = (_context4 = (_context4 = (_context4 = (_context4 = new _BehaviorSubject.BehaviorSubject(initial), _filter.filter).call(_context4, this[$$filterBy]), _filter.filter).call(_context4, isValid.bind(this)), _takeUntil.takeUntil).call(_context4, this[$$takeUntil]), _distinctUntilChanged.distinctUntilChanged).call(_context4, isEqual.bind(this));
					this[$$properties][name] = readonly ? subject.asObservable() : subject;
		
					/* keep track of current value */
					this[$$properties][name].subscribe(function (v) {
						_this[$$currentValues][name] = v;
					});
		
					/* create event version of the property */
					this[$$events][name] = (_context4 = subject.asObservable(), _skip.skip).call(_context4, 1); // skip 'current value' on subscribe
		
					/* return property */
					return this[$$settableProperties][name];
				}
		
				/**
		   * Retrieve an event stream by name. If the name of a property is given, a stream
		   * based on changes to that property is returned.
		   *
		   * @public
		   * @method
		   * @param  {String}  name - the name of the event stream to retrieve
		   * @return {Observable} - the event stream associated with the given name
		   */
		
			}, {
				key: 'e',
				value: function e(name) {
					this[$$initialize]();
					return this[$$events][name] || (0, _never.never)();
				}
		
				/**
		   * Retrieve a property by name.
		   *
		   * @public
		   * @method
		   * @param  {String|Array} nameOrDeps          - the name of the property to retrieve, or a list of active dependencies for a derived property
		   * @param  {Array?}       optionalPassiveDeps - an optional list of passive dependencies for a derived property
		   * @param  {Function?}    optionalTransformer - an optional function to map the dependencies to a new value for the derived property
		   * @return {BehaviorSubject | Observable} - the property associated with the given name or an observable of combined properties
		   */
		
			}, {
				key: 'p',
				value: function p(nameOrDeps) {
					var optionalPassiveDeps = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
					var optionalTransformer = arguments.length <= 2 || arguments[2] === undefined ? function () {
						for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
							args[_key] = arguments[_key];
						}
		
						return args;
					} : arguments[2];
		
					this[$$initialize]();
					if (_isArray2.default.call(nameOrDeps)) {
						var _context6, _ref4;
		
						return (_ref4 = (_context6 = _combineLatest.combineLatest.apply(undefined, _toConsumableArray(nameOrDeps.map(this.p.bind(this)))), _withLatestFrom.withLatestFrom)).call.apply(_ref4, [_context6].concat(_toConsumableArray(optionalPassiveDeps.map(this.p.bind(this))), [// TODO: withLatestFrom doesn't work; provides old values
						function (active) {
							for (var _len2 = arguments.length, passive = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
								passive[_key2 - 1] = arguments[_key2];
							}
		
							return optionalTransformer.apply(undefined, _toConsumableArray(active).concat(passive));
						}]));
					} else if (_isString2.default.call(nameOrDeps)) {
						if (!this[$$properties][nameOrDeps]) {
							var butEventExists = this[$$events][nameOrDeps] ? (0, _misc.humanMsg)(_templateObject, nameOrDeps) : '';
							throw new Error((0, _misc.humanMsg)(_templateObject2, nameOrDeps, butEventExists));
						}
						return this[$$properties][nameOrDeps];
					}
				}
		
				/**
		   * Retrieve a property by name. This returns as a Subject
		   * regardless of 'readonly' option, only to be used by
		   * the 'owner' of the property.
		   *
		   * @public
		   * @method
		   * @param  {String} name     - the name of the property to retrieve
		   * @return {BehaviorSubject} - the property associated with the given name
		   */
		
			}, {
				key: 'pSubject',
				value: function pSubject(name) {
					this[$$initialize]();
					return this[$$settableProperties][name];
				}
			}]);
		
			return ValueTracker;
		}();
		
		exports.default = ValueTracker;
		;
		
		var property = exports.property = function property() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
			return function (target, key) {
				_set2.default.call(target, ['constructor', $$properties, key], options);
				return _extends({
					get: function get() {
						return this[$$currentValues][key];
					}
				}, !options.readonly && {
					set: function set(value) {
						this.p(key).next(value);
					}
				});
			};
		};
		
		var event = exports.event = function event() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
			return function (target, key) {
				var match = key.match(/^(\w+)Event$/);
				(0, _misc.constraint)(match, '@event() decorators require a name that ends in \'Event\'.');
				var name = match[1];
				_set2.default.call(target, ['constructor', $$events, name], options);
				return {
					get: function get() {
						return this.e(name);
					}
				};
			};
		};
	
	/***/ },
	/* 141 */,
	/* 142 */,
	/* 143 */
	/***/ function(module, exports, __webpack_require__) {
	
		(function webpackUniversalModuleDefinition(root, factory) {
			if(true)
				module.exports = factory();
			else if(typeof define === 'function' && define.amd)
				define([], factory);
			else if(typeof exports === 'object')
				exports["Graph"] = factory();
			else
				root["Graph"] = factory();
		})(this, function() {
		return /******/ (function(modules) { // webpackBootstrap
		/******/ 	// The module cache
		/******/ 	var installedModules = {};
		/******/
		/******/ 	// The require function
		/******/ 	function __webpack_require__(moduleId) {
		/******/
		/******/ 		// Check if module is in cache
		/******/ 		if(installedModules[moduleId])
		/******/ 			return installedModules[moduleId].exports;
		/******/
		/******/ 		// Create a new module (and put it into the cache)
		/******/ 		var module = installedModules[moduleId] = {
		/******/ 			exports: {},
		/******/ 			id: moduleId,
		/******/ 			loaded: false
		/******/ 		};
		/******/
		/******/ 		// Execute the module function
		/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		/******/
		/******/ 		// Flag the module as loaded
		/******/ 		module.loaded = true;
		/******/
		/******/ 		// Return the exports of the module
		/******/ 		return module.exports;
		/******/ 	}
		/******/
		/******/
		/******/ 	// expose the modules object (__webpack_modules__)
		/******/ 	__webpack_require__.m = modules;
		/******/
		/******/ 	// expose the module cache
		/******/ 	__webpack_require__.c = installedModules;
		/******/
		/******/ 	// __webpack_public_path__
		/******/ 	__webpack_require__.p = "";
		/******/
		/******/ 	// Load entry module and return exports
		/******/ 	return __webpack_require__(0);
		/******/ })
		/************************************************************************/
		/******/ ({
		
		/***/ 0:
		/***/ function(module, exports, __webpack_require__) {
		
			module.exports = __webpack_require__(49);
		
		
		/***/ },
		
		/***/ 49:
		/***/ function(module, exports) {
		
			'use strict';
			
			//  ////////////////////////////////////////////////////////////////////////////////////////////////
			//  // Symbols for private members /////////////////////////////////////////////////////////////////
			//  ////////////////////////////////////////////////////////////////////////////////////////////////
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var _bind = Function.prototype.bind;
			
			var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();
			
			var _get = function get(_x9, _x10, _x11) { var _again = true; _function: while (_again) { var object = _x9, property = _x10, receiver = _x11; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x9 = parent; _x10 = property; _x11 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
			
			var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
			
			function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }
			
			function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
			
			function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
			
			var _vertices = Symbol("vertices");
			var _edges = Symbol("edges");
			var _reverseEdges = Symbol("reverse edges");
			var _sources = Symbol("sources");
			var _sinks = Symbol("sinks");
			var _edgeCount = Symbol("edge count");
			
			var _listeners = Symbol("listeners");
			var _trigger = Symbol("trigger");
			
			var _verticesFrom = Symbol("vertices from");
			var _verticesTo = Symbol("vertices to");
			var _verticesWithPathTo = Symbol("vertices with path to");
			var _verticesWithPathFrom = Symbol("vertices with path from");
			var _paths = Symbol("paths");
			
			var _expectVertices = Symbol("expect vertices");
			var _expectVerticesAbsent = Symbol("expect vertex absent");
			var _expectEdges = Symbol("expect edge");
			var _expectEdgesAbsent = Symbol("expect edge absent");
			var _expectNoConnectedEdges = Symbol("expect no connected edges");
			
			//  ////////////////////////////////////////////////////////////////////////////////////////////////
			//  // Graph class /////////////////////////////////////////////////////////////////////////////////
			//  ////////////////////////////////////////////////////////////////////////////////////////////////
			
			/**
			 * @class Graph
			 * @classdesc The main class of this library, to be used for representing a mathematical (di)graph.
			 *
			 * @description Constructor arguments can be used to supply initial vertices and edges.
			 * @param ...parts {Array.<Array>}
			 *        a short notation for vertices and edges to initially add to the graph;
			 *        A vertex should be an array of the form `[key, value]`.
			 *        An edge should be an array of the form `[[from, to], value]`.
			 *        Later values of vertices or edges in this list will overwrite earlier
			 *        values, but vertices need not precede their edges. Vertices that are
			 *        connected but store no value need not be listed at all.
			 * @example
			 * var map = new Graph(
			 *     ['Amsterdam',             { population: 825000 }], // vertex
			 *     ['Leiden',                { population: 122000 }], // vertex
			 *     [['Amsterdam', 'Leiden'], { distance:   "40km" }]  // edge
			 * );
			 */
			
			var Graph = (function () {
				function Graph() {
					_classCallCheck(this, Graph);
			
					/* storage */
					this[_vertices] = new Map(); // Map.< string, * >
					this[_edges] = new Map(); // Map.< string, Map.<string, *> >
			
					/* bookkeeping */
					this[_reverseEdges] = new Map(); // Map.< string, Set.<*> >
					this[_sources] = new Set(); // Set.< string >
					this[_sinks] = new Set(); // Set.< string >
					this[_edgeCount] = 0;
			
					/* listeners */
					this[_listeners] = new Map();
			
					/* add vertices and values from constructor arguments */
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;
			
					try {
						for (var _len = arguments.length, parts = Array(_len), _key = 0; _key < _len; _key++) {
							parts[_key] = arguments[_key];
						}
			
						for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var _step$value = _slicedToArray(_step.value, 2);
			
							var key = _step$value[0];
							var value = _step$value[1];
			
							if (Array.isArray(key)) {
								/////////////// an edge
			
								var _key2 = _slicedToArray(key, 2);
			
								var from = _key2[0];
								var to = _key2[1];
			
								this.createEdge(from, to, value);
							} else {
								//////////////////////////////// a vertex
								this.addVertex(key, value);
							}
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator["return"]) {
								_iterator["return"]();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
				}
			
				//  ////////////////////////////////////////////////////////////////////////////////////////////////
				//  // Errors //////////////////////////////////////////////////////////////////////////////////////
				//  ////////////////////////////////////////////////////////////////////////////////////////////////
			
				/**
			  * @class
			  * @classdesc This type of error is thrown when specific vertices are expected not to exist, but do.
			  * @extends Error
			  */
			
				/////////////////////////////////////
				////////// Event Handling //////////
				/////////////////////////////////////
			
				/**
			  * Register an event handler.
			  * @param event   {string}   the event to listen for
			  * @param handler {Function} the function to call for each such event fired, receiving its corresponding value
			  */
			
				_createClass(Graph, [{
					key: "on",
					value: function on(event, handler) {
						if (!this[_listeners].has(event)) {
							this[_listeners].set(event, new Set());
						}
						this[_listeners].get(event).add(handler);
					}
			
					/**
			   * Deregister a previously registered event handler.
			   * @param event   {string}   the event used to originally register a handler
			   * @param handler {Function} the handler originally registered
			   */
				}, {
					key: "off",
					value: function off(event, handler) {
						if (this[_listeners].has(event)) {
							this[_listeners].get(event)["delete"](handler);
						}
					}
				}, {
					key: _trigger,
					value: function value(event, _value) {
						var _iteratorNormalCompletion2 = true;
						var _didIteratorError2 = false;
						var _iteratorError2 = undefined;
			
						try {
							for (var _iterator2 = (this[_listeners].get(event) || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
								var handler = _step2.value;
			
								handler(_value);
							}
						} catch (err) {
							_didIteratorError2 = true;
							_iteratorError2 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
									_iterator2["return"]();
								}
							} finally {
								if (_didIteratorError2) {
									throw _iteratorError2;
								}
							}
						}
					}
			
					/**
			   * An event that is triggered just after a vertex is added to this graph.
			   * Handlers receive the new vertex `[key, value]` as an argument.
			   * @event vertex-added
			   * @memberof Graph
			   * @instance
			   * @see {@link Graph#on}
			   * @see {@link Graph#off}
			   */
					/**
			   * An event that is triggered just after a vertex is removed from this graph.
			   * Handlers receive the vertex key as an argument.
			   * @event vertex-removed
			   * @memberof Graph
			   * @instance
			   * @see {@link Graph#on}
			   * @see {@link Graph#off}
			   */
					/**
			   * An event that is triggered after a vertex in this graph is modified.
			   * It is also triggered after any {@link #Graph#event_vertex-added|"vertex-added"} event.
			   * Handlers receive the vertex `[key, value]` as an argument.
			   * @event vertex-modified
			   * @memberof Graph
			   * @instance
			   * @see {@link Graph#on}
			   * @see {@link Graph#off}
			   */
					/**
			   * An event that is triggered just after an edge is added to this graph.
			   * Handlers receive the new edge `[[from, to], value]` as an argument.
			   * @event edge-added
			   * @memberof Graph
			   * @instance
			   * @see {@link Graph#on}
			   * @see {@link Graph#off}
			   */
					/**
			   * An event that is triggered just after an edge is removed from this graph.
			   * Handlers receive the edge key `[from, to]` as an argument.
			   * @event edge-removed
			   * @memberof Graph
			   * @instance
			   * @see {@link Graph#on}
			   * @see {@link Graph#off}
			   */
					/**
			   * An event that is triggered after an edge in this graph is modified.
			   * It is also triggered after any {@link #Graph#event_edge-added|"edge-added"} event.
			   * Handlers receive the edge `[[from, to], value]` as an argument.
			   * @event edge-modified
			   * @memberof Graph
			   * @instance
			   * @see {@link Graph#on}
			   * @see {@link Graph#off}
			   */
			
					//////////////////////////////
					////////// Vertices //////////
					//////////////////////////////
			
					////////// creating them //////////
			
					/**
			   * Add a new vertex to this graph.
			   * @throws {Graph.VertexExistsError} if a vertex with this key already exists
			   * @param  key    {string} the key with which to refer to this new vertex
			   * @param [value] {*}      the value to store in this new vertex
			   */
				}, {
					key: "addNewVertex",
					value: function addNewVertex(key, value) {
						this[_expectVerticesAbsent](key);
						this[_vertices].set(key, value);
						this[_edges].set(key, new Map());
						this[_reverseEdges].set(key, new Set());
						this[_sources].add(key);
						this[_sinks].add(key);
						this[_trigger]('vertex-added', [key, value]);
						this[_trigger]('vertex-modified', [key, value]);
					}
			
					/**
			   * Set the value of an existing vertex in this graph.
			   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
			   * @param  key    {string} the key belonging to the vertex
			   * @param [value] {*}      the value to store in this vertex
			   */
				}, {
					key: "setVertex",
					value: function setVertex(key, value) {
						this[_expectVertices](key);
						this[_vertices].set(key, value);
						this[_trigger]('vertex-modified', [key, value]);
					}
			
					/**
			   * Make sure a vertex with a specific key exists in this graph. If it already exists,
			   * do nothing. If it does not yet exist, add a new vertex with the given value.
			   * @param  key    {string} the key for the vertex
			   * @param [value] {*}      the value to store if a new vertex is added
			   */
				}, {
					key: "ensureVertex",
					value: function ensureVertex(key, value) {
						if (!this.hasVertex(key)) {
							this.addNewVertex(key, value);
						}
					}
			
					/**
			   * Add a new vertex to this graph. If a vertex with this key already exists,
			   * the value of that vertex is overwritten.
			   * @param  key    {string} the key with which to refer to this new vertex
			   * @param [value] {*}      the value to store in this new vertex
			   */
				}, {
					key: "addVertex",
					value: function addVertex(key, value) {
						if (this.hasVertex(key)) {
							this.setVertex(key, value);
						} else {
							this.addNewVertex(key, value);
						}
					}
			
					////////// removing them //////////
			
					/**
			   * Remove an existing vertex from this graph.
			   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
			   * @throws {Graph.HasConnectedEdgesError} if there are still edges connected to this vertex
			   * @param key {string} the key of the vertex to remove
			   */
				}, {
					key: "removeExistingVertex",
					value: function removeExistingVertex(key) {
						this[_expectVertices](key);
						this[_expectNoConnectedEdges](key);
						this[_vertices]["delete"](key);
						this[_sources]["delete"](key);
						this[_sinks]["delete"](key);
						this[_trigger]('vertex-removed', key);
					}
			
					/**
			   * Remove an existing vertex from this graph, as well as all edges connected to it.
			   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
			   * @param key {string} the key of the vertex to remove
			   */
				}, {
					key: "destroyExistingVertex",
					value: function destroyExistingVertex(key) {
						this[_expectVertices](key);
						var _iteratorNormalCompletion3 = true;
						var _didIteratorError3 = false;
						var _iteratorError3 = undefined;
			
						try {
							for (var _iterator3 = this.verticesFrom(key)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
								var _step3$value = _slicedToArray(_step3.value, 1);
			
								var to = _step3$value[0];
								this.removeEdge(key, to);
							}
						} catch (err) {
							_didIteratorError3 = true;
							_iteratorError3 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
									_iterator3["return"]();
								}
							} finally {
								if (_didIteratorError3) {
									throw _iteratorError3;
								}
							}
						}
			
						var _iteratorNormalCompletion4 = true;
						var _didIteratorError4 = false;
						var _iteratorError4 = undefined;
			
						try {
							for (var _iterator4 = this.verticesTo(key)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
								var _step4$value = _slicedToArray(_step4.value, 1);
			
								var from = _step4$value[0];
								this.removeEdge(from, key);
							}
						} catch (err) {
							_didIteratorError4 = true;
							_iteratorError4 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
									_iterator4["return"]();
								}
							} finally {
								if (_didIteratorError4) {
									throw _iteratorError4;
								}
							}
						}
			
						this.removeExistingVertex(key);
					}
			
					/**
			   * Remove an existing vertex from this graph.
			   * If a vertex with this key does not exist, nothing happens.
			   * @throws {Graph.HasConnectedEdgesError} if there are still edges connected to this vertex
			   * @param key {string} the key of the vertex to remove
			   */
				}, {
					key: "removeVertex",
					value: function removeVertex(key) {
						if (this.hasVertex(key)) {
							this.removeExistingVertex(key);
						}
					}
			
					/**
			   * Remove a vertex from this graph, as well as all edges connected to it.
			   * If a vertex with this key does not exist, nothing happens.
			   * @param key {string} the key of the vertex to remove
			   */
				}, {
					key: "destroyVertex",
					value: function destroyVertex(key) {
						if (this.hasVertex(key)) {
							this.destroyExistingVertex(key);
						}
					}
			
					////////// querying them //////////
			
					/**
			   * @returns {number} the number of vertices in the whole graph
			   */
				}, {
					key: "vertexCount",
					value: function vertexCount() {
						return this[_vertices].size;
					}
			
					/**
			   * Ask whether a vertex with a given key exists.
			   * @param key {string} the key to query
			   * @returns {boolean} whether there is a vertex with the given key
			   */
				}, {
					key: "hasVertex",
					value: function hasVertex(key) {
						return this[_vertices].has(key);
					}
			
					/**
			   * Get the value associated with the vertex of a given key.
			   * @param key {string} the key to query
			   * @returns {*} the value associated with the vertex of the given key.
			   * Note that a return value of `undefined` can mean
			   *
			   * 1. that there is no such vertex, or
			   * 2. that the stored value is actually `undefined`.
			   *
			   * Use {@link Graph#hasVertex} to distinguish these cases.
			   */
				}, {
					key: "vertexValue",
					value: function vertexValue(key) {
						return this[_vertices].get(key);
					}
			
					///////////////////////////
					////////// Edges //////////
					///////////////////////////
			
					////////// adding them //////////
			
					/**
			   * Add a new edge to this graph.
			   * @throws {Graph.EdgeExistsError} if an edge between `from` and `to` already exists
			   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
			   * @param  from   {string} the key for the originating vertex
			   * @param  to     {string} the key for the terminating vertex
			   * @param [value] {*}      the value to store in this new edge
			   */
				}, {
					key: "addNewEdge",
					value: function addNewEdge(from, to, value) {
						this[_expectEdgesAbsent]([from, to]);
						this[_expectVertices](from, to);
						this[_edges].get(from).set(to, value);
						this[_reverseEdges].get(to).add(from);
						this[_edgeCount] += 1;
						this[_sources]["delete"](to);
						this[_sinks]["delete"](from);
						this[_trigger]('edge-added', [[from, to], value]);
						this[_trigger]('edge-modified', [[from, to], value]);
					}
			
					/**
			   * Add a new edge to this graph. If the `from` and/or `to` vertices do not yet exist
			   * in the graph, they are implicitly added with an `undefined` value.
			   * @throws {Graph.EdgeExistsError} if an edge between `from` and `to` already exists
			   * @param  from   {string} the key for the originating vertex
			   * @param  to     {string} the key for the terminating vertex
			   * @param [value] {*}      the value to store in this new edge
			   */
				}, {
					key: "createNewEdge",
					value: function createNewEdge(from, to, value) {
						this[_expectEdgesAbsent]([from, to]);
						this.ensureVertex(from);
						this.ensureVertex(to);
						this.addNewEdge(from, to, value);
					}
			
					/**
			   * Set the value of an existing edge in this graph.
			   * @throws {Graph.EdgeNotExistsError} if an edge between `from` and `to` does not yet exist
			   * @param  from   {string} the key for the originating vertex
			   * @param  to     {string} the key for the terminating vertex
			   * @param [value] {*}      the value to store in this edge
			   */
				}, {
					key: "setEdge",
					value: function setEdge(from, to, value) {
						this[_expectEdges]([from, to]);
						this[_edges].get(from).set(to, value);
						this[_trigger]('edge-modified', [[from, to], value]);
					}
			
					/**
			   * Make sure an edge between the `from` and `to` vertices in this graph.
			   * If one already exists, nothing is done.
			   * If one does not yet exist, a new edge is added with the given value.
			   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
			   * @param  from   {string} the key for the originating vertex
			   * @param  to     {string} the key for the terminating vertex
			   * @param [value] {*}      the value to store if a new edge is added
			   */
				}, {
					key: "spanEdge",
					value: function spanEdge(from, to, value) {
						this[_expectVertices](from, to);
						if (!this.hasEdge(from, to)) {
							this.addNewEdge(from, to, value);
						}
					}
			
					/**
			   * Add a new edge to this graph. If an edge between `from` and `to` already exists,
			   * the value of that edge is overwritten.
			   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
			   * @param  from   {string} the key for the originating vertex
			   * @param  to     {string} the key for the terminating vertex
			   * @param [value] {*}      the value to store in this new edge
			   */
				}, {
					key: "addEdge",
					value: function addEdge(from, to, value) {
						if (this.hasEdge(from, to)) {
							this.setEdge(from, to, value);
						} else {
							this.addNewEdge(from, to, value);
						}
					}
			
					/**
			   * Make sure an edge between the `from` and `to` vertices exists in this graph.
			   * If it already exists, nothing is done.
			   * If it does not yet exist, a new edge is added with the given value.
			   * If the `from` and/or `to` vertices do not yet exist
			   * in the graph, they are implicitly added with an `undefined` value.
			   * @param  from   {string} the key for the originating vertex
			   * @param  to     {string} the key for the terminating vertex
			   * @param [value] {*}      the value to store if a new edge is added
			   */
				}, {
					key: "ensureEdge",
					value: function ensureEdge(from, to, value) {
						if (!this.hasEdge(from, to)) {
							this.createNewEdge(from, to, value);
						}
					}
			
					/**
			   * Add a new edge to this graph. If an edge between the `from` and `to`
			   * vertices already exists, the value of that edge is overwritten.
			   * If the `from` and/or `to` vertices do not yet exist
			   * in the graph, they are implicitly added with an `undefined` value.
			   * @param  from   {string} the key for the originating vertex
			   * @param  to     {string} the key for the terminating vertex
			   * @param [value] {*}      the value to store if a new edge is added
			   */
				}, {
					key: "createEdge",
					value: function createEdge(from, to, value) {
						if (this.hasEdge(from, to)) {
							this.setEdge(from, to, value);
						} else {
							this.createNewEdge(from, to, value);
						}
					}
			
					////////// removing them //////////
			
					/**
			   * Remove an existing edge from this graph.
			   * @throws {Graph.EdgeNotExistsError} if an edge between the `from` and `to` vertices doesn't exist
			   * @param from {string} the key for the originating vertex
			   * @param to   {string} the key for the terminating vertex
			   */
				}, {
					key: "removeExistingEdge",
					value: function removeExistingEdge(from, to) {
						this[_expectEdges]([from, to]);
						this[_edges].get(from)["delete"](to);
						this[_reverseEdges].get(to)["delete"](from);
						this[_edgeCount] -= 1;
						if (this.inDegree(to) === 0) {
							this[_sources].add(to);
						}
						if (this.outDegree(from) === 0) {
							this[_sinks].add(from);
						}
						this[_trigger]('edge-removed', [from, to]);
					}
			
					/**
			   * Remove an edge from this graph.
			   * If an edge between the `from` and `to` vertices doesn't exist, nothing happens.
			   * @param from {string} the key for the originating vertex
			   * @param to   {string} the key for the terminating vertex
			   */
				}, {
					key: "removeEdge",
					value: function removeEdge(from, to) {
						if (this.hasEdge(from, to)) {
							this.removeExistingEdge(from, to);
						}
					}
			
					////////// querying them //////////
			
					/**
			   * @returns {number} the number of edges in the whole graph
			   */
				}, {
					key: "edgeCount",
					value: function edgeCount() {
						return this[_edgeCount];
					}
			
					/**
			   * Ask whether an edge between given `from` and `to` vertices exist.
			   * @param from {string} the key for the originating vertex
			   * @param to   {string} the key for the terminating vertex
			   * @returns {boolean} whether there is an edge between the given `from` and `to` vertices
			   */
				}, {
					key: "hasEdge",
					value: function hasEdge(from, to) {
						return this.hasVertex(from) && this.hasVertex(to) && this[_edges].has(from) && this[_edges].get(from).has(to);
					}
			
					/**
			   * Get the value associated with the edge between given `from` and `to` vertices.
			   * @param from {string} the key for the originating vertex
			   * @param to   {string} the key for the terminating vertex
			   * @returns {*} the value associated with the edge between the given `from` and `to` vertices
			   * Note that a return value of `undefined` can mean
			   *
			   * 1. that there is no such edge, or
			   * 2. that the stored value is actually `undefined`.
			   *
			   * Use {@link Graph#hasEdge} to distinguish these cases.
			   */
				}, {
					key: "edgeValue",
					value: function edgeValue(from, to) {
						return this.hasEdge(from, to) ? this[_edges].get(from).get(to) : undefined;
					}
			
					///////////////////////////////////////////////
					//////////// ES6 Iterable interfaces //////////
					///////////////////////////////////////////////
			
					/**
			   * Iterate over all vertices of the graph, in no particular order.
			   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
			   * @example
			   * for (var it = graph.vertices(), kv; !(kv = it.next()).done;) {
			   *     var key   = kv.value[0],
			   *         value = kv.value[1];
			   *     // iterates over all vertices of the graph
			   * }
			   * @example
			   * // in ECMAScript 6, you can use a for..of loop
			   * for (let [key, value] of graph.vertices()) {
			   *     // iterates over all vertices of the graph
			   * }
			   * @see {@link Graph#@@iterator}
			   */
				}, {
					key: "vertices",
					value: regeneratorRuntime.mark(function vertices() {
						var done, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, _step5$value, key, value;
			
						return regeneratorRuntime.wrap(function vertices$(context$2$0) {
							while (1) switch (context$2$0.prev = context$2$0.next) {
								case 0:
									done = new Set();
									_iteratorNormalCompletion5 = true;
									_didIteratorError5 = false;
									_iteratorError5 = undefined;
									context$2$0.prev = 4;
									_iterator5 = this[_vertices][Symbol.iterator]();
			
								case 6:
									if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
										context$2$0.next = 17;
										break;
									}
			
									_step5$value = _slicedToArray(_step5.value, 2);
									key = _step5$value[0];
									value = _step5$value[1];
			
									if (!(this.hasVertex(key) && !done.has(key))) {
										context$2$0.next = 14;
										break;
									}
			
									done.add(key);
									context$2$0.next = 14;
									return [key, value];
			
								case 14:
									_iteratorNormalCompletion5 = true;
									context$2$0.next = 6;
									break;
			
								case 17:
									context$2$0.next = 23;
									break;
			
								case 19:
									context$2$0.prev = 19;
									context$2$0.t0 = context$2$0["catch"](4);
									_didIteratorError5 = true;
									_iteratorError5 = context$2$0.t0;
			
								case 23:
									context$2$0.prev = 23;
									context$2$0.prev = 24;
			
									if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
										_iterator5["return"]();
									}
			
								case 26:
									context$2$0.prev = 26;
			
									if (!_didIteratorError5) {
										context$2$0.next = 29;
										break;
									}
			
									throw _iteratorError5;
			
								case 29:
									return context$2$0.finish(26);
			
								case 30:
									return context$2$0.finish(23);
			
								case 31:
								case "end":
									return context$2$0.stop();
							}
						}, vertices, this, [[4, 19, 23, 31], [24,, 26, 30]]);
					})
			
					/**
			   * A {@link Graph} object is itself {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol|iterable},
			   * and serves as a short notation in ECMAScript 6 to iterate over all vertices in the graph, in no particular order.
			   * @method Graph#@@iterator
			   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
			   * @example
			   * for (let [key, value] of graph) {
			   *     // iterates over all vertices of the graph
			   * }
			   * @see {@link Graph#vertices}
			   */
				}, {
					key: Symbol.iterator,
					value: function value() {
						return this.vertices();
					}
			
					/**
			   * Iterate over all edges of the graph, in no particular order.
			   * @returns { Iterator.<string, string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
			   * @example
			   * for (var it = graph.edges(), kv; !(kv = it.next()).done;) {
			   *     var from  = kv.value[0],
			   *         to    = kv.value[1],
			   *         value = kv.value[2];
			   *     // iterates over all edges of the graph
			   * }
			   * @example
			   * // in ECMAScript 6, you can use a for..of loop
			   * for (let [from, to, value] of graph.edges()) {
			   *     // iterates over all vertices of the graph
			   * }
			   */
				}, {
					key: "edges",
					value: regeneratorRuntime.mark(function edges() {
						var done, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, from, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, to;
			
						return regeneratorRuntime.wrap(function edges$(context$2$0) {
							while (1) switch (context$2$0.prev = context$2$0.next) {
								case 0:
									done = new Map();
									_iteratorNormalCompletion6 = true;
									_didIteratorError6 = false;
									_iteratorError6 = undefined;
									context$2$0.prev = 4;
									_iterator6 = this[_edges].keys()[Symbol.iterator]();
			
								case 6:
									if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
										context$2$0.next = 40;
										break;
									}
			
									from = _step6.value;
			
									done.set(from, new Set());
									_iteratorNormalCompletion7 = true;
									_didIteratorError7 = false;
									_iteratorError7 = undefined;
									context$2$0.prev = 12;
									_iterator7 = this[_edges].get(from).keys()[Symbol.iterator]();
			
								case 14:
									if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
										context$2$0.next = 23;
										break;
									}
			
									to = _step7.value;
			
									if (!(this.hasEdge(from, to) && !done.get(from).has(to))) {
										context$2$0.next = 20;
										break;
									}
			
									done.get(from).add(to);
									context$2$0.next = 20;
									return [from, to, this[_edges].get(from).get(to)];
			
								case 20:
									_iteratorNormalCompletion7 = true;
									context$2$0.next = 14;
									break;
			
								case 23:
									context$2$0.next = 29;
									break;
			
								case 25:
									context$2$0.prev = 25;
									context$2$0.t0 = context$2$0["catch"](12);
									_didIteratorError7 = true;
									_iteratorError7 = context$2$0.t0;
			
								case 29:
									context$2$0.prev = 29;
									context$2$0.prev = 30;
			
									if (!_iteratorNormalCompletion7 && _iterator7["return"]) {
										_iterator7["return"]();
									}
			
								case 32:
									context$2$0.prev = 32;
			
									if (!_didIteratorError7) {
										context$2$0.next = 35;
										break;
									}
			
									throw _iteratorError7;
			
								case 35:
									return context$2$0.finish(32);
			
								case 36:
									return context$2$0.finish(29);
			
								case 37:
									_iteratorNormalCompletion6 = true;
									context$2$0.next = 6;
									break;
			
								case 40:
									context$2$0.next = 46;
									break;
			
								case 42:
									context$2$0.prev = 42;
									context$2$0.t1 = context$2$0["catch"](4);
									_didIteratorError6 = true;
									_iteratorError6 = context$2$0.t1;
			
								case 46:
									context$2$0.prev = 46;
									context$2$0.prev = 47;
			
									if (!_iteratorNormalCompletion6 && _iterator6["return"]) {
										_iterator6["return"]();
									}
			
								case 49:
									context$2$0.prev = 49;
			
									if (!_didIteratorError6) {
										context$2$0.next = 52;
										break;
									}
			
									throw _iteratorError6;
			
								case 52:
									return context$2$0.finish(49);
			
								case 53:
									return context$2$0.finish(46);
			
								case 54:
								case "end":
									return context$2$0.stop();
							}
						}, edges, this, [[4, 42, 46, 54], [12, 25, 29, 37], [30,, 32, 36], [47,, 49, 53]]);
					})
			
					/**
			   * Iterate over the outgoing edges of a given vertex in the graph, in no particular order.
			   * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist
			   * @param from {string} the key of the vertex to take the outgoing edges from
			   * @returns { Iterator.<string, *, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
			   * @example
			   * for (var it = graph.verticesFrom(from), kv; !(kv = it.next()).done;) {
			   *     var to          = kv.value[0],
			   *         vertexValue = kv.value[1],
			   *         edgeValue   = kv.value[2];
			   *     // iterates over all outgoing vertices of the `from` vertex
			   * }
			   * @example
			   * // in ECMAScript 6, you can use a for..of loop
			   * for (let [to, vertexValue, edgeValue] of graph.verticesFrom(from)) {
			   *     // iterates over all outgoing edges of the `from` vertex
			   * }
			   */
				}, {
					key: "verticesFrom",
					value: function verticesFrom(from) {
						this[_expectVertices](from);
						return this[_verticesFrom](from);
					}
				}, {
					key: _verticesFrom,
					value: regeneratorRuntime.mark(function value(from) {
						var done, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, to;
			
						return regeneratorRuntime.wrap(function value$(context$2$0) {
							while (1) switch (context$2$0.prev = context$2$0.next) {
								case 0:
									done = new Set();
									_iteratorNormalCompletion8 = true;
									_didIteratorError8 = false;
									_iteratorError8 = undefined;
									context$2$0.prev = 4;
									_iterator8 = this[_edges].get(from).keys()[Symbol.iterator]();
			
								case 6:
									if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
										context$2$0.next = 15;
										break;
									}
			
									to = _step8.value;
			
									if (!(this.hasEdge(from, to) && !done.has(to))) {
										context$2$0.next = 12;
										break;
									}
			
									done.add(to);
									context$2$0.next = 12;
									return [to, this[_vertices].get(to), this[_edges].get(from).get(to)];
			
								case 12:
									_iteratorNormalCompletion8 = true;
									context$2$0.next = 6;
									break;
			
								case 15:
									context$2$0.next = 21;
									break;
			
								case 17:
									context$2$0.prev = 17;
									context$2$0.t0 = context$2$0["catch"](4);
									_didIteratorError8 = true;
									_iteratorError8 = context$2$0.t0;
			
								case 21:
									context$2$0.prev = 21;
									context$2$0.prev = 22;
			
									if (!_iteratorNormalCompletion8 && _iterator8["return"]) {
										_iterator8["return"]();
									}
			
								case 24:
									context$2$0.prev = 24;
			
									if (!_didIteratorError8) {
										context$2$0.next = 27;
										break;
									}
			
									throw _iteratorError8;
			
								case 27:
									return context$2$0.finish(24);
			
								case 28:
									return context$2$0.finish(21);
			
								case 29:
								case "end":
									return context$2$0.stop();
							}
						}, value, this, [[4, 17, 21, 29], [22,, 24, 28]]);
					})
			
					/**
			   * Iterate over the incoming edges of a given vertex in the graph, in no particular order.
			   * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist
			   * @param to {string} the key of the vertex to take the incoming edges from
			   * @returns { Iterator.<string, *, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
			   * @example
			   * for (var it = graph.verticesTo(to), kv; !(kv = it.next()).done;) {
			   *     var from        = kv.value[0],
			   *         vertexValue = kv.value[1],
			   *         edgeValue   = kv.value[2];
			   *     // iterates over all outgoing vertices of the `from` vertex
			   * }
			   * @example
			   * // in ECMAScript 6, you can use a for..of loop
			   * for (let [from, vertexValue, edgeValue] of graph.verticesTo(to)) {
			   *     // iterates over all incoming edges of the `to` vertex
			   * }
			   */
				}, {
					key: "verticesTo",
					value: function verticesTo(to) {
						this[_expectVertices](to);
						return this[_verticesTo](to);
					}
				}, {
					key: _verticesTo,
					value: regeneratorRuntime.mark(function value(to) {
						var done, _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, from;
			
						return regeneratorRuntime.wrap(function value$(context$2$0) {
							while (1) switch (context$2$0.prev = context$2$0.next) {
								case 0:
									done = new Set();
									_iteratorNormalCompletion9 = true;
									_didIteratorError9 = false;
									_iteratorError9 = undefined;
									context$2$0.prev = 4;
									_iterator9 = this[_reverseEdges].get(to)[Symbol.iterator]();
			
								case 6:
									if (_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done) {
										context$2$0.next = 15;
										break;
									}
			
									from = _step9.value;
			
									if (!(this.hasEdge(from, to) && !done.has(from))) {
										context$2$0.next = 12;
										break;
									}
			
									done.add(from);
									context$2$0.next = 12;
									return [from, this[_vertices].get(from), this[_edges].get(from).get(to)];
			
								case 12:
									_iteratorNormalCompletion9 = true;
									context$2$0.next = 6;
									break;
			
								case 15:
									context$2$0.next = 21;
									break;
			
								case 17:
									context$2$0.prev = 17;
									context$2$0.t0 = context$2$0["catch"](4);
									_didIteratorError9 = true;
									_iteratorError9 = context$2$0.t0;
			
								case 21:
									context$2$0.prev = 21;
									context$2$0.prev = 22;
			
									if (!_iteratorNormalCompletion9 && _iterator9["return"]) {
										_iterator9["return"]();
									}
			
								case 24:
									context$2$0.prev = 24;
			
									if (!_didIteratorError9) {
										context$2$0.next = 27;
										break;
									}
			
									throw _iteratorError9;
			
								case 27:
									return context$2$0.finish(24);
			
								case 28:
									return context$2$0.finish(21);
			
								case 29:
								case "end":
									return context$2$0.stop();
							}
						}, value, this, [[4, 17, 21, 29], [22,, 24, 28]]);
					})
			
					/**
			   * Iterate over all vertices reachable from a given vertex in the graph, in no particular order.
			   * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist
			   * @param from {string} the key of the vertex to take the reachable vertices from
			   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
			   * @example
			   * for (var it = graph.verticesWithPathFrom(from), kv; !(kv = it.next()).done;) {
			   *     var key   = kv.value[0],
			   *         value = kv.value[1];
			   *     // iterates over all vertices reachable from `from`
			   * }
			   * @example
			   * // in ECMAScript 6, you can use a for..of loop
			   * for (let [key, value] of graph.verticesWithPathFrom(from)) {
			   *     // iterates over all vertices reachable from `from`
			   * }
			   */
				}, {
					key: "verticesWithPathFrom",
					value: function verticesWithPathFrom(from) {
						this[_expectVertices](from);
						return this[_verticesWithPathFrom](from, new Set());
					}
				}, {
					key: _verticesWithPathFrom,
					value: regeneratorRuntime.mark(function value(from, done) {
						var _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, to;
			
						return regeneratorRuntime.wrap(function value$(context$2$0) {
							while (1) switch (context$2$0.prev = context$2$0.next) {
								case 0:
									_iteratorNormalCompletion10 = true;
									_didIteratorError10 = false;
									_iteratorError10 = undefined;
									context$2$0.prev = 3;
									_iterator10 = this[_edges].get(from).keys()[Symbol.iterator]();
			
								case 5:
									if (_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done) {
										context$2$0.next = 15;
										break;
									}
			
									to = _step10.value;
			
									if (!(this.hasEdge(from, to) && !done.has(to))) {
										context$2$0.next = 12;
										break;
									}
			
									done.add(to);
									context$2$0.next = 11;
									return [to, this[_vertices].get(to)];
			
								case 11:
									return context$2$0.delegateYield(this[_verticesWithPathFrom](to, done), "t0", 12);
			
								case 12:
									_iteratorNormalCompletion10 = true;
									context$2$0.next = 5;
									break;
			
								case 15:
									context$2$0.next = 21;
									break;
			
								case 17:
									context$2$0.prev = 17;
									context$2$0.t1 = context$2$0["catch"](3);
									_didIteratorError10 = true;
									_iteratorError10 = context$2$0.t1;
			
								case 21:
									context$2$0.prev = 21;
									context$2$0.prev = 22;
			
									if (!_iteratorNormalCompletion10 && _iterator10["return"]) {
										_iterator10["return"]();
									}
			
								case 24:
									context$2$0.prev = 24;
			
									if (!_didIteratorError10) {
										context$2$0.next = 27;
										break;
									}
			
									throw _iteratorError10;
			
								case 27:
									return context$2$0.finish(24);
			
								case 28:
									return context$2$0.finish(21);
			
								case 29:
								case "end":
									return context$2$0.stop();
							}
						}, value, this, [[3, 17, 21, 29], [22,, 24, 28]]);
					})
			
					/**
			   * Iterate over all vertices from which a given vertex in the graph can be reached, in no particular order.
			   * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist
			   * @param to {string} the key of the vertex to take the reachable vertices from
			   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
			   * @example
			   * for (var it = graph.verticesWithPathTo(to), kv; !(kv = it.next()).done;) {
			   *     var key   = kv.value[0],
			   *         value = kv.value[1];
			   *     // iterates over all vertices from which `to` can be reached
			   * }
			   * @example
			   * // in ECMAScript 6, you can use a for..of loop
			   * for (let [key, value] of graph.verticesWithPathTo(to)) {
			   *     // iterates over all vertices from which `to` can be reached
			   * }
			   */
				}, {
					key: "verticesWithPathTo",
					value: function verticesWithPathTo(to) {
						this[_expectVertices](to);
						return this[_verticesWithPathTo](to, new Set());
					}
				}, {
					key: _verticesWithPathTo,
					value: regeneratorRuntime.mark(function value(to, done) {
						var _iteratorNormalCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, from;
			
						return regeneratorRuntime.wrap(function value$(context$2$0) {
							while (1) switch (context$2$0.prev = context$2$0.next) {
								case 0:
									_iteratorNormalCompletion11 = true;
									_didIteratorError11 = false;
									_iteratorError11 = undefined;
									context$2$0.prev = 3;
									_iterator11 = this[_reverseEdges].get(to)[Symbol.iterator]();
			
								case 5:
									if (_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done) {
										context$2$0.next = 15;
										break;
									}
			
									from = _step11.value;
			
									if (!(this.hasEdge(from, to) && !done.has(from))) {
										context$2$0.next = 12;
										break;
									}
			
									done.add(from);
									context$2$0.next = 11;
									return [from, this[_vertices].get(from)];
			
								case 11:
									return context$2$0.delegateYield(this[_verticesWithPathTo](from, done), "t0", 12);
			
								case 12:
									_iteratorNormalCompletion11 = true;
									context$2$0.next = 5;
									break;
			
								case 15:
									context$2$0.next = 21;
									break;
			
								case 17:
									context$2$0.prev = 17;
									context$2$0.t1 = context$2$0["catch"](3);
									_didIteratorError11 = true;
									_iteratorError11 = context$2$0.t1;
			
								case 21:
									context$2$0.prev = 21;
									context$2$0.prev = 22;
			
									if (!_iteratorNormalCompletion11 && _iterator11["return"]) {
										_iterator11["return"]();
									}
			
								case 24:
									context$2$0.prev = 24;
			
									if (!_didIteratorError11) {
										context$2$0.next = 27;
										break;
									}
			
									throw _iteratorError11;
			
								case 27:
									return context$2$0.finish(24);
			
								case 28:
									return context$2$0.finish(21);
			
								case 29:
								case "end":
									return context$2$0.stop();
							}
						}, value, this, [[3, 17, 21, 29], [22,, 24, 28]]);
					})
			
					/**
			   * Iterate over all vertices that have no incoming edges, in no particular order.
			   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
			   * @example
			   * for (var it = graph.sources(), kv; !(kv = it.next()).done;) {
			   *     var key   = kv.value[0],
			   *         value = kv.value[1];
			   *     // iterates over all vertices with no incoming edges
			   * }
			   * @example
			   * // in ECMAScript 6, you can use a for..of loop
			   * for (let [key, value] of graph.sources()) {
			   *     // iterates over all vertices with no incoming edges
			   * }
			   */
				}, {
					key: "sources",
					value: regeneratorRuntime.mark(function sources() {
						var done, _iteratorNormalCompletion12, _didIteratorError12, _iteratorError12, _iterator12, _step12, key;
			
						return regeneratorRuntime.wrap(function sources$(context$2$0) {
							while (1) switch (context$2$0.prev = context$2$0.next) {
								case 0:
									done = new Set();
									_iteratorNormalCompletion12 = true;
									_didIteratorError12 = false;
									_iteratorError12 = undefined;
									context$2$0.prev = 4;
									_iterator12 = this[_sources][Symbol.iterator]();
			
								case 6:
									if (_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done) {
										context$2$0.next = 15;
										break;
									}
			
									key = _step12.value;
			
									if (!(this.hasVertex(key) && !done.has(key))) {
										context$2$0.next = 12;
										break;
									}
			
									done.add(key);
									context$2$0.next = 12;
									return [key, this.vertexValue(key)];
			
								case 12:
									_iteratorNormalCompletion12 = true;
									context$2$0.next = 6;
									break;
			
								case 15:
									context$2$0.next = 21;
									break;
			
								case 17:
									context$2$0.prev = 17;
									context$2$0.t0 = context$2$0["catch"](4);
									_didIteratorError12 = true;
									_iteratorError12 = context$2$0.t0;
			
								case 21:
									context$2$0.prev = 21;
									context$2$0.prev = 22;
			
									if (!_iteratorNormalCompletion12 && _iterator12["return"]) {
										_iterator12["return"]();
									}
			
								case 24:
									context$2$0.prev = 24;
			
									if (!_didIteratorError12) {
										context$2$0.next = 27;
										break;
									}
			
									throw _iteratorError12;
			
								case 27:
									return context$2$0.finish(24);
			
								case 28:
									return context$2$0.finish(21);
			
								case 29:
								case "end":
									return context$2$0.stop();
							}
						}, sources, this, [[4, 17, 21, 29], [22,, 24, 28]]);
					})
			
					/**
			   * Iterate over all vertices that have no outgoing edges, in no particular order.
			   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
			   * @example
			   * for (var it = graph.sinks(), kv; !(kv = it.next()).done;) {
			   *     var key   = kv.value[0],
			   *         value = kv.value[1];
			   *     // iterates over all vertices with no outgoing edges
			   * }
			   * @example
			   * // in ECMAScript 6, you can use a for..of loop
			   * for (let [key, value] of graph.sinks()) {
			   *     // iterates over all vertices with no outgoing edges
			   * }
			   */
				}, {
					key: "sinks",
					value: regeneratorRuntime.mark(function sinks() {
						var done, _iteratorNormalCompletion13, _didIteratorError13, _iteratorError13, _iterator13, _step13, key;
			
						return regeneratorRuntime.wrap(function sinks$(context$2$0) {
							while (1) switch (context$2$0.prev = context$2$0.next) {
								case 0:
									done = new Set();
									_iteratorNormalCompletion13 = true;
									_didIteratorError13 = false;
									_iteratorError13 = undefined;
									context$2$0.prev = 4;
									_iterator13 = this[_sinks][Symbol.iterator]();
			
								case 6:
									if (_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done) {
										context$2$0.next = 15;
										break;
									}
			
									key = _step13.value;
			
									if (!(this.hasVertex(key) && !done.has(key))) {
										context$2$0.next = 12;
										break;
									}
			
									done.add(key);
									context$2$0.next = 12;
									return [key, this.vertexValue(key)];
			
								case 12:
									_iteratorNormalCompletion13 = true;
									context$2$0.next = 6;
									break;
			
								case 15:
									context$2$0.next = 21;
									break;
			
								case 17:
									context$2$0.prev = 17;
									context$2$0.t0 = context$2$0["catch"](4);
									_didIteratorError13 = true;
									_iteratorError13 = context$2$0.t0;
			
								case 21:
									context$2$0.prev = 21;
									context$2$0.prev = 22;
			
									if (!_iteratorNormalCompletion13 && _iterator13["return"]) {
										_iterator13["return"]();
									}
			
								case 24:
									context$2$0.prev = 24;
			
									if (!_didIteratorError13) {
										context$2$0.next = 27;
										break;
									}
			
									throw _iteratorError13;
			
								case 27:
									return context$2$0.finish(24);
			
								case 28:
									return context$2$0.finish(21);
			
								case 29:
								case "end":
									return context$2$0.stop();
							}
						}, sinks, this, [[4, 17, 21, 29], [22,, 24, 28]]);
					})
			
					/**
			   * Iterate over all vertices of the graph in topological order.
			   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
			   * @example
			   * for (var it = graph.vertices_topologically(), kv; !(kv = it.next()).done;) {
			   *     var key   = kv.value[0],
			   *         value = kv.value[1];
			   *     // iterates over all vertices of the graph in topological order
			   * }
			   * @example
			   * // in ECMAScript 6, you can use a for..of loop
			   * for (let [key, value] of graph.vertices_topologically()) {
			   *     // iterates over all vertices of the graph in topological order
			   * }
			   */
				}, {
					key: "vertices_topologically",
					value: regeneratorRuntime.mark(function vertices_topologically() {
						var marked2$0, visited, handled, _this, visit, _iteratorNormalCompletion15, _didIteratorError15, _iteratorError15, _iterator15, _step15, _step15$value, a;
			
						return regeneratorRuntime.wrap(function vertices_topologically$(context$2$0) {
							while (1) switch (context$2$0.prev = context$2$0.next) {
								case 0:
									visit = function visit(a) {
										var i, cycle, _iteratorNormalCompletion14, _didIteratorError14, _iteratorError14, _iterator14, _step14, _step14$value, b;
			
										return regeneratorRuntime.wrap(function visit$(context$3$0) {
											while (1) switch (context$3$0.prev = context$3$0.next) {
												case 0:
													visited.push(a);
													i = visited.indexOf(a);
			
													if (!(i !== visited.length - 1)) {
														context$3$0.next = 5;
														break;
													}
			
													cycle = visited.slice(i + 1).reverse();
													throw new Graph.CycleError(cycle);
			
												case 5:
													if (handled.has(a)) {
														context$3$0.next = 36;
														break;
													}
			
													_iteratorNormalCompletion14 = true;
													_didIteratorError14 = false;
													_iteratorError14 = undefined;
													context$3$0.prev = 9;
													_iterator14 = _this.verticesTo(a)[Symbol.iterator]();
			
												case 11:
													if (_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done) {
														context$3$0.next = 18;
														break;
													}
			
													_step14$value = _slicedToArray(_step14.value, 1);
													b = _step14$value[0];
													return context$3$0.delegateYield(visit(b), "t0", 15);
			
												case 15:
													_iteratorNormalCompletion14 = true;
													context$3$0.next = 11;
													break;
			
												case 18:
													context$3$0.next = 24;
													break;
			
												case 20:
													context$3$0.prev = 20;
													context$3$0.t1 = context$3$0["catch"](9);
													_didIteratorError14 = true;
													_iteratorError14 = context$3$0.t1;
			
												case 24:
													context$3$0.prev = 24;
													context$3$0.prev = 25;
			
													if (!_iteratorNormalCompletion14 && _iterator14["return"]) {
														_iterator14["return"]();
													}
			
												case 27:
													context$3$0.prev = 27;
			
													if (!_didIteratorError14) {
														context$3$0.next = 30;
														break;
													}
			
													throw _iteratorError14;
			
												case 30:
													return context$3$0.finish(27);
			
												case 31:
													return context$3$0.finish(24);
			
												case 32:
													if (!_this.hasVertex(a)) {
														context$3$0.next = 35;
														break;
													}
			
													context$3$0.next = 35;
													return [a, _this[_vertices].get(a)];
			
												case 35:
													handled.add(a);
			
												case 36:
													visited.pop();
			
												case 37:
												case "end":
													return context$3$0.stop();
											}
										}, marked2$0[0], this, [[9, 20, 24, 32], [25,, 27, 31]]);
									};
			
									marked2$0 = [visit].map(regeneratorRuntime.mark);
									visited = [];
									handled = new Set();
									_this = this;
									_iteratorNormalCompletion15 = true;
									_didIteratorError15 = false;
									_iteratorError15 = undefined;
									context$2$0.prev = 8;
									_iterator15 = this.vertices()[Symbol.iterator]();
			
								case 10:
									if (_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done) {
										context$2$0.next = 18;
										break;
									}
			
									_step15$value = _slicedToArray(_step15.value, 1);
									a = _step15$value[0];
			
									if (handled.has(a)) {
										context$2$0.next = 15;
										break;
									}
			
									return context$2$0.delegateYield(visit(a), "t0", 15);
			
								case 15:
									_iteratorNormalCompletion15 = true;
									context$2$0.next = 10;
									break;
			
								case 18:
									context$2$0.next = 24;
									break;
			
								case 20:
									context$2$0.prev = 20;
									context$2$0.t1 = context$2$0["catch"](8);
									_didIteratorError15 = true;
									_iteratorError15 = context$2$0.t1;
			
								case 24:
									context$2$0.prev = 24;
									context$2$0.prev = 25;
			
									if (!_iteratorNormalCompletion15 && _iterator15["return"]) {
										_iterator15["return"]();
									}
			
								case 27:
									context$2$0.prev = 27;
			
									if (!_didIteratorError15) {
										context$2$0.next = 30;
										break;
									}
			
									throw _iteratorError15;
			
								case 30:
									return context$2$0.finish(27);
			
								case 31:
									return context$2$0.finish(24);
			
								case 32:
								case "end":
									return context$2$0.stop();
							}
						}, vertices_topologically, this, [[8, 20, 24, 32], [25,, 27, 31]]);
					})
			
					//////////////////////////////
					////////// Clearing //////////
					//////////////////////////////
			
					/**
			   * Remove all edges from the graph, but leave the vertices intact.
			   */
				}, {
					key: "clearEdges",
					value: function clearEdges() {
						var _iteratorNormalCompletion16 = true;
						var _didIteratorError16 = false;
						var _iteratorError16 = undefined;
			
						try {
							for (var _iterator16 = this.edges()[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
								var _step16$value = _slicedToArray(_step16.value, 2);
			
								var from = _step16$value[0];
								var to = _step16$value[1];
								this.removeEdge(from, to);
							}
						} catch (err) {
							_didIteratorError16 = true;
							_iteratorError16 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion16 && _iterator16["return"]) {
									_iterator16["return"]();
								}
							} finally {
								if (_didIteratorError16) {
									throw _iteratorError16;
								}
							}
						}
					}
			
					/**
			   * Remove all edges and vertices from the graph, putting it back in its initial state.
			   */
				}, {
					key: "clear",
					value: function clear() {
						var _iteratorNormalCompletion17 = true;
						var _didIteratorError17 = false;
						var _iteratorError17 = undefined;
			
						try {
							for (var _iterator17 = this.vertices()[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
								var _step17$value = _slicedToArray(_step17.value, 1);
			
								var v = _step17$value[0];
								this.destroyVertex(v);
							}
						} catch (err) {
							_didIteratorError17 = true;
							_iteratorError17 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion17 && _iterator17["return"]) {
									_iterator17["return"]();
								}
							} finally {
								if (_didIteratorError17) {
									throw _iteratorError17;
								}
							}
						}
					}
			
					////////////////////////////////////////
					////////// (Advanced) Queries //////////
					////////////////////////////////////////
			
					/**
			   * Ask whether `this` graph and a given `other` graph are equal.
			   * Two graphs are equal if they have the same vertices and the same edges.
			   * @param other {Graph} the other graph to compare to `this` one
			   * @param [eqV] {function(*, *, string): boolean}
			   *     a custom equality function for values stored in vertices;
			   *     defaults to `===` comparison; The first two arguments are the
			   *     values to compare. The third is the corresponding `key`.
			   * @param [eqE] {function(*, *, string, string): boolean}
			   *     a custom equality function for values stored in edges;
			   *     defaults to the function given for `trV`; The first two arguments
			   *     are the values to compare. The third and fourth are the `from`
			   *     and `to` keys respectively.
			   * @returns {boolean} `true` if the two graphs are equal; `false` otherwise
			   */
				}, {
					key: "equals",
					value: function equals(other) {
						var eqV = arguments.length <= 1 || arguments[1] === undefined ? function (x, y) {
							return x === y;
						} : arguments[1];
						var eqE = arguments.length <= 2 || arguments[2] === undefined ? eqV : arguments[2];
						return (function () {
							if (!(other instanceof Graph)) {
								return false;
							}
							if (this.vertexCount() !== other.vertexCount()) {
								return false;
							}
							if (this.edgeCount() !== other.edgeCount()) {
								return false;
							}
							var _iteratorNormalCompletion18 = true;
							var _didIteratorError18 = false;
							var _iteratorError18 = undefined;
			
							try {
								for (var _iterator18 = this.vertices()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
									var _step18$value = _slicedToArray(_step18.value, 2);
			
									var key = _step18$value[0];
									var value = _step18$value[1];
			
									if (!other.hasVertex(key)) {
										return false;
									}
									if (!eqV(value, other.vertexValue(key), key)) {
										return false;
									}
								}
							} catch (err) {
								_didIteratorError18 = true;
								_iteratorError18 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion18 && _iterator18["return"]) {
										_iterator18["return"]();
									}
								} finally {
									if (_didIteratorError18) {
										throw _iteratorError18;
									}
								}
							}
			
							var _iteratorNormalCompletion19 = true;
							var _didIteratorError19 = false;
							var _iteratorError19 = undefined;
			
							try {
								for (var _iterator19 = this.edges()[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
									var _step19$value = _slicedToArray(_step19.value, 3);
			
									var from = _step19$value[0];
									var to = _step19$value[1];
									var value = _step19$value[2];
			
									if (!other.hasEdge(from, to)) {
										return false;
									}
									if (!eqE(value, other.edgeValue(from, to), from, to)) {
										return false;
									}
								}
							} catch (err) {
								_didIteratorError19 = true;
								_iteratorError19 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion19 && _iterator19["return"]) {
										_iterator19["return"]();
									}
								} finally {
									if (_didIteratorError19) {
										throw _iteratorError19;
									}
								}
							}
			
							return true;
						}).apply(this, arguments);
					}
			
					/**
			   * Iterate over all simple directed cycles in this graph, in no particular order.
			   * If you mutate the graph in between iterations, behavior of the iterator
			   * becomes unspecified. (So, don't.)
			   * @returns { Iterator.< Array.<string> > }
			   *          an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}.
			   *          Each iterated value is an array containing the vertex keys describing the cycle.
			   *          These arrays will contain each vertex key only once — even the first/last one.
			   * @example
			   * for (var it = graph.cycles(), kv; !(kv = it.next()).done;) {
			   *     var cycle = kv.value;
			   *     // iterates over all cycles of the graph
			   * }
			   * @example
			   * // in ECMAScript 6, you can use a for..of loop
			   * for (let cycle of graph.cycles()) {
			   *     // iterates over all cycles of the graph
			   * }
			   */
				}, {
					key: "cycles",
					value: regeneratorRuntime.mark(function cycles() {
						var marked2$0, pointStack, markedStack, mark, _this, backtrack, _iteratorNormalCompletion20, _didIteratorError20, _iteratorError20, _iterator20, _step20, _step20$value, a;
			
						return regeneratorRuntime.wrap(function cycles$(context$2$0) {
							while (1) switch (context$2$0.prev = context$2$0.next) {
								case 0:
									backtrack = function backtrack(v) {
										var out = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
			
										var _arr, _i, _arr$_i, w, o, u;
			
										return regeneratorRuntime.wrap(function backtrack$(context$3$0) {
											while (1) switch (context$3$0.prev = context$3$0.next) {
												case 0:
													pointStack.push(v);
													mark.add(v);
													markedStack.push(v);
													_arr = [].concat(_toConsumableArray(_this.verticesFrom(v)));
													_i = 0;
			
												case 5:
													if (!(_i < _arr.length)) {
														context$3$0.next = 23;
														break;
													}
			
													_arr$_i = _slicedToArray(_arr[_i], 1);
													w = _arr$_i[0];
			
													if (!(w < pointStack[0])) {
														context$3$0.next = 10;
														break;
													}
			
													return context$3$0.abrupt("continue", 20);
			
												case 10:
													if (!(w === pointStack[0])) {
														context$3$0.next = 16;
														break;
													}
			
													context$3$0.next = 13;
													return [].concat(pointStack);
			
												case 13:
													out.found = true;
													context$3$0.next = 20;
													break;
			
												case 16:
													if (mark.has(w)) {
														context$3$0.next = 20;
														break;
													}
			
													o = {};
													return context$3$0.delegateYield(backtrack(w, o), "t0", 19);
			
												case 19:
													out.found = out.found || o.found;
			
												case 20:
													_i++;
													context$3$0.next = 5;
													break;
			
												case 23:
													if (out.found) {
														u = undefined;
			
														do {
															u = markedStack.pop();
															mark["delete"](u);
														} while (u !== v);
													}
													pointStack.pop();
			
												case 25:
												case "end":
													return context$3$0.stop();
											}
										}, marked2$0[0], this);
									};
			
									marked2$0 = [backtrack].map(regeneratorRuntime.mark);
									pointStack = [];
									markedStack = undefined, mark = undefined;
									_this = this;
									_iteratorNormalCompletion20 = true;
									_didIteratorError20 = false;
									_iteratorError20 = undefined;
									context$2$0.prev = 8;
									_iterator20 = this.vertices()[Symbol.iterator]();
			
								case 10:
									if (_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done) {
										context$2$0.next = 19;
										break;
									}
			
									_step20$value = _slicedToArray(_step20.value, 1);
									a = _step20$value[0];
			
									markedStack = [];
									mark = new Set();
									return context$2$0.delegateYield(backtrack(a), "t0", 16);
			
								case 16:
									_iteratorNormalCompletion20 = true;
									context$2$0.next = 10;
									break;
			
								case 19:
									context$2$0.next = 25;
									break;
			
								case 21:
									context$2$0.prev = 21;
									context$2$0.t1 = context$2$0["catch"](8);
									_didIteratorError20 = true;
									_iteratorError20 = context$2$0.t1;
			
								case 25:
									context$2$0.prev = 25;
									context$2$0.prev = 26;
			
									if (!_iteratorNormalCompletion20 && _iterator20["return"]) {
										_iterator20["return"]();
									}
			
								case 28:
									context$2$0.prev = 28;
			
									if (!_didIteratorError20) {
										context$2$0.next = 31;
										break;
									}
			
									throw _iteratorError20;
			
								case 31:
									return context$2$0.finish(28);
			
								case 32:
									return context$2$0.finish(25);
			
								case 33:
								case "end":
									return context$2$0.stop();
							}
						}, cycles, this, [[8, 21, 25, 33], [26,, 28, 32]]);
					})
			
					/**
			   * Find any directed cycle in this graph.
			   * @returns {?Array} an array containing the vertex keys describing the cycle; `null`, if there is no cycle;
			   *                   The array will contain each vertex key only once — even the first/last one.
			   */
				}, {
					key: "cycle",
					value: function cycle() {
						var result = this.cycles().next();
						return result.done ? null : result.value;
					}
			
					/**
			   * Test whether this graph contains a directed cycle.
			   * @returns {boolean} whether this graph contains any directed cycle
			   */
				}, {
					key: "hasCycle",
					value: function hasCycle() {
						return !this.cycles().next().done;
					}
			
					/**
			   * Iterate over all paths between two given keys in this graph, in no particular order.
			   * If you mutate the graph in between iterations, behavior of the iterator
			   * becomes unspecified. (So, don't.)
			   * @param from {string} the key for the originating vertex
			   * @param to   {string} the key for the terminating vertex
			   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
			   * @returns { Iterator.< Array.<string> > }
			   *          an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}.
			   *          Each iterated value is an array containing the vertex-keys describing the path.
			   * @example
			   * for (var it = graph.paths(), kv; !(kv = it.next()).done;) {
			   *     var path = kv.value;
			   *     // iterates over all paths between `from` and `to` in the graph
			   * }
			   * @example
			   * // in ECMAScript 6, you can use a for..of loop
			   * for (let path of graph.paths()) {
			   *     // iterates over all paths between `from` and `to` in the graph
			   * }
			   */
				}, {
					key: "paths",
					value: function paths(from, to) {
						this[_expectVertices](from, to);
						return this[_paths](from, to);
					}
				}, {
					key: _paths,
					value: regeneratorRuntime.mark(function value(from, to) {
						var marked2$0, stack, _this, pathsFromPrefix;
			
						return regeneratorRuntime.wrap(function value$(context$2$0) {
							while (1) switch (context$2$0.prev = context$2$0.next) {
								case 0:
									pathsFromPrefix = function pathsFromPrefix(current) {
										var _iteratorNormalCompletion21, _didIteratorError21, _iteratorError21, _iterator21, _step21, _step21$value, next;
			
										return regeneratorRuntime.wrap(function pathsFromPrefix$(context$3$0) {
											while (1) switch (context$3$0.prev = context$3$0.next) {
												case 0:
													stack.push(current);
													_iteratorNormalCompletion21 = true;
													_didIteratorError21 = false;
													_iteratorError21 = undefined;
													context$3$0.prev = 4;
													_iterator21 = _this.verticesFrom(current)[Symbol.iterator]();
			
												case 6:
													if (_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done) {
														context$3$0.next = 19;
														break;
													}
			
													_step21$value = _slicedToArray(_step21.value, 1);
													next = _step21$value[0];
			
													if (!(next === to)) {
														context$3$0.next = 14;
														break;
													}
			
													context$3$0.next = 12;
													return [].concat(stack, [to]);
			
												case 12:
													context$3$0.next = 16;
													break;
			
												case 14:
													if (!(stack.indexOf(next) === -1)) {
														context$3$0.next = 16;
														break;
													}
			
													return context$3$0.delegateYield(pathsFromPrefix(next), "t0", 16);
			
												case 16:
													_iteratorNormalCompletion21 = true;
													context$3$0.next = 6;
													break;
			
												case 19:
													context$3$0.next = 25;
													break;
			
												case 21:
													context$3$0.prev = 21;
													context$3$0.t1 = context$3$0["catch"](4);
													_didIteratorError21 = true;
													_iteratorError21 = context$3$0.t1;
			
												case 25:
													context$3$0.prev = 25;
													context$3$0.prev = 26;
			
													if (!_iteratorNormalCompletion21 && _iterator21["return"]) {
														_iterator21["return"]();
													}
			
												case 28:
													context$3$0.prev = 28;
			
													if (!_didIteratorError21) {
														context$3$0.next = 31;
														break;
													}
			
													throw _iteratorError21;
			
												case 31:
													return context$3$0.finish(28);
			
												case 32:
													return context$3$0.finish(25);
			
												case 33:
													stack.pop();
			
												case 34:
												case "end":
													return context$3$0.stop();
											}
										}, marked2$0[0], this, [[4, 21, 25, 33], [26,, 28, 32]]);
									};
			
									marked2$0 = [pathsFromPrefix].map(regeneratorRuntime.mark);
									stack = [];
									_this = this;
									return context$2$0.delegateYield(pathsFromPrefix(from), "t0", 5);
			
								case 5:
								case "end":
									return context$2$0.stop();
							}
						}, value, this);
					})
			
					/**
			   * Find any path between a given pair of keys.
			   * @param from {string} the originating vertex
			   * @param to   {string} the terminating vertex
			   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
			   * @returns {?Array} an array with the keys of the path found between the two vertices,
			   *                   including those two vertices themselves; `null` if no such path exists
			   */
				}, {
					key: "path",
					value: function path(from, to) {
						var result = this.paths(from, to).next();
						return result.done ? null : result.value;
					}
			
					/**
			   * Test whether there is a directed path between a given pair of keys.
			   * @param from {string} the originating vertex
			   * @param to   {string} the terminating vertex
			   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
			   * @returns {boolean} whether such a path exists
			   */
				}, {
					key: "hasPath",
					value: function hasPath(from, to) {
						return !this.paths(from, to).next().done;
					}
			
					/**
			   * Get the number of edges going out of a given vertex.
			   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
			   * @param key {string} the key of the vertex to query
			   * @returns {number} the number of edges going out of the `key` vertex
			   */
				}, {
					key: "outDegree",
					value: function outDegree(key) {
						this[_expectVertices](key);
						return this[_edges].get(key).size;
					}
			
					/**
			   * Get the number of edges coming into a given vertex.
			   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
			   * @param key {string} the key of the vertex to query
			   * @returns {number} the number of edges coming into the `key` vertex
			   */
				}, {
					key: "inDegree",
					value: function inDegree(key) {
						this[_expectVertices](key);
						return this[_reverseEdges].get(key).size;
					}
			
					/**
			   * Get the number of edges connected to a given vertex.
			   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
			   * @param key {string} the key of the vertex to query
			   * @returns {number} the number of edges connected to the `key` vertex
			   */
				}, {
					key: "degree",
					value: function degree(key) {
						return this.outDegree(key) + this.inDegree(key);
					}
			
					///////////////////////////////////////
					////////// Cloning and stuff //////////
					///////////////////////////////////////
			
					/**
			   * Merge another graph into this graph.
			   * @param other {Graph} the other graph to merge into this one
			   * @param [mV] {function(*, *, string): *}
			   *     a custom merge function for values stored in vertices;
			   *     defaults to whichever of the two values is not `undefined`,
			   *     giving preference to that of the other graph; The first and
			   *     second arguments are the vertex values of `this` graph and the
			   *     `other` graph respectively. The third is the corresponding `key`.
			   * @param [mE] {function(*, *, string, string): *}
			   *     a custom merge function for values stored in edges;
			   *     defaults to whichever of the two values is not `undefined`,
			   *     giving preference to that of the other graph; The first and
			   *     second arguments are the edge values of `this` graph and the
			   *     `other` graph respectively. The third and fourth are the
			   *     corresponding `from` and `to` keys.
			   */
				}, {
					key: "mergeIn",
					value: function mergeIn(other, mV, mE) {
						if (!mV) {
							mV = function (v1, v2) {
								return typeof v2 === 'undefined' ? v1 : v2;
							};
						}
						if (!mE) {
							mE = mV;
						}
						var _iteratorNormalCompletion22 = true;
						var _didIteratorError22 = false;
						var _iteratorError22 = undefined;
			
						try {
							for (var _iterator22 = other.vertices()[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
								var _step22$value = _slicedToArray(_step22.value, 1);
			
								var key = _step22$value[0];
			
								this.addVertex(key, mV(this.vertexValue(key), other.vertexValue(key), key));
							}
						} catch (err) {
							_didIteratorError22 = true;
							_iteratorError22 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion22 && _iterator22["return"]) {
									_iterator22["return"]();
								}
							} finally {
								if (_didIteratorError22) {
									throw _iteratorError22;
								}
							}
						}
			
						var _iteratorNormalCompletion23 = true;
						var _didIteratorError23 = false;
						var _iteratorError23 = undefined;
			
						try {
							for (var _iterator23 = other.edges()[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
								var _step23$value = _slicedToArray(_step23.value, 2);
			
								var from = _step23$value[0];
								var to = _step23$value[1];
			
								this.addEdge(from, to, mE(this.edgeValue(from, to), other.edgeValue(from, to), from, to));
							}
						} catch (err) {
							_didIteratorError23 = true;
							_iteratorError23 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion23 && _iterator23["return"]) {
									_iterator23["return"]();
								}
							} finally {
								if (_didIteratorError23) {
									throw _iteratorError23;
								}
							}
						}
					}
			
					/**
			   * Create a clone of this graph.
			   * @param [trV] {function(*, string): *}
			   *     a custom transformation function for values stored in vertices;
			   *     defaults to the identity function; The first argument is the
			   *     value to clone. The second is the corresponding `key`.
			   * @param [trE] {function(*, string, string): *}
			   *     a custom transformation function for values stored in edges;
			   *     defaults to the function given for `trV`; The first argument
			   *     is the value to clone. The second and third are the `from`
			   *     and `to` keys respectively.
			   * @returns {Graph} a clone of this graph
			   */
				}, {
					key: "clone",
					value: function clone() {
						var trV = arguments.length <= 0 || arguments[0] === undefined ? function (v) {
							return v;
						} : arguments[0];
						var trE = arguments.length <= 1 || arguments[1] === undefined ? trV : arguments[1];
						return (function () {
							var result = new Graph();
							result.mergeIn(this, function (v1, v2, key) {
								return trV(v2, key);
							}, function (v1, v2, from, to) {
								return trE(v2, from, to);
							});
							return result;
						}).apply(this, arguments);
					}
			
					/**
			   * Create a clone of this graph, but without any transitive edges.
			   * @param [trV] {function(*, string): *}
			   *     a custom transformation function for values stored in vertices;
			   *     defaults to the identity function; The first argument is the
			   *     value to clone. The second is the corresponding `key`.
			   * @param [trE] {function(*, string, string): *}
			   *     a custom transformation function for values stored in edges;
			   *     defaults to the function given for `trV`; The first argument
			   *     is the value to clone. The second and third are the `from`
			   *     and `to` keys respectively.
			   * @returns {Graph} a clone of this graph with all transitive edges removed
			   */
				}, {
					key: "transitiveReduction",
					value: function transitiveReduction(trV, trE) {
						// argument defaults are handled in `clone`
						var result = this.clone(trV, trE);
						var _iteratorNormalCompletion24 = true;
						var _didIteratorError24 = false;
						var _iteratorError24 = undefined;
			
						try {
							for (var _iterator24 = this.vertices()[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
								var _step24$value = _slicedToArray(_step24.value, 1);
			
								var x = _step24$value[0];
								var _iteratorNormalCompletion25 = true;
								var _didIteratorError25 = false;
								var _iteratorError25 = undefined;
			
								try {
									for (var _iterator25 = this.vertices()[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
										var _step25$value = _slicedToArray(_step25.value, 1);
			
										var y = _step25$value[0];
			
										if (result.hasEdge(x, y)) {
											var _iteratorNormalCompletion26 = true;
											var _didIteratorError26 = false;
											var _iteratorError26 = undefined;
			
											try {
												for (var _iterator26 = this.vertices()[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
													var _step26$value = _slicedToArray(_step26.value, 1);
			
													var z = _step26$value[0];
			
													if (result.hasPath(y, z)) result.removeEdge(x, z);
												}
											} catch (err) {
												_didIteratorError26 = true;
												_iteratorError26 = err;
											} finally {
												try {
													if (!_iteratorNormalCompletion26 && _iterator26["return"]) {
														_iterator26["return"]();
													}
												} finally {
													if (_didIteratorError26) {
														throw _iteratorError26;
													}
												}
											}
										}
									}
								} catch (err) {
									_didIteratorError25 = true;
									_iteratorError25 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion25 && _iterator25["return"]) {
											_iterator25["return"]();
										}
									} finally {
										if (_didIteratorError25) {
											throw _iteratorError25;
										}
									}
								}
							}
						} catch (err) {
							_didIteratorError24 = true;
							_iteratorError24 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion24 && _iterator24["return"]) {
									_iterator24["return"]();
								}
							} finally {
								if (_didIteratorError24) {
									throw _iteratorError24;
								}
							}
						}
			
						return result;
					}
			
					/**
			   * This method replaces stretches of non-branching directed pathway into single edges.
			   * More specifically, it identifies all 'nexus' vertices in the graph and preserves them.
			   * It then removes all other vertices and all edges from the graph, then inserts edges
			   * between nexuses that summarize the connectivity that was there before.
			   *
			   * A nexus is any vertex that is *not* characterized by '1 edge in, 1 edge out'.
			   * A custom `isNexus` function may be provided to manually select additional vertices
			   * that should be preserved as nexus.
			   * @param [isNexus] {function(string, *): boolean}
			   *                  a predicate for identifying additional vertices that should be treated as nexus;
			   *                  It receives a `key` and `value` associated to a vertex and should return
			   *                  true if and only if that vertex should be a nexus.
			   * @throws {Graph.BranchlessCycleError} if the graph contains a cycle with no branches or nexuses
			   */
				}, {
					key: "contractPaths",
					value: function contractPaths() {
						var _this2 = this;
			
						var isNexus = arguments.length <= 0 || arguments[0] === undefined ? function () {
							return false;
						} : arguments[0];
			
						/* what makes a a vertex a nexus (start/end-point) */
						var nexuses = new Set([].concat(_toConsumableArray(this.vertices())).filter(function (_ref) {
							var _ref2 = _slicedToArray(_ref, 2);
			
							var key = _ref2[0];
							var val = _ref2[1];
							return _this2.outDegree(key) !== 1 || _this2.inDegree(key) !== 1 || isNexus(key, val);
						}).map(function (_ref3) {
							var _ref32 = _slicedToArray(_ref3, 1);
			
							var key = _ref32[0];
							return key;
						}));
			
						/* error if there is a branch-less cycle */
						{
							var _iteratorNormalCompletion29;
			
							var _didIteratorError29;
			
							var _iteratorError29;
			
							var _iterator29, _step29;
			
							(function () {
								var unhandledVertices = new Set([].concat(_toConsumableArray(_this2.vertices())).map(function (_ref4) {
									var _ref42 = _slicedToArray(_ref4, 1);
			
									var key = _ref42[0];
									return key;
								}));
								var checkForBlCycle = function checkForBlCycle(key) {
									if (!unhandledVertices.has(key)) {
										return;
									}
									unhandledVertices["delete"](key);
									var _iteratorNormalCompletion27 = true;
									var _didIteratorError27 = false;
									var _iteratorError27 = undefined;
			
									try {
										for (var _iterator27 = _this2.verticesFrom(key)[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
											var _step27$value = _slicedToArray(_step27.value, 1);
			
											var next = _step27$value[0];
											checkForBlCycle(next);
										}
									} catch (err) {
										_didIteratorError27 = true;
										_iteratorError27 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion27 && _iterator27["return"]) {
												_iterator27["return"]();
											}
										} finally {
											if (_didIteratorError27) {
												throw _iteratorError27;
											}
										}
									}
			
									var _iteratorNormalCompletion28 = true;
									var _didIteratorError28 = false;
									var _iteratorError28 = undefined;
			
									try {
										for (var _iterator28 = _this2.verticesTo(key)[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
											var _step28$value = _slicedToArray(_step28.value, 1);
			
											var next = _step28$value[0];
											checkForBlCycle(next);
										}
									} catch (err) {
										_didIteratorError28 = true;
										_iteratorError28 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion28 && _iterator28["return"]) {
												_iterator28["return"]();
											}
										} finally {
											if (_didIteratorError28) {
												throw _iteratorError28;
											}
										}
									}
								};
								_iteratorNormalCompletion29 = true;
								_didIteratorError29 = false;
								_iteratorError29 = undefined;
			
								try {
									for (_iterator29 = nexuses[Symbol.iterator](); !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
										var key = _step29.value;
										checkForBlCycle(key);
									}
								} catch (err) {
									_didIteratorError29 = true;
									_iteratorError29 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion29 && _iterator29["return"]) {
											_iterator29["return"]();
										}
									} finally {
										if (_didIteratorError29) {
											throw _iteratorError29;
										}
									}
								}
			
								if (unhandledVertices.size > 0) {
									var startingKey = unhandledVertices.values().next().value,
									    cycle = [],
									    current = startingKey;
									do {
										cycle.push(current);
										current = _this2.verticesFrom(current).next().value[0];
									} while (current !== startingKey);
									throw new Graph.BranchlessCycleError(cycle);
								}
							})();
						}
			
						/* bookkeeping */
						var contractionsToAdd = new Map();
			
						/* register the path starting with the given edge */
						var startPath = function startPath(start, next, backwards) {
							/* functions to help branch on `backwards` */
							var fromTo = function fromTo() {
								var strt = arguments.length <= 0 || arguments[0] === undefined ? start : arguments[0];
								var nxt = arguments.length <= 1 || arguments[1] === undefined ? next : arguments[1];
								return backwards ? [nxt, strt] : [strt, nxt];
							};
							var verticesNext = function verticesNext(v) {
								return backwards ? _this2.verticesTo(v) : _this2.verticesFrom(v);
							};
			
							/* bookkeeping */
							var verticesToRemove = new Set();
							var edgesToRemove = new Set();
							var path = new Graph();
			
							/* process the start of the path */
							path.addVertex(start, _this2.vertexValue(start));
							path.addVertex(next, _this2.vertexValue(next));
							path.addNewEdge.apply(path, _toConsumableArray(fromTo()).concat([_this2.edgeValue.apply(_this2, _toConsumableArray(fromTo()))]));
							edgesToRemove.add(fromTo());
			
							/* process as [current, next] moves across the path */
							var current = undefined;
							while (!nexuses.has(next)) {
								var _ref5 = [next, verticesNext(next).next().value[0]];
								current = _ref5[0];
								next = _ref5[1];
			
								path.addVertex(next, _this2.vertexValue(next));
								path.addNewEdge.apply(path, _toConsumableArray(fromTo(current, next)).concat([_this2.edgeValue.apply(_this2, _toConsumableArray(fromTo(current, next)))]));
								verticesToRemove.add(current);
								edgesToRemove.add(fromTo(current, next));
							}
			
							/* register new path contraction */
							if (!contractionsToAdd.get(fromTo()[0])) {
								contractionsToAdd.set(fromTo()[0], new Map());
							}
							if (!contractionsToAdd.get(fromTo()[0]).get(fromTo()[1])) {
								contractionsToAdd.get(fromTo()[0]).set(fromTo()[1], new Graph());
							}
							contractionsToAdd.get(fromTo()[0]).get(fromTo()[1]).mergeIn(path);
			
							/* remove old edges and vertices */
							var _iteratorNormalCompletion30 = true;
							var _didIteratorError30 = false;
							var _iteratorError30 = undefined;
			
							try {
								for (var _iterator30 = edgesToRemove[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
									var key = _step30.value;
									_this2.removeExistingEdge.apply(_this2, _toConsumableArray(key));
								}
							} catch (err) {
								_didIteratorError30 = true;
								_iteratorError30 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion30 && _iterator30["return"]) {
										_iterator30["return"]();
									}
								} finally {
									if (_didIteratorError30) {
										throw _iteratorError30;
									}
								}
							}
			
							var _iteratorNormalCompletion31 = true;
							var _didIteratorError31 = false;
							var _iteratorError31 = undefined;
			
							try {
								for (var _iterator31 = verticesToRemove[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
									var key = _step31.value;
									_this2.destroyExistingVertex(key);
								}
							} catch (err) {
								_didIteratorError31 = true;
								_iteratorError31 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion31 && _iterator31["return"]) {
										_iterator31["return"]();
									}
								} finally {
									if (_didIteratorError31) {
										throw _iteratorError31;
									}
								}
							}
						};
			
						/* process paths starting at all nexus points */
						var _iteratorNormalCompletion32 = true;
						var _didIteratorError32 = false;
						var _iteratorError32 = undefined;
			
						try {
							for (var _iterator32 = nexuses[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
								var first = _step32.value;
								var _iteratorNormalCompletion34 = true;
								var _didIteratorError34 = false;
								var _iteratorError34 = undefined;
			
								try {
									for (var _iterator34 = this.verticesFrom(first)[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
										var _step34$value = _slicedToArray(_step34.value, 1);
			
										var next = _step34$value[0];
										startPath(first, next, false);
									}
								} catch (err) {
									_didIteratorError34 = true;
									_iteratorError34 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion34 && _iterator34["return"]) {
											_iterator34["return"]();
										}
									} finally {
										if (_didIteratorError34) {
											throw _iteratorError34;
										}
									}
								}
			
								var _iteratorNormalCompletion35 = true;
								var _didIteratorError35 = false;
								var _iteratorError35 = undefined;
			
								try {
									for (var _iterator35 = this.verticesTo(first)[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
										var _step35$value = _slicedToArray(_step35.value, 1);
			
										var next = _step35$value[0];
										startPath(first, next, true);
									}
								} catch (err) {
									_didIteratorError35 = true;
									_iteratorError35 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion35 && _iterator35["return"]) {
											_iterator35["return"]();
										}
									} finally {
										if (_didIteratorError35) {
											throw _iteratorError35;
										}
									}
								}
							}
			
							/* add the replacement edges */
						} catch (err) {
							_didIteratorError32 = true;
							_iteratorError32 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion32 && _iterator32["return"]) {
									_iterator32["return"]();
								}
							} finally {
								if (_didIteratorError32) {
									throw _iteratorError32;
								}
							}
						}
			
						var _iteratorNormalCompletion33 = true;
						var _didIteratorError33 = false;
						var _iteratorError33 = undefined;
			
						try {
							for (var _iterator33 = contractionsToAdd[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
								var _step33$value = _slicedToArray(_step33.value, 2);
			
								var from = _step33$value[0];
								var toVal = _step33$value[1];
								var _iteratorNormalCompletion36 = true;
								var _didIteratorError36 = false;
								var _iteratorError36 = undefined;
			
								try {
									for (var _iterator36 = toVal[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
										var _step36$value = _slicedToArray(_step36.value, 2);
			
										var to = _step36$value[0];
										var rememberedPath = _step36$value[1];
			
										this.addNewEdge(from, to, rememberedPath);
									}
								} catch (err) {
									_didIteratorError36 = true;
									_iteratorError36 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion36 && _iterator36["return"]) {
											_iterator36["return"]();
										}
									} finally {
										if (_didIteratorError36) {
											throw _iteratorError36;
										}
									}
								}
							}
						} catch (err) {
							_didIteratorError33 = true;
							_iteratorError33 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion33 && _iterator33["return"]) {
									_iterator33["return"]();
								}
							} finally {
								if (_didIteratorError33) {
									throw _iteratorError33;
								}
							}
						}
					}
			
					////////////////////////////////
					////////// Assertions //////////
					////////////////////////////////
			
				}, {
					key: _expectVertices,
					value: function value() {
						var _this3 = this;
			
						for (var _len2 = arguments.length, keys = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
							keys[_key3] = arguments[_key3];
						}
			
						var missingVertices = keys.filter(function (k) {
							return !_this3.hasVertex(k);
						});
						if (missingVertices.length) {
							throw new (_bind.apply(Graph.VertexNotExistsError, [null].concat(_toConsumableArray(missingVertices))))();
						}
					}
				}, {
					key: _expectVerticesAbsent,
					value: function value() {
						var _this4 = this;
			
						for (var _len3 = arguments.length, keys = Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
							keys[_key4] = arguments[_key4];
						}
			
						var presentVertices = keys.filter(function (k) {
							return _this4.hasVertex(k);
						});
						if (presentVertices.length) {
							throw new (_bind.apply(Graph.VertexExistsError, [null].concat(_toConsumableArray(presentVertices.map(function (k) {
								return [k, _this4.vertexValue(k)];
							})))))();
						}
					}
				}, {
					key: _expectEdges,
					value: function value() {
						var _this5 = this;
			
						for (var _len4 = arguments.length, keys = Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
							keys[_key5] = arguments[_key5];
						}
			
						var absentEdges = keys.filter(function (k) {
							return !_this5.hasEdge.apply(_this5, _toConsumableArray(k));
						});
						if (absentEdges.length) {
							throw new (_bind.apply(Graph.EdgeNotExistsError, [null].concat(_toConsumableArray(absentEdges))))();
						}
					}
				}, {
					key: _expectEdgesAbsent,
					value: function value() {
						var _this6 = this;
			
						for (var _len5 = arguments.length, keys = Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
							keys[_key6] = arguments[_key6];
						}
			
						var presentEdges = keys.filter(function (k) {
							return _this6.hasEdge.apply(_this6, _toConsumableArray(k));
						});
						if (presentEdges.length) {
							throw new (_bind.apply(Graph.EdgeExistsError, [null].concat(_toConsumableArray(presentEdges.map(function (k) {
								return [k, _this6.edgeValue.apply(_this6, _toConsumableArray(k))];
							})))))();
						}
					}
				}, {
					key: _expectNoConnectedEdges,
					value: function value(key) {
						var edges = [];
						var _iteratorNormalCompletion37 = true;
						var _didIteratorError37 = false;
						var _iteratorError37 = undefined;
			
						try {
							for (var _iterator37 = this.verticesFrom(key)[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
								var _step37$value = _slicedToArray(_step37.value, 1);
			
								var to = _step37$value[0];
								edges.push([[key, to], this.edgeValue(key, to)]);
							}
						} catch (err) {
							_didIteratorError37 = true;
							_iteratorError37 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion37 && _iterator37["return"]) {
									_iterator37["return"]();
								}
							} finally {
								if (_didIteratorError37) {
									throw _iteratorError37;
								}
							}
						}
			
						var _iteratorNormalCompletion38 = true;
						var _didIteratorError38 = false;
						var _iteratorError38 = undefined;
			
						try {
							for (var _iterator38 = this.verticesTo(key)[Symbol.iterator](), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
								var _step38$value = _slicedToArray(_step38.value, 1);
			
								var from = _step38$value[0];
								edges.push([[from, key], this.edgeValue(from, key)]);
							}
						} catch (err) {
							_didIteratorError38 = true;
							_iteratorError38 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion38 && _iterator38["return"]) {
									_iterator38["return"]();
								}
							} finally {
								if (_didIteratorError38) {
									throw _iteratorError38;
								}
							}
						}
			
						if (edges.length) {
							throw new (_bind.apply(Graph.HasConnectedEdgesError, [null].concat([key], edges)))();
						}
					}
				}]);
			
				return Graph;
			})();
			
			exports["default"] = Graph;
			Graph.VertexExistsError = (function (_Error) {
				_inherits(VertexExistsError, _Error);
			
				function VertexExistsError() {
					_classCallCheck(this, VertexExistsError);
			
					_get(Object.getPrototypeOf(VertexExistsError.prototype), "constructor", this).call(this);
					/**
			   * the set of relevant vertices as `[key, value]` shaped arrays
			   * @public
			   * @constant vertices
			   * @memberof Graph.VertexExistsError
			   * @instance
			   * @type {Set.<Array>}
			   */
			
					for (var _len6 = arguments.length, vertices = Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {
						vertices[_key7] = arguments[_key7];
					}
			
					this.vertices = new Set(vertices);
					this.message = "This graph has " + (this.vertices.size === 1 ? "a vertex" : "vertices") + " '" + [].concat(_toConsumableArray(this.vertices)).map(function (_ref6) {
						var _ref62 = _slicedToArray(_ref6, 1);
			
						var key = _ref62[0];
						return key;
					}).join("', '") + "'";
				}
			
				return VertexExistsError;
			})(Error);
			
			/**
			 * @class
			 * @classdesc This type of error is thrown when specific vertices are expected to exist, but don't.
			 * @extends Error
			 */
			Graph.VertexNotExistsError = (function (_Error2) {
				_inherits(VertexNotExistsError, _Error2);
			
				function VertexNotExistsError() {
					_classCallCheck(this, VertexNotExistsError);
			
					_get(Object.getPrototypeOf(VertexNotExistsError.prototype), "constructor", this).call(this);
					/**
			   * the set of relevant vertex keys
			   * @public
			   * @constant vertices
			   * @memberof Graph.VertexNotExistsError
			   * @instance
			   * @type {Set.<string>}
			   */
			
					for (var _len7 = arguments.length, keys = Array(_len7), _key8 = 0; _key8 < _len7; _key8++) {
						keys[_key8] = arguments[_key8];
					}
			
					this.vertices = new Set(keys);
					this.message = "This graph does not have " + (this.vertices.size === 1 ? "a vertex" : "vertices") + " '" + [].concat(_toConsumableArray(this.vertices)).join("', '") + "'";
				}
			
				return VertexNotExistsError;
			})(Error);
			
			/**
			 * @class
			 * @classdesc This type of error is thrown when specific edges are expected not to exist, but do.
			 * @extends Error
			 */
			Graph.EdgeExistsError = (function (_Error3) {
				_inherits(EdgeExistsError, _Error3);
			
				function EdgeExistsError() {
					_classCallCheck(this, EdgeExistsError);
			
					_get(Object.getPrototypeOf(EdgeExistsError.prototype), "constructor", this).call(this);
					/**
			   * the set of relevant edges as `[[from, to], value]` shaped arrays
			   * @public
			   * @constant edges
			   * @memberof Graph.EdgeExistsError
			   * @instance
			   * @type {Set.<Array>}
			   */
			
					for (var _len8 = arguments.length, edges = Array(_len8), _key9 = 0; _key9 < _len8; _key9++) {
						edges[_key9] = arguments[_key9];
					}
			
					this.edges = new Set(edges);
					this.message = "This graph has " + (this.edges.size === 1 ? "an edge" : "edges") + " " + [].concat(_toConsumableArray(this.edges)).map(function (_ref7) {
						var _ref72 = _slicedToArray(_ref7, 1);
			
						var _ref72$0 = _slicedToArray(_ref72[0], 2);
			
						var from = _ref72$0[0];
						var to = _ref72$0[1];
						return "['" + from + "', '" + to + "']";
					}).join(", ");
				}
			
				return EdgeExistsError;
			})(Error);
			
			/**
			 * @class
			 * @classdesc This type of error is thrown when specific edges are expected to exist, but don't.
			 * @extends Error
			 */
			Graph.EdgeNotExistsError = (function (_Error4) {
				_inherits(EdgeNotExistsError, _Error4);
			
				function EdgeNotExistsError() {
					_classCallCheck(this, EdgeNotExistsError);
			
					_get(Object.getPrototypeOf(EdgeNotExistsError.prototype), "constructor", this).call(this);
					/**
			   * the set of relevant edge keys as `[from, to]` shaped arrays
			   * @public
			   * @constant edges
			   * @memberof Graph.EdgeNotExistsError
			   * @instance
			   * @type {Set.<Array.<string>>}
			   */
			
					for (var _len9 = arguments.length, edges = Array(_len9), _key10 = 0; _key10 < _len9; _key10++) {
						edges[_key10] = arguments[_key10];
					}
			
					this.edges = new Set(edges);
					this.message = "This graph does not have " + (this.edges.size === 1 ? "an edge" : "edges") + " " + [].concat(_toConsumableArray(this.edges)).map(function (_ref8) {
						var _ref82 = _slicedToArray(_ref8, 2);
			
						var from = _ref82[0];
						var to = _ref82[1];
						return "['" + from + "', '" + to + "']";
					}).join(", ");
				}
			
				return EdgeNotExistsError;
			})(Error);
			
			/**
			 * @class
			 * @classdesc This type of error is thrown when a vertex is expected not to have any connected edges, but does.
			 * @extends Graph.EdgeExistsError
			 */
			Graph.HasConnectedEdgesError = (function (_Graph$EdgeExistsError) {
				_inherits(HasConnectedEdgesError, _Graph$EdgeExistsError);
			
				function HasConnectedEdgesError(key) {
					_classCallCheck(this, HasConnectedEdgesError);
			
					for (var _len10 = arguments.length, edges = Array(_len10 > 1 ? _len10 - 1 : 0), _key11 = 1; _key11 < _len10; _key11++) {
						edges[_key11 - 1] = arguments[_key11];
					}
			
					_get(Object.getPrototypeOf(HasConnectedEdgesError.prototype), "constructor", this).apply(this, edges);
					/**
			   * the key of the vertex that has connected edges
			   * @public
			   * @constant vertex
			   * @memberof Graph.HasConnectedEdgesError
			   * @instance
			   * @type {string}
			   */
					this.vertex = key;
					this.message = "The '" + key + "' vertex has connected " + (this.edges.size === 1 ? "an edge" : "edges") + " " + [].concat(_toConsumableArray(this.edges)).map(function (_ref9) {
						var _ref92 = _slicedToArray(_ref9, 1);
			
						var _ref92$0 = _slicedToArray(_ref92[0], 2);
			
						var from = _ref92$0[0];
						var to = _ref92$0[1];
						return "['" + from + "', '" + to + "']";
					}).join(", ");
				}
			
				return HasConnectedEdgesError;
			})(Graph.EdgeExistsError);
			
			/**
			 * @class
			 * @classdesc This type of error is thrown when a graph is expected not to have a directed cycle, but does.
			 * @extends Error
			 */
			Graph.CycleError = (function (_Error5) {
				_inherits(CycleError, _Error5);
			
				function CycleError(cycle) {
					_classCallCheck(this, CycleError);
			
					_get(Object.getPrototypeOf(CycleError.prototype), "constructor", this).call(this);
					/**
			   * the vertices involved in the cycle, in order but with an unspecified starting point
			   * @public
			   * @constant cycle
			   * @memberof Graph.CycleError
			   * @instance
			   * @type {Array.<string>}
			   */
					this.cycle = cycle;
					this.message = "This graph contains a cycle: " + cycle;
				}
			
				return CycleError;
			})(Error);
			
			/**
			 * @class
			 * @classdesc This type of error is thrown when a graph is expected not to have a branch-less directed cycle, but does.
			 * @extends Graph.CycleError
			 */
			Graph.BranchlessCycleError = (function (_Graph$CycleError) {
				_inherits(BranchlessCycleError, _Graph$CycleError);
			
				function BranchlessCycleError(cycle) {
					_classCallCheck(this, BranchlessCycleError);
			
					_get(Object.getPrototypeOf(BranchlessCycleError.prototype), "constructor", this).call(this, cycle);
					this.message = "This graph contains a branch-less cycle: " + cycle;
				}
			
				return BranchlessCycleError;
			})(Graph.CycleError);
			module.exports = exports["default"];
			// stack
		
			// This algorithm is based on the following article:
			// Enumeration of the elementary circuits of a directed graph
			// R. Tarjan, SIAM Journal on Computing, 2 (1973), pp. 211-216
			// http://dx.doi.org/10.1137/0202017
			// -----
			// TODO: implement the improved version as defined by Johnson:
			// Finding all the elementary circuits of a directed graph.
			// D. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.
			// http://dx.doi.org/10.1137/0204007
		
			/* bookkeeping */
		
			/* the main recursive backtracking algorithm */
			// if a simple cycle continuing the partial path on the pointStack has been found
		
			/* start backtracking from each vertex in the graph */
		
		/***/ }
		
		/******/ })
		});
		;
		//# sourceMappingURL=graph.js.map
	
	/***/ },
	/* 144 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(123);
		
		module.exports = function get() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 145 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(384);
		
		module.exports = function inRange() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 146 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(8);
		
		module.exports = function isArray() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 147 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(388);
		
		module.exports = function isNull() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 148 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(57);
		
		module.exports = function isString() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 149 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(9);
		
		module.exports = function keys() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 150 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getNative = __webpack_require__(39),
		    root = __webpack_require__(11);
		
		/* Built-in method references that are verified to be native. */
		var Set = getNative(root, 'Set');
		
		module.exports = Set;
	
	
	/***/ },
	/* 151 */
	/***/ function(module, exports, __webpack_require__) {
	
		var MapCache = __webpack_require__(110),
		    setCacheAdd = __webpack_require__(363),
		    setCacheHas = __webpack_require__(364);
		
		/**
		 *
		 * Creates an array cache object to store unique values.
		 *
		 * @private
		 * @constructor
		 * @param {Array} [values] The values to cache.
		 */
		function SetCache(values) {
		  var index = -1,
		      length = values ? values.length : 0;
		
		  this.__data__ = new MapCache;
		  while (++index < length) {
		    this.add(values[index]);
		  }
		}
		
		// Add methods to `SetCache`.
		SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
		SetCache.prototype.has = setCacheHas;
		
		module.exports = SetCache;
	
	
	/***/ },
	/* 152 */
	/***/ function(module, exports, __webpack_require__) {
	
		var root = __webpack_require__(11);
		
		/** Built-in value references. */
		var Uint8Array = root.Uint8Array;
		
		module.exports = Uint8Array;
	
	
	/***/ },
	/* 153 */
	/***/ function(module, exports) {
	
		/**
		 * A faster alternative to `Function#apply`, this function invokes `func`
		 * with the `this` binding of `thisArg` and the arguments of `args`.
		 *
		 * @private
		 * @param {Function} func The function to invoke.
		 * @param {*} thisArg The `this` binding of `func`.
		 * @param {Array} args The arguments to invoke `func` with.
		 * @returns {*} Returns the result of `func`.
		 */
		function apply(func, thisArg, args) {
		  switch (args.length) {
		    case 0: return func.call(thisArg);
		    case 1: return func.call(thisArg, args[0]);
		    case 2: return func.call(thisArg, args[0], args[1]);
		    case 3: return func.call(thisArg, args[0], args[1], args[2]);
		  }
		  return func.apply(thisArg, args);
		}
		
		module.exports = apply;
	
	
	/***/ },
	/* 154 */
	/***/ function(module, exports) {
	
		/**
		 * A specialized version of `_.reduce` for arrays without support for
		 * iteratee shorthands.
		 *
		 * @private
		 * @param {Array} [array] The array to iterate over.
		 * @param {Function} iteratee The function invoked per iteration.
		 * @param {*} [accumulator] The initial value.
		 * @param {boolean} [initAccum] Specify using the first element of `array` as
		 *  the initial value.
		 * @returns {*} Returns the accumulated value.
		 */
		function arrayReduce(array, iteratee, accumulator, initAccum) {
		  var index = -1,
		      length = array ? array.length : 0;
		
		  if (initAccum && length) {
		    accumulator = array[++index];
		  }
		  while (++index < length) {
		    accumulator = iteratee(accumulator, array[index], index, array);
		  }
		  return accumulator;
		}
		
		module.exports = arrayReduce;
	
	
	/***/ },
	/* 155 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseFor = __webpack_require__(290),
		    keys = __webpack_require__(9);
		
		/**
		 * The base implementation of `_.forOwn` without support for iteratee shorthands.
		 *
		 * @private
		 * @param {Object} object The object to iterate over.
		 * @param {Function} iteratee The function invoked per iteration.
		 * @returns {Object} Returns `object`.
		 */
		function baseForOwn(object, iteratee) {
		  return object && baseFor(object, iteratee, keys);
		}
		
		module.exports = baseForOwn;
	
	
	/***/ },
	/* 156 */
	/***/ function(module, exports, __webpack_require__) {
	
		var castPath = __webpack_require__(115),
		    isKey = __webpack_require__(55),
		    toKey = __webpack_require__(40);
		
		/**
		 * The base implementation of `_.get` without support for default values.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @param {Array|string} path The path of the property to get.
		 * @returns {*} Returns the resolved value.
		 */
		function baseGet(object, path) {
		  path = isKey(path, object) ? [path] : castPath(path);
		
		  var index = 0,
		      length = path.length;
		
		  while (object != null && index < length) {
		    object = object[toKey(path[index++])];
		  }
		  return (index && index == length) ? object : undefined;
		}
		
		module.exports = baseGet;
	
	
	/***/ },
	/* 157 */
	/***/ function(module, exports, __webpack_require__) {
	
		var arrayPush = __webpack_require__(112),
		    isArray = __webpack_require__(8);
		
		/**
		 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
		 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
		 * symbols of `object`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @param {Function} keysFunc The function to get the keys of `object`.
		 * @param {Function} symbolsFunc The function to get the symbols of `object`.
		 * @returns {Array} Returns the array of property names and symbols.
		 */
		function baseGetAllKeys(object, keysFunc, symbolsFunc) {
		  var result = keysFunc(object);
		  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
		}
		
		module.exports = baseGetAllKeys;
	
	
	/***/ },
	/* 158 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getPrototype = __webpack_require__(118);
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
		
		/**
		 * The base implementation of `_.has` without support for deep paths.
		 *
		 * @private
		 * @param {Object} [object] The object to query.
		 * @param {Array|string} key The key to check.
		 * @returns {boolean} Returns `true` if `key` exists, else `false`.
		 */
		function baseHas(object, key) {
		  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
		  // that are composed entirely of index properties, return `false` for
		  // `hasOwnProperty` checks of them.
		  return object != null &&
		    (hasOwnProperty.call(object, key) ||
		      (typeof object == 'object' && key in object && getPrototype(object) === null));
		}
		
		module.exports = baseHas;
	
	
	/***/ },
	/* 159 */
	/***/ function(module, exports) {
	
		/**
		 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
		 *
		 * @private
		 * @param {Object} object The source object.
		 * @param {string[]} props The property identifiers to pick from.
		 * @param {Function} predicate The function invoked per property.
		 * @returns {Object} Returns the new object.
		 */
		function basePickBy(object, props, predicate) {
		  var index = -1,
		      length = props.length,
		      result = {};
		
		  while (++index < length) {
		    var key = props[index],
		        value = object[key];
		
		    if (predicate(value, key)) {
		      result[key] = value;
		    }
		  }
		  return result;
		}
		
		module.exports = basePickBy;
	
	
	/***/ },
	/* 160 */
	/***/ function(module, exports) {
	
		/**
		 * The base implementation of `_.times` without support for iteratee shorthands
		 * or max array length checks.
		 *
		 * @private
		 * @param {number} n The number of times to invoke `iteratee`.
		 * @param {Function} iteratee The function invoked per iteration.
		 * @returns {Array} Returns the array of results.
		 */
		function baseTimes(n, iteratee) {
		  var index = -1,
		      result = Array(n);
		
		  while (++index < n) {
		    result[index] = iteratee(index);
		  }
		  return result;
		}
		
		module.exports = baseTimes;
	
	
	/***/ },
	/* 161 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Symbol = __webpack_require__(74),
		    isSymbol = __webpack_require__(58);
		
		/** Used as references for various `Number` constants. */
		var INFINITY = 1 / 0;
		
		/** Used to convert symbols to primitives and strings. */
		var symbolProto = Symbol ? Symbol.prototype : undefined,
		    symbolToString = symbolProto ? symbolProto.toString : undefined;
		
		/**
		 * The base implementation of `_.toString` which doesn't convert nullish
		 * values to empty strings.
		 *
		 * @private
		 * @param {*} value The value to process.
		 * @returns {string} Returns the string.
		 */
		function baseToString(value) {
		  // Exit early for strings to avoid a performance hit in some environments.
		  if (typeof value == 'string') {
		    return value;
		  }
		  if (isSymbol(value)) {
		    return symbolToString ? symbolToString.call(value) : '';
		  }
		  var result = (value + '');
		  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		}
		
		module.exports = baseToString;
	
	
	/***/ },
	/* 162 */
	/***/ function(module, exports) {
	
		/**
		 * The base implementation of `_.unary` without support for storing metadata.
		 *
		 * @private
		 * @param {Function} func The function to cap arguments for.
		 * @returns {Function} Returns the new capped function.
		 */
		function baseUnary(func) {
		  return function(value) {
		    return func(value);
		  };
		}
		
		module.exports = baseUnary;
	
	
	/***/ },
	/* 163 */
	/***/ function(module, exports, __webpack_require__) {
	
		var SetCache = __webpack_require__(151),
		    arrayIncludes = __webpack_require__(279),
		    arrayIncludesWith = __webpack_require__(280),
		    cacheHas = __webpack_require__(312),
		    createSet = __webpack_require__(328),
		    setToArray = __webpack_require__(83);
		
		/** Used as the size to enable large array optimizations. */
		var LARGE_ARRAY_SIZE = 200;
		
		/**
		 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
		 *
		 * @private
		 * @param {Array} array The array to inspect.
		 * @param {Function} [iteratee] The iteratee invoked per element.
		 * @param {Function} [comparator] The comparator invoked per element.
		 * @returns {Array} Returns the new duplicate free array.
		 */
		function baseUniq(array, iteratee, comparator) {
		  var index = -1,
		      includes = arrayIncludes,
		      length = array.length,
		      isCommon = true,
		      result = [],
		      seen = result;
		
		  if (comparator) {
		    isCommon = false;
		    includes = arrayIncludesWith;
		  }
		  else if (length >= LARGE_ARRAY_SIZE) {
		    var set = iteratee ? null : createSet(array);
		    if (set) {
		      return setToArray(set);
		    }
		    isCommon = false;
		    includes = cacheHas;
		    seen = new SetCache;
		  }
		  else {
		    seen = iteratee ? [] : result;
		  }
		  outer:
		  while (++index < length) {
		    var value = array[index],
		        computed = iteratee ? iteratee(value) : value;
		
		    value = (comparator || value !== 0) ? value : 0;
		    if (isCommon && computed === computed) {
		      var seenIndex = seen.length;
		      while (seenIndex--) {
		        if (seen[seenIndex] === computed) {
		          continue outer;
		        }
		      }
		      if (iteratee) {
		        seen.push(computed);
		      }
		      result.push(value);
		    }
		    else if (!includes(seen, computed, comparator)) {
		      if (seen !== result) {
		        seen.push(computed);
		      }
		      result.push(value);
		    }
		  }
		  return result;
		}
		
		module.exports = baseUniq;
	
	
	/***/ },
	/* 164 */
	/***/ function(module, exports, __webpack_require__) {
	
		var SetCache = __webpack_require__(151),
		    arraySome = __webpack_require__(281);
		
		/** Used to compose bitmasks for comparison styles. */
		var UNORDERED_COMPARE_FLAG = 1,
		    PARTIAL_COMPARE_FLAG = 2;
		
		/**
		 * A specialized version of `baseIsEqualDeep` for arrays with support for
		 * partial deep comparisons.
		 *
		 * @private
		 * @param {Array} array The array to compare.
		 * @param {Array} other The other array to compare.
		 * @param {Function} equalFunc The function to determine equivalents of values.
		 * @param {Function} customizer The function to customize comparisons.
		 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
		 *  for more details.
		 * @param {Object} stack Tracks traversed `array` and `other` objects.
		 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
		 */
		function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
		  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
		      arrLength = array.length,
		      othLength = other.length;
		
		  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
		    return false;
		  }
		  // Assume cyclic values are equal.
		  var stacked = stack.get(array);
		  if (stacked && stack.get(other)) {
		    return stacked == other;
		  }
		  var index = -1,
		      result = true,
		      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;
		
		  stack.set(array, other);
		  stack.set(other, array);
		
		  // Ignore non-index properties.
		  while (++index < arrLength) {
		    var arrValue = array[index],
		        othValue = other[index];
		
		    if (customizer) {
		      var compared = isPartial
		        ? customizer(othValue, arrValue, index, other, array, stack)
		        : customizer(arrValue, othValue, index, array, other, stack);
		    }
		    if (compared !== undefined) {
		      if (compared) {
		        continue;
		      }
		      result = false;
		      break;
		    }
		    // Recursively compare arrays (susceptible to call stack limits).
		    if (seen) {
		      if (!arraySome(other, function(othValue, othIndex) {
		            if (!seen.has(othIndex) &&
		                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
		              return seen.add(othIndex);
		            }
		          })) {
		        result = false;
		        break;
		      }
		    } else if (!(
		          arrValue === othValue ||
		            equalFunc(arrValue, othValue, customizer, bitmask, stack)
		        )) {
		      result = false;
		      break;
		    }
		  }
		  stack['delete'](array);
		  stack['delete'](other);
		  return result;
		}
		
		module.exports = equalArrays;
	
	
	/***/ },
	/* 165 */
	/***/ function(module, exports) {
	
		/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
		var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
		
		module.exports = freeGlobal;
		
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 166 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseTimes = __webpack_require__(160),
		    isArguments = __webpack_require__(124),
		    isArray = __webpack_require__(8),
		    isLength = __webpack_require__(85),
		    isString = __webpack_require__(57);
		
		/**
		 * Creates an array of index keys for `object` values of arrays,
		 * `arguments` objects, and strings, otherwise `null` is returned.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @returns {Array|null} Returns index keys, else `null`.
		 */
		function indexKeys(object) {
		  var length = object ? object.length : undefined;
		  if (isLength(length) &&
		      (isArray(object) || isString(object) || isArguments(object))) {
		    return baseTimes(length, String);
		  }
		  return null;
		}
		
		module.exports = indexKeys;
	
	
	/***/ },
	/* 167 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isObject = __webpack_require__(12);
		
		/**
		 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` if suitable for strict
		 *  equality comparisons, else `false`.
		 */
		function isStrictComparable(value) {
		  return value === value && !isObject(value);
		}
		
		module.exports = isStrictComparable;
	
	
	/***/ },
	/* 168 */
	/***/ function(module, exports) {
	
		/**
		 * A specialized version of `matchesProperty` for source values suitable
		 * for strict equality comparisons, i.e. `===`.
		 *
		 * @private
		 * @param {string} key The key of the property to get.
		 * @param {*} srcValue The value to match.
		 * @returns {Function} Returns the new spec function.
		 */
		function matchesStrictComparable(key, srcValue) {
		  return function(object) {
		    if (object == null) {
		      return false;
		    }
		    return object[key] === srcValue &&
		      (srcValue !== undefined || (key in Object(object)));
		  };
		}
		
		module.exports = matchesStrictComparable;
	
	
	/***/ },
	/* 169 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(165);
		
		/** Detect free variable `exports`. */
		var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
		
		/** Detect free variable `module`. */
		var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
		
		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;
		
		/** Detect free variable `process` from Node.js. */
		var freeProcess = moduleExports && freeGlobal.process;
		
		/** Used to access faster Node.js helpers. */
		var nodeUtil = (function() {
		  try {
		    return freeProcess && freeProcess.binding('util');
		  } catch (e) {}
		}());
		
		module.exports = nodeUtil;
		
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(132)(module)))
	
	/***/ },
	/* 170 */
	/***/ function(module, exports) {
	
		/** Used to resolve the decompiled source of functions. */
		var funcToString = Function.prototype.toString;
		
		/**
		 * Converts `func` to its source code.
		 *
		 * @private
		 * @param {Function} func The function to process.
		 * @returns {string} Returns the source code.
		 */
		function toSource(func) {
		  if (func != null) {
		    try {
		      return funcToString.call(func);
		    } catch (e) {}
		    try {
		      return (func + '');
		    } catch (e) {}
		  }
		  return '';
		}
		
		module.exports = toSource;
	
	
	/***/ },
	/* 171 */
	/***/ function(module, exports) {
	
		/**
		 * This method returns the first argument it receives.
		 *
		 * @static
		 * @since 0.1.0
		 * @memberOf _
		 * @category Util
		 * @param {*} value Any value.
		 * @returns {*} Returns `value`.
		 * @example
		 *
		 * var object = { 'a': 1 };
		 *
		 * console.log(_.identity(object) === object);
		 * // => true
		 */
		function identity(value) {
		  return value;
		}
		
		module.exports = identity;
	
	
	/***/ },
	/* 172 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIsEqual = __webpack_require__(113);
		
		/**
		 * Performs a deep comparison between two values to determine if they are
		 * equivalent.
		 *
		 * **Note:** This method supports comparing arrays, array buffers, booleans,
		 * date objects, error objects, maps, numbers, `Object` objects, regexes,
		 * sets, strings, symbols, and typed arrays. `Object` objects are compared
		 * by their own, not inherited, enumerable properties. Functions and DOM
		 * nodes are **not** supported.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to compare.
		 * @param {*} other The other value to compare.
		 * @returns {boolean} Returns `true` if the values are equivalent,
		 *  else `false`.
		 * @example
		 *
		 * var object = { 'a': 1 };
		 * var other = { 'a': 1 };
		 *
		 * _.isEqual(object, other);
		 * // => true
		 *
		 * object === other;
		 * // => false
		 */
		function isEqual(value, other) {
		  return baseIsEqual(value, other);
		}
		
		module.exports = isEqual;
	
	
	/***/ },
	/* 173 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseKeysIn = __webpack_require__(302),
		    indexKeys = __webpack_require__(166),
		    isIndex = __webpack_require__(54),
		    isPrototype = __webpack_require__(81);
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
		
		/**
		 * Creates an array of the own and inherited enumerable property names of `object`.
		 *
		 * **Note:** Non-object values are coerced to objects.
		 *
		 * @static
		 * @memberOf _
		 * @since 3.0.0
		 * @category Object
		 * @param {Object} object The object to query.
		 * @returns {Array} Returns the array of property names.
		 * @example
		 *
		 * function Foo() {
		 *   this.a = 1;
		 *   this.b = 2;
		 * }
		 *
		 * Foo.prototype.c = 3;
		 *
		 * _.keysIn(new Foo);
		 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
		 */
		function keysIn(object) {
		  var index = -1,
		      isProto = isPrototype(object),
		      props = baseKeysIn(object),
		      propsLength = props.length,
		      indexes = indexKeys(object),
		      skipIndexes = !!indexes,
		      result = indexes || [],
		      length = result.length;
		
		  while (++index < propsLength) {
		    var key = props[index];
		    if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
		        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
		      result.push(key);
		    }
		  }
		  return result;
		}
		
		module.exports = keysIn;
	
	
	/***/ },
	/* 174 */
	/***/ function(module, exports, __webpack_require__) {
	
		var MapCache = __webpack_require__(110);
		
		/** Used as the `TypeError` message for "Functions" methods. */
		var FUNC_ERROR_TEXT = 'Expected a function';
		
		/**
		 * Creates a function that memoizes the result of `func`. If `resolver` is
		 * provided, it determines the cache key for storing the result based on the
		 * arguments provided to the memoized function. By default, the first argument
		 * provided to the memoized function is used as the map cache key. The `func`
		 * is invoked with the `this` binding of the memoized function.
		 *
		 * **Note:** The cache is exposed as the `cache` property on the memoized
		 * function. Its creation may be customized by replacing the `_.memoize.Cache`
		 * constructor with one whose instances implement the
		 * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
		 * method interface of `delete`, `get`, `has`, and `set`.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Function
		 * @param {Function} func The function to have its output memoized.
		 * @param {Function} [resolver] The function to resolve the cache key.
		 * @returns {Function} Returns the new memoized function.
		 * @example
		 *
		 * var object = { 'a': 1, 'b': 2 };
		 * var other = { 'c': 3, 'd': 4 };
		 *
		 * var values = _.memoize(_.values);
		 * values(object);
		 * // => [1, 2]
		 *
		 * values(other);
		 * // => [3, 4]
		 *
		 * object.a = 2;
		 * values(object);
		 * // => [1, 2]
		 *
		 * // Modify the result cache.
		 * values.cache.set(object, ['a', 'b']);
		 * values(object);
		 * // => ['a', 'b']
		 *
		 * // Replace `_.memoize.Cache`.
		 * _.memoize.Cache = WeakMap;
		 */
		function memoize(func, resolver) {
		  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
		    throw new TypeError(FUNC_ERROR_TEXT);
		  }
		  var memoized = function() {
		    var args = arguments,
		        key = resolver ? resolver.apply(this, args) : args[0],
		        cache = memoized.cache;
		
		    if (cache.has(key)) {
		      return cache.get(key);
		    }
		    var result = func.apply(this, args);
		    memoized.cache = cache.set(key, result);
		    return result;
		  };
		  memoized.cache = new (memoize.Cache || MapCache);
		  return memoized;
		}
		
		// Assign cache to `_.memoize`.
		memoize.Cache = MapCache;
		
		module.exports = memoize;
	
	
	/***/ },
	/* 175 */
	/***/ function(module, exports) {
	
		/**
		 * This method returns a new empty array.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.13.0
		 * @category Util
		 * @returns {Array} Returns the new empty array.
		 * @example
		 *
		 * var arrays = _.times(2, _.stubArray);
		 *
		 * console.log(arrays);
		 * // => [[], []]
		 *
		 * console.log(arrays[0] === arrays[1]);
		 * // => false
		 */
		function stubArray() {
		  return [];
		}
		
		module.exports = stubArray;
	
	
	/***/ },
	/* 176 */
	/***/ function(module, exports, __webpack_require__) {
	
		var toNumber = __webpack_require__(178);
		
		/** Used as references for various `Number` constants. */
		var INFINITY = 1 / 0,
		    MAX_INTEGER = 1.7976931348623157e+308;
		
		/**
		 * Converts `value` to a finite number.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.12.0
		 * @category Lang
		 * @param {*} value The value to convert.
		 * @returns {number} Returns the converted number.
		 * @example
		 *
		 * _.toFinite(3.2);
		 * // => 3.2
		 *
		 * _.toFinite(Number.MIN_VALUE);
		 * // => 5e-324
		 *
		 * _.toFinite(Infinity);
		 * // => 1.7976931348623157e+308
		 *
		 * _.toFinite('3.2');
		 * // => 3.2
		 */
		function toFinite(value) {
		  if (!value) {
		    return value === 0 ? value : 0;
		  }
		  value = toNumber(value);
		  if (value === INFINITY || value === -INFINITY) {
		    var sign = (value < 0 ? -1 : 1);
		    return sign * MAX_INTEGER;
		  }
		  return value === value ? value : 0;
		}
		
		module.exports = toFinite;
	
	
	/***/ },
	/* 177 */
	/***/ function(module, exports, __webpack_require__) {
	
		var toFinite = __webpack_require__(176);
		
		/**
		 * Converts `value` to an integer.
		 *
		 * **Note:** This method is loosely based on
		 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to convert.
		 * @returns {number} Returns the converted integer.
		 * @example
		 *
		 * _.toInteger(3.2);
		 * // => 3
		 *
		 * _.toInteger(Number.MIN_VALUE);
		 * // => 0
		 *
		 * _.toInteger(Infinity);
		 * // => 1.7976931348623157e+308
		 *
		 * _.toInteger('3.2');
		 * // => 3
		 */
		function toInteger(value) {
		  var result = toFinite(value),
		      remainder = result % 1;
		
		  return result === result ? (remainder ? result - remainder : result) : 0;
		}
		
		module.exports = toInteger;
	
	
	/***/ },
	/* 178 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isFunction = __webpack_require__(84),
		    isObject = __webpack_require__(12),
		    isSymbol = __webpack_require__(58);
		
		/** Used as references for various `Number` constants. */
		var NAN = 0 / 0;
		
		/** Used to match leading and trailing whitespace. */
		var reTrim = /^\s+|\s+$/g;
		
		/** Used to detect bad signed hexadecimal string values. */
		var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
		
		/** Used to detect binary string values. */
		var reIsBinary = /^0b[01]+$/i;
		
		/** Used to detect octal string values. */
		var reIsOctal = /^0o[0-7]+$/i;
		
		/** Built-in method references without a dependency on `root`. */
		var freeParseInt = parseInt;
		
		/**
		 * Converts `value` to a number.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to process.
		 * @returns {number} Returns the number.
		 * @example
		 *
		 * _.toNumber(3.2);
		 * // => 3.2
		 *
		 * _.toNumber(Number.MIN_VALUE);
		 * // => 5e-324
		 *
		 * _.toNumber(Infinity);
		 * // => Infinity
		 *
		 * _.toNumber('3.2');
		 * // => 3.2
		 */
		function toNumber(value) {
		  if (typeof value == 'number') {
		    return value;
		  }
		  if (isSymbol(value)) {
		    return NAN;
		  }
		  if (isObject(value)) {
		    var other = isFunction(value.valueOf) ? value.valueOf() : value;
		    value = isObject(other) ? (other + '') : other;
		  }
		  if (typeof value != 'string') {
		    return value === 0 ? value : +value;
		  }
		  value = value.replace(reTrim, '');
		  var isBinary = reIsBinary.test(value);
		  return (isBinary || reIsOctal.test(value))
		    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
		    : (reIsBadHex.test(value) ? NAN : +value);
		}
		
		module.exports = toNumber;
	
	
	/***/ },
	/* 179 */
	/***/ function(module, exports, __webpack_require__) {
	
		var toString = __webpack_require__(86);
		
		/** Used to generate unique IDs. */
		var idCounter = 0;
		
		/**
		 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
		 *
		 * @static
		 * @since 0.1.0
		 * @memberOf _
		 * @category Util
		 * @param {string} [prefix=''] The value to prefix the ID with.
		 * @returns {string} Returns the unique ID.
		 * @example
		 *
		 * _.uniqueId('contact_');
		 * // => 'contact_104'
		 *
		 * _.uniqueId();
		 * // => '105'
		 */
		function uniqueId(prefix) {
		  var id = ++idCounter;
		  return toString(prefix) + id;
		}
		
		module.exports = uniqueId;
	
	
	/***/ },
	/* 180 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseValues = __webpack_require__(311),
		    keys = __webpack_require__(9);
		
		/**
		 * Creates an array of the own enumerable string keyed property values of `object`.
		 *
		 * **Note:** Non-object values are coerced to objects.
		 *
		 * @static
		 * @since 0.1.0
		 * @memberOf _
		 * @category Object
		 * @param {Object} object The object to query.
		 * @returns {Array} Returns the array of property values.
		 * @example
		 *
		 * function Foo() {
		 *   this.a = 1;
		 *   this.b = 2;
		 * }
		 *
		 * Foo.prototype.c = 3;
		 *
		 * _.values(new Foo);
		 * // => [1, 2] (iteration order is not guaranteed)
		 *
		 * _.values('hi');
		 * // => ['h', 'i']
		 */
		function values(object) {
		  return object ? baseValues(object, keys(object)) : [];
		}
		
		module.exports = values;
	
	
	/***/ },
	/* 181 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Observable_1 = __webpack_require__(22);
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @extends {Ignored}
		 * @hide true
		 */
		var ScalarObservable = (function (_super) {
		    __extends(ScalarObservable, _super);
		    function ScalarObservable(value, scheduler) {
		        _super.call(this);
		        this.value = value;
		        this.scheduler = scheduler;
		        this._isScalar = true;
		        if (scheduler) {
		            this._isScalar = false;
		        }
		    }
		    ScalarObservable.create = function (value, scheduler) {
		        return new ScalarObservable(value, scheduler);
		    };
		    ScalarObservable.dispatch = function (state) {
		        var done = state.done, value = state.value, subscriber = state.subscriber;
		        if (done) {
		            subscriber.complete();
		            return;
		        }
		        subscriber.next(value);
		        if (subscriber.isUnsubscribed) {
		            return;
		        }
		        state.done = true;
		        this.schedule(state);
		    };
		    ScalarObservable.prototype._subscribe = function (subscriber) {
		        var value = this.value;
		        var scheduler = this.scheduler;
		        if (scheduler) {
		            return scheduler.schedule(ScalarObservable.dispatch, 0, {
		                done: false, value: value, subscriber: subscriber
		            });
		        }
		        else {
		            subscriber.next(value);
		            if (!subscriber.isUnsubscribed) {
		                subscriber.complete();
		            }
		        }
		    };
		    return ScalarObservable;
		}(Observable_1.Observable));
		exports.ScalarObservable = ScalarObservable;
		//# sourceMappingURL=ScalarObservable.js.map
	
	/***/ },
	/* 182 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var isScheduler_1 = __webpack_require__(62);
		var isArray_1 = __webpack_require__(88);
		var ArrayObservable_1 = __webpack_require__(60);
		var combineLatest_1 = __webpack_require__(421);
		/* tslint:enable:max-line-length */
		/**
		 * Combines multiple Observables to create an Observable whose values are
		 * calculated from the latest values of each of its input Observables.
		 *
		 * <span class="informal">Whenever any input Observable emits a value, it
		 * computes a formula using the latest values from all the inputs, then emits
		 * the output of that formula.</span>
		 *
		 * <img src="./img/combineLatest.png" width="100%">
		 *
		 * `combineLatest` combines the values from all the Observables passed as
		 * arguments. This is done by subscribing to each Observable, in order, and
		 * collecting an array of each of the most recent values any time any of the
		 * input Observables emits, then either taking that array and passing it as
		 * arguments to an optional `project` function and emitting the return value of
		 * that, or just emitting the array of recent values directly if there is no
		 * `project` function.
		 *
		 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
		 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
		 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
		 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
		 * bmi.subscribe(x => console.log('BMI is ' + x));
		 *
		 * @see {@link combineAll}
		 * @see {@link merge}
		 * @see {@link withLatestFrom}
		 *
		 * @param {Observable} observable1 An input Observable to combine with the
		 * source Observable.
		 * @param {Observable} observable2 An input Observable to combine with the
		 * source Observable. More than one input Observables may be given as argument.
		 * @param {function} [project] An optional function to project the values from
		 * the combined latest values into a new value on the output Observable.
		 * @param {Scheduler} [scheduler=null] The Scheduler to use for subscribing to
		 * each input Observable.
		 * @return {Observable} An Observable of projected values from the most recent
		 * values from each input Observable, or an array of the most recent values from
		 * each input Observable.
		 * @static true
		 * @name combineLatest
		 * @owner Observable
		 */
		function combineLatest() {
		    var observables = [];
		    for (var _i = 0; _i < arguments.length; _i++) {
		        observables[_i - 0] = arguments[_i];
		    }
		    var project = null;
		    var scheduler = null;
		    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
		        scheduler = observables.pop();
		    }
		    if (typeof observables[observables.length - 1] === 'function') {
		        project = observables.pop();
		    }
		    // if the first and only other argument besides the resultSelector is an array
		    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
		    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
		        observables = observables[0];
		    }
		    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
		}
		exports.combineLatest = combineLatest;
		//# sourceMappingURL=combineLatest.js.map
	
	/***/ },
	/* 183 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var concat_1 = __webpack_require__(184);
		exports.concat = concat_1.concatStatic;
		//# sourceMappingURL=concat.js.map
	
	/***/ },
	/* 184 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var isScheduler_1 = __webpack_require__(62);
		var ArrayObservable_1 = __webpack_require__(60);
		var mergeAll_1 = __webpack_require__(186);
		/**
		 * Creates an output Observable which sequentially emits all values from every
		 * given input Observable after the current Observable.
		 *
		 * <span class="informal">Concatenates multiple Observables together by
		 * sequentially emitting their values, one Observable after the other.</span>
		 *
		 * <img src="./img/concat.png" width="100%">
		 *
		 * Joins this Observable with multiple other Observables by subscribing to them
		 * one at a time, starting with the source, and merging their results into the
		 * output Observable. Will wait for each Observable to complete before moving
		 * on to the next.
		 *
		 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
		 * var timer = Rx.Observable.interval(1000).take(4);
		 * var sequence = Rx.Observable.range(1, 10);
		 * var result = timer.concat(sequence);
		 * result.subscribe(x => console.log(x));
		 *
		 * @example <caption>Concatenate 3 Observables</caption>
		 * var timer1 = Rx.Observable.interval(1000).take(10);
		 * var timer2 = Rx.Observable.interval(2000).take(6);
		 * var timer3 = Rx.Observable.interval(500).take(10);
		 * var result = timer1.concat(timer2, timer3);
		 * result.subscribe(x => console.log(x));
		 *
		 * @see {@link concatAll}
		 * @see {@link concatMap}
		 * @see {@link concatMapTo}
		 *
		 * @param {Observable} other An input Observable to concatenate after the source
		 * Observable. More than one input Observables may be given as argument.
		 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
		 * Observable subscription on.
		 * @return {Observable} All values of each passed Observable merged into a
		 * single Observable, in order, in serial fashion.
		 * @method concat
		 * @owner Observable
		 */
		function concat() {
		    var observables = [];
		    for (var _i = 0; _i < arguments.length; _i++) {
		        observables[_i - 0] = arguments[_i];
		    }
		    return concatStatic.apply(void 0, [this].concat(observables));
		}
		exports.concat = concat;
		/* tslint:enable:max-line-length */
		/**
		 * Creates an output Observable which sequentially emits all values from every
		 * given input Observable after the current Observable.
		 *
		 * <span class="informal">Concatenates multiple Observables together by
		 * sequentially emitting their values, one Observable after the other.</span>
		 *
		 * <img src="./img/concat.png" width="100%">
		 *
		 * Joins multiple Observables together by subscribing to them one at a time and
		 * merging their results into the output Observable. Will wait for each
		 * Observable to complete before moving on to the next.
		 *
		 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
		 * var timer = Rx.Observable.interval(1000).take(4);
		 * var sequence = Rx.Observable.range(1, 10);
		 * var result = Rx.Observable.concat(timer, sequence);
		 * result.subscribe(x => console.log(x));
		 *
		 * @example <caption>Concatenate 3 Observables</caption>
		 * var timer1 = Rx.Observable.interval(1000).take(10);
		 * var timer2 = Rx.Observable.interval(2000).take(6);
		 * var timer3 = Rx.Observable.interval(500).take(10);
		 * var result = Rx.Observable.concat(timer1, timer2, timer3);
		 * result.subscribe(x => console.log(x));
		 *
		 * @see {@link concatAll}
		 * @see {@link concatMap}
		 * @see {@link concatMapTo}
		 *
		 * @param {Observable} input1 An input Observable to concatenate with others.
		 * @param {Observable} input2 An input Observable to concatenate with others.
		 * More than one input Observables may be given as argument.
		 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
		 * Observable subscription on.
		 * @return {Observable} All values of each passed Observable merged into a
		 * single Observable, in order, in serial fashion.
		 * @static true
		 * @name concat
		 * @owner Observable
		 */
		function concatStatic() {
		    var observables = [];
		    for (var _i = 0; _i < arguments.length; _i++) {
		        observables[_i - 0] = arguments[_i];
		    }
		    var scheduler = null;
		    var args = observables;
		    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
		        scheduler = args.pop();
		    }
		    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
		}
		exports.concatStatic = concatStatic;
		//# sourceMappingURL=concat.js.map
	
	/***/ },
	/* 185 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var ArrayObservable_1 = __webpack_require__(60);
		var mergeAll_1 = __webpack_require__(186);
		var isScheduler_1 = __webpack_require__(62);
		/**
		 * Creates an output Observable which concurrently emits all values from every
		 * given input Observable.
		 *
		 * <span class="informal">Flattens multiple Observables together by blending
		 * their values into one Observable.</span>
		 *
		 * <img src="./img/merge.png" width="100%">
		 *
		 * `merge` subscribes to each given input Observable (either the source or an
		 * Observable given as argument), and simply forwards (without doing any
		 * transformation) all the values from all the input Observables to the output
		 * Observable. The output Observable only completes once all input Observables
		 * have completed. Any error delivered by an input Observable will be immediately
		 * emitted on the output Observable.
		 *
		 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
		 * var clicks = Rx.Observable.fromEvent(document, 'click');
		 * var timer = Rx.Observable.interval(1000);
		 * var clicksOrTimer = clicks.merge(timer);
		 * clicksOrTimer.subscribe(x => console.log(x));
		 *
		 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
		 * var timer1 = Rx.Observable.interval(1000).take(10);
		 * var timer2 = Rx.Observable.interval(2000).take(6);
		 * var timer3 = Rx.Observable.interval(500).take(10);
		 * var concurrent = 2; // the argument
		 * var merged = timer1.merge(timer2, timer3, concurrent);
		 * merged.subscribe(x => console.log(x));
		 *
		 * @see {@link mergeAll}
		 * @see {@link mergeMap}
		 * @see {@link mergeMapTo}
		 * @see {@link mergeScan}
		 *
		 * @param {Observable} other An input Observable to merge with the source
		 * Observable. More than one input Observables may be given as argument.
		 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
		 * Observables being subscribed to concurrently.
		 * @param {Scheduler} [scheduler=null] The Scheduler to use for managing
		 * concurrency of input Observables.
		 * @return {Observable} an Observable that emits items that are the result of
		 * every input Observable.
		 * @method merge
		 * @owner Observable
		 */
		function merge() {
		    var observables = [];
		    for (var _i = 0; _i < arguments.length; _i++) {
		        observables[_i - 0] = arguments[_i];
		    }
		    observables.unshift(this);
		    return mergeStatic.apply(this, observables);
		}
		exports.merge = merge;
		/* tslint:enable:max-line-length */
		/**
		 * Creates an output Observable which concurrently emits all values from every
		 * given input Observable.
		 *
		 * <span class="informal">Flattens multiple Observables together by blending
		 * their values into one Observable.</span>
		 *
		 * <img src="./img/merge.png" width="100%">
		 *
		 * `merge` subscribes to each given input Observable (as arguments), and simply
		 * forwards (without doing any transformation) all the values from all the input
		 * Observables to the output Observable. The output Observable only completes
		 * once all input Observables have completed. Any error delivered by an input
		 * Observable will be immediately emitted on the output Observable.
		 *
		 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
		 * var clicks = Rx.Observable.fromEvent(document, 'click');
		 * var timer = Rx.Observable.interval(1000);
		 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
		 * clicksOrTimer.subscribe(x => console.log(x));
		 *
		 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
		 * var timer1 = Rx.Observable.interval(1000).take(10);
		 * var timer2 = Rx.Observable.interval(2000).take(6);
		 * var timer3 = Rx.Observable.interval(500).take(10);
		 * var concurrent = 2; // the argument
		 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
		 * merged.subscribe(x => console.log(x));
		 *
		 * @see {@link mergeAll}
		 * @see {@link mergeMap}
		 * @see {@link mergeMapTo}
		 * @see {@link mergeScan}
		 *
		 * @param {Observable} input1 An input Observable to merge with others.
		 * @param {Observable} input2 An input Observable to merge with others.
		 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
		 * Observables being subscribed to concurrently.
		 * @param {Scheduler} [scheduler=null] The Scheduler to use for managing
		 * concurrency of input Observables.
		 * @return {Observable} an Observable that emits items that are the result of
		 * every input Observable.
		 * @static true
		 * @name merge
		 * @owner Observable
		 */
		function mergeStatic() {
		    var observables = [];
		    for (var _i = 0; _i < arguments.length; _i++) {
		        observables[_i - 0] = arguments[_i];
		    }
		    var concurrent = Number.POSITIVE_INFINITY;
		    var scheduler = null;
		    var last = observables[observables.length - 1];
		    if (isScheduler_1.isScheduler(last)) {
		        scheduler = observables.pop();
		        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
		            concurrent = observables.pop();
		        }
		    }
		    else if (typeof last === 'number') {
		        concurrent = observables.pop();
		    }
		    if (observables.length === 1) {
		        return observables[0];
		    }
		    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
		}
		exports.mergeStatic = mergeStatic;
		//# sourceMappingURL=merge.js.map
	
	/***/ },
	/* 186 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var OuterSubscriber_1 = __webpack_require__(41);
		var subscribeToResult_1 = __webpack_require__(43);
		/**
		 * Converts a higher-order Observable into a first-order Observable which
		 * concurrently delivers all values that are emitted on the inner Observables.
		 *
		 * <span class="informal">Flattens an Observable-of-Observables.</span>
		 *
		 * <img src="./img/mergeAll.png" width="100%">
		 *
		 * `mergeAll` subscribes to an Observable that emits Observables, also known as
		 * a higher-order Observable. Each time it observes one of these emitted inner
		 * Observables, it subscribes to that and delivers all the values from the
		 * inner Observable on the output Observable. The output Observable only
		 * completes once all inner Observables have completed. Any error delivered by
		 * a inner Observable will be immediately emitted on the output Observable.
		 *
		 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
		 * var clicks = Rx.Observable.fromEvent(document, 'click');
		 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
		 * var firstOrder = higherOrder.mergeAll();
		 * firstOrder.subscribe(x => console.log(x));
		 *
		 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
		 * var clicks = Rx.Observable.fromEvent(document, 'click');
		 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
		 * var firstOrder = higherOrder.mergeAll(2);
		 * firstOrder.subscribe(x => console.log(x));
		 *
		 * @see {@link combineAll}
		 * @see {@link concatAll}
		 * @see {@link exhaust}
		 * @see {@link merge}
		 * @see {@link mergeMap}
		 * @see {@link mergeMapTo}
		 * @see {@link mergeScan}
		 * @see {@link switch}
		 * @see {@link zipAll}
		 *
		 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
		 * Observables being subscribed to concurrently.
		 * @return {Observable} An Observable that emits values coming from all the
		 * inner Observables emitted by the source Observable.
		 * @method mergeAll
		 * @owner Observable
		 */
		function mergeAll(concurrent) {
		    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
		    return this.lift(new MergeAllOperator(concurrent));
		}
		exports.mergeAll = mergeAll;
		var MergeAllOperator = (function () {
		    function MergeAllOperator(concurrent) {
		        this.concurrent = concurrent;
		    }
		    MergeAllOperator.prototype.call = function (observer, source) {
		        return source._subscribe(new MergeAllSubscriber(observer, this.concurrent));
		    };
		    return MergeAllOperator;
		}());
		exports.MergeAllOperator = MergeAllOperator;
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var MergeAllSubscriber = (function (_super) {
		    __extends(MergeAllSubscriber, _super);
		    function MergeAllSubscriber(destination, concurrent) {
		        _super.call(this, destination);
		        this.concurrent = concurrent;
		        this.hasCompleted = false;
		        this.buffer = [];
		        this.active = 0;
		    }
		    MergeAllSubscriber.prototype._next = function (observable) {
		        if (this.active < this.concurrent) {
		            this.active++;
		            this.add(subscribeToResult_1.subscribeToResult(this, observable));
		        }
		        else {
		            this.buffer.push(observable);
		        }
		    };
		    MergeAllSubscriber.prototype._complete = function () {
		        this.hasCompleted = true;
		        if (this.active === 0 && this.buffer.length === 0) {
		            this.destination.complete();
		        }
		    };
		    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
		        var buffer = this.buffer;
		        this.remove(innerSub);
		        this.active--;
		        if (buffer.length > 0) {
		            this._next(buffer.shift());
		        }
		        else if (this.active === 0 && this.hasCompleted) {
		            this.destination.complete();
		        }
		    };
		    return MergeAllSubscriber;
		}(OuterSubscriber_1.OuterSubscriber));
		exports.MergeAllSubscriber = MergeAllSubscriber;
		//# sourceMappingURL=mergeAll.js.map
	
	/***/ },
	/* 187 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var OuterSubscriber_1 = __webpack_require__(41);
		var subscribeToResult_1 = __webpack_require__(43);
		/**
		 * Emits the values emitted by the source Observable until a `notifier`
		 * Observable emits a value.
		 *
		 * <span class="informal">Lets values pass until a second Observable,
		 * `notifier`, emits something. Then, it completes.</span>
		 *
		 * <img src="./img/takeUntil.png" width="100%">
		 *
		 * `takeUntil` subscribes and begins mirroring the source Observable. It also
		 * monitors a second Observable, `notifier` that you provide. If the `notifier`
		 * emits a value or a complete notification, the output Observable stops
		 * mirroring the source Observable and completes.
		 *
		 * @example <caption>Tick every second until the first click happens</caption>
		 * var interval = Rx.Observable.interval(1000);
		 * var clicks = Rx.Observable.fromEvent(document, 'click');
		 * var result = interval.takeUntil(clicks);
		 * result.subscribe(x => console.log(x));
		 *
		 * @see {@link take}
		 * @see {@link takeLast}
		 * @see {@link takeWhile}
		 * @see {@link skip}
		 *
		 * @param {Observable} notifier The Observable whose first emitted value will
		 * cause the output Observable of `takeUntil` to stop emitting values from the
		 * source Observable.
		 * @return {Observable<T>} An Observable that emits the values from the source
		 * Observable until such time as `notifier` emits its first value.
		 * @method takeUntil
		 * @owner Observable
		 */
		function takeUntil(notifier) {
		    return this.lift(new TakeUntilOperator(notifier));
		}
		exports.takeUntil = takeUntil;
		var TakeUntilOperator = (function () {
		    function TakeUntilOperator(notifier) {
		        this.notifier = notifier;
		    }
		    TakeUntilOperator.prototype.call = function (subscriber, source) {
		        return source._subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
		    };
		    return TakeUntilOperator;
		}());
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var TakeUntilSubscriber = (function (_super) {
		    __extends(TakeUntilSubscriber, _super);
		    function TakeUntilSubscriber(destination, notifier) {
		        _super.call(this, destination);
		        this.notifier = notifier;
		        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
		    }
		    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
		        this.complete();
		    };
		    TakeUntilSubscriber.prototype.notifyComplete = function () {
		        // noop
		    };
		    return TakeUntilSubscriber;
		}(OuterSubscriber_1.OuterSubscriber));
		//# sourceMappingURL=takeUntil.js.map
	
	/***/ },
	/* 188 */
	/***/ function(module, exports) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		/**
		 * An error thrown when an action is invalid because the object has been
		 * unsubscribed.
		 *
		 * @see {@link Subject}
		 * @see {@link BehaviorSubject}
		 *
		 * @class ObjectUnsubscribedError
		 */
		var ObjectUnsubscribedError = (function (_super) {
		    __extends(ObjectUnsubscribedError, _super);
		    function ObjectUnsubscribedError() {
		        var err = _super.call(this, 'object unsubscribed');
		        this.name = err.name = 'ObjectUnsubscribedError';
		        this.stack = err.stack;
		        this.message = err.message;
		    }
		    return ObjectUnsubscribedError;
		}(Error));
		exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
		//# sourceMappingURL=ObjectUnsubscribedError.js.map
	
	/***/ },
	/* 189 */
	/***/ function(module, exports) {
	
		"use strict";
		function isFunction(x) {
		    return typeof x === 'function';
		}
		exports.isFunction = isFunction;
		//# sourceMappingURL=isFunction.js.map
	
	/***/ },
	/* 190 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var errorObject_1 = __webpack_require__(131);
		var tryCatchTarget;
		function tryCatcher() {
		    try {
		        return tryCatchTarget.apply(this, arguments);
		    }
		    catch (e) {
		        errorObject_1.errorObject.e = e;
		        return errorObject_1.errorObject;
		    }
		}
		function tryCatch(fn) {
		    tryCatchTarget = fn;
		    return tryCatcher;
		}
		exports.tryCatch = tryCatch;
		;
		//# sourceMappingURL=tryCatch.js.map
	
	/***/ },
	/* 191 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = __webpack_require__(435);
	
	
	/***/ },
	/* 192 */,
	/* 193 */,
	/* 194 */,
	/* 195 */,
	/* 196 */,
	/* 197 */,
	/* 198 */,
	/* 199 */,
	/* 200 */,
	/* 201 */,
	/* 202 */,
	/* 203 */,
	/* 204 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.default = undefined;
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _desc, _value, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _class2, _temp, _initialiseProps, _assign$call;
		
		var _templateObject = _taggedTemplateLiteral(['\n\t\t\t\t\t\t\tThe ', ' property does not exist on ', '.\n\t\t\t\t\t\t'], ['\n\t\t\t\t\t\t\tThe ', ' property does not exist on ', '.\n\t\t\t\t\t\t']),
		    _templateObject2 = _taggedTemplateLiteral(['\n\t\t\tThe entity at \'', '\'\n\t\t\tis not of class \'', '\'\n\t\t\tbut of class \'', '\'.\n\t\t'], ['\n\t\t\tThe entity at \'', '\'\n\t\t\tis not of class \'', '\'\n\t\t\tbut of class \'', '\'.\n\t\t']),
		    _templateObject3 = _taggedTemplateLiteral(['\n\t\t\tThe \'', '\' class is not a singleton class.\n\t\t'], ['\n\t\t\tThe \'', '\' class is not a singleton class.\n\t\t']),
		    _templateObject4 = _taggedTemplateLiteral(['\n\t\t\tDo not use \'new ', '(...args)\'.\n\t\t\tInstead, use \'', '.new(...args)\'.\n\t\t'], ['\n\t\t\tDo not use \'new ', '(...args)\'.\n\t\t\tInstead, use \'', '.new(...args)\'.\n\t\t']),
		    _templateObject5 = _taggedTemplateLiteral(['\n\t\t\t\tCannot instantiate the abstract\n\t\t\t\tclass ', '.\n\t\t\t'], ['\n\t\t\t\tCannot instantiate the abstract\n\t\t\t\tclass ', '.\n\t\t\t']);
		
		var _isObject = __webpack_require__(72);
		
		var _isObject2 = _interopRequireDefault(_isObject);
		
		var _defaults = __webpack_require__(71);
		
		var _defaults2 = _interopRequireDefault(_defaults);
		
		var _size = __webpack_require__(107);
		
		var _size2 = _interopRequireDefault(_size);
		
		var _keys = __webpack_require__(149);
		
		var _keys2 = _interopRequireDefault(_keys);
		
		var _values = __webpack_require__(108);
		
		var _values2 = _interopRequireDefault(_values);
		
		var _isFunction = __webpack_require__(105);
		
		var _isFunction2 = _interopRequireDefault(_isFunction);
		
		var _uniqueId2 = __webpack_require__(179);
		
		var _uniqueId3 = _interopRequireDefault(_uniqueId2);
		
		var _ObservableSet = __webpack_require__(67);
		
		var _ObservableSet2 = _interopRequireDefault(_ObservableSet);
		
		var _misc = __webpack_require__(3);
		
		var _fields = __webpack_require__(138);
		
		var _ValueTracker2 = __webpack_require__(140);
		
		var _ValueTracker3 = _interopRequireDefault(_ValueTracker2);
		
		var _Change = __webpack_require__(205);
		
		var _BehaviorSubject = __webpack_require__(126);
		
		var _filter = __webpack_require__(29);
		
		var _merge = __webpack_require__(419);
		
		var _map = __webpack_require__(42);
		
		var _combineLatest = __webpack_require__(182);
		
		__webpack_require__(23);
		
		var _boundNativeMethods = __webpack_require__(10);
		
		var _babelHelpers = __webpack_require__(216);
		
		var _babelHelpers2 = _interopRequireDefault(_babelHelpers);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _initDefineProp(target, property, descriptor, context) {
			if (!descriptor) return;
			Object.defineProperty(target, property, {
				enumerable: descriptor.enumerable,
				configurable: descriptor.configurable,
				writable: descriptor.writable,
				value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
			});
		}
		
		function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
			var desc = {};
			Object['ke' + 'ys'](descriptor).forEach(function (key) {
				desc[key] = descriptor[key];
			});
			desc.enumerable = !!desc.enumerable;
			desc.configurable = !!desc.configurable;
		
			if ('value' in desc || desc.initializer) {
				desc.writable = true;
			}
		
			desc = decorators.slice().reverse().reduce(function (desc, decorator) {
				return decorator(target, property, desc) || desc;
			}, desc);
		
			if (context && desc.initializer !== void 0) {
				desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
				desc.initializer = undefined;
			}
		
			if (desc.initializer === void 0) {
				Object['define' + 'Property'](target, property, desc);
				desc = null;
			}
		
			return desc;
		}
		
		function _initializerWarningHelper(descriptor, context) {
			throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
		}
		
		var $$committedEntitiesByHref = Symbol('$$committedEntitiesByHref');
		var $$committedEntities = Symbol('$$committedEntities');
		var $$entities = Symbol('$$allEntities');
		var $$singletonObject = Symbol('$$singletonObject');
		var $$newEntitySubject = Symbol('$$newEntitySubject');
		var $$deleted = Symbol('$$deleted');
		var $$entitiesSubject = Symbol('$$allSubject');
		var $$committedEntitiesSubject = Symbol('$$allCommittedSubject');
		var $$set = Symbol('$$set');
		var $$PreferredClass = Symbol('$$PreferredClass');
		
		////////////////////////////////////////////////////////////////////////////////
		
		var Entity = (_dec = (0, _ValueTracker2.event)(), _dec2 = (0, _ValueTracker2.event)(), _dec3 = (0, _ValueTracker2.event)(), _dec4 = (0, _ValueTracker2.property)({ initial: false, readonly: true }), _dec5 = (0, _ValueTracker2.property)({ initial: true, readonly: true }), _dec6 = (0, _ValueTracker2.property)({ initial: false, readonly: true }), (_class = (_temp = _class2 = function (_ValueTracker) {
			_inherits(Entity, _ValueTracker);
		
			_createClass(Entity, [{
				key: Symbol.toStringTag,
		
		
				///////////////////////////////
				////////// INSTANCES //////////
				///////////////////////////////
		
				//noinspection JSDuplicatedDeclaration // hiding warning due to Webstorm bug
				get: function get() {
					return this.constructor.name;
				}
			}], [{
				key: 'createClass',
		
		
				////////////////////////////////////////////////////////////
				////////// STATIC (building Entity-based classes) //////////
				////////////////////////////////////////////////////////////
		
				value: function createClass(config) {
					var _defineProperties$cal;
		
					/* create the class with the right name, constructor and static content */
					var name = config.name;
		
					var rest = _objectWithoutProperties(config, ['name']);
		
					/* create the new class */
					// using Function constructor to give the class a dynamic name
					// http://stackoverflow.com/a/9947842/681588
					// (and using babel-technique to build it, rather than using class
					// expression, so that it can be extended by babel-compiled code)
		
		
					var EntitySubclass = new Function('Entity', '\n\t\t\t\'use strict\';\n\t\t\t' + _babelHelpers2.default + ';\n\t\t\treturn function (_Entity) {\n\t\t\t\t_inherits(' + name + ', _Entity);\n\t\t\t\tfunction ' + name + '() {\n\t\t\t\t\t_classCallCheck(this, ' + name + ');\n\t\t\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(' + name + ').apply(this, arguments));\n\t\t\t\t}\n\t\t\t\treturn ' + name + ';\n\t\t\t}(Entity);\n\t\t')(Entity);
					// const EntitySubclass = class extends Entity {};
		
					/* populate it with the necessary data and behavior */
					_boundNativeMethods.assign.call(EntitySubclass, rest);
					_boundNativeMethods.defineProperties.call(EntitySubclass, (_defineProperties$cal = {
						name: { value: name }
					}, _defineProperty(_defineProperties$cal, Symbol.hasInstance, {
						value: function value(instance) {
							return this.hasInstance(instance);
						}
					}), _defineProperty(_defineProperties$cal, 'hasInstance', {
						value: function value(instance) {
							if (!instance) {
								return false;
							}
							return this.hasSubclass(instance.constructor);
						}
					}), _defineProperty(_defineProperties$cal, 'hasSubclass', {
						value: function value(otherClass) {
							// For both sides of this, there are two possibilities:
							// 1) the class is derived by this library
							// 2) the class is an extension of such
							// We need to check both possibilities.
							// We assume there is no subclass cycle.
							var isExtension = function isExtension(c) {
								return c && c.__proto__ !== Entity;
							};
							if (isExtension(this)) {
								// 'this' is an extension
								while (isExtension(otherClass) && otherClass !== this) {
									otherClass = otherClass.__proto__;
								}
								return otherClass === this;
							} else {
								while (isExtension(otherClass)) {
									// 'otherClass' is an extension
									otherClass = otherClass.__proto__;
								}
								if (!otherClass) {
									return false;
								}
								// both 'this' and 'otherClass' are library-derived
								if (otherClass === this) {
									return true;
								}
								var _iteratorNormalCompletion = true;
								var _didIteratorError = false;
								var _iteratorError = undefined;
		
								try {
									for (var _iterator = this.extendedBy[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
										var SubClass = _step.value;
		
										if (SubClass.hasSubclass(otherClass)) {
											return true;
										}
									}
								} catch (err) {
									_didIteratorError = true;
									_iteratorError = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion && _iterator.return) {
											_iterator.return();
										}
									} finally {
										if (_didIteratorError) {
											throw _iteratorError;
										}
									}
								}
		
								return false;
							}
						}
					}), _defineProperty(_defineProperties$cal, 'p', {
						value: function value(name) {
							switch (name) {
								case 'all':
									return this[$$entitiesSubject];
								case 'allCommitted':
									return this[$$committedEntitiesSubject];
								default:
									(0, _misc.constraint)(false, (0, _misc.humanMsg)(_templateObject, name, this.name));
							}
						}
					}), _defineProperty(_defineProperties$cal, 'supersede', {
						value: function value(factory) {
							return EntitySubclass[$$PreferredClass] = factory(EntitySubclass[$$PreferredClass] || EntitySubclass);
						}
					}), _defineProperties$cal));
		
					/* maintaining <Class>.p('all') and <Class>.p('allCommitted') */
					var _arr = [[$$entities, $$entitiesSubject], [$$committedEntities, $$committedEntitiesSubject]];
					for (var _i = 0; _i < _arr.length; _i++) {
						var _context;
		
						var _arr$_i = _slicedToArray(_arr[_i], 2);
		
						var _$$set = _arr$_i[0];
						var $$subject = _arr$_i[1];
		
						var localSet = new _ObservableSet2.default();
						(_context = Entity[_$$set].e('add'), _filter.filter).call(_context, EntitySubclass.hasInstance.bind(EntitySubclass)).subscribe(localSet.e('add'));
						(_context = Entity[_$$set].e('delete'), _filter.filter).call(_context, EntitySubclass.hasInstance.bind(EntitySubclass)).subscribe(localSet.e('delete'));
						_boundNativeMethods.defineProperty.call(EntitySubclass, $$subject, { value: localSet.p('value') });
					}
		
					return EntitySubclass;
				}
		
				/////////////////////////////////////////////////////////////////////
				////////// STATIC (creating / caching / finding instances) //////////
				/////////////////////////////////////////////////////////////////////
		
		
			}, {
				key: 'new',
				value: function _new() {
					var vals = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
					var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		
					return new this.Change_new(this, vals, options).run();
				}
			}, {
				key: 'get',
				value: function get(href) {
					var _context2;
		
					var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		
					if ((_context2 = href, _isObject2.default).call(_context2)) {
						href = { href: href };
					}
					var entity = void 0;
					if (href in Entity[$$committedEntitiesByHref]) {
						entity = Entity[$$committedEntitiesByHref][href];
					} else {
						// We're assuming that this is solely a synchronous method call,
						// so we can't query the server here.
						return null;
					}
					(0, _misc.constraint)(this.hasInstance(entity), (0, _misc.humanMsg)(_templateObject2, JSON.stringify(href), this.name, entity.constructor.name));
					return entity;
				}
			}, {
				key: 'getAll',
				value: function getAll() {
					return new Set([].concat(_toConsumableArray(this[$$entities])).filter(this.hasInstance.bind(this)));
				}
			}, {
				key: 'getAllCommitted',
				value: function getAllCommitted() {
					return new Set([].concat(_toConsumableArray(this[$$committedEntities])).filter(this.hasInstance.bind(this)));
				}
			}, {
				key: 'newOrSingleton',
				value: function newOrSingleton() {
					return this.singleton ? this.getSingleton() : this.new();
				}
			}, {
				key: 'getSingleton',
				value: function getSingleton() {
					(0, _misc.constraint)(this.singleton, (0, _misc.humanMsg)(_templateObject3, this.name));
					if (!this[$$singletonObject]) {
						this[$$singletonObject] = this.new({
							name: this.singular
						});
						this[$$singletonObject].commit();
						// TODO: make sure that the singleton object is always loaded,
						//     : so this can be done synchronously
					}
					return this[$$singletonObject];
				}
			}, {
				key: 'load',
				value: function () {
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(href) {
						var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
						return regeneratorRuntime.wrap(function _callee$(_context3) {
							while (1) {
								switch (_context3.prev = _context3.next) {
									case 0:
									case 'end':
										return _context3.stop();
								}
							}
						}, _callee, this);
					}));
		
					function load(_x4, _x5) {
						return _ref.apply(this, arguments);
					}
		
					return load;
				}()
			}]);
		
			function Entity() {
				var _context4;
		
				var initialValues = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		
				var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		
				var _ref2$allowInvokingCo = _ref2.allowInvokingConstructor;
				var allowInvokingConstructor = _ref2$allowInvokingCo === undefined ? false : _ref2$allowInvokingCo;
		
				_classCallCheck(this, Entity);
		
				var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Entity).call(this));
		
				/* initialize value tracking */
		
		
				_initialiseProps.call(_this);
		
				_get(Object.getPrototypeOf(Entity.prototype), 'setValueTrackerOptions', _this).call(_this, {
					takeUntil: (_context4 = (0, _combineLatest.combineLatest)(_this.p('isDeleted'), _this.p('isPristine'), _this.p('isNew'), function (isDeleted, isPristine, isNew) {
						return isDeleted && (isPristine || isNew);
					}), _filter.filter).call(_context4, function (isGone) {
						return isGone;
					}),
					filterAllBy: function filterAllBy() {
						return _this.isDeleted.getValue();
					}
				});
		
				/* make sure this constructor was invoked under proper conditions */
				(0, _misc.constraint)(allowInvokingConstructor, (0, _misc.humanMsg)(_templateObject4, _this.constructor.name, _this.constructor.name));
		
		
				/* Treating singleton classes specially? Or do we double-check singleton-ness here? */
				if (_this.constructor.singleton) {}
				// TODO
		
		
				/* set defaults for the core initial field values */
				_defaults2.default.call(initialValues, {
					id: null,
					href: null,
					class: _this.constructor.name
				});
		
				/* initialize all fields in this entity */
				_fields.Field.initializeEntity(_this, initialValues);
		
				/* entity is pristine if all its fields are pristine */
				_combineLatest.combineLatest.apply(undefined, _toConsumableArray((_context4 = _this.fields, _values2.default).call(_context4).map(function (f) {
					return f.p('isPristine');
				})).concat([function () {
					for (var _len = arguments.length, fieldPristines = Array(_len), _key = 0; _key < _len; _key++) {
						fieldPristines[_key] = arguments[_key];
					}
		
					return fieldPristines.every(function (v) {
						return !!v;
					});
				}])).subscribe(_this.pSubject('isPristine'));
		
				/* register this entity */
				Entity[$$entities].add(_this);
		
				// TODO: CHECK CROSS-PROPERTY CONSTRAINTS?
		
				return _this;
			}
		
			_createClass(Entity, [{
				key: 'delete',
				value: function _delete() {
					// TODO: this is the synchronous delete operation;
					//     : a `.commit()` call is required before it
					//     : is actually deleted from asynchronous storage.
					//     : That means we need to be able to rollback a deletion.
					//     : We need to create a partially ordered
					//     : log of performed actions (since last commit),
					//     : that also allows undo. This will replace storing 'pristine' ops.
					//     : (This is the Command design pattern.)
		
					if (this.isDeleted) {
						return;
					}
					this.pSubject('isDeleted').next(true);
					this.pSubject('isPristine').next(false);
					Entity[$$entities].delete(this);
				}
			}, {
				key: 'undelete',
				value: function undelete() {
					if (!this.isDeleted) {
						return;
					}
					this.pSubject('isDeleted').next(false);
					this.pSubject('isPristine').next(false);
					Entity[$$entities].add(this);
				}
		
				//noinspection JSDuplicatedDeclaration // temporary, to suppress warning due to Webstorm bug; TODO: report bug
		
			}, {
				key: 'get',
				value: function get(key) {
					return this.fields[key].get();
				}
			}, {
				key: 'set',
				value: function set(key, val, options) {
					return this.fields[key].set(val, options);
				}
			}, {
				key: 'commit',
				value: function () {
					var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
						var _context5,
						    _this2 = this;
		
						for (var _len2 = arguments.length, keysToCommit = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
							keysToCommit[_key2] = arguments[_key2];
						}
		
						var _context6, newId, newHref, opts;
		
						return regeneratorRuntime.wrap(function _callee2$(_context7) {
							while (1) {
								switch (_context7.prev = _context7.next) {
									case 0:
										if (this.isDeleted) {}
										// TODO
		
		
										/* commit each field individually */ // TODO: commit all in a single transaction?
										if ((_context5 = keysToCommit, _size2.default).call(_context5) === 0) {
											keysToCommit = (_context6 = this.fields, _keys2.default).call(_context6);
										}
										_context7.next = 4;
										return Promise.all(keysToCommit.map(function (key) {
											return _this2.fields[key].commit();
										}));
		
									case 4:
		
										/* setting up as a committed entity */
										// TODO: remove when the server actually does this
										if (this.get('id') === null) {
											/* id and href are set here until actual server communication is set up */
											newId = parseInt((0, _uniqueId3.default)());
											newHref = 'cache://' + newId;
											opts = { ignoreReadonly: true, updatePristine: true };
		
											this.set('id', newId, opts);
											this.set('href', newHref, opts);
		
											/* after it's first committed, it's no longer new */
											this.pSubject('isNew').next(false);
		
											/* maintain caches */
											Entity[$$committedEntitiesByHref][newHref] = this;
											Entity[$$committedEntities].add(this);
										}
		
										/* directly after a commit, it's pristine */
										this.pSubject('isPristine').next(true);
		
									case 6:
									case 'end':
										return _context7.stop();
								}
							}
						}, _callee2, this);
					}));
		
					function commit(_x9) {
						return _ref3.apply(this, arguments);
					}
		
					return commit;
				}()
			}, {
				key: 'rollback',
				value: function rollback() {
					var _context8,
					    _this3 = this;
		
					for (var _len3 = arguments.length, keysToRollback = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
						keysToRollback[_key3] = arguments[_key3];
					}
		
					if ((_context8 = keysToRollback, _size2.default).call(_context8) === 0) {
						var _context9;
		
						keysToRollback = (_context9 = this.fields, _keys2.default).call(_context9);
					}
					keysToRollback.map(function (key) {
						_this3.fields[key].rollback();
					});
					this.e('rollback').next(this);
				}
			}, {
				key: 'p',
				value: function p(key, t) {
					// Provide easier access to field property observables
					return this.fields && this.fields[key] ? this.fields[key].p('value', t) : _get(Object.getPrototypeOf(Entity.prototype), 'p', this).call(this, key, t);
				}
			}]);
		
			return Entity;
		}(_ValueTracker3.default), _class2.Change_new = function (_tracker$Change) {
			_inherits(_class3, _tracker$Change);
		
			function _class3(context) {
				var initialValues = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
				var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
		
				_classCallCheck(this, _class3);
		
				var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(_class3).call(this, options));
		
				_this4.context = context;
				_this4.initialValues = initialValues;
				_this4.options = options;
				return _this4;
			}
		
			_createClass(_class3, [{
				key: 'run',
				value: function run() {
					var _context10;
		
					if ((_context10 = this.context.behavior.new, _isFunction2.default).call(_context10)) {
						var customResult = this.context.behavior.new(_extends({}, this.initialValues), _extends({}, this.options));
						if (customResult) {
							return customResult;
						}
					}
					(0, _misc.constraint)(!this.context.abstract, (0, _misc.humanMsg)(_templateObject5, this.context.name));
					return new (this.context[$$PreferredClass] || this.context)(_extends({}, this.initialValues), _extends({}, this.options, { allowInvokingConstructor: true, new: true }));
				}
			}, {
				key: 'commit',
				value: function () {
					var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
						return regeneratorRuntime.wrap(function _callee3$(_context11) {
							while (1) {
								switch (_context11.prev = _context11.next) {
									case 0:
									case 'end':
										return _context11.stop();
								}
							}
						}, _callee3, this);
					}));
		
					function commit() {
						return _ref4.apply(this, arguments);
					}
		
					return commit;
				}()
			}, {
				key: 'rollback',
				value: function rollback() {
					// TODO
				}
			}]);
		
			return _class3;
		}(_Change.tracker.Change), _initialiseProps = function _initialiseProps() {
			_initDefineProp(this, 'deleteEvent', _descriptor, this);
		
			_initDefineProp(this, 'commitEvent', _descriptor2, this);
		
			_initDefineProp(this, 'rollbackEvent', _descriptor3, this);
		
			_initDefineProp(this, 'isDeleted', _descriptor4, this);
		
			_initDefineProp(this, 'isPristine', _descriptor5, this);
		
			_initDefineProp(this, 'isNew', _descriptor6, this);
		}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'deleteEvent', [_dec], {
			enumerable: true,
			initializer: null
		}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'commitEvent', [_dec2], {
			enumerable: true,
			initializer: null
		}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, 'rollbackEvent', [_dec3], {
			enumerable: true,
			initializer: null
		}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, 'isDeleted', [_dec4], {
			enumerable: true,
			initializer: null
		}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, 'isPristine', [_dec5], {
			enumerable: true,
			initializer: null
		}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, 'isNew', [_dec6], {
			enumerable: true,
			initializer: null
		})), _class));
		exports.default = Entity;
		
		
		_boundNativeMethods.assign.call(Entity, (_assign$call = {}, _defineProperty(_assign$call, $$entities, new _ObservableSet2.default()), _defineProperty(_assign$call, $$entitiesSubject, new _BehaviorSubject.BehaviorSubject(new Set())), _defineProperty(_assign$call, $$committedEntities, new _ObservableSet2.default()), _defineProperty(_assign$call, $$committedEntitiesSubject, new _BehaviorSubject.BehaviorSubject(new Set())), _defineProperty(_assign$call, $$committedEntitiesByHref, {}), _assign$call));
	
	/***/ },
	/* 205 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.tracker = undefined;
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _graph = __webpack_require__(143);
		
		var _graph2 = _interopRequireDefault(_graph);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var $$changes = Symbol('$$changes');
		
		var $$class = Symbol('$$class');
		var $$props = Symbol('$$props');
		var $$revDeps = Symbol('$$revDeps');
		var $$causes = Symbol('$$causes');
		var $$Change = Symbol('$$Change');
		
		var $$commitUpToHere = Symbol('$$commitUpToHere');
		var $$commitForcedFromHere = Symbol('$$commitForcedFromHere');
		
		var ChangeT = function ChangeT(tracker) {
			return function () {
				function Change() {
					var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		
					var _ref$changeDependenci = _ref.changeDependencies;
					var changeDependencies = _ref$changeDependenci === undefined ? [] : _ref$changeDependenci;
					var _ref$changeCauses = _ref.changeCauses;
					var changeCauses = _ref$changeCauses === undefined ? [] : _ref$changeCauses;
		
					_classCallCheck(this, Change);
		
					var g = tracker[$$changes];
					g.addVertex(this, this);
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;
		
					try {
						for (var _iterator = changeDependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var dep = _step.value;
							g.addEdge(this, dep, {});
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
		
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;
		
					try {
						for (var _iterator2 = changeCauses[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var _dep = _step2.value;
							g.addEdge(this, _dep, { forced: true });
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
				}
		
				_createClass(Change, [{
					key: 'run',
					value: function run() {}
				}, {
					key: 'commit',
					value: function () {
						var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
							return regeneratorRuntime.wrap(function _callee$(_context) {
								while (1) {
									switch (_context.prev = _context.next) {
										case 0:
											this.committed = true;
		
										case 1:
										case 'end':
											return _context.stop();
									}
								}
							}, _callee, this);
						}));
		
						function commit() {
							return _ref2.apply(this, arguments);
						}
		
						return commit;
					}()
				}, {
					key: 'rollback',
					value: function rollback() {}
				}, {
					key: 'commitUpToHere',
					value: function () {
						var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
							return regeneratorRuntime.wrap(function _callee2$(_context2) {
								while (1) {
									switch (_context2.prev = _context2.next) {
										case 0:
											if (this.committed) {
												_context2.next = 5;
												break;
											}
		
											_context2.next = 3;
											return this[$$commitUpToHere]();
		
										case 3:
											_context2.next = 5;
											return this.commit();
		
										case 5:
											_context2.next = 7;
											return this[$$commitForcedFromHere]();
		
										case 7:
										case 'end':
											return _context2.stop();
									}
								}
							}, _callee2, this);
						}));
		
						function commitUpToHere() {
							return _ref3.apply(this, arguments);
						}
		
						return commitUpToHere;
					}()
				}, {
					key: $$commitUpToHere,
					value: function () {
						var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
							var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _step3$value, dep;
		
							return regeneratorRuntime.wrap(function _callee3$(_context3) {
								while (1) {
									switch (_context3.prev = _context3.next) {
										case 0:
											_iteratorNormalCompletion3 = true;
											_didIteratorError3 = false;
											_iteratorError3 = undefined;
											_context3.prev = 3;
											_iterator3 = tracker[$$changes].verticesTo(this)[Symbol.iterator]();
		
										case 5:
											if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
												_context3.next = 16;
												break;
											}
		
											_step3$value = _slicedToArray(_step3.value, 1);
											dep = _step3$value[0];
		
											if (dep.committed) {
												_context3.next = 13;
												break;
											}
		
											_context3.next = 11;
											return dep[$$commitUpToHere]();
		
										case 11:
											_context3.next = 13;
											return dep.commit();
		
										case 13:
											_iteratorNormalCompletion3 = true;
											_context3.next = 5;
											break;
		
										case 16:
											_context3.next = 22;
											break;
		
										case 18:
											_context3.prev = 18;
											_context3.t0 = _context3['catch'](3);
											_didIteratorError3 = true;
											_iteratorError3 = _context3.t0;
		
										case 22:
											_context3.prev = 22;
											_context3.prev = 23;
		
											if (!_iteratorNormalCompletion3 && _iterator3.return) {
												_iterator3.return();
											}
		
										case 25:
											_context3.prev = 25;
		
											if (!_didIteratorError3) {
												_context3.next = 28;
												break;
											}
		
											throw _iteratorError3;
		
										case 28:
											return _context3.finish(25);
		
										case 29:
											return _context3.finish(22);
		
										case 30:
										case 'end':
											return _context3.stop();
									}
								}
							}, _callee3, this, [[3, 18, 22, 30], [23,, 25, 29]]);
						}));
		
						function value() {
							return _ref4.apply(this, arguments);
						}
		
						return value;
					}()
				}, {
					key: $$commitForcedFromHere,
					value: function () {
						var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
							var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _step4$value, rdep, forced;
		
							return regeneratorRuntime.wrap(function _callee4$(_context4) {
								while (1) {
									switch (_context4.prev = _context4.next) {
										case 0:
											_iteratorNormalCompletion4 = true;
											_didIteratorError4 = false;
											_iteratorError4 = undefined;
											_context4.prev = 3;
											_iterator4 = tracker[$$changes].verticesFrom(this)[Symbol.iterator]();
		
										case 5:
											if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
												_context4.next = 18;
												break;
											}
		
											_step4$value = _slicedToArray(_step4.value, 3);
											rdep = _step4$value[0];
											forced = _step4$value[2].forced;
		
											if (!forced) {
												_context4.next = 15;
												break;
											}
		
											if (rdep.committed) {
												_context4.next = 13;
												break;
											}
		
											_context4.next = 13;
											return rdep.commit();
		
										case 13:
											_context4.next = 15;
											return rdep[$$commitForcedFromHere]();
		
										case 15:
											_iteratorNormalCompletion4 = true;
											_context4.next = 5;
											break;
		
										case 18:
											_context4.next = 24;
											break;
		
										case 20:
											_context4.prev = 20;
											_context4.t0 = _context4['catch'](3);
											_didIteratorError4 = true;
											_iteratorError4 = _context4.t0;
		
										case 24:
											_context4.prev = 24;
											_context4.prev = 25;
		
											if (!_iteratorNormalCompletion4 && _iterator4.return) {
												_iterator4.return();
											}
		
										case 27:
											_context4.prev = 27;
		
											if (!_didIteratorError4) {
												_context4.next = 30;
												break;
											}
		
											throw _iteratorError4;
		
										case 30:
											return _context4.finish(27);
		
										case 31:
											return _context4.finish(24);
		
										case 32:
										case 'end':
											return _context4.stop();
									}
								}
							}, _callee4, this, [[3, 20, 24, 32], [25,, 27, 31]]);
						}));
		
						function value() {
							return _ref5.apply(this, arguments);
						}
		
						return value;
					}()
				}, {
					key: 'rollbackToHere',
					value: function rollbackToHere() {}
				}]);
		
				return Change;
			}();
		};
		
		var ChangeTracker = function () {
			_createClass(ChangeTracker, [{
				key: 'Change',
				get: function get() {
					if (!this[$$Change]) {
						this[$$Change] = ChangeT(this);
					}
					return this[$$Change];
				}
			}]);
		
			function ChangeTracker() {
				_classCallCheck(this, ChangeTracker);
		
				this[$$changes] = new _graph2.default();
			}
		
			return ChangeTracker;
		}();
		
		var tracker = exports.tracker = new ChangeTracker();
		
		// export class CreateEntity extends Change {
		//
		// 	constructor(cls, props = {}, options = {}) {
		// 		super(options);
		// 		this[$$class] = cls;
		// 		this[$$props] = props;
		// 	}
		//
		// 	run() {
		//
		// 	}
		//
		// 	commit() {
		//
		// 	}
		//
		// 	rollback() {
		//
		// 	}
		//
		// }
		//
		// export class DeleteEntity extends Change {}
		//
		// export class SetPropertyField extends Change {}
		//
		// export class SetSideField extends Change {}
		//
		// export class SetRel1Field extends Change {}
		//
		// export class SetRel1ShortcutField extends Change {}
		//
		// export class SetRel$Field extends Change {}
		//
		// export class SetRel$ShortcutField extends Change {}
	
	/***/ },
	/* 206 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _templateObject = _taggedTemplateLiteral(['\n\t\t\tYou tried to manually assign a value ', '\n\t\t\tto ', '#', ',\n\t\t\tbut it already has a fixed value of ', '.\n\t\t'], ['\n\t\t\tYou tried to manually assign a value ', '\n\t\t\tto ', '#', ',\n\t\t\tbut it already has a fixed value of ', '.\n\t\t']),
		    _templateObject2 = _taggedTemplateLiteral(['\n\t\t\t    No value given for required field\n\t\t\t    \'', '#', '\'.\n\t\t\t'], ['\n\t\t\t    No value given for required field\n\t\t\t    \'', '#', '\'.\n\t\t\t']);
		
		var _isUndefined = __webpack_require__(37);
		
		var _isUndefined2 = _interopRequireDefault(_isUndefined);
		
		var _entries = __webpack_require__(17);
		
		var _entries2 = _interopRequireDefault(_entries);
		
		var _cloneDeep = __webpack_require__(254);
		
		var _cloneDeep2 = _interopRequireDefault(_cloneDeep);
		
		var _boundNativeMethods = __webpack_require__(10);
		
		var _misc = __webpack_require__(3);
		
		var _Field2 = __webpack_require__(25);
		
		var _symbols = __webpack_require__(26);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		_Field2.Field[_symbols.$$registerFieldClass](function (_Field) {
			_inherits(PropertyField, _Field);
		
			_createClass(PropertyField, null, [{
				key: 'initClass',
		
		
				//////////////////
				// Change class //
				//////////////////
		
		
				// this[$$owner] instanceof RelatedTo | Resource
				// this[$$key]   instanceof "name" | "class" | "href" | ...
				// this[$$value] instanceof any
		
				////////////
				// static //
				////////////
		
				value: function initClass(_ref) {
					var _context;
		
					var cls = _ref.cls;
					var key = _ref.key;
					var readonly = _ref.desc.readonly;
		
					if (cls.prototype.hasOwnProperty(key)) {
						return;
					}
					(_context = cls.prototype, _boundNativeMethods.defineProperty).call(_context, key, _extends({
						get: function get() {
							return this.fields[key].get();
						}
					}, readonly ? undefined : {
						set: function set(val) {
							this.fields[key].set(val);
						}
					}, {
						enumerable: true,
						configurable: false
					}));
				}
			}, {
				key: _symbols.$$entriesIn,
				value: function value(cls) {
					var _context2;
		
					return (_context2 = cls.properties, _entries2.default).call(_context2).map(function (_ref2) {
						var _ref3 = _slicedToArray(_ref2, 2);
		
						var key = _ref3[0];
						var desc = _ref3[1];
						return {
							key: key,
							desc: desc,
							relatedKeys: []
						};
					});
				}
		
				//////////////
				// instance //
				//////////////
		
			}]);
		
			function PropertyField(options) {
				var _context3;
		
				_classCallCheck(this, PropertyField);
		
				var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PropertyField).call(this, options));
		
				var owner = options.owner;
				var key = options.key;
				var desc = options.desc;
				var initialValue = options.initialValue;
		
				/* sanity checks */
		
				(0, _misc.constraint)((_context3 = desc.value, _isUndefined2.default).call(_context3) || _isUndefined2.default.call(initialValue), (0, _misc.humanMsg)(_templateObject, JSON.stringify(initialValue), owner.constructor.name, key, JSON.stringify(desc.value)));
		
				/* set the initial value */
				_this[_symbols.$$initSet]([!_isUndefined2.default.call(initialValue), (_context3 = _misc.callOrReturn.call(initialValue, owner), _cloneDeep2.default).call(_context3)], ['default' in desc, (_context3 = (_context3 = desc.default, _misc.callOrReturn).call(_context3, owner), _cloneDeep2.default).call(_context3)], ['value' in desc, (_context3 = (_context3 = desc.value, _misc.callOrReturn).call(_context3, owner), _cloneDeep2.default).call(_context3)], [!desc.required]);
				return _this;
			}
		
			_createClass(PropertyField, [{
				key: 'validate',
				value: function validate(val) {
					var stages = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
		
		
					if (stages.includes('commit')) {
						(0, _misc.constraint)(!this[_symbols.$$desc].required || !_isUndefined2.default.call(val), (0, _misc.humanMsg)(_templateObject2, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
					}
		
					// TODO: CHECK CONSTRAINT: given property value conforms to JSON schema
					// TODO: CHECK ADDITIONAL (PROPERTY-SPECIFIC) CONSTRAINTS: e.g., if this
					//     : is a template, does it conform to its corresponding type?
				}
			}]);
		
			return PropertyField;
		}(_Field2.Field));
	
	/***/ },
	/* 207 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _templateObject = _taggedTemplateLiteral(['\n\t\t\tThe value ', ' given for ', '#', '\n\t\t\tis not an iterable collection (like array or set).\n\t\t'], ['\n\t\t\tThe value ', ' given for ', '#', '\n\t\t\tis not an iterable collection (like array or set).\n\t\t']),
		    _templateObject2 = _taggedTemplateLiteral(['\n\t\t\t\tInvalid value ', ' given as element for\n\t\t\t\t', '#', '.\n\t\t\t'], ['\n\t\t\t\tInvalid value ', ' given as element for\n\t\t\t\t', '#', '.\n\t\t\t']);
		
		var _map = __webpack_require__(42);
		
		var _filter = __webpack_require__(29);
		
		var _switchMap = __webpack_require__(129);
		
		var _startWith = __webpack_require__(61);
		
		var _pairwise = __webpack_require__(87);
		
		var _concat = __webpack_require__(183);
		
		var _Subject = __webpack_require__(59);
		
		__webpack_require__(23);
		
		var _inRange = __webpack_require__(145);
		
		var _inRange2 = _interopRequireDefault(_inRange);
		
		var _get = __webpack_require__(144);
		
		var _get2 = _interopRequireDefault(_get);
		
		var _size = __webpack_require__(107);
		
		var _size2 = _interopRequireDefault(_size);
		
		var _entries = __webpack_require__(17);
		
		var _entries2 = _interopRequireDefault(_entries);
		
		var _boundNativeMethods = __webpack_require__(10);
		
		var _ObservableSet = __webpack_require__(67);
		
		var _ObservableSet2 = _interopRequireDefault(_ObservableSet);
		
		var _misc = __webpack_require__(3);
		
		var _Field = __webpack_require__(25);
		
		var _symbols = __webpack_require__(26);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		_Field.Field[_symbols.$$registerFieldClass](function (_RelField) {
			_inherits(Rel$Field, _RelField);
		
			_createClass(Rel$Field, null, [{
				key: 'initClass',
		
		
				// this[$$owner] instanceof Resource
				// this[$$key]   instanceof "-->ContainsMaterial" | "-->HasPart" | "<--FlowsTo" | ...
				// this[$$value] instanceof Set<IsRelatedTo>
		
				////////////
				// static //
				////////////
		
				value: function initClass(_ref) {
					var _context;
		
					var cls = _ref.cls;
					var key = _ref.key;
					var readonly = _ref.desc.readonly;
		
					if (cls.prototype.hasOwnProperty(key)) {
						return;
					}
					(_context = cls.prototype, _boundNativeMethods.defineProperty).call(_context, key, _extends({
						get: function get() {
							return this.fields[key].get();
						}
					}, readonly ? undefined : {
						set: function set(val) {
							this.fields[key].set(val);
						}
					}, {
						enumerable: true,
						configurable: false
					}));
				}
			}, {
				key: _symbols.$$entriesIn,
				value: function value(cls) {
					var _context2;
		
					if (!cls.isResource) {
						return [];
					}
					return (_context2 = cls.relationships, _entries2.default).call(_context2).filter(function (_ref2) {
						var _ref3 = _slicedToArray(_ref2, 2);
		
						var rel = _ref3[1];
						return rel.cardinality.max > 1;
					}).map(function (_ref4) {
						var _ref5 = _slicedToArray(_ref4, 2);
		
						var key = _ref5[0];
						var desc = _ref5[1];
						return {
							key: key,
							desc: desc,
							relatedKeys: desc.shortcutKey ? [desc.shortcutKey] : []
						};
					});
				}
			}]);
		
			//////////////
			// instance //
			//////////////
		
			function Rel$Field(options) {
				var _context4;
		
				_classCallCheck(this, Rel$Field);
		
				var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Rel$Field).call(this, _extends({}, options, { setValueThroughSignal: false })));
		
				var owner = options.owner;
				var desc = options.desc;
				var initialValue = options.initialValue;
				var waitUntilConstructed = options.waitUntilConstructed;
				var constructingOwner = options.constructingOwner;
				var related = options.related;
		
		
				_boundNativeMethods.defineProperty.call(_this, _symbols.$$pristine, { value: new Set() });
				_boundNativeMethods.defineProperty.call(_this, _symbols.$$value, { value: new _ObservableSet2.default() });
		
				/* mirror stuff that happens in sub-fields */
		
				constructingOwner.subscribe({ complete: function complete() {
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;
		
						try {
							for (var _iterator = desc.relationshipClass.extendedBy[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var subCls = _step.value;
		
								var subFieldKey = subCls.keyInResource[desc.keyInRelationship];
								var subField = owner.fields[subFieldKey];
								if (!subField) {
									continue;
								}
								if (_instanceof(subField, Rel$Field)) {
									subField.get().e('add').subscribe(_this.get().e('add'));
									subField.get().e('delete').subscribe(_this.get().e('delete'));
								} else {
									var _context3;
		
									// Rel1Field
									(_context3 = (_context3 = subField.p('value'), _startWith.startWith).call(_context3, null), _pairwise.pairwise).call(_context3).subscribe(function (_ref6) {
										var _ref7 = _slicedToArray(_ref6, 2);
		
										var prev = _ref7[0];
										var curr = _ref7[1];
		
										if (prev) {
											_this.get().delete(prev);
										}
										if (curr) {
											_this.get().add(curr);
										}
									});
								}
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator.return) {
									_iterator.return();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
					} });
		
				/* update relationships that are added or deleted here */
				(_context4 = _this[_symbols.$$value].e('add'), waitUntilConstructed).call(_context4).subscribe(function (rel) {
					rel.fields[desc.keyInRelationship].set(_this[_symbols.$$owner]);
				});
				(_context4 = _this[_symbols.$$value].e('delete'), waitUntilConstructed).call(_context4).subscribe(function (rel) {
					rel.delete();
				});
		
				/* decouple a relationship when it decouples from this resource */
				(_context4 = (_context4 = _this[_symbols.$$value].e('add'), waitUntilConstructed).call(_context4), _switchMap.switchMap).call(_context4, function (newRel) {
					var _context5;
		
					return (_context5 = (_context5 = newRel.fields[desc.keyInRelationship].p('value'), _filter.filter).call(_context5, function (res) {
						return res !== owner;
					}), _map.map).call(_context5, function () {
						return newRel;
					});
				}).subscribe(_this.get().e('delete'));
		
				/* handle initial values */
				if (initialValue && initialValue[Symbol.iterator]) {
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;
		
					try {
						for (var _iterator2 = initialValue[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var rel = _step2.value;
		
							if (!rel.fields[desc.keyInRelationship].get()) {
								rel.fields[desc.keyInRelationship].set(_this);
							}
		
		
							_this[_symbols.$$pristine].add(rel);
							_this[_symbols.$$value].add(rel);
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
				} else if (_get2.default.call(related, [desc.shortcutKey, 'initialValue'])) {
					// OK, a shortcut was given
				} else if (desc.cardinality.min === 0) {}
				// OK, this field is optional
		
		
				/* fill up missing required values with 'auto'matic ones */
				if (desc.options.auto) {
					var shortcutInitial = _get2.default.call(related, [desc.shortcutKey, 'initialValue']);
					for (var i = (_context6 = _this[_symbols.$$value], _size2.default).call(_context6) + _size2.default.call(shortcutInitial); i < desc.cardinality.min; ++i) {
						var _context6, _desc$relationshipCla;
		
						var _rel = desc.relationshipClass.new((_desc$relationshipCla = {}, _defineProperty(_desc$relationshipCla, desc.keyInRelationship, _this[_symbols.$$owner]), _defineProperty(_desc$relationshipCla, desc.codomain.keyInRelationship, desc.codomain.resourceClass.newOrSingleton()), _desc$relationshipCla));
						_this[_symbols.$$pristine].add(_rel);
						_this[_symbols.$$value].add(_rel);
					}
				}
		
				/* emit 'value' signals (but note that setValueThroughSignal = false) */
				(_context4 = _this[_symbols.$$value].p('value'), waitUntilConstructed).call(_context4).subscribe(_this.p('value'));
				return _this;
			}
		
			_createClass(Rel$Field, [{
				key: 'set',
				value: function set(newValue) {
					var _ref8 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		
					var _ref8$ignoreReadonly = _ref8.ignoreReadonly;
					var ignoreReadonly = _ref8$ignoreReadonly === undefined ? false : _ref8$ignoreReadonly;
					var _ref8$ignoreValidatio = _ref8.ignoreValidation;
					var ignoreValidation = _ref8$ignoreValidatio === undefined ? false : _ref8$ignoreValidatio;
					var _ref8$updatePristine = _ref8.updatePristine;
					var updatePristine = _ref8$updatePristine === undefined ? false : _ref8$updatePristine;
		
					(0, _misc.constraint)(ignoreReadonly || !this[_symbols.$$desc].readonly);
					if (!ignoreValidation) {
						this.validate(newValue, ['set']);
					}
					if (updatePristine) {
						(0, _ObservableSet.copySetContent)(this[_symbols.$$pristine], newValue);
					}
					(0, _ObservableSet.copySetContent)(this[_symbols.$$value], newValue);
				}
			}, {
				key: 'validate',
				value: function validate(val) {
					var stages = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
		
					(0, _misc.constraint)(val[Symbol.iterator], (0, _misc.humanMsg)(_templateObject, val, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
					if (stages.includes('commit')) {
						var _context7;
		
						var _$$desc$cardinality = this[_symbols.$$desc].cardinality;
						var min = _$$desc$cardinality.min;
						var max = _$$desc$cardinality.max;
		
						(0, _misc.constraint)((_context7 = val.size, _inRange2.default).call(_context7, min, max + 1), '\n\t\t\t\tThe number of values in field ' + this[_symbols.$$owner].constructor.name + '#' + this[_symbols.$$key] + '\n\t\t\t\tis not within the expected range [' + min + ', ' + max + '].\n\t\t\t');
					}
					val.forEach(this.validateElement.bind(this));
				}
			}, {
				key: 'validateElement',
				value: function validateElement(element) {
					/* the value must be of the proper domain */
					if (!this[_symbols.$$desc].relationshipClass.hasInstance(element)) {
						throw new Error((0, _misc.humanMsg)(_templateObject2, element, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
					}
				}
			}, {
				key: 'commit',
				value: function () {
					var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
						return regeneratorRuntime.wrap(function _callee$(_context8) {
							while (1) {
								switch (_context8.prev = _context8.next) {
									case 0:
										this.validate(this[_symbols.$$value], ['commit']);
										(0, _ObservableSet.copySetContent)(this[_symbols.$$pristine], this[_symbols.$$value]);
										this.e('commit').next(this[_symbols.$$value]);
		
									case 3:
									case 'end':
										return _context8.stop();
								}
							}
						}, _callee, this);
					}));
		
					function commit() {
						return _ref9.apply(this, arguments);
					}
		
					return commit;
				}()
			}, {
				key: 'rollback',
				value: function rollback() {
					(0, _ObservableSet.copySetContent)(this[_symbols.$$value], this[_symbols.$$pristine]);
					this.e('rollback').next(this[_symbols.$$value]);
				}
			}]);
		
			return Rel$Field;
		}(_Field.RelField));
	
	/***/ },
	/* 208 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _templateObject = _taggedTemplateLiteral(['\n\t\t\tYou cannot set the fields \'', '\' and \'', '\'\n\t\t\tat the same time for a ', '.\n\t\t'], ['\n\t\t\tYou cannot set the fields \'', '\' and \'', '\'\n\t\t\tat the same time for a ', '.\n\t\t']),
		    _templateObject2 = _taggedTemplateLiteral(['\n\t\t\t\tNo value given for required field\n\t\t\t\t', '#', '.\n\t\t\t'], ['\n\t\t\t\tNo value given for required field\n\t\t\t\t', '#', '.\n\t\t\t']),
		    _templateObject3 = _taggedTemplateLiteral(['\n\t\t\tInvalid value \'', '\' given for field ', '#', '.\n\t\t'], ['\n\t\t\tInvalid value \'', '\' given for field ', '#', '.\n\t\t']);
		
		var _map = __webpack_require__(42);
		
		var _filter = __webpack_require__(29);
		
		var _pairwise = __webpack_require__(87);
		
		var _switchMap = __webpack_require__(129);
		
		var _startWith = __webpack_require__(61);
		
		__webpack_require__(23);
		
		var _get = __webpack_require__(144);
		
		var _get2 = _interopRequireDefault(_get);
		
		var _isUndefined = __webpack_require__(37);
		
		var _isUndefined2 = _interopRequireDefault(_isUndefined);
		
		var _isNull = __webpack_require__(147);
		
		var _isNull2 = _interopRequireDefault(_isNull);
		
		var _entries = __webpack_require__(17);
		
		var _entries2 = _interopRequireDefault(_entries);
		
		var _isObject2 = __webpack_require__(12);
		
		var _isObject3 = _interopRequireDefault(_isObject2);
		
		var _boundNativeMethods = __webpack_require__(10);
		
		var _misc = __webpack_require__(3);
		
		var _Field = __webpack_require__(25);
		
		var _symbols = __webpack_require__(26);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		_Field.Field[_symbols.$$registerFieldClass](function (_RelField) {
			_inherits(Rel1Field, _RelField);
		
			_createClass(Rel1Field, null, [{
				key: 'initClass',
		
		
				// this[$$owner] instanceof Resource
				// this[$$key]   instanceof "-->HasInnerBorder" | "<--HasPlusBorder" | ...
				// this[$$value] instanceof IsRelatedTo
		
				////////////
				// static //
				////////////
		
				value: function initClass(_ref) {
					var _context;
		
					var cls = _ref.cls;
					var key = _ref.key;
					var readonly = _ref.desc.readonly;
		
					if (cls.prototype.hasOwnProperty(key)) {
						return;
					}
					(_context = cls.prototype, _boundNativeMethods.defineProperty).call(_context, key, _extends({
						get: function get() {
							return this.fields[key].get();
						}
					}, readonly ? undefined : {
						set: function set(val) {
							this.fields[key].set(val);
						}
					}, {
						enumerable: true,
						configurable: false
					}));
				}
			}, {
				key: _symbols.$$entriesIn,
				value: function value(cls) {
					var _context2;
		
					if (!cls.isResource) {
						return [];
					}
					return (_context2 = cls.relationships, _entries2.default).call(_context2).filter(function (_ref2) {
						var _ref3 = _slicedToArray(_ref2, 2);
		
						var desc = _ref3[1];
						return desc.cardinality.max === 1;
					}).map(function (_ref4) {
						var _ref5 = _slicedToArray(_ref4, 2);
		
						var key = _ref5[0];
						var desc = _ref5[1];
						return {
							key: key,
							desc: desc,
							relatedKeys: desc.shortcutKey ? [desc.shortcutKey] : []
						};
					});
				}
		
				//////////////
				// instance //
				//////////////
		
			}]);
		
			function Rel1Field(options) {
				var _context4;
		
				_classCallCheck(this, Rel1Field);
		
				var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Rel1Field).call(this, options));
		
				var owner = options.owner;
				var key = options.key;
				var desc = options.desc;
				var initialValue = options.initialValue;
				var waitUntilConstructed = options.waitUntilConstructed;
				var constructingOwner = options.constructingOwner;
				var related = options.related;
		
				/* you cannot give a value as an actual relation and as a shortcut at the same time */
		
				var givenShortcutInitialValue = _get2.default.call(related, [desc.shortcutKey, 'initialValue']);
				(0, _misc.constraint)(!initialValue || !givenShortcutInitialValue, (0, _misc.humanMsg)(_templateObject, key, desc.shortcutKey, _this.constructor.singular));
		
				/* set the initial value */
				_this[_symbols.$$initSet]([initialValue, initialValue], [givenShortcutInitialValue], [desc.options.auto, function () {
					var _desc$relationshipCla;
		
					return desc.relationshipClass.new((_desc$relationshipCla = {}, _defineProperty(_desc$relationshipCla, desc.keyInRelationship, _this[_symbols.$$owner]), _defineProperty(_desc$relationshipCla, desc.codomain.keyInRelationship, desc.codomain.resourceClass.newOrSingleton()), _desc$relationshipCla));
				}], [desc.options.default, function () {
					var _context3, _desc$relationshipCla2;
		
					return desc.relationshipClass.new((_desc$relationshipCla2 = {}, _defineProperty(_desc$relationshipCla2, desc.keyInRelationship, _this[_symbols.$$owner]), _defineProperty(_desc$relationshipCla2, desc.codomain.keyInRelationship, (_context3 = desc.options.default, _misc.callOrReturn).call(_context3)), _desc$relationshipCla2));
				}], [desc.cardinality.min === 0, null]);
		
				/* pull in values set in sub-fields */
				constructingOwner.subscribe({ complete: function complete() {
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;
		
						try {
							for (var _iterator = desc.relationshipClass.extendedBy[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var subCls = _step.value;
		
								var subFieldKey = subCls.keyInResource[desc.keyInRelationship];
								var subField = owner.fields[subFieldKey];
								if (!subField) {
									continue;
								}
								subField.p('value').subscribe(_this.p('value'));
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator.return) {
									_iterator.return();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
					} });
		
				/* keep the relationship up to date with changes here */
				(_context4 = (_context4 = (_context4 = _this.p('value'), waitUntilConstructed).call(_context4), _startWith.startWith).call(_context4, null), _pairwise.pairwise).call(_context4).subscribe(function (_ref6) {
					var _ref7 = _slicedToArray(_ref6, 2);
		
					var prev = _ref7[0];
					var curr = _ref7[1];
		
					if (prev) {
						prev.fields[desc.keyInRelationship].set(null);
					}
					if (curr) {
						curr.fields[desc.keyInRelationship].set(_this[_symbols.$$owner]);
					}
				});
		
				/* set the value of this field to null when the relationship replaces this resource */
				(_context4 = (_context4 = (_context4 = (_context4 = (_context4 = _this.p('value'), waitUntilConstructed).call(_context4), _filter.filter).call(_context4, _isObject3.default), _switchMap.switchMap).call(_context4, function (newRel) {
					return newRel.fields[desc.keyInRelationship].p('value');
				}), _filter.filter).call(_context4, function (res) {
					return res !== owner;
				}), _map.map).call(_context4, function () {
					return null;
				}).subscribe(_this.p('value'));
				return _this;
			}
		
			_createClass(Rel1Field, [{
				key: 'validate',
				value: function validate(val) {
					var stages = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
		
		
					var notGiven = _isNull2.default.call(val) || _isUndefined2.default.call(val);
		
					if (stages.includes('commit')) {
						/* if there's a minimum cardinality, a value must have been given */
						(0, _misc.constraint)(!notGiven || this[_symbols.$$desc].cardinality.min === 0, (0, _misc.humanMsg)(_templateObject2, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
					}
		
					/* the value must be of the proper domain */
					(0, _misc.constraint)(notGiven || this[_symbols.$$desc].relationshipClass.hasInstance(val), (0, _misc.humanMsg)(_templateObject3, val, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
		
					// TODO: these should not be assertions, but proper constraint-checks,
					//     : recording errors, possibly allowing them temporarily, etc.
				}
			}]);
		
			return Rel1Field;
		}(_Field.RelField));
	
	/***/ },
	/* 209 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _templateObject = _taggedTemplateLiteral(['\n\t\t\tYou\'re trying to set a readonly field ', '#', '.\n\t\t'], ['\n\t\t\tYou\'re trying to set a readonly field ', '#', '.\n\t\t']),
		    _templateObject2 = _taggedTemplateLiteral(['\n\t\t\tThe value ', ' given for ', '#', '\n\t\t\tis not an iterable collection (like array or set).\n\t\t'], ['\n\t\t\tThe value ', ' given for ', '#', '\n\t\t\tis not an iterable collection (like array or set).\n\t\t']),
		    _templateObject3 = _taggedTemplateLiteral(['\n\t\t\t\tThe number of values in field ', '#', '\n\t\t\t\tis not within the expected range [', ', ', '].\n\t\t\t'], ['\n\t\t\t\tThe number of values in field ', '#', '\n\t\t\t\tis not within the expected range [', ', ', '].\n\t\t\t']),
		    _templateObject4 = _taggedTemplateLiteral(['\n\t\t\t\tInvalid value ', ' given as element for\n\t\t\t\t', '#', '.\n\t\t\t'], ['\n\t\t\t\tInvalid value ', ' given as element for\n\t\t\t\t', '#', '.\n\t\t\t']);
		
		var _filter = __webpack_require__(29);
		
		var _pairwise = __webpack_require__(87);
		
		var _takeUntil = __webpack_require__(187);
		
		var _take = __webpack_require__(425);
		
		var _startWith = __webpack_require__(61);
		
		__webpack_require__(23);
		
		var _inRange = __webpack_require__(145);
		
		var _inRange2 = _interopRequireDefault(_inRange);
		
		var _size = __webpack_require__(107);
		
		var _size2 = _interopRequireDefault(_size);
		
		var _entries = __webpack_require__(17);
		
		var _entries2 = _interopRequireDefault(_entries);
		
		var _boundNativeMethods = __webpack_require__(10);
		
		var _ObservableSet = __webpack_require__(67);
		
		var _ObservableSet2 = _interopRequireDefault(_ObservableSet);
		
		var _misc = __webpack_require__(3);
		
		var _Field = __webpack_require__(25);
		
		var _symbols = __webpack_require__(26);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		_Field.Field[_symbols.$$registerFieldClass](function (_RelField) {
			_inherits(RelShortcut$Field, _RelField);
		
			_createClass(RelShortcut$Field, null, [{
				key: 'initClass',
		
		
				// this[$$owner] instanceof Resource
				// this[$$key]   instanceof "materials" | "parts" | "incomingProcesses" | ...
				// this[$$value] instanceof Set<Resource>
		
				////////////
				// static //
				////////////
		
				value: function initClass(_ref) {
					var _context;
		
					var key = _ref.key;
					var cls = _ref.cls;
					var readonly = _ref.desc.readonly;
		
					if (cls.prototype.hasOwnProperty(key)) {
						return;
					}
					(_context = cls.prototype, _boundNativeMethods.defineProperty).call(_context, key, _extends({
						get: function get() {
							return this.fields[key].get();
						}
					}, readonly ? undefined : {
						set: function set(val) {
							this.fields[key].set(val);
						}
					}, {
						enumerable: true,
						configurable: false
					}));
				}
			}, {
				key: _symbols.$$entriesIn,
				value: function value(cls) {
					var _context2;
		
					if (!cls.isResource) {
						return [];
					}
					return (_context2 = cls.relationshipShortcuts, _entries2.default).call(_context2).filter(function (_ref2) {
						var _ref3 = _slicedToArray(_ref2, 2);
		
						var rel = _ref3[1];
						return rel.cardinality.max > 1;
					}).map(function (_ref4) {
						var _ref5 = _slicedToArray(_ref4, 2);
		
						var key = _ref5[0];
						var desc = _ref5[1];
						return {
							key: key,
							desc: desc,
							relatedKeys: desc.keyInResource ? [desc.keyInResource] : []
						};
					});
				}
			}]);
		
			//////////////
			// instance //
			//////////////
		
			function RelShortcut$Field(options) {
				var _context3;
		
				_classCallCheck(this, RelShortcut$Field);
		
				var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RelShortcut$Field).call(this, _extends({}, options, { setValueThroughSignal: false })));
		
				var owner = options.owner;
				var desc = options.desc;
				var initialValue = options.initialValue;
				var waitUntilConstructed = options.waitUntilConstructed;
				var related = options.related;
		
		
				_boundNativeMethods.defineProperty.call(_this, _symbols.$$pristine, { value: new Set() });
				_boundNativeMethods.defineProperty.call(_this, _symbols.$$value, { value: new _ObservableSet2.default() });
		
				/* syncing with relationship field */
				var correspondingRelField = owner.fields[desc.keyInResource][_symbols.$$value];
				(_context3 = correspondingRelField.e('add'), waitUntilConstructed).call(_context3).subscribe(function (newRel) {
					var _context4;
		
					var newRelDisconnected = (_context4 = (_context4 = newRel.fields[desc.keyInRelationship].p('value'), _filter.filter).call(_context4, function (v) {
						return v !== owner;
					}), _take.take).call(_context4, 1);
					(_context4 = (_context4 = (_context4 = newRel.fields[desc.codomain.keyInRelationship].p('value'), _takeUntil.takeUntil).call(_context4, newRelDisconnected), _startWith.startWith).call(_context4, null), _pairwise.pairwise).call(_context4).subscribe(function (_ref6) {
						var _ref7 = _slicedToArray(_ref6, 2);
		
						var prev = _ref7[0];
						var curr = _ref7[1];
		
						if (prev) {
							_this[_symbols.$$value].delete(prev);
						}
						if (curr) {
							_this[_symbols.$$value].add(curr);
						}
					});
					newRelDisconnected.subscribe(function () {
						_this[_symbols.$$value].delete(newRel.fields[desc.codomain.keyInRelationship][_symbols.$$value]);
					});
				});
		
				/* syncing with relationship field */
				(_context3 = _this[_symbols.$$value].e('add'), waitUntilConstructed).call(_context3).subscribe(function (newRes) {
					var rel = [].concat(_toConsumableArray(correspondingRelField)).find(function (rel) {
						return rel.fields[desc.keyInRelationship].get() === owner && rel.fields[desc.codomain.keyInRelationship].get() === newRes;
					});
					if (!rel) {
						var _desc$relationshipCla;
		
						correspondingRelField.add(desc.relationshipClass.new((_desc$relationshipCla = {}, _defineProperty(_desc$relationshipCla, desc.keyInRelationship, owner), _defineProperty(_desc$relationshipCla, desc.codomain.keyInRelationship, newRes), _desc$relationshipCla)));
					}
				});
		
				/* handle initial values */
				if (initialValue !== undefined) {
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;
		
					try {
						for (var _iterator = initialValue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var res = _step.value;
		
							// TODO: - rel may be a reference to an existing resource;
							//     :   then go get it
							//     : - It may also be a description of a new resource;
							//     :   then create it
							_this[_symbols.$$pristine].add(res);
							_this[_symbols.$$value].add(res);
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
				}
		
				/* emit 'value' signals (but note that setValueThroughSignal = false) */
				(_context3 = _this[_symbols.$$value].p('value'), waitUntilConstructed).call(_context3).subscribe(_this.p('value'));
		
				return _this;
			}
		
			_createClass(RelShortcut$Field, [{
				key: 'set',
				value: function set(newValue) {
					var _ref8 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		
					var _ref8$ignoreReadonly = _ref8.ignoreReadonly;
					var ignoreReadonly = _ref8$ignoreReadonly === undefined ? false : _ref8$ignoreReadonly;
					var _ref8$ignoreValidatio = _ref8.ignoreValidation;
					var ignoreValidation = _ref8$ignoreValidatio === undefined ? false : _ref8$ignoreValidatio;
					var _ref8$updatePristine = _ref8.updatePristine;
					var updatePristine = _ref8$updatePristine === undefined ? false : _ref8$updatePristine;
		
					(0, _misc.constraint)(ignoreReadonly || !this[_symbols.$$desc].readonly, (0, _misc.humanMsg)(_templateObject, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
					if (!ignoreValidation) {
						this.validate(newValue, ['set']);
					}
					if (updatePristine) {
						(0, _ObservableSet.copySetContent)(this[_symbols.$$pristine], newValue);
					}
					(0, _ObservableSet.copySetContent)(this[_symbols.$$value], newValue);
				}
			}, {
				key: 'validate',
				value: function validate(val) {
					var stages = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
		
					(0, _misc.constraint)(val[Symbol.iterator], (0, _misc.humanMsg)(_templateObject2, val, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
					if (stages.includes('commit')) {
						var _context5;
		
						var _$$desc$cardinality = this[_symbols.$$desc].cardinality;
						var min = _$$desc$cardinality.min;
						var max = _$$desc$cardinality.max;
		
						(0, _misc.constraint)((_context5 = _size2.default.call(val), _inRange2.default).call(_context5, min, max + 1), (0, _misc.humanMsg)(_templateObject3, this[_symbols.$$owner].constructor.name, this[_symbols.$$key], min, max));
					}
					val.forEach(this.validateElement.bind(this));
				}
			}, {
				key: 'validateElement',
				value: function validateElement(element) {
					/* the value must be of the proper domain */
					if (!this[_symbols.$$desc].codomain.resourceClass.hasInstance(element)) {
						throw new Error((0, _misc.humanMsg)(_templateObject4, element, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
					}
				}
			}, {
				key: 'commit',
				value: function () {
					var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
						return regeneratorRuntime.wrap(function _callee$(_context6) {
							while (1) {
								switch (_context6.prev = _context6.next) {
									case 0:
										this.validate(this[_symbols.$$value], ['commit']);
										(0, _ObservableSet.copySetContent)(this[_symbols.$$pristine], this[_symbols.$$value]);
										this.e('commit').next(this[_symbols.$$value]);
		
									case 3:
									case 'end':
										return _context6.stop();
								}
							}
						}, _callee, this);
					}));
		
					function commit() {
						return _ref9.apply(this, arguments);
					}
		
					return commit;
				}()
			}, {
				key: 'rollback',
				value: function rollback() {
					(0, _ObservableSet.copySetContent)(this[_symbols.$$value], this[_symbols.$$pristine]);
					this.e('rollback').next(this[_symbols.$$value]);
				}
			}]);
		
			return RelShortcut$Field;
		}(_Field.RelField));
	
	/***/ },
	/* 210 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _templateObject = _taggedTemplateLiteral(['\n\t\t\t\tNo value given for required field ', '#', '.\n\t\t\t'], ['\n\t\t\t\tNo value given for required field ', '#', '.\n\t\t\t']),
		    _templateObject2 = _taggedTemplateLiteral(['\n\t\t\tInvalid value \'', '\' given for field ', '#', '.\n\t\t'], ['\n\t\t\tInvalid value \'', '\' given for field ', '#', '.\n\t\t']);
		
		var _filter = __webpack_require__(29);
		
		var _switchMap = __webpack_require__(129);
		
		var _startWith = __webpack_require__(61);
		
		var _defer = __webpack_require__(418);
		
		__webpack_require__(23);
		
		var _entries = __webpack_require__(17);
		
		var _entries2 = _interopRequireDefault(_entries);
		
		var _isObject = __webpack_require__(72);
		
		var _isObject2 = _interopRequireDefault(_isObject);
		
		var _boundNativeMethods = __webpack_require__(10);
		
		var _misc = __webpack_require__(3);
		
		var _Field = __webpack_require__(25);
		
		var _symbols = __webpack_require__(26);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		_Field.Field[_symbols.$$registerFieldClass](function (_RelField) {
			_inherits(RelShortcut1Field, _RelField);
		
			_createClass(RelShortcut1Field, null, [{
				key: 'initClass',
		
		
				// this[$$owner] instanceof Resource
				// this[$$key]   instanceof "innerBorder" | "plusBorder" | ...
				// this[$$value] instanceof Resource
		
				////////////
				// static //
				////////////
		
				value: function initClass(_ref) {
					var _context;
		
					var key = _ref.key;
					var cls = _ref.cls;
					var readonly = _ref.desc.readonly;
		
					if (cls.prototype.hasOwnProperty(key)) {
						return;
					}
					(_context = cls.prototype, _boundNativeMethods.defineProperty).call(_context, key, _extends({
						get: function get() {
							return this.fields[key].get();
						}
					}, readonly ? {} : {
						set: function set(val) {
							this.fields[key].set(val);
						}
					}, {
						enumerable: true,
						configurable: false
					}));
				}
			}, {
				key: _symbols.$$entriesIn,
				value: function value(cls) {
					var _context2;
		
					if (!cls.isResource) {
						return [];
					}
					return (_context2 = cls.relationshipShortcuts, _entries2.default).call(_context2).filter(function (_ref2) {
						var _ref3 = _slicedToArray(_ref2, 2);
		
						var rel = _ref3[1];
						return rel.cardinality.max === 1;
					}).map(function (_ref4) {
						var _ref5 = _slicedToArray(_ref4, 2);
		
						var key = _ref5[0];
						var desc = _ref5[1];
						return {
							key: key,
							desc: desc,
							relatedKeys: desc.keyInResource ? [desc.keyInResource] : []
						};
					});
				}
		
				//////////////
				// instance //
				//////////////
		
			}]);
		
			function RelShortcut1Field(options) {
				var _context3;
		
				_classCallCheck(this, RelShortcut1Field);
		
				var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RelShortcut1Field).call(this, options));
		
				var owner = options.owner;
				var key = options.key;
				var desc = options.desc;
				var initialValue = options.initialValue;
				var waitUntilConstructed = options.waitUntilConstructed;
				var related = options.related;
		
				/* set the initial value */
				// shortcuts are only initialized with explicit initial values;
				// all the fallback options are left to the actual relationship field,
				// so that the two don't compete. Therefore, this constructor is very
				// forgiving. The constraint checks are done on the other constructor.
		
				_this[_symbols.$$initSet]([initialValue, initialValue], [true]);
		
				var correspondingRelValue = (_context3 = (0, _defer.defer)(function () {
					return owner.fields[desc.keyInResource].p('value');
				}), waitUntilConstructed).call(_context3);
		
				/* keep this value up to date with new sides of new relationships */
				(_context3 = _filter.filter.call(correspondingRelValue, function (v) {
					return v;
				}), _switchMap.switchMap).call(_context3, function (rel) {
					return rel.fields[desc.codomain.keyInRelationship].p('value');
				}).subscribe(_this.p('value'));
		
				/* keep the relationship up to date */
				(_context3 = _this.p('value'), waitUntilConstructed).call(_context3).subscribe(function (scValue) {
					var relValue = owner.fields[desc.keyInResource].get();
					if (relValue) {
						relValue.fields[desc.codomain.keyInRelationship].set(scValue || null);
					} else if (scValue && !desc.relationshipClass.abstract) {
						var _desc$relationshipCla;
		
						// TODO: Is the abstractness test above really the best way?
						owner.fields[desc.keyInResource].set(desc.relationshipClass.new((_desc$relationshipCla = {}, _defineProperty(_desc$relationshipCla, desc.keyInRelationship, owner), _defineProperty(_desc$relationshipCla, desc.codomain.keyInRelationship, scValue), _desc$relationshipCla)));
					}
				});
				return _this;
			}
		
			_createClass(RelShortcut1Field, [{
				key: 'validate',
				value: function validate(val) {
					var stages = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
		
		
					if (stages.includes('commit')) {
						/* if there's a minimum cardinality, a value must have been given */
						(0, _misc.constraint)(_isObject2.default.call(val) || this[_symbols.$$desc].cardinality.min === 0, (0, _misc.humanMsg)(_templateObject, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
					}
		
					/* a given value must always be of the proper domain */
					(0, _misc.constraint)(!_isObject2.default.call(val) || this[_symbols.$$desc].codomain.resourceClass.hasInstance(val), (0, _misc.humanMsg)(_templateObject2, val, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
		
					// TODO: these should not be assertions, but proper constraint-checks,
					//     : recording errors, possibly allowing them temporarily, etc.
				}
			}]);
		
			return RelShortcut1Field;
		}(_Field.RelField));
	
	/***/ },
	/* 211 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _templateObject = _taggedTemplateLiteral(['\n\t\t\t    No resource specified for side ', ' of\n\t\t\t\tthis \'', '\'.\n\t\t\t'], ['\n\t\t\t    No resource specified for side ', ' of\n\t\t\t\tthis \'', '\'.\n\t\t\t']),
		    _templateObject2 = _taggedTemplateLiteral(['\n\t\t\tInvalid value \'', '\' given for ', '#', '.\n\t\t'], ['\n\t\t\tInvalid value \'', '\' given for ', '#', '.\n\t\t']);
		
		var _filter = __webpack_require__(29);
		
		var _pairwise = __webpack_require__(87);
		
		var _startWith = __webpack_require__(61);
		
		__webpack_require__(23);
		
		var _isUndefined = __webpack_require__(37);
		
		var _isUndefined2 = _interopRequireDefault(_isUndefined);
		
		var _isNull = __webpack_require__(147);
		
		var _isNull2 = _interopRequireDefault(_isNull);
		
		var _isObject = __webpack_require__(72);
		
		var _isObject2 = _interopRequireDefault(_isObject);
		
		var _boundNativeMethods = __webpack_require__(10);
		
		var _misc = __webpack_require__(3);
		
		var _Field2 = __webpack_require__(25);
		
		var _symbols = __webpack_require__(26);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return _instanceof(left, right); } }
		
		function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
		
		function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		_Field2.Field[_symbols.$$registerFieldClass](function (_Field) {
			_inherits(SideField, _Field);
		
			_createClass(SideField, null, [{
				key: 'initClass',
		
		
				// this[$$owner] instanceof RelatedTo
				// this[$$key]   instanceof 1 | 2
				// this[$$value] instanceof Resource
		
				////////////
				// static //
				////////////
		
				value: function initClass(_ref) {
					var _context;
		
					var cls = _ref.cls;
					var key = _ref.key;
					var readonly = _ref.desc.readonly;
		
					if (cls.prototype.hasOwnProperty(key)) {
						return;
					}
					(_context = cls.prototype, _boundNativeMethods.defineProperty).call(_context, key, _extends({
						get: function get() {
							return this.fields[key].get();
						}
					}, readonly ? undefined : {
						set: function set(val) {
							this.fields[key].set(val);
						}
					}, {
						enumerable: true,
						configurable: false
					}));
				}
			}, {
				key: _symbols.$$entriesIn,
				value: function value(cls) {
					if (!cls.isRelationship) {
						return [];
					}
					return [{ key: 1, cls: cls, desc: cls.domainPairs[0][1], relatedKeys: [2] }, { key: 2, cls: cls, desc: cls.domainPairs[0][2], relatedKeys: [1] }];
					// TODO: unify multiple overlapping domainPairs when needed
				}
		
				//////////////
				// instance //
				//////////////
		
			}]);
		
			function SideField(options) {
				var _context2;
		
				_classCallCheck(this, SideField);
		
				var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SideField).call(this, options));
		
				var owner = options.owner;
				var desc = options.desc;
				var key = options.key;
				var initialValue = options.initialValue;
				var waitUntilConstructed = options.waitUntilConstructed;
		
				/* set the initial value */
		
				_this[_symbols.$$initSet]([_isObject2.default.call(initialValue) || _isNull2.default.call(initialValue), initialValue], [desc.resourceClass.singleton, (_context2 = desc.resourceClass).getSingleton.bind(_context2)], [desc.options.auto, (_context2 = desc.resourceClass).new.bind(_context2)]);
		
				/* if one side becomes null, then so does the other, */
				/* releasing the relationship                        */
				(_context2 = (_context2 = _this.p('value'), waitUntilConstructed).call(_context2), _filter.filter).call(_context2, function (v) {
					return v === null;
				}).subscribe(owner.fields[desc.codomain.keyInRelationship]);
		
				/* when a side changes, let the relevant resources know */
				(_context2 = (_context2 = (_context2 = _this.p('value'), _startWith.startWith).call(_context2, null), waitUntilConstructed).call(_context2), _pairwise.pairwise).call(_context2).subscribe(function (_ref2) {
					var _ref3 = _slicedToArray(_ref2, 2);
		
					var prev = _ref3[0];
					var curr = _ref3[1];
		
					if (desc.cardinality.max === 1) {
						if (prev) {
							prev.fields[desc.keyInResource].set(null);
						}
						if (curr) {
							curr.fields[desc.keyInResource].set(_this[_symbols.$$owner]);
						}
					} else {
						if (prev) {
							prev.fields[desc.keyInResource].get().delete(_this[_symbols.$$owner]);
						}
						if (curr) {
							curr.fields[desc.keyInResource].get().add(_this[_symbols.$$owner]);
						}
					}
				});
		
				return _this;
			}
		
			_createClass(SideField, [{
				key: 'validate',
				value: function validate(val) {
					var stages = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
		
		
					var notGiven = _isNull2.default.call(val) || _isUndefined2.default.call(val);
		
					if (stages.includes('commit')) {
						/* if there's a minimum cardinality, a value must have been given */
						(0, _misc.constraint)(!notGiven, (0, _misc.humanMsg)(_templateObject, this[_symbols.$$key], this[_symbols.$$owner].constructor.name));
					}
		
					/* the value must be of the proper domain */
					(0, _misc.constraint)(notGiven || this[_symbols.$$desc].resourceClass.hasInstance(val), (0, _misc.humanMsg)(_templateObject2, val, this[_symbols.$$owner].constructor.name, this[_symbols.$$key]));
		
					// TODO: these should not be assertions, but proper constraint-checks,
					//     : recording errors, possibly allowing them temporarily, etc.
				}
			}]);
		
			return SideField;
		}(_Field2.Field));
	
	/***/ },
	/* 212 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _resources = __webpack_require__(16);
		
		var _resources2 = _interopRequireDefault(_resources);
		
		var _typed = __webpack_require__(27);
		
		var _typed2 = _interopRequireDefault(_typed);
		
		var _lyphs = __webpack_require__(47);
		
		var _lyphs2 = _interopRequireDefault(_lyphs);
		
		var _groups = __webpack_require__(139);
		
		var _groups2 = _interopRequireDefault(_groups);
		
		var _measurables = __webpack_require__(94);
		
		var _measurables2 = _interopRequireDefault(_measurables);
		
		var _omegaTrees = __webpack_require__(213);
		
		var _omegaTrees2 = _interopRequireDefault(_omegaTrees);
		
		var _processes = __webpack_require__(95);
		
		var _processes2 = _interopRequireDefault(_processes);
		
		var _research = __webpack_require__(214);
		
		var _research2 = _interopRequireDefault(_research);
		
		var _visualisations = __webpack_require__(215);
		
		var _visualisations2 = _interopRequireDefault(_visualisations);
		
		var _Module = __webpack_require__(46);
		
		var _Module2 = _interopRequireDefault(_Module);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _Module2.default.create('all', [_resources2.default, _typed2.default, _lyphs2.default, _groups2.default, _measurables2.default, _omegaTrees2.default, _processes2.default, _research2.default, _visualisations2.default]);
	
	/***/ },
	/* 213 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _TypedModule = __webpack_require__(31);
		
		var _TypedModule2 = _interopRequireDefault(_TypedModule);
		
		var _resources = __webpack_require__(16);
		
		var _resources2 = _interopRequireDefault(_resources);
		
		var _typed = __webpack_require__(27);
		
		var _typed2 = _interopRequireDefault(_typed);
		
		var _groups = __webpack_require__(139);
		
		var _groups2 = _interopRequireDefault(_groups);
		
		var _lyphs = __webpack_require__(47);
		
		var _lyphs2 = _interopRequireDefault(_lyphs);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _TypedModule2.default.create('omegaTrees', [_resources2.default, _typed2.default, _groups2.default, _lyphs2.default], function (M, _ref) {
			var IsRelatedTo = _ref.IsRelatedTo;
			var Template = _ref.Template;
			var Group = _ref.Group;
			var Lyph = _ref.Lyph;
			var Node = _ref.Node;
			var Has = _ref.Has;
			var PullsIntoTypeDefinition = _ref.PullsIntoTypeDefinition;
		
		
			var OmegaTree = M.TYPED_RESOURCE({ ////////////////////////////////////////
		
				name: 'OmegaTree',
		
				extends: Group,
		
				singular: "omega tree"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var HasAsRoot = M.RELATIONSHIP({
		
				name: 'HasAsRoot',
		
				extends: PullsIntoTypeDefinition,
		
				singular: "has as root",
		
				1: [OmegaTree, '0..*', { anchors: true, key: 'root' }],
				2: [Node, '0..*']
		
			});
		
			var OmegaTreePart = M.TYPED_RESOURCE({ ////////////////////////////////////
		
				name: 'OmegaTreePart',
		
				abstract: true,
		
				extends: Template,
				extendedBy: [Lyph, OmegaTree],
		
				singular: "omega tree part"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var HasTreeChildren = M.RELATIONSHIP({
		
				name: 'HasTreeChildren',
		
				extends: PullsIntoTypeDefinition,
		
				singular: "has tree-children",
		
				1: [OmegaTreePart, '0..*', { key: 'treeChildren' }],
				2: [OmegaTreePart, '0..1', { key: 'treeParent' }],
		
				noCycles: true
		
			});
		
			var HasTreePart = M.RELATIONSHIP({
		
				name: 'HasTreePart',
		
				extends: PullsIntoTypeDefinition,
		
				singular: "has tree-part",
		
				1: [OmegaTree, '0..*', { anchors: true, key: 'parts' }],
				2: [OmegaTreePart, '0..*']
		
			});
		});
	
	/***/ },
	/* 214 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _Module = __webpack_require__(46);
		
		var _Module2 = _interopRequireDefault(_Module);
		
		var _resources = __webpack_require__(16);
		
		var _resources2 = _interopRequireDefault(_resources);
		
		var _measurables = __webpack_require__(94);
		
		var _measurables2 = _interopRequireDefault(_measurables);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _Module2.default.create('research', [_resources2.default, _measurables2.default], function (M, _ref) {
			var Resource = _ref.Resource;
			var IsRelatedTo = _ref.IsRelatedTo;
			var Measurable = _ref.Measurable;
		
		
			var Correlation = M.RESOURCE({ ////////////////////////////////////////////
		
				name: 'Correlation',
		
				extends: Resource,
		
				singular: "correlation",
		
				properties: {
					'comment': { type: 'string' }
				}
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var InvolvesMeasurable = M.RELATIONSHIP({
		
				name: 'InvolvesMeasurable',
		
				extends: IsRelatedTo,
		
				singular: "involves measurable",
		
				1: [Correlation, '0..*', { anchors: true, key: 'measurables' }],
				2: [Measurable, '0..*']
		
			});
		
			var ClinicalIndex = M.RESOURCE({ ///////////////////////////////////////////
		
				name: 'ClinicalIndex',
		
				extends: Resource,
		
				singular: "clinical index",
				plural: "clinical indices"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var EncompassesClinicalIndex = M.RELATIONSHIP({
		
				name: 'EncompassesClinicalIndex',
		
				extends: IsRelatedTo,
		
				singular: "encompasses clinical index",
		
				1: [ClinicalIndex, '0..*', { anchors: true, key: 'children' }],
				2: [ClinicalIndex, '0..1', { key: 'parent' }],
		
				noCycles: true
		
			});
		
			var InvolvesClinicalIndex = M.RELATIONSHIP({
		
				name: 'InvolvesClinicalIndex',
		
				extends: IsRelatedTo,
		
				singular: "involves clinical index",
		
				1: [Correlation, '0..*', { anchors: true, key: 'clinicalIndices' }],
				2: [ClinicalIndex, '0..*']
		
			});
		
			var Publication = M.RESOURCE({ ////////////////////////////////////////////
		
				name: 'Publication',
		
				extends: Resource,
		
				singular: "publication"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var InvolvesPublication = M.RELATIONSHIP({
		
				name: 'InvolvesPublication',
		
				extends: IsRelatedTo,
		
				singular: "involves publication",
		
				1: [Correlation, '0..1', { anchors: true, key: 'publication' }],
				2: [Publication, '0..*']
		
			});
		});
	
	/***/ },
	/* 215 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		var _TypedModule = __webpack_require__(31);
		
		var _TypedModule2 = _interopRequireDefault(_TypedModule);
		
		var _schemas = __webpack_require__(32);
		
		var _resources = __webpack_require__(16);
		
		var _resources2 = _interopRequireDefault(_resources);
		
		var _lyphs = __webpack_require__(47);
		
		var _lyphs2 = _interopRequireDefault(_lyphs);
		
		var _typed = __webpack_require__(27);
		
		var _typed2 = _interopRequireDefault(_typed);
		
		var _processes = __webpack_require__(95);
		
		var _processes2 = _interopRequireDefault(_processes);
		
		var _measurables = __webpack_require__(94);
		
		var _measurables2 = _interopRequireDefault(_measurables);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		
		exports.default = _TypedModule2.default.create('visualisations', [_resources2.default, _lyphs2.default, _typed2.default, _processes2.default, _measurables2.default], function (M, _ref) {
			var Resource = _ref.Resource;
			var IsRelatedTo = _ref.IsRelatedTo;
			var Material = _ref.Material;
			var Lyph = _ref.Lyph;
			var Border = _ref.Border;
			var Coalescence = _ref.Coalescence;
			var Node = _ref.Node;
			var Template = _ref.Template;
			var Process = _ref.Process;
			var Measurable = _ref.Measurable;
			var Causality = _ref.Causality;
		
		
			var Theme = M.RESOURCE({ //////////////////////////////////////////////////
		
				name: 'Theme',
		
				extends: Resource,
		
				singular: "theme"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			var PrescribesStyleFor = M.RELATIONSHIP({
		
				name: 'PrescribesStyleFor',
		
				extends: IsRelatedTo,
		
				singular: "prescribes style for",
		
				1: [Theme, '0..*', { key: 'resources' }],
				2: [Resource, '0..*', { key: 'themes' }],
		
				patternProperties: _defineProperty({}, _schemas.identifierRegex, { type: 'string', minLength: 1 })
		
			});
		
			////////////////////////////
			//// Artefact Hierarchy ////
			////////////////////////////
		
			var Artefact = M.RESOURCE({ ///////////////////////////////////////////////
		
				name: 'Artefact',
		
				extends: Resource,
				abstract: true,
		
				singular: "artefact"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var Dim2Artefact = M.RESOURCE({ ///////////////////////////////////////////
		
				name: 'Dim2Artefact',
		
				extends: Artefact,
				abstract: true,
		
				singular: "2-dimensional artefact"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var Dim1Artefact = M.RESOURCE({ ///////////////////////////////////////////
		
				name: 'Dim1Artefact',
		
				extends: Dim2Artefact,
				abstract: true,
		
				singular: "1-dimensional artefact"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var Dim0Artefact = M.RESOURCE({ ///////////////////////////////////////////
		
				name: 'Dim0Artefact',
		
				extends: Dim1Artefact,
				abstract: true,
		
				singular: "0-dimensional artefact"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			//////////////////////////////////////
			//// Artefact Container Hierarchy ////
			//////////////////////////////////////
		
			var ArtefactContainer = M.RESOURCE({ //////////////////////////////////////
		
				name: 'ArtefactContainer',
		
				abstract: true,
		
				extends: Artefact,
		
				singular: "artefact container"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var Dim2Container = M.RESOURCE({ //////////////////////////////////////////
		
				name: 'Dim2Container',
		
				extends: [ArtefactContainer, Dim2Artefact],
				abstract: true,
		
				singular: "2-dimensional container"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var Dim1Container = M.RESOURCE({ //////////////////////////////////////////
		
				name: 'Dim1Container',
		
				extends: [ArtefactContainer, Dim1Artefact],
				abstract: true,
		
				singular: "1-dimensional container"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var Dim0Container = M.RESOURCE({ //////////////////////////////////////////
		
				name: 'Dim0Container',
		
				extends: [ArtefactContainer, Dim0Artefact],
				abstract: true,
		
				singular: "0-dimensional container"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			/////////////////////////////////////////////////////
			//// Artefact Containment Relationship Hierarchy ////
			/////////////////////////////////////////////////////
		
			var ContainsArtefact = M.RELATIONSHIP({
		
				name: 'ContainsArtefact',
		
				abstract: true,
		
				extends: IsRelatedTo,
		
				singular: "contains artefact",
		
				1: [ArtefactContainer, '0..*', { anchors: true, key: 'children' }],
				2: [Artefact, '0..1', { key: 'parent' }]
		
			});
		
			/* in 2-dimensional containers */
			var ContainsArtefact_22 = M.RELATIONSHIP({
		
				name: 'ContainsArtefact_22',
		
				extends: ContainsArtefact,
		
				1: [Dim2Container, '0..*', { anchors: true, key: 'children' }],
				2: [Dim2Artefact, '0..1', { key: 'parent' }],
		
				properties: {
					'x': _extends({}, _schemas.rationalNumberSchema, { required: true }),
					'y': _extends({}, _schemas.rationalNumberSchema, { required: true }),
					'rotation': _extends({}, _schemas.angleSchema, { default: 0, required: true }),
					'width': _extends({}, _schemas.rationalNumberSchema, { required: true }),
					'height': _extends({}, _schemas.rationalNumberSchema, { required: true })
				}
		
			});
			var ContainsArtefact_21 = M.RELATIONSHIP({
		
				name: 'ContainsArtefact_21',
		
				extends: ContainsArtefact_22,
		
				1: [Dim2Container, '0..*', { anchors: true, key: 'children' }],
				2: [Dim1Artefact, '0..1', { key: 'parent' }],
		
				properties: { 'height': { value: 0 } }
		
			});
			var ContainsArtefact_20 = M.RELATIONSHIP({
		
				name: 'ContainsArtefact_20',
		
				extends: ContainsArtefact_21,
		
				1: [Dim2Container, '0..*', { anchors: true, key: 'children' }],
				2: [Dim0Artefact, '0..1', { key: 'parent' }],
		
				properties: { 'width': { value: 0 } }
		
			});
		
			/* in 1-dimensional containers */
			var ContainsArtefact_11 = M.RELATIONSHIP({
		
				name: 'ContainsArtefact_11',
		
				extends: ContainsArtefact,
		
				1: [Dim1Container, '0..*', { anchors: true, key: 'children' }],
				2: [Dim1Artefact, '0..1', { key: 'parent' }],
		
				properties: {
					'x': _extends({}, _schemas.rationalNumberSchema, { required: true }),
					'width': _extends({}, _schemas.rationalNumberSchema, { required: true })
				}
		
			});
			var ContainsArtefact_10 = M.RELATIONSHIP({
		
				name: 'ContainsArtefact_10',
		
				extends: ContainsArtefact_11,
		
				1: [Dim1Container, '0..*', { anchors: true, key: 'children' }],
				2: [Dim0Artefact, '0..1', { key: 'parent' }],
		
				properties: { 'width': { value: 0 } }
		
			});
		
			/* containment in 0-dimensional containers */
			var ContainsArtefact_00 = M.RELATIONSHIP({
		
				name: 'ContainsArtefact_00',
		
				extends: ContainsArtefact,
		
				1: [Dim0Container, '0..*', { anchors: true, key: 'children' }],
				2: [Dim0Artefact, '0..1', { key: 'parent' }]
		
			});
		
			////////////////////////////
			//// Specific Artefacts ////
			////////////////////////////
		
			var LyphCanvas = M.RESOURCE({ /////////////////////////////////////////////
		
				name: 'LyphCanvas',
		
				extends: Dim2Container,
		
				singular: "lyph canvas",
				plural: "lyph canvases"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var MaterialGlyph = M.RESOURCE({ //////////////////////////////////////////
		
				name: 'MaterialGlyph',
		
				extends: Dim0Artefact,
		
				singular: "material glyph"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var LyphRectangle = M.RESOURCE({ //////////////////////////////////////////
		
				name: 'LyphRectangle',
		
				extends: Dim2Container,
		
				singular: "lyph rectangle"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var LyphArtefact = M.RESOURCE({ ///////////////////////////////////////////
		
				name: 'LyphArtefact',
		
				extends: Dim2Container,
				extendedBy: [LyphCanvas, LyphRectangle],
		
				singular: "lyph artefact"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var BorderLine = M.RESOURCE({ /////////////////////////////////////////////
		
				name: 'BorderLine',
		
				extends: Dim1Container,
		
				singular: "border line"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var CoalescenceRectangle = M.RESOURCE({ ///////////////////////////////////
		
				name: 'CoalescenceRectangle',
		
				extends: Dim2Container,
		
				singular: "coalescence rectangle"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var NodeGlyph = M.RESOURCE({ //////////////////////////////////////////////
		
				name: 'NodeGlyph',
		
				extends: Dim0Container,
		
				singular: "node glyph"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var ProcessEdge = M.RESOURCE({ ////////////////////////////////////////////
		
				name: 'ProcessEdge',
		
				extends: Dim1Container,
		
				singular: "process edge"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var MeasurableGlyph = M.RESOURCE({ ////////////////////////////////////////
		
				name: 'MeasurableGlyph',
		
				extends: Dim0Artefact,
		
				singular: "measurable glyph"
		
			}); /////////////////////////////////////////////////////////////////////////
		
			var CausalityArrow = M.RESOURCE({ /////////////////////////////////////////
		
				name: 'CausalityArrow',
		
				extends: Dim1Artefact,
		
				singular: "causality arrow"
		
			}); /////////////////////////////////////////////////////////////////////////
		
		
			////////////////////////////////////////
			//// Model - Artefact Relationships ////
			////////////////////////////////////////
		
			var _M$RELATIONSHIP = M.RELATIONSHIP([[Artefact, Template], [MaterialGlyph, Material], [LyphArtefact, Lyph], [BorderLine, Border], [NodeGlyph, Node], [ProcessEdge, Process], [MeasurableGlyph, Measurable], [CausalityArrow, Causality], [CoalescenceRectangle, Coalescence]].map(function (_ref2) {
				var _ref3 = _slicedToArray(_ref2, 2);
		
				var ArtefactClass = _ref3[0];
				var ModelClass = _ref3[1];
				return {
		
					name: 'PresentsModel',
		
					extends: IsRelatedTo,
		
					singular: "presents model",
		
					1: [ArtefactClass, '1..1', { anchors: true, key: 'model' }],
					2: [ModelClass, '0..*']
		
				};
			}));
		
			var _M$RELATIONSHIP2 = _slicedToArray(_M$RELATIONSHIP, 1);
		
			var PresentsModel = _M$RELATIONSHIP2[0];
		});
	
	/***/ },
	/* 216 */
	/***/ function(module, exports) {
	
		"use strict";
	
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.default = "\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n";
	
	/***/ },
	/* 217 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		exports.__esModule = true;
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		var _functionGenerator = __webpack_require__(19);
		
		var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
		
		exports['default'] = (0, _functionGenerator2['default'])(ArrayBuffer, ['isView', 'transfer']);
		module.exports = exports['default'];
	
	/***/ },
	/* 218 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		exports.__esModule = true;
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		var _functionGenerator = __webpack_require__(19);
		
		var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
		
		exports['default'] = (0, _functionGenerator2['default'])(Array, ['isArray', 'observe']);
		module.exports = exports['default'];
	
	/***/ },
	/* 219 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		exports.__esModule = true;
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		var _functionGenerator = __webpack_require__(19);
		
		var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
		
		exports['default'] = (0, _functionGenerator2['default'])(Date, ['parse'], {
		  parse: 'toUnixOffset'
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 220 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		exports.__esModule = true;
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		var _functionGenerator = __webpack_require__(19);
		
		var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
		
		exports['default'] = (0, _functionGenerator2['default'])(JSON, ['parse', 'stringify'], {
		  parse: 'toObject',
		  stringify: 'toJSON'
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 221 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		exports.__esModule = true;
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		var _functionGenerator = __webpack_require__(19);
		
		var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
		
		exports['default'] = (0, _functionGenerator2['default'])(Math, ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'cbrt', 'ceil', 'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'hypot', 'imul', 'log', 'log10', 'log1p', 'log2', 'max', 'min', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc']);
		module.exports = exports['default'];
	
	/***/ },
	/* 222 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		exports.__esModule = true;
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		var _functionGenerator = __webpack_require__(19);
		
		var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
		
		exports['default'] = (0, _functionGenerator2['default'])(Number, ['isFinite', 'isInteger', 'isNaN', 'isSafeInteger', 'parseFloat', 'parseInt'], {
		  parseFloat: 'toFloat',
		  parseInt: 'toInt'
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 223 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		exports.__esModule = true;
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		var _functionGenerator = __webpack_require__(19);
		
		var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
		
		exports['default'] = (0, _functionGenerator2['default'])(Object, ['assign', 'create', 'defineProperties', 'defineProperty', 'freeze', 'getOwnPropertyDescriptor', 'getOwnPropertyNames', 'getOwnPropertySymbols', 'getPrototypeOf', 'is', 'isExtensible', 'isFrozen', 'isSealed', 'keys', 'observe', 'preventExtensions', 'seal', 'setPrototypeOf'], {
		  getPrototypeOf: 'getPrototype',
		  setPrototypeOf: 'setPrototype'
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 224 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		exports.__esModule = true;
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		var _functionGenerator = __webpack_require__(19);
		
		var _functionGenerator2 = _interopRequireDefault(_functionGenerator);
		
		exports['default'] = (0, _functionGenerator2['default'])(Symbol, ['for', 'keyFor'], {
		  'for': 'toSymbol',
		  keyFor: 'key'
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 225 */,
	/* 226 */,
	/* 227 */,
	/* 228 */,
	/* 229 */,
	/* 230 */,
	/* 231 */,
	/* 232 */,
	/* 233 */,
	/* 234 */,
	/* 235 */,
	/* 236 */,
	/* 237 */,
	/* 238 */,
	/* 239 */,
	/* 240 */,
	/* 241 */,
	/* 242 */,
	/* 243 */,
	/* 244 */,
	/* 245 */,
	/* 246 */,
	/* 247 */,
	/* 248 */,
	/* 249 */,
	/* 250 */,
	/* 251 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(374);
		
		module.exports = function assign() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 252 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(376);
		
		module.exports = function assignWith() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 253 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(377);
		
		module.exports = function at() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 254 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(378);
		
		module.exports = function cloneDeep() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 255 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(381);
		
		module.exports = function flatten() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 256 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(382);
		
		module.exports = function fromPairs() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 257 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(385);
		
		module.exports = function includes() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 258 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(387);
		
		module.exports = function isInteger() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 259 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(389);
		
		module.exports = function isNumber() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 260 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(390);
		
		module.exports = function isSet() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 261 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(393);
		
		module.exports = function isWeakSet() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 262 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(395);
		
		module.exports = function mapValues() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 263 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(396);
		
		module.exports = function max() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 264 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(399);
		
		module.exports = function omitBy() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 265 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(400);
		
		module.exports = function parseInt() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 266 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(401);
		
		module.exports = function pick() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 267 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(404);
		
		module.exports = function set() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 268 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(408);
		
		module.exports = function trim() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 269 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var fn = __webpack_require__(410);
		
		module.exports = function uniq() {
		  return fn.apply(undefined, [this].concat(Array.prototype.slice.apply(arguments)));
		};
	
	
	/***/ },
	/* 270 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getNative = __webpack_require__(39),
		    root = __webpack_require__(11);
		
		/* Built-in method references that are verified to be native. */
		var DataView = getNative(root, 'DataView');
		
		module.exports = DataView;
	
	
	/***/ },
	/* 271 */
	/***/ function(module, exports, __webpack_require__) {
	
		var hashClear = __webpack_require__(339),
		    hashDelete = __webpack_require__(340),
		    hashGet = __webpack_require__(341),
		    hashHas = __webpack_require__(342),
		    hashSet = __webpack_require__(343);
		
		/**
		 * Creates a hash object.
		 *
		 * @private
		 * @constructor
		 * @param {Array} [entries] The key-value pairs to cache.
		 */
		function Hash(entries) {
		  var index = -1,
		      length = entries ? entries.length : 0;
		
		  this.clear();
		  while (++index < length) {
		    var entry = entries[index];
		    this.set(entry[0], entry[1]);
		  }
		}
		
		// Add methods to `Hash`.
		Hash.prototype.clear = hashClear;
		Hash.prototype['delete'] = hashDelete;
		Hash.prototype.get = hashGet;
		Hash.prototype.has = hashHas;
		Hash.prototype.set = hashSet;
		
		module.exports = Hash;
	
	
	/***/ },
	/* 272 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getNative = __webpack_require__(39),
		    root = __webpack_require__(11);
		
		/* Built-in method references that are verified to be native. */
		var Promise = getNative(root, 'Promise');
		
		module.exports = Promise;
	
	
	/***/ },
	/* 273 */
	/***/ function(module, exports, __webpack_require__) {
	
		var root = __webpack_require__(11);
		
		/** Built-in value references. */
		var Reflect = root.Reflect;
		
		module.exports = Reflect;
	
	
	/***/ },
	/* 274 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getNative = __webpack_require__(39),
		    root = __webpack_require__(11);
		
		/* Built-in method references that are verified to be native. */
		var WeakMap = getNative(root, 'WeakMap');
		
		module.exports = WeakMap;
	
	
	/***/ },
	/* 275 */
	/***/ function(module, exports) {
	
		/**
		 * Adds the key-value `pair` to `map`.
		 *
		 * @private
		 * @param {Object} map The map to modify.
		 * @param {Array} pair The key-value pair to add.
		 * @returns {Object} Returns `map`.
		 */
		function addMapEntry(map, pair) {
		  // Don't return `map.set` because it's not chainable in IE 11.
		  map.set(pair[0], pair[1]);
		  return map;
		}
		
		module.exports = addMapEntry;
	
	
	/***/ },
	/* 276 */
	/***/ function(module, exports) {
	
		/**
		 * Adds `value` to `set`.
		 *
		 * @private
		 * @param {Object} set The set to modify.
		 * @param {*} value The value to add.
		 * @returns {Object} Returns `set`.
		 */
		function addSetEntry(set, value) {
		  // Don't return `set.add` because it's not chainable in IE 11.
		  set.add(value);
		  return set;
		}
		
		module.exports = addSetEntry;
	
	
	/***/ },
	/* 277 */
	/***/ function(module, exports) {
	
		/**
		 * A specialized version of `_.forEach` for arrays without support for
		 * iteratee shorthands.
		 *
		 * @private
		 * @param {Array} [array] The array to iterate over.
		 * @param {Function} iteratee The function invoked per iteration.
		 * @returns {Array} Returns `array`.
		 */
		function arrayEach(array, iteratee) {
		  var index = -1,
		      length = array ? array.length : 0;
		
		  while (++index < length) {
		    if (iteratee(array[index], index, array) === false) {
		      break;
		    }
		  }
		  return array;
		}
		
		module.exports = arrayEach;
	
	
	/***/ },
	/* 278 */
	/***/ function(module, exports) {
	
		/**
		 * A specialized version of `_.filter` for arrays without support for
		 * iteratee shorthands.
		 *
		 * @private
		 * @param {Array} [array] The array to iterate over.
		 * @param {Function} predicate The function invoked per iteration.
		 * @returns {Array} Returns the new filtered array.
		 */
		function arrayFilter(array, predicate) {
		  var index = -1,
		      length = array ? array.length : 0,
		      resIndex = 0,
		      result = [];
		
		  while (++index < length) {
		    var value = array[index];
		    if (predicate(value, index, array)) {
		      result[resIndex++] = value;
		    }
		  }
		  return result;
		}
		
		module.exports = arrayFilter;
	
	
	/***/ },
	/* 279 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIndexOf = __webpack_require__(78);
		
		/**
		 * A specialized version of `_.includes` for arrays without support for
		 * specifying an index to search from.
		 *
		 * @private
		 * @param {Array} [array] The array to search.
		 * @param {*} target The value to search for.
		 * @returns {boolean} Returns `true` if `target` is found, else `false`.
		 */
		function arrayIncludes(array, value) {
		  var length = array ? array.length : 0;
		  return !!length && baseIndexOf(array, value, 0) > -1;
		}
		
		module.exports = arrayIncludes;
	
	
	/***/ },
	/* 280 */
	/***/ function(module, exports) {
	
		/**
		 * This function is like `arrayIncludes` except that it accepts a comparator.
		 *
		 * @private
		 * @param {Array} [array] The array to search.
		 * @param {*} target The value to search for.
		 * @param {Function} comparator The comparator invoked per element.
		 * @returns {boolean} Returns `true` if `target` is found, else `false`.
		 */
		function arrayIncludesWith(array, value, comparator) {
		  var index = -1,
		      length = array ? array.length : 0;
		
		  while (++index < length) {
		    if (comparator(value, array[index])) {
		      return true;
		    }
		  }
		  return false;
		}
		
		module.exports = arrayIncludesWith;
	
	
	/***/ },
	/* 281 */
	/***/ function(module, exports) {
	
		/**
		 * A specialized version of `_.some` for arrays without support for iteratee
		 * shorthands.
		 *
		 * @private
		 * @param {Array} [array] The array to iterate over.
		 * @param {Function} predicate The function invoked per iteration.
		 * @returns {boolean} Returns `true` if any element passes the predicate check,
		 *  else `false`.
		 */
		function arraySome(array, predicate) {
		  var index = -1,
		      length = array ? array.length : 0;
		
		  while (++index < length) {
		    if (predicate(array[index], index, array)) {
		      return true;
		    }
		  }
		  return false;
		}
		
		module.exports = arraySome;
	
	
	/***/ },
	/* 282 */
	/***/ function(module, exports, __webpack_require__) {
	
		var eq = __webpack_require__(56);
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
		
		/**
		 * Used by `_.defaults` to customize its `_.assignIn` use.
		 *
		 * @private
		 * @param {*} objValue The destination value.
		 * @param {*} srcValue The source value.
		 * @param {string} key The key of the property to assign.
		 * @param {Object} object The parent object of `objValue`.
		 * @returns {*} Returns the value to assign.
		 */
		function assignInDefaults(objValue, srcValue, key, object) {
		  if (objValue === undefined ||
		      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		    return srcValue;
		  }
		  return objValue;
		}
		
		module.exports = assignInDefaults;
	
	
	/***/ },
	/* 283 */
	/***/ function(module, exports, __webpack_require__) {
	
		var copyObject = __webpack_require__(52),
		    keys = __webpack_require__(9);
		
		/**
		 * The base implementation of `_.assign` without support for multiple sources
		 * or `customizer` functions.
		 *
		 * @private
		 * @param {Object} object The destination object.
		 * @param {Object} source The source object.
		 * @returns {Object} Returns `object`.
		 */
		function baseAssign(object, source) {
		  return object && copyObject(source, keys(source), object);
		}
		
		module.exports = baseAssign;
	
	
	/***/ },
	/* 284 */
	/***/ function(module, exports, __webpack_require__) {
	
		var get = __webpack_require__(123);
		
		/**
		 * The base implementation of `_.at` without support for individual paths.
		 *
		 * @private
		 * @param {Object} object The object to iterate over.
		 * @param {string[]} paths The property paths of elements to pick.
		 * @returns {Array} Returns the picked elements.
		 */
		function baseAt(object, paths) {
		  var index = -1,
		      isNil = object == null,
		      length = paths.length,
		      result = Array(length);
		
		  while (++index < length) {
		    result[index] = isNil ? undefined : get(object, paths[index]);
		  }
		  return result;
		}
		
		module.exports = baseAt;
	
	
	/***/ },
	/* 285 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Stack = __webpack_require__(111),
		    arrayEach = __webpack_require__(277),
		    assignValue = __webpack_require__(75),
		    baseAssign = __webpack_require__(283),
		    cloneBuffer = __webpack_require__(316),
		    copyArray = __webpack_require__(323),
		    copySymbols = __webpack_require__(324),
		    getAllKeys = __webpack_require__(332),
		    getTag = __webpack_require__(53),
		    initCloneArray = __webpack_require__(344),
		    initCloneByTag = __webpack_require__(345),
		    initCloneObject = __webpack_require__(346),
		    isArray = __webpack_require__(8),
		    isBuffer = __webpack_require__(386),
		    isHostObject = __webpack_require__(120),
		    isObject = __webpack_require__(12),
		    keys = __webpack_require__(9);
		
		/** `Object#toString` result references. */
		var argsTag = '[object Arguments]',
		    arrayTag = '[object Array]',
		    boolTag = '[object Boolean]',
		    dateTag = '[object Date]',
		    errorTag = '[object Error]',
		    funcTag = '[object Function]',
		    genTag = '[object GeneratorFunction]',
		    mapTag = '[object Map]',
		    numberTag = '[object Number]',
		    objectTag = '[object Object]',
		    regexpTag = '[object RegExp]',
		    setTag = '[object Set]',
		    stringTag = '[object String]',
		    symbolTag = '[object Symbol]',
		    weakMapTag = '[object WeakMap]';
		
		var arrayBufferTag = '[object ArrayBuffer]',
		    dataViewTag = '[object DataView]',
		    float32Tag = '[object Float32Array]',
		    float64Tag = '[object Float64Array]',
		    int8Tag = '[object Int8Array]',
		    int16Tag = '[object Int16Array]',
		    int32Tag = '[object Int32Array]',
		    uint8Tag = '[object Uint8Array]',
		    uint8ClampedTag = '[object Uint8ClampedArray]',
		    uint16Tag = '[object Uint16Array]',
		    uint32Tag = '[object Uint32Array]';
		
		/** Used to identify `toStringTag` values supported by `_.clone`. */
		var cloneableTags = {};
		cloneableTags[argsTag] = cloneableTags[arrayTag] =
		cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
		cloneableTags[boolTag] = cloneableTags[dateTag] =
		cloneableTags[float32Tag] = cloneableTags[float64Tag] =
		cloneableTags[int8Tag] = cloneableTags[int16Tag] =
		cloneableTags[int32Tag] = cloneableTags[mapTag] =
		cloneableTags[numberTag] = cloneableTags[objectTag] =
		cloneableTags[regexpTag] = cloneableTags[setTag] =
		cloneableTags[stringTag] = cloneableTags[symbolTag] =
		cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
		cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
		cloneableTags[errorTag] = cloneableTags[funcTag] =
		cloneableTags[weakMapTag] = false;
		
		/**
		 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
		 * traversed objects.
		 *
		 * @private
		 * @param {*} value The value to clone.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @param {boolean} [isFull] Specify a clone including symbols.
		 * @param {Function} [customizer] The function to customize cloning.
		 * @param {string} [key] The key of `value`.
		 * @param {Object} [object] The parent object of `value`.
		 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
		 * @returns {*} Returns the cloned value.
		 */
		function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
		  var result;
		  if (customizer) {
		    result = object ? customizer(value, key, object, stack) : customizer(value);
		  }
		  if (result !== undefined) {
		    return result;
		  }
		  if (!isObject(value)) {
		    return value;
		  }
		  var isArr = isArray(value);
		  if (isArr) {
		    result = initCloneArray(value);
		    if (!isDeep) {
		      return copyArray(value, result);
		    }
		  } else {
		    var tag = getTag(value),
		        isFunc = tag == funcTag || tag == genTag;
		
		    if (isBuffer(value)) {
		      return cloneBuffer(value, isDeep);
		    }
		    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
		      if (isHostObject(value)) {
		        return object ? value : {};
		      }
		      result = initCloneObject(isFunc ? {} : value);
		      if (!isDeep) {
		        return copySymbols(value, baseAssign(result, value));
		      }
		    } else {
		      if (!cloneableTags[tag]) {
		        return object ? value : {};
		      }
		      result = initCloneByTag(value, tag, baseClone, isDeep);
		    }
		  }
		  // Check for circular references and return its corresponding clone.
		  stack || (stack = new Stack);
		  var stacked = stack.get(value);
		  if (stacked) {
		    return stacked;
		  }
		  stack.set(value, result);
		
		  if (!isArr) {
		    var props = isFull ? getAllKeys(value) : keys(value);
		  }
		  arrayEach(props || value, function(subValue, key) {
		    if (props) {
		      key = subValue;
		      subValue = value[key];
		    }
		    // Recursively populate clone (susceptible to call stack limits).
		    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
		  });
		  return result;
		}
		
		module.exports = baseClone;
	
	
	/***/ },
	/* 286 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isObject = __webpack_require__(12);
		
		/** Built-in value references. */
		var objectCreate = Object.create;
		
		/**
		 * The base implementation of `_.create` without support for assigning
		 * properties to the created object.
		 *
		 * @private
		 * @param {Object} prototype The object to inherit from.
		 * @returns {Object} Returns the new object.
		 */
		function baseCreate(proto) {
		  return isObject(proto) ? objectCreate(proto) : {};
		}
		
		module.exports = baseCreate;
	
	
	/***/ },
	/* 287 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseForOwn = __webpack_require__(155),
		    createBaseEach = __webpack_require__(326);
		
		/**
		 * The base implementation of `_.forEach` without support for iteratee shorthands.
		 *
		 * @private
		 * @param {Array|Object} collection The collection to iterate over.
		 * @param {Function} iteratee The function invoked per iteration.
		 * @returns {Array|Object} Returns `collection`.
		 */
		var baseEach = createBaseEach(baseForOwn);
		
		module.exports = baseEach;
	
	
	/***/ },
	/* 288 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isSymbol = __webpack_require__(58);
		
		/**
		 * The base implementation of methods like `_.max` and `_.min` which accepts a
		 * `comparator` to determine the extremum value.
		 *
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} iteratee The iteratee invoked per iteration.
		 * @param {Function} comparator The comparator used to compare values.
		 * @returns {*} Returns the extremum value.
		 */
		function baseExtremum(array, iteratee, comparator) {
		  var index = -1,
		      length = array.length;
		
		  while (++index < length) {
		    var value = array[index],
		        current = iteratee(value);
		
		    if (current != null && (computed === undefined
		          ? (current === current && !isSymbol(current))
		          : comparator(current, computed)
		        )) {
		      var computed = current,
		          result = value;
		    }
		  }
		  return result;
		}
		
		module.exports = baseExtremum;
	
	
	/***/ },
	/* 289 */
	/***/ function(module, exports) {
	
		/**
		 * The base implementation of `_.findIndex` and `_.findLastIndex` without
		 * support for iteratee shorthands.
		 *
		 * @private
		 * @param {Array} array The array to search.
		 * @param {Function} predicate The function invoked per iteration.
		 * @param {number} fromIndex The index to search from.
		 * @param {boolean} [fromRight] Specify iterating from right to left.
		 * @returns {number} Returns the index of the matched value, else `-1`.
		 */
		function baseFindIndex(array, predicate, fromIndex, fromRight) {
		  var length = array.length,
		      index = fromIndex + (fromRight ? 1 : -1);
		
		  while ((fromRight ? index-- : ++index < length)) {
		    if (predicate(array[index], index, array)) {
		      return index;
		    }
		  }
		  return -1;
		}
		
		module.exports = baseFindIndex;
	
	
	/***/ },
	/* 290 */
	/***/ function(module, exports, __webpack_require__) {
	
		var createBaseFor = __webpack_require__(327);
		
		/**
		 * The base implementation of `baseForOwn` which iterates over `object`
		 * properties returned by `keysFunc` and invokes `iteratee` for each property.
		 * Iteratee functions may exit iteration early by explicitly returning `false`.
		 *
		 * @private
		 * @param {Object} object The object to iterate over.
		 * @param {Function} iteratee The function invoked per iteration.
		 * @param {Function} keysFunc The function to get the keys of `object`.
		 * @returns {Object} Returns `object`.
		 */
		var baseFor = createBaseFor();
		
		module.exports = baseFor;
	
	
	/***/ },
	/* 291 */
	/***/ function(module, exports) {
	
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
		
		/**
		 * The base implementation of `getTag`.
		 *
		 * @private
		 * @param {*} value The value to query.
		 * @returns {string} Returns the `toStringTag`.
		 */
		function baseGetTag(value) {
		  return objectToString.call(value);
		}
		
		module.exports = baseGetTag;
	
	
	/***/ },
	/* 292 */
	/***/ function(module, exports) {
	
		/**
		 * The base implementation of `_.gt` which doesn't coerce arguments.
		 *
		 * @private
		 * @param {*} value The value to compare.
		 * @param {*} other The other value to compare.
		 * @returns {boolean} Returns `true` if `value` is greater than `other`,
		 *  else `false`.
		 */
		function baseGt(value, other) {
		  return value > other;
		}
		
		module.exports = baseGt;
	
	
	/***/ },
	/* 293 */
	/***/ function(module, exports) {
	
		/**
		 * The base implementation of `_.hasIn` without support for deep paths.
		 *
		 * @private
		 * @param {Object} [object] The object to query.
		 * @param {Array|string} key The key to check.
		 * @returns {boolean} Returns `true` if `key` exists, else `false`.
		 */
		function baseHasIn(object, key) {
		  return object != null && key in Object(object);
		}
		
		module.exports = baseHasIn;
	
	
	/***/ },
	/* 294 */
	/***/ function(module, exports) {
	
		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeMax = Math.max,
		    nativeMin = Math.min;
		
		/**
		 * The base implementation of `_.inRange` which doesn't coerce arguments.
		 *
		 * @private
		 * @param {number} number The number to check.
		 * @param {number} start The start of the range.
		 * @param {number} end The end of the range.
		 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		 */
		function baseInRange(number, start, end) {
		  return number >= nativeMin(start, end) && number < nativeMax(start, end);
		}
		
		module.exports = baseInRange;
	
	
	/***/ },
	/* 295 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Stack = __webpack_require__(111),
		    equalArrays = __webpack_require__(164),
		    equalByTag = __webpack_require__(330),
		    equalObjects = __webpack_require__(331),
		    getTag = __webpack_require__(53),
		    isArray = __webpack_require__(8),
		    isHostObject = __webpack_require__(120),
		    isTypedArray = __webpack_require__(391);
		
		/** Used to compose bitmasks for comparison styles. */
		var PARTIAL_COMPARE_FLAG = 2;
		
		/** `Object#toString` result references. */
		var argsTag = '[object Arguments]',
		    arrayTag = '[object Array]',
		    objectTag = '[object Object]';
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
		
		/**
		 * A specialized version of `baseIsEqual` for arrays and objects which performs
		 * deep comparisons and tracks traversed objects enabling objects with circular
		 * references to be compared.
		 *
		 * @private
		 * @param {Object} object The object to compare.
		 * @param {Object} other The other object to compare.
		 * @param {Function} equalFunc The function to determine equivalents of values.
		 * @param {Function} [customizer] The function to customize comparisons.
		 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
		 *  for more details.
		 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
		 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		 */
		function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
		  var objIsArr = isArray(object),
		      othIsArr = isArray(other),
		      objTag = arrayTag,
		      othTag = arrayTag;
		
		  if (!objIsArr) {
		    objTag = getTag(object);
		    objTag = objTag == argsTag ? objectTag : objTag;
		  }
		  if (!othIsArr) {
		    othTag = getTag(other);
		    othTag = othTag == argsTag ? objectTag : othTag;
		  }
		  var objIsObj = objTag == objectTag && !isHostObject(object),
		      othIsObj = othTag == objectTag && !isHostObject(other),
		      isSameTag = objTag == othTag;
		
		  if (isSameTag && !objIsObj) {
		    stack || (stack = new Stack);
		    return (objIsArr || isTypedArray(object))
		      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
		      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
		  }
		  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
		    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
		        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
		
		    if (objIsWrapped || othIsWrapped) {
		      var objUnwrapped = objIsWrapped ? object.value() : object,
		          othUnwrapped = othIsWrapped ? other.value() : other;
		
		      stack || (stack = new Stack);
		      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
		    }
		  }
		  if (!isSameTag) {
		    return false;
		  }
		  stack || (stack = new Stack);
		  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
		}
		
		module.exports = baseIsEqualDeep;
	
	
	/***/ },
	/* 296 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Stack = __webpack_require__(111),
		    baseIsEqual = __webpack_require__(113);
		
		/** Used to compose bitmasks for comparison styles. */
		var UNORDERED_COMPARE_FLAG = 1,
		    PARTIAL_COMPARE_FLAG = 2;
		
		/**
		 * The base implementation of `_.isMatch` without support for iteratee shorthands.
		 *
		 * @private
		 * @param {Object} object The object to inspect.
		 * @param {Object} source The object of property values to match.
		 * @param {Array} matchData The property names, values, and compare flags to match.
		 * @param {Function} [customizer] The function to customize comparisons.
		 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		 */
		function baseIsMatch(object, source, matchData, customizer) {
		  var index = matchData.length,
		      length = index,
		      noCustomizer = !customizer;
		
		  if (object == null) {
		    return !length;
		  }
		  object = Object(object);
		  while (index--) {
		    var data = matchData[index];
		    if ((noCustomizer && data[2])
		          ? data[1] !== object[data[0]]
		          : !(data[0] in object)
		        ) {
		      return false;
		    }
		  }
		  while (++index < length) {
		    data = matchData[index];
		    var key = data[0],
		        objValue = object[key],
		        srcValue = data[1];
		
		    if (noCustomizer && data[2]) {
		      if (objValue === undefined && !(key in object)) {
		        return false;
		      }
		    } else {
		      var stack = new Stack;
		      if (customizer) {
		        var result = customizer(objValue, srcValue, key, object, source, stack);
		      }
		      if (!(result === undefined
		            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
		            : result
		          )) {
		        return false;
		      }
		    }
		  }
		  return true;
		}
		
		module.exports = baseIsMatch;
	
	
	/***/ },
	/* 297 */
	/***/ function(module, exports) {
	
		/**
		 * The base implementation of `_.isNaN` without support for number objects.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		 */
		function baseIsNaN(value) {
		  return value !== value;
		}
		
		module.exports = baseIsNaN;
	
	
	/***/ },
	/* 298 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isFunction = __webpack_require__(84),
		    isHostObject = __webpack_require__(120),
		    isMasked = __webpack_require__(350),
		    isObject = __webpack_require__(12),
		    toSource = __webpack_require__(170);
		
		/**
		 * Used to match `RegExp`
		 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
		 */
		var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
		
		/** Used to detect host constructors (Safari). */
		var reIsHostCtor = /^\[object .+?Constructor\]$/;
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Used to resolve the decompiled source of functions. */
		var funcToString = Function.prototype.toString;
		
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
		
		/** Used to detect if a method is native. */
		var reIsNative = RegExp('^' +
		  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
		  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
		);
		
		/**
		 * The base implementation of `_.isNative` without bad shim checks.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a native function,
		 *  else `false`.
		 */
		function baseIsNative(value) {
		  if (!isObject(value) || isMasked(value)) {
		    return false;
		  }
		  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
		  return pattern.test(toSource(value));
		}
		
		module.exports = baseIsNative;
	
	
	/***/ },
	/* 299 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getTag = __webpack_require__(53),
		    isObjectLike = __webpack_require__(18);
		
		/** `Object#toString` result references. */
		var setTag = '[object Set]';
		
		/**
		 * The base implementation of `_.isSet` without Node.js optimizations.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		 */
		function baseIsSet(value) {
		  return isObjectLike(value) && getTag(value) == setTag;
		}
		
		module.exports = baseIsSet;
	
	
	/***/ },
	/* 300 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isLength = __webpack_require__(85),
		    isObjectLike = __webpack_require__(18);
		
		/** `Object#toString` result references. */
		var argsTag = '[object Arguments]',
		    arrayTag = '[object Array]',
		    boolTag = '[object Boolean]',
		    dateTag = '[object Date]',
		    errorTag = '[object Error]',
		    funcTag = '[object Function]',
		    mapTag = '[object Map]',
		    numberTag = '[object Number]',
		    objectTag = '[object Object]',
		    regexpTag = '[object RegExp]',
		    setTag = '[object Set]',
		    stringTag = '[object String]',
		    weakMapTag = '[object WeakMap]';
		
		var arrayBufferTag = '[object ArrayBuffer]',
		    dataViewTag = '[object DataView]',
		    float32Tag = '[object Float32Array]',
		    float64Tag = '[object Float64Array]',
		    int8Tag = '[object Int8Array]',
		    int16Tag = '[object Int16Array]',
		    int32Tag = '[object Int32Array]',
		    uint8Tag = '[object Uint8Array]',
		    uint8ClampedTag = '[object Uint8ClampedArray]',
		    uint16Tag = '[object Uint16Array]',
		    uint32Tag = '[object Uint32Array]';
		
		/** Used to identify `toStringTag` values of typed arrays. */
		var typedArrayTags = {};
		typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
		typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
		typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
		typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
		typedArrayTags[uint32Tag] = true;
		typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
		typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
		typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
		typedArrayTags[errorTag] = typedArrayTags[funcTag] =
		typedArrayTags[mapTag] = typedArrayTags[numberTag] =
		typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
		typedArrayTags[setTag] = typedArrayTags[stringTag] =
		typedArrayTags[weakMapTag] = false;
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
		
		/**
		 * The base implementation of `_.isTypedArray` without Node.js optimizations.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		 */
		function baseIsTypedArray(value) {
		  return isObjectLike(value) &&
		    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
		}
		
		module.exports = baseIsTypedArray;
	
	
	/***/ },
	/* 301 */
	/***/ function(module, exports, __webpack_require__) {
	
		var overArg = __webpack_require__(122);
		
		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeKeys = Object.keys;
		
		/**
		 * The base implementation of `_.keys` which doesn't skip the constructor
		 * property of prototypes or treat sparse arrays as dense.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @returns {Array} Returns the array of property names.
		 */
		var baseKeys = overArg(nativeKeys, Object);
		
		module.exports = baseKeys;
	
	
	/***/ },
	/* 302 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Reflect = __webpack_require__(273),
		    iteratorToArray = __webpack_require__(351);
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Built-in value references. */
		var enumerate = Reflect ? Reflect.enumerate : undefined,
		    propertyIsEnumerable = objectProto.propertyIsEnumerable;
		
		/**
		 * The base implementation of `_.keysIn` which doesn't skip the constructor
		 * property of prototypes or treat sparse arrays as dense.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @returns {Array} Returns the array of property names.
		 */
		function baseKeysIn(object) {
		  object = object == null ? object : Object(object);
		
		  var result = [];
		  for (var key in object) {
		    result.push(key);
		  }
		  return result;
		}
		
		// Fallback for IE < 9 with es6-shim.
		if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
		  baseKeysIn = function(object) {
		    return iteratorToArray(enumerate(object));
		  };
		}
		
		module.exports = baseKeysIn;
	
	
	/***/ },
	/* 303 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseEach = __webpack_require__(287),
		    isArrayLike = __webpack_require__(21);
		
		/**
		 * The base implementation of `_.map` without support for iteratee shorthands.
		 *
		 * @private
		 * @param {Array|Object} collection The collection to iterate over.
		 * @param {Function} iteratee The function invoked per iteration.
		 * @returns {Array} Returns the new mapped array.
		 */
		function baseMap(collection, iteratee) {
		  var index = -1,
		      result = isArrayLike(collection) ? Array(collection.length) : [];
		
		  baseEach(collection, function(value, key, collection) {
		    result[++index] = iteratee(value, key, collection);
		  });
		  return result;
		}
		
		module.exports = baseMap;
	
	
	/***/ },
	/* 304 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIsMatch = __webpack_require__(296),
		    getMatchData = __webpack_require__(335),
		    matchesStrictComparable = __webpack_require__(168);
		
		/**
		 * The base implementation of `_.matches` which doesn't clone `source`.
		 *
		 * @private
		 * @param {Object} source The object of property values to match.
		 * @returns {Function} Returns the new spec function.
		 */
		function baseMatches(source) {
		  var matchData = getMatchData(source);
		  if (matchData.length == 1 && matchData[0][2]) {
		    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
		  }
		  return function(object) {
		    return object === source || baseIsMatch(object, source, matchData);
		  };
		}
		
		module.exports = baseMatches;
	
	
	/***/ },
	/* 305 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIsEqual = __webpack_require__(113),
		    get = __webpack_require__(123),
		    hasIn = __webpack_require__(383),
		    isKey = __webpack_require__(55),
		    isStrictComparable = __webpack_require__(167),
		    matchesStrictComparable = __webpack_require__(168),
		    toKey = __webpack_require__(40);
		
		/** Used to compose bitmasks for comparison styles. */
		var UNORDERED_COMPARE_FLAG = 1,
		    PARTIAL_COMPARE_FLAG = 2;
		
		/**
		 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
		 *
		 * @private
		 * @param {string} path The path of the property to get.
		 * @param {*} srcValue The value to match.
		 * @returns {Function} Returns the new spec function.
		 */
		function baseMatchesProperty(path, srcValue) {
		  if (isKey(path) && isStrictComparable(srcValue)) {
		    return matchesStrictComparable(toKey(path), srcValue);
		  }
		  return function(object) {
		    var objValue = get(object, path);
		    return (objValue === undefined && objValue === srcValue)
		      ? hasIn(object, path)
		      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
		  };
		}
		
		module.exports = baseMatchesProperty;
	
	
	/***/ },
	/* 306 */
	/***/ function(module, exports, __webpack_require__) {
	
		var basePickBy = __webpack_require__(159);
		
		/**
		 * The base implementation of `_.pick` without support for individual
		 * property identifiers.
		 *
		 * @private
		 * @param {Object} object The source object.
		 * @param {string[]} props The property identifiers to pick.
		 * @returns {Object} Returns the new object.
		 */
		function basePick(object, props) {
		  object = Object(object);
		  return basePickBy(object, props, function(value, key) {
		    return key in object;
		  });
		}
		
		module.exports = basePick;
	
	
	/***/ },
	/* 307 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseGet = __webpack_require__(156);
		
		/**
		 * A specialized version of `baseProperty` which supports deep paths.
		 *
		 * @private
		 * @param {Array|string} path The path of the property to get.
		 * @returns {Function} Returns the new accessor function.
		 */
		function basePropertyDeep(path) {
		  return function(object) {
		    return baseGet(object, path);
		  };
		}
		
		module.exports = basePropertyDeep;
	
	
	/***/ },
	/* 308 */
	/***/ function(module, exports, __webpack_require__) {
	
		var assignValue = __webpack_require__(75),
		    castPath = __webpack_require__(115),
		    isIndex = __webpack_require__(54),
		    isKey = __webpack_require__(55),
		    isObject = __webpack_require__(12),
		    toKey = __webpack_require__(40);
		
		/**
		 * The base implementation of `_.set`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @param {Array|string} path The path of the property to set.
		 * @param {*} value The value to set.
		 * @param {Function} [customizer] The function to customize path creation.
		 * @returns {Object} Returns `object`.
		 */
		function baseSet(object, path, value, customizer) {
		  path = isKey(path, object) ? [path] : castPath(path);
		
		  var index = -1,
		      length = path.length,
		      lastIndex = length - 1,
		      nested = object;
		
		  while (nested != null && ++index < length) {
		    var key = toKey(path[index]);
		    if (isObject(nested)) {
		      var newValue = value;
		      if (index != lastIndex) {
		        var objValue = nested[key];
		        newValue = customizer ? customizer(objValue, key, nested) : undefined;
		        if (newValue === undefined) {
		          newValue = objValue == null
		            ? (isIndex(path[index + 1]) ? [] : {})
		            : objValue;
		        }
		      }
		      assignValue(nested, key, newValue);
		    }
		    nested = nested[key];
		  }
		  return object;
		}
		
		module.exports = baseSet;
	
	
	/***/ },
	/* 309 */
	/***/ function(module, exports) {
	
		/**
		 * The base implementation of `_.slice` without an iteratee call guard.
		 *
		 * @private
		 * @param {Array} array The array to slice.
		 * @param {number} [start=0] The start position.
		 * @param {number} [end=array.length] The end position.
		 * @returns {Array} Returns the slice of `array`.
		 */
		function baseSlice(array, start, end) {
		  var index = -1,
		      length = array.length;
		
		  if (start < 0) {
		    start = -start > length ? 0 : (length + start);
		  }
		  end = end > length ? length : end;
		  if (end < 0) {
		    end += length;
		  }
		  length = start > end ? 0 : ((end - start) >>> 0);
		  start >>>= 0;
		
		  var result = Array(length);
		  while (++index < length) {
		    result[index] = array[index + start];
		  }
		  return result;
		}
		
		module.exports = baseSlice;
	
	
	/***/ },
	/* 310 */
	/***/ function(module, exports, __webpack_require__) {
	
		var arrayMap = __webpack_require__(51);
		
		/**
		 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
		 * of key-value pairs for `object` corresponding to the property names of `props`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @param {Array} props The property names to get values for.
		 * @returns {Object} Returns the key-value pairs.
		 */
		function baseToPairs(object, props) {
		  return arrayMap(props, function(key) {
		    return [key, object[key]];
		  });
		}
		
		module.exports = baseToPairs;
	
	
	/***/ },
	/* 311 */
	/***/ function(module, exports, __webpack_require__) {
	
		var arrayMap = __webpack_require__(51);
		
		/**
		 * The base implementation of `_.values` and `_.valuesIn` which creates an
		 * array of `object` property values corresponding to the property names
		 * of `props`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @param {Array} props The property names to get values for.
		 * @returns {Object} Returns the array of property values.
		 */
		function baseValues(object, props) {
		  return arrayMap(props, function(key) {
		    return object[key];
		  });
		}
		
		module.exports = baseValues;
	
	
	/***/ },
	/* 312 */
	/***/ function(module, exports) {
	
		/**
		 * Checks if a cache value for `key` exists.
		 *
		 * @private
		 * @param {Object} cache The cache to query.
		 * @param {string} key The key of the entry to check.
		 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		 */
		function cacheHas(cache, key) {
		  return cache.has(key);
		}
		
		module.exports = cacheHas;
	
	
	/***/ },
	/* 313 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseSlice = __webpack_require__(309);
		
		/**
		 * Casts `array` to a slice if it's needed.
		 *
		 * @private
		 * @param {Array} array The array to inspect.
		 * @param {number} start The start position.
		 * @param {number} [end=array.length] The end position.
		 * @returns {Array} Returns the cast slice.
		 */
		function castSlice(array, start, end) {
		  var length = array.length;
		  end = end === undefined ? length : end;
		  return (!start && end >= length) ? array : baseSlice(array, start, end);
		}
		
		module.exports = castSlice;
	
	
	/***/ },
	/* 314 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIndexOf = __webpack_require__(78);
		
		/**
		 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
		 * that is not found in the character symbols.
		 *
		 * @private
		 * @param {Array} strSymbols The string symbols to inspect.
		 * @param {Array} chrSymbols The character symbols to find.
		 * @returns {number} Returns the index of the last unmatched string symbol.
		 */
		function charsEndIndex(strSymbols, chrSymbols) {
		  var index = strSymbols.length;
		
		  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		  return index;
		}
		
		module.exports = charsEndIndex;
	
	
	/***/ },
	/* 315 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIndexOf = __webpack_require__(78);
		
		/**
		 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
		 * that is not found in the character symbols.
		 *
		 * @private
		 * @param {Array} strSymbols The string symbols to inspect.
		 * @param {Array} chrSymbols The character symbols to find.
		 * @returns {number} Returns the index of the first unmatched string symbol.
		 */
		function charsStartIndex(strSymbols, chrSymbols) {
		  var index = -1,
		      length = strSymbols.length;
		
		  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		  return index;
		}
		
		module.exports = charsStartIndex;
	
	
	/***/ },
	/* 316 */
	/***/ function(module, exports) {
	
		/**
		 * Creates a clone of  `buffer`.
		 *
		 * @private
		 * @param {Buffer} buffer The buffer to clone.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Buffer} Returns the cloned buffer.
		 */
		function cloneBuffer(buffer, isDeep) {
		  if (isDeep) {
		    return buffer.slice();
		  }
		  var result = new buffer.constructor(buffer.length);
		  buffer.copy(result);
		  return result;
		}
		
		module.exports = cloneBuffer;
	
	
	/***/ },
	/* 317 */
	/***/ function(module, exports, __webpack_require__) {
	
		var cloneArrayBuffer = __webpack_require__(116);
		
		/**
		 * Creates a clone of `dataView`.
		 *
		 * @private
		 * @param {Object} dataView The data view to clone.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Object} Returns the cloned data view.
		 */
		function cloneDataView(dataView, isDeep) {
		  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
		  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
		}
		
		module.exports = cloneDataView;
	
	
	/***/ },
	/* 318 */
	/***/ function(module, exports, __webpack_require__) {
	
		var addMapEntry = __webpack_require__(275),
		    arrayReduce = __webpack_require__(154),
		    mapToArray = __webpack_require__(121);
		
		/**
		 * Creates a clone of `map`.
		 *
		 * @private
		 * @param {Object} map The map to clone.
		 * @param {Function} cloneFunc The function to clone values.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Object} Returns the cloned map.
		 */
		function cloneMap(map, isDeep, cloneFunc) {
		  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
		  return arrayReduce(array, addMapEntry, new map.constructor);
		}
		
		module.exports = cloneMap;
	
	
	/***/ },
	/* 319 */
	/***/ function(module, exports) {
	
		/** Used to match `RegExp` flags from their coerced string values. */
		var reFlags = /\w*$/;
		
		/**
		 * Creates a clone of `regexp`.
		 *
		 * @private
		 * @param {Object} regexp The regexp to clone.
		 * @returns {Object} Returns the cloned regexp.
		 */
		function cloneRegExp(regexp) {
		  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
		  result.lastIndex = regexp.lastIndex;
		  return result;
		}
		
		module.exports = cloneRegExp;
	
	
	/***/ },
	/* 320 */
	/***/ function(module, exports, __webpack_require__) {
	
		var addSetEntry = __webpack_require__(276),
		    arrayReduce = __webpack_require__(154),
		    setToArray = __webpack_require__(83);
		
		/**
		 * Creates a clone of `set`.
		 *
		 * @private
		 * @param {Object} set The set to clone.
		 * @param {Function} cloneFunc The function to clone values.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Object} Returns the cloned set.
		 */
		function cloneSet(set, isDeep, cloneFunc) {
		  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
		  return arrayReduce(array, addSetEntry, new set.constructor);
		}
		
		module.exports = cloneSet;
	
	
	/***/ },
	/* 321 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Symbol = __webpack_require__(74);
		
		/** Used to convert symbols to primitives and strings. */
		var symbolProto = Symbol ? Symbol.prototype : undefined,
		    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
		
		/**
		 * Creates a clone of the `symbol` object.
		 *
		 * @private
		 * @param {Object} symbol The symbol object to clone.
		 * @returns {Object} Returns the cloned symbol object.
		 */
		function cloneSymbol(symbol) {
		  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
		}
		
		module.exports = cloneSymbol;
	
	
	/***/ },
	/* 322 */
	/***/ function(module, exports, __webpack_require__) {
	
		var cloneArrayBuffer = __webpack_require__(116);
		
		/**
		 * Creates a clone of `typedArray`.
		 *
		 * @private
		 * @param {Object} typedArray The typed array to clone.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Object} Returns the cloned typed array.
		 */
		function cloneTypedArray(typedArray, isDeep) {
		  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
		  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
		}
		
		module.exports = cloneTypedArray;
	
	
	/***/ },
	/* 323 */
	/***/ function(module, exports) {
	
		/**
		 * Copies the values of `source` to `array`.
		 *
		 * @private
		 * @param {Array} source The array to copy values from.
		 * @param {Array} [array=[]] The array to copy values to.
		 * @returns {Array} Returns `array`.
		 */
		function copyArray(source, array) {
		  var index = -1,
		      length = source.length;
		
		  array || (array = Array(length));
		  while (++index < length) {
		    array[index] = source[index];
		  }
		  return array;
		}
		
		module.exports = copyArray;
	
	
	/***/ },
	/* 324 */
	/***/ function(module, exports, __webpack_require__) {
	
		var copyObject = __webpack_require__(52),
		    getSymbols = __webpack_require__(119);
		
		/**
		 * Copies own symbol properties of `source` to `object`.
		 *
		 * @private
		 * @param {Object} source The object to copy symbols from.
		 * @param {Object} [object={}] The object to copy symbols to.
		 * @returns {Object} Returns `object`.
		 */
		function copySymbols(source, object) {
		  return copyObject(source, getSymbols(source), object);
		}
		
		module.exports = copySymbols;
	
	
	/***/ },
	/* 325 */
	/***/ function(module, exports, __webpack_require__) {
	
		var root = __webpack_require__(11);
		
		/** Used to detect overreaching core-js shims. */
		var coreJsData = root['__core-js_shared__'];
		
		module.exports = coreJsData;
	
	
	/***/ },
	/* 326 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isArrayLike = __webpack_require__(21);
		
		/**
		 * Creates a `baseEach` or `baseEachRight` function.
		 *
		 * @private
		 * @param {Function} eachFunc The function to iterate over a collection.
		 * @param {boolean} [fromRight] Specify iterating from right to left.
		 * @returns {Function} Returns the new base function.
		 */
		function createBaseEach(eachFunc, fromRight) {
		  return function(collection, iteratee) {
		    if (collection == null) {
		      return collection;
		    }
		    if (!isArrayLike(collection)) {
		      return eachFunc(collection, iteratee);
		    }
		    var length = collection.length,
		        index = fromRight ? length : -1,
		        iterable = Object(collection);
		
		    while ((fromRight ? index-- : ++index < length)) {
		      if (iteratee(iterable[index], index, iterable) === false) {
		        break;
		      }
		    }
		    return collection;
		  };
		}
		
		module.exports = createBaseEach;
	
	
	/***/ },
	/* 327 */
	/***/ function(module, exports) {
	
		/**
		 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
		 *
		 * @private
		 * @param {boolean} [fromRight] Specify iterating from right to left.
		 * @returns {Function} Returns the new base function.
		 */
		function createBaseFor(fromRight) {
		  return function(object, iteratee, keysFunc) {
		    var index = -1,
		        iterable = Object(object),
		        props = keysFunc(object),
		        length = props.length;
		
		    while (length--) {
		      var key = props[fromRight ? length : ++index];
		      if (iteratee(iterable[key], key, iterable) === false) {
		        break;
		      }
		    }
		    return object;
		  };
		}
		
		module.exports = createBaseFor;
	
	
	/***/ },
	/* 328 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Set = __webpack_require__(150),
		    noop = __webpack_require__(398),
		    setToArray = __webpack_require__(83);
		
		/** Used as references for various `Number` constants. */
		var INFINITY = 1 / 0;
		
		/**
		 * Creates a set object of `values`.
		 *
		 * @private
		 * @param {Array} values The values to add to the set.
		 * @returns {Object} Returns the new set.
		 */
		var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
		  return new Set(values);
		};
		
		module.exports = createSet;
	
	
	/***/ },
	/* 329 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseToPairs = __webpack_require__(310),
		    getTag = __webpack_require__(53),
		    mapToArray = __webpack_require__(121),
		    setToPairs = __webpack_require__(365);
		
		/** `Object#toString` result references. */
		var mapTag = '[object Map]',
		    setTag = '[object Set]';
		
		/**
		 * Creates a `_.toPairs` or `_.toPairsIn` function.
		 *
		 * @private
		 * @param {Function} keysFunc The function to get the keys of a given object.
		 * @returns {Function} Returns the new pairs function.
		 */
		function createToPairs(keysFunc) {
		  return function(object) {
		    var tag = getTag(object);
		    if (tag == mapTag) {
		      return mapToArray(object);
		    }
		    if (tag == setTag) {
		      return setToPairs(object);
		    }
		    return baseToPairs(object, keysFunc(object));
		  };
		}
		
		module.exports = createToPairs;
	
	
	/***/ },
	/* 330 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Symbol = __webpack_require__(74),
		    Uint8Array = __webpack_require__(152),
		    eq = __webpack_require__(56),
		    equalArrays = __webpack_require__(164),
		    mapToArray = __webpack_require__(121),
		    setToArray = __webpack_require__(83);
		
		/** Used to compose bitmasks for comparison styles. */
		var UNORDERED_COMPARE_FLAG = 1,
		    PARTIAL_COMPARE_FLAG = 2;
		
		/** `Object#toString` result references. */
		var boolTag = '[object Boolean]',
		    dateTag = '[object Date]',
		    errorTag = '[object Error]',
		    mapTag = '[object Map]',
		    numberTag = '[object Number]',
		    regexpTag = '[object RegExp]',
		    setTag = '[object Set]',
		    stringTag = '[object String]',
		    symbolTag = '[object Symbol]';
		
		var arrayBufferTag = '[object ArrayBuffer]',
		    dataViewTag = '[object DataView]';
		
		/** Used to convert symbols to primitives and strings. */
		var symbolProto = Symbol ? Symbol.prototype : undefined,
		    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
		
		/**
		 * A specialized version of `baseIsEqualDeep` for comparing objects of
		 * the same `toStringTag`.
		 *
		 * **Note:** This function only supports comparing values with tags of
		 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
		 *
		 * @private
		 * @param {Object} object The object to compare.
		 * @param {Object} other The other object to compare.
		 * @param {string} tag The `toStringTag` of the objects to compare.
		 * @param {Function} equalFunc The function to determine equivalents of values.
		 * @param {Function} customizer The function to customize comparisons.
		 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
		 *  for more details.
		 * @param {Object} stack Tracks traversed `object` and `other` objects.
		 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		 */
		function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
		  switch (tag) {
		    case dataViewTag:
		      if ((object.byteLength != other.byteLength) ||
		          (object.byteOffset != other.byteOffset)) {
		        return false;
		      }
		      object = object.buffer;
		      other = other.buffer;
		
		    case arrayBufferTag:
		      if ((object.byteLength != other.byteLength) ||
		          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
		        return false;
		      }
		      return true;
		
		    case boolTag:
		    case dateTag:
		    case numberTag:
		      // Coerce booleans to `1` or `0` and dates to milliseconds.
		      // Invalid dates are coerced to `NaN`.
		      return eq(+object, +other);
		
		    case errorTag:
		      return object.name == other.name && object.message == other.message;
		
		    case regexpTag:
		    case stringTag:
		      // Coerce regexes to strings and treat strings, primitives and objects,
		      // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
		      // for more details.
		      return object == (other + '');
		
		    case mapTag:
		      var convert = mapToArray;
		
		    case setTag:
		      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
		      convert || (convert = setToArray);
		
		      if (object.size != other.size && !isPartial) {
		        return false;
		      }
		      // Assume cyclic values are equal.
		      var stacked = stack.get(object);
		      if (stacked) {
		        return stacked == other;
		      }
		      bitmask |= UNORDERED_COMPARE_FLAG;
		
		      // Recursively compare objects (susceptible to call stack limits).
		      stack.set(object, other);
		      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
		      stack['delete'](object);
		      return result;
		
		    case symbolTag:
		      if (symbolValueOf) {
		        return symbolValueOf.call(object) == symbolValueOf.call(other);
		      }
		  }
		  return false;
		}
		
		module.exports = equalByTag;
	
	
	/***/ },
	/* 331 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseHas = __webpack_require__(158),
		    keys = __webpack_require__(9);
		
		/** Used to compose bitmasks for comparison styles. */
		var PARTIAL_COMPARE_FLAG = 2;
		
		/**
		 * A specialized version of `baseIsEqualDeep` for objects with support for
		 * partial deep comparisons.
		 *
		 * @private
		 * @param {Object} object The object to compare.
		 * @param {Object} other The other object to compare.
		 * @param {Function} equalFunc The function to determine equivalents of values.
		 * @param {Function} customizer The function to customize comparisons.
		 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
		 *  for more details.
		 * @param {Object} stack Tracks traversed `object` and `other` objects.
		 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		 */
		function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
		  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
		      objProps = keys(object),
		      objLength = objProps.length,
		      othProps = keys(other),
		      othLength = othProps.length;
		
		  if (objLength != othLength && !isPartial) {
		    return false;
		  }
		  var index = objLength;
		  while (index--) {
		    var key = objProps[index];
		    if (!(isPartial ? key in other : baseHas(other, key))) {
		      return false;
		    }
		  }
		  // Assume cyclic values are equal.
		  var stacked = stack.get(object);
		  if (stacked && stack.get(other)) {
		    return stacked == other;
		  }
		  var result = true;
		  stack.set(object, other);
		  stack.set(other, object);
		
		  var skipCtor = isPartial;
		  while (++index < objLength) {
		    key = objProps[index];
		    var objValue = object[key],
		        othValue = other[key];
		
		    if (customizer) {
		      var compared = isPartial
		        ? customizer(othValue, objValue, key, other, object, stack)
		        : customizer(objValue, othValue, key, object, other, stack);
		    }
		    // Recursively compare objects (susceptible to call stack limits).
		    if (!(compared === undefined
		          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
		          : compared
		        )) {
		      result = false;
		      break;
		    }
		    skipCtor || (skipCtor = key == 'constructor');
		  }
		  if (result && !skipCtor) {
		    var objCtor = object.constructor,
		        othCtor = other.constructor;
		
		    // Non `Object` object instances with different constructors are not equal.
		    if (objCtor != othCtor &&
		        ('constructor' in object && 'constructor' in other) &&
		        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
		          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
		      result = false;
		    }
		  }
		  stack['delete'](object);
		  stack['delete'](other);
		  return result;
		}
		
		module.exports = equalObjects;
	
	
	/***/ },
	/* 332 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseGetAllKeys = __webpack_require__(157),
		    getSymbols = __webpack_require__(119),
		    keys = __webpack_require__(9);
		
		/**
		 * Creates an array of own enumerable property names and symbols of `object`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @returns {Array} Returns the array of property names and symbols.
		 */
		function getAllKeys(object) {
		  return baseGetAllKeys(object, keys, getSymbols);
		}
		
		module.exports = getAllKeys;
	
	
	/***/ },
	/* 333 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseGetAllKeys = __webpack_require__(157),
		    getSymbolsIn = __webpack_require__(336),
		    keysIn = __webpack_require__(173);
		
		/**
		 * Creates an array of own and inherited enumerable property names and
		 * symbols of `object`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @returns {Array} Returns the array of property names and symbols.
		 */
		function getAllKeysIn(object) {
		  return baseGetAllKeys(object, keysIn, getSymbolsIn);
		}
		
		module.exports = getAllKeysIn;
	
	
	/***/ },
	/* 334 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseProperty = __webpack_require__(114);
		
		/**
		 * Gets the "length" property value of `object`.
		 *
		 * **Note:** This function is used to avoid a
		 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
		 * Safari on at least iOS 8.1-8.3 ARM64.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @returns {*} Returns the "length" value.
		 */
		var getLength = baseProperty('length');
		
		module.exports = getLength;
	
	
	/***/ },
	/* 335 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isStrictComparable = __webpack_require__(167),
		    keys = __webpack_require__(9);
		
		/**
		 * Gets the property names, values, and compare flags of `object`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @returns {Array} Returns the match data of `object`.
		 */
		function getMatchData(object) {
		  var result = keys(object),
		      length = result.length;
		
		  while (length--) {
		    var key = result[length],
		        value = object[key];
		
		    result[length] = [key, value, isStrictComparable(value)];
		  }
		  return result;
		}
		
		module.exports = getMatchData;
	
	
	/***/ },
	/* 336 */
	/***/ function(module, exports, __webpack_require__) {
	
		var arrayPush = __webpack_require__(112),
		    getPrototype = __webpack_require__(118),
		    getSymbols = __webpack_require__(119),
		    stubArray = __webpack_require__(175);
		
		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeGetSymbols = Object.getOwnPropertySymbols;
		
		/**
		 * Creates an array of the own and inherited enumerable symbol properties
		 * of `object`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @returns {Array} Returns the array of symbols.
		 */
		var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
		  var result = [];
		  while (object) {
		    arrayPush(result, getSymbols(object));
		    object = getPrototype(object);
		  }
		  return result;
		};
		
		module.exports = getSymbolsIn;
	
	
	/***/ },
	/* 337 */
	/***/ function(module, exports) {
	
		/**
		 * Gets the value at `key` of `object`.
		 *
		 * @private
		 * @param {Object} [object] The object to query.
		 * @param {string} key The key of the property to get.
		 * @returns {*} Returns the property value.
		 */
		function getValue(object, key) {
		  return object == null ? undefined : object[key];
		}
		
		module.exports = getValue;
	
	
	/***/ },
	/* 338 */
	/***/ function(module, exports, __webpack_require__) {
	
		var castPath = __webpack_require__(115),
		    isArguments = __webpack_require__(124),
		    isArray = __webpack_require__(8),
		    isIndex = __webpack_require__(54),
		    isKey = __webpack_require__(55),
		    isLength = __webpack_require__(85),
		    isString = __webpack_require__(57),
		    toKey = __webpack_require__(40);
		
		/**
		 * Checks if `path` exists on `object`.
		 *
		 * @private
		 * @param {Object} object The object to query.
		 * @param {Array|string} path The path to check.
		 * @param {Function} hasFunc The function to check properties.
		 * @returns {boolean} Returns `true` if `path` exists, else `false`.
		 */
		function hasPath(object, path, hasFunc) {
		  path = isKey(path, object) ? [path] : castPath(path);
		
		  var result,
		      index = -1,
		      length = path.length;
		
		  while (++index < length) {
		    var key = toKey(path[index]);
		    if (!(result = object != null && hasFunc(object, key))) {
		      break;
		    }
		    object = object[key];
		  }
		  if (result) {
		    return result;
		  }
		  var length = object ? object.length : 0;
		  return !!length && isLength(length) && isIndex(key, length) &&
		    (isArray(object) || isString(object) || isArguments(object));
		}
		
		module.exports = hasPath;
	
	
	/***/ },
	/* 339 */
	/***/ function(module, exports, __webpack_require__) {
	
		var nativeCreate = __webpack_require__(82);
		
		/**
		 * Removes all key-value entries from the hash.
		 *
		 * @private
		 * @name clear
		 * @memberOf Hash
		 */
		function hashClear() {
		  this.__data__ = nativeCreate ? nativeCreate(null) : {};
		}
		
		module.exports = hashClear;
	
	
	/***/ },
	/* 340 */
	/***/ function(module, exports) {
	
		/**
		 * Removes `key` and its value from the hash.
		 *
		 * @private
		 * @name delete
		 * @memberOf Hash
		 * @param {Object} hash The hash to modify.
		 * @param {string} key The key of the value to remove.
		 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		 */
		function hashDelete(key) {
		  return this.has(key) && delete this.__data__[key];
		}
		
		module.exports = hashDelete;
	
	
	/***/ },
	/* 341 */
	/***/ function(module, exports, __webpack_require__) {
	
		var nativeCreate = __webpack_require__(82);
		
		/** Used to stand-in for `undefined` hash values. */
		var HASH_UNDEFINED = '__lodash_hash_undefined__';
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
		
		/**
		 * Gets the hash value for `key`.
		 *
		 * @private
		 * @name get
		 * @memberOf Hash
		 * @param {string} key The key of the value to get.
		 * @returns {*} Returns the entry value.
		 */
		function hashGet(key) {
		  var data = this.__data__;
		  if (nativeCreate) {
		    var result = data[key];
		    return result === HASH_UNDEFINED ? undefined : result;
		  }
		  return hasOwnProperty.call(data, key) ? data[key] : undefined;
		}
		
		module.exports = hashGet;
	
	
	/***/ },
	/* 342 */
	/***/ function(module, exports, __webpack_require__) {
	
		var nativeCreate = __webpack_require__(82);
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
		
		/**
		 * Checks if a hash value for `key` exists.
		 *
		 * @private
		 * @name has
		 * @memberOf Hash
		 * @param {string} key The key of the entry to check.
		 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		 */
		function hashHas(key) {
		  var data = this.__data__;
		  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
		}
		
		module.exports = hashHas;
	
	
	/***/ },
	/* 343 */
	/***/ function(module, exports, __webpack_require__) {
	
		var nativeCreate = __webpack_require__(82);
		
		/** Used to stand-in for `undefined` hash values. */
		var HASH_UNDEFINED = '__lodash_hash_undefined__';
		
		/**
		 * Sets the hash `key` to `value`.
		 *
		 * @private
		 * @name set
		 * @memberOf Hash
		 * @param {string} key The key of the value to set.
		 * @param {*} value The value to set.
		 * @returns {Object} Returns the hash instance.
		 */
		function hashSet(key, value) {
		  var data = this.__data__;
		  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
		  return this;
		}
		
		module.exports = hashSet;
	
	
	/***/ },
	/* 344 */
	/***/ function(module, exports) {
	
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
		
		/**
		 * Initializes an array clone.
		 *
		 * @private
		 * @param {Array} array The array to clone.
		 * @returns {Array} Returns the initialized clone.
		 */
		function initCloneArray(array) {
		  var length = array.length,
		      result = array.constructor(length);
		
		  // Add properties assigned by `RegExp#exec`.
		  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
		    result.index = array.index;
		    result.input = array.input;
		  }
		  return result;
		}
		
		module.exports = initCloneArray;
	
	
	/***/ },
	/* 345 */
	/***/ function(module, exports, __webpack_require__) {
	
		var cloneArrayBuffer = __webpack_require__(116),
		    cloneDataView = __webpack_require__(317),
		    cloneMap = __webpack_require__(318),
		    cloneRegExp = __webpack_require__(319),
		    cloneSet = __webpack_require__(320),
		    cloneSymbol = __webpack_require__(321),
		    cloneTypedArray = __webpack_require__(322);
		
		/** `Object#toString` result references. */
		var boolTag = '[object Boolean]',
		    dateTag = '[object Date]',
		    mapTag = '[object Map]',
		    numberTag = '[object Number]',
		    regexpTag = '[object RegExp]',
		    setTag = '[object Set]',
		    stringTag = '[object String]',
		    symbolTag = '[object Symbol]';
		
		var arrayBufferTag = '[object ArrayBuffer]',
		    dataViewTag = '[object DataView]',
		    float32Tag = '[object Float32Array]',
		    float64Tag = '[object Float64Array]',
		    int8Tag = '[object Int8Array]',
		    int16Tag = '[object Int16Array]',
		    int32Tag = '[object Int32Array]',
		    uint8Tag = '[object Uint8Array]',
		    uint8ClampedTag = '[object Uint8ClampedArray]',
		    uint16Tag = '[object Uint16Array]',
		    uint32Tag = '[object Uint32Array]';
		
		/**
		 * Initializes an object clone based on its `toStringTag`.
		 *
		 * **Note:** This function only supports cloning values with tags of
		 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
		 *
		 * @private
		 * @param {Object} object The object to clone.
		 * @param {string} tag The `toStringTag` of the object to clone.
		 * @param {Function} cloneFunc The function to clone values.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Object} Returns the initialized clone.
		 */
		function initCloneByTag(object, tag, cloneFunc, isDeep) {
		  var Ctor = object.constructor;
		  switch (tag) {
		    case arrayBufferTag:
		      return cloneArrayBuffer(object);
		
		    case boolTag:
		    case dateTag:
		      return new Ctor(+object);
		
		    case dataViewTag:
		      return cloneDataView(object, isDeep);
		
		    case float32Tag: case float64Tag:
		    case int8Tag: case int16Tag: case int32Tag:
		    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
		      return cloneTypedArray(object, isDeep);
		
		    case mapTag:
		      return cloneMap(object, isDeep, cloneFunc);
		
		    case numberTag:
		    case stringTag:
		      return new Ctor(object);
		
		    case regexpTag:
		      return cloneRegExp(object);
		
		    case setTag:
		      return cloneSet(object, isDeep, cloneFunc);
		
		    case symbolTag:
		      return cloneSymbol(object);
		  }
		}
		
		module.exports = initCloneByTag;
	
	
	/***/ },
	/* 346 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseCreate = __webpack_require__(286),
		    getPrototype = __webpack_require__(118),
		    isPrototype = __webpack_require__(81);
		
		/**
		 * Initializes an object clone.
		 *
		 * @private
		 * @param {Object} object The object to clone.
		 * @returns {Object} Returns the initialized clone.
		 */
		function initCloneObject(object) {
		  return (typeof object.constructor == 'function' && !isPrototype(object))
		    ? baseCreate(getPrototype(object))
		    : {};
		}
		
		module.exports = initCloneObject;
	
	
	/***/ },
	/* 347 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Symbol = __webpack_require__(74),
		    isArguments = __webpack_require__(124),
		    isArray = __webpack_require__(8);
		
		/** Built-in value references. */
		var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
		
		/**
		 * Checks if `value` is a flattenable `arguments` object or array.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
		 */
		function isFlattenable(value) {
		  return isArray(value) || isArguments(value) ||
		    !!(spreadableSymbol && value && value[spreadableSymbol]);
		}
		
		module.exports = isFlattenable;
	
	
	/***/ },
	/* 348 */
	/***/ function(module, exports, __webpack_require__) {
	
		var eq = __webpack_require__(56),
		    isArrayLike = __webpack_require__(21),
		    isIndex = __webpack_require__(54),
		    isObject = __webpack_require__(12);
		
		/**
		 * Checks if the given arguments are from an iteratee call.
		 *
		 * @private
		 * @param {*} value The potential iteratee value argument.
		 * @param {*} index The potential iteratee index or key argument.
		 * @param {*} object The potential iteratee object argument.
		 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
		 *  else `false`.
		 */
		function isIterateeCall(value, index, object) {
		  if (!isObject(object)) {
		    return false;
		  }
		  var type = typeof index;
		  if (type == 'number'
		        ? (isArrayLike(object) && isIndex(index, object.length))
		        : (type == 'string' && index in object)
		      ) {
		    return eq(object[index], value);
		  }
		  return false;
		}
		
		module.exports = isIterateeCall;
	
	
	/***/ },
	/* 349 */
	/***/ function(module, exports) {
	
		/**
		 * Checks if `value` is suitable for use as unique object key.
		 *
		 * @private
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
		 */
		function isKeyable(value) {
		  var type = typeof value;
		  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
		    ? (value !== '__proto__')
		    : (value === null);
		}
		
		module.exports = isKeyable;
	
	
	/***/ },
	/* 350 */
	/***/ function(module, exports, __webpack_require__) {
	
		var coreJsData = __webpack_require__(325);
		
		/** Used to detect methods masquerading as native. */
		var maskSrcKey = (function() {
		  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
		  return uid ? ('Symbol(src)_1.' + uid) : '';
		}());
		
		/**
		 * Checks if `func` has its source masked.
		 *
		 * @private
		 * @param {Function} func The function to check.
		 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
		 */
		function isMasked(func) {
		  return !!maskSrcKey && (maskSrcKey in func);
		}
		
		module.exports = isMasked;
	
	
	/***/ },
	/* 351 */
	/***/ function(module, exports) {
	
		/**
		 * Converts `iterator` to an array.
		 *
		 * @private
		 * @param {Object} iterator The iterator to convert.
		 * @returns {Array} Returns the converted array.
		 */
		function iteratorToArray(iterator) {
		  var data,
		      result = [];
		
		  while (!(data = iterator.next()).done) {
		    result.push(data.value);
		  }
		  return result;
		}
		
		module.exports = iteratorToArray;
	
	
	/***/ },
	/* 352 */
	/***/ function(module, exports) {
	
		/**
		 * Removes all key-value entries from the list cache.
		 *
		 * @private
		 * @name clear
		 * @memberOf ListCache
		 */
		function listCacheClear() {
		  this.__data__ = [];
		}
		
		module.exports = listCacheClear;
	
	
	/***/ },
	/* 353 */
	/***/ function(module, exports, __webpack_require__) {
	
		var assocIndexOf = __webpack_require__(76);
		
		/** Used for built-in method references. */
		var arrayProto = Array.prototype;
		
		/** Built-in value references. */
		var splice = arrayProto.splice;
		
		/**
		 * Removes `key` and its value from the list cache.
		 *
		 * @private
		 * @name delete
		 * @memberOf ListCache
		 * @param {string} key The key of the value to remove.
		 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		 */
		function listCacheDelete(key) {
		  var data = this.__data__,
		      index = assocIndexOf(data, key);
		
		  if (index < 0) {
		    return false;
		  }
		  var lastIndex = data.length - 1;
		  if (index == lastIndex) {
		    data.pop();
		  } else {
		    splice.call(data, index, 1);
		  }
		  return true;
		}
		
		module.exports = listCacheDelete;
	
	
	/***/ },
	/* 354 */
	/***/ function(module, exports, __webpack_require__) {
	
		var assocIndexOf = __webpack_require__(76);
		
		/**
		 * Gets the list cache value for `key`.
		 *
		 * @private
		 * @name get
		 * @memberOf ListCache
		 * @param {string} key The key of the value to get.
		 * @returns {*} Returns the entry value.
		 */
		function listCacheGet(key) {
		  var data = this.__data__,
		      index = assocIndexOf(data, key);
		
		  return index < 0 ? undefined : data[index][1];
		}
		
		module.exports = listCacheGet;
	
	
	/***/ },
	/* 355 */
	/***/ function(module, exports, __webpack_require__) {
	
		var assocIndexOf = __webpack_require__(76);
		
		/**
		 * Checks if a list cache value for `key` exists.
		 *
		 * @private
		 * @name has
		 * @memberOf ListCache
		 * @param {string} key The key of the entry to check.
		 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		 */
		function listCacheHas(key) {
		  return assocIndexOf(this.__data__, key) > -1;
		}
		
		module.exports = listCacheHas;
	
	
	/***/ },
	/* 356 */
	/***/ function(module, exports, __webpack_require__) {
	
		var assocIndexOf = __webpack_require__(76);
		
		/**
		 * Sets the list cache `key` to `value`.
		 *
		 * @private
		 * @name set
		 * @memberOf ListCache
		 * @param {string} key The key of the value to set.
		 * @param {*} value The value to set.
		 * @returns {Object} Returns the list cache instance.
		 */
		function listCacheSet(key, value) {
		  var data = this.__data__,
		      index = assocIndexOf(data, key);
		
		  if (index < 0) {
		    data.push([key, value]);
		  } else {
		    data[index][1] = value;
		  }
		  return this;
		}
		
		module.exports = listCacheSet;
	
	
	/***/ },
	/* 357 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Hash = __webpack_require__(271),
		    ListCache = __webpack_require__(73),
		    Map = __webpack_require__(109);
		
		/**
		 * Removes all key-value entries from the map.
		 *
		 * @private
		 * @name clear
		 * @memberOf MapCache
		 */
		function mapCacheClear() {
		  this.__data__ = {
		    'hash': new Hash,
		    'map': new (Map || ListCache),
		    'string': new Hash
		  };
		}
		
		module.exports = mapCacheClear;
	
	
	/***/ },
	/* 358 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getMapData = __webpack_require__(80);
		
		/**
		 * Removes `key` and its value from the map.
		 *
		 * @private
		 * @name delete
		 * @memberOf MapCache
		 * @param {string} key The key of the value to remove.
		 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		 */
		function mapCacheDelete(key) {
		  return getMapData(this, key)['delete'](key);
		}
		
		module.exports = mapCacheDelete;
	
	
	/***/ },
	/* 359 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getMapData = __webpack_require__(80);
		
		/**
		 * Gets the map value for `key`.
		 *
		 * @private
		 * @name get
		 * @memberOf MapCache
		 * @param {string} key The key of the value to get.
		 * @returns {*} Returns the entry value.
		 */
		function mapCacheGet(key) {
		  return getMapData(this, key).get(key);
		}
		
		module.exports = mapCacheGet;
	
	
	/***/ },
	/* 360 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getMapData = __webpack_require__(80);
		
		/**
		 * Checks if a map value for `key` exists.
		 *
		 * @private
		 * @name has
		 * @memberOf MapCache
		 * @param {string} key The key of the entry to check.
		 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		 */
		function mapCacheHas(key) {
		  return getMapData(this, key).has(key);
		}
		
		module.exports = mapCacheHas;
	
	
	/***/ },
	/* 361 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getMapData = __webpack_require__(80);
		
		/**
		 * Sets the map `key` to `value`.
		 *
		 * @private
		 * @name set
		 * @memberOf MapCache
		 * @param {string} key The key of the value to set.
		 * @param {*} value The value to set.
		 * @returns {Object} Returns the map cache instance.
		 */
		function mapCacheSet(key, value) {
		  getMapData(this, key).set(key, value);
		  return this;
		}
		
		module.exports = mapCacheSet;
	
	
	/***/ },
	/* 362 */
	/***/ function(module, exports) {
	
		/** Used to compose unicode character classes. */
		var rsAstralRange = '\\ud800-\\udfff',
		    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
		    rsComboSymbolsRange = '\\u20d0-\\u20f0',
		    rsVarRange = '\\ufe0e\\ufe0f';
		
		/** Used to compose unicode capture groups. */
		var rsZWJ = '\\u200d';
		
		/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
		var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
		
		module.exports = reHasComplexSymbol;
	
	
	/***/ },
	/* 363 */
	/***/ function(module, exports) {
	
		/** Used to stand-in for `undefined` hash values. */
		var HASH_UNDEFINED = '__lodash_hash_undefined__';
		
		/**
		 * Adds `value` to the array cache.
		 *
		 * @private
		 * @name add
		 * @memberOf SetCache
		 * @alias push
		 * @param {*} value The value to cache.
		 * @returns {Object} Returns the cache instance.
		 */
		function setCacheAdd(value) {
		  this.__data__.set(value, HASH_UNDEFINED);
		  return this;
		}
		
		module.exports = setCacheAdd;
	
	
	/***/ },
	/* 364 */
	/***/ function(module, exports) {
	
		/**
		 * Checks if `value` is in the array cache.
		 *
		 * @private
		 * @name has
		 * @memberOf SetCache
		 * @param {*} value The value to search for.
		 * @returns {number} Returns `true` if `value` is found, else `false`.
		 */
		function setCacheHas(value) {
		  return this.__data__.has(value);
		}
		
		module.exports = setCacheHas;
	
	
	/***/ },
	/* 365 */
	/***/ function(module, exports) {
	
		/**
		 * Converts `set` to its value-value pairs.
		 *
		 * @private
		 * @param {Object} set The set to convert.
		 * @returns {Array} Returns the value-value pairs.
		 */
		function setToPairs(set) {
		  var index = -1,
		      result = Array(set.size);
		
		  set.forEach(function(value) {
		    result[++index] = [value, value];
		  });
		  return result;
		}
		
		module.exports = setToPairs;
	
	
	/***/ },
	/* 366 */
	/***/ function(module, exports, __webpack_require__) {
	
		var ListCache = __webpack_require__(73);
		
		/**
		 * Removes all key-value entries from the stack.
		 *
		 * @private
		 * @name clear
		 * @memberOf Stack
		 */
		function stackClear() {
		  this.__data__ = new ListCache;
		}
		
		module.exports = stackClear;
	
	
	/***/ },
	/* 367 */
	/***/ function(module, exports) {
	
		/**
		 * Removes `key` and its value from the stack.
		 *
		 * @private
		 * @name delete
		 * @memberOf Stack
		 * @param {string} key The key of the value to remove.
		 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		 */
		function stackDelete(key) {
		  return this.__data__['delete'](key);
		}
		
		module.exports = stackDelete;
	
	
	/***/ },
	/* 368 */
	/***/ function(module, exports) {
	
		/**
		 * Gets the stack value for `key`.
		 *
		 * @private
		 * @name get
		 * @memberOf Stack
		 * @param {string} key The key of the value to get.
		 * @returns {*} Returns the entry value.
		 */
		function stackGet(key) {
		  return this.__data__.get(key);
		}
		
		module.exports = stackGet;
	
	
	/***/ },
	/* 369 */
	/***/ function(module, exports) {
	
		/**
		 * Checks if a stack value for `key` exists.
		 *
		 * @private
		 * @name has
		 * @memberOf Stack
		 * @param {string} key The key of the entry to check.
		 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		 */
		function stackHas(key) {
		  return this.__data__.has(key);
		}
		
		module.exports = stackHas;
	
	
	/***/ },
	/* 370 */
	/***/ function(module, exports, __webpack_require__) {
	
		var ListCache = __webpack_require__(73),
		    Map = __webpack_require__(109),
		    MapCache = __webpack_require__(110);
		
		/** Used as the size to enable large array optimizations. */
		var LARGE_ARRAY_SIZE = 200;
		
		/**
		 * Sets the stack `key` to `value`.
		 *
		 * @private
		 * @name set
		 * @memberOf Stack
		 * @param {string} key The key of the value to set.
		 * @param {*} value The value to set.
		 * @returns {Object} Returns the stack cache instance.
		 */
		function stackSet(key, value) {
		  var cache = this.__data__;
		  if (cache instanceof ListCache) {
		    var pairs = cache.__data__;
		    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
		      pairs.push([key, value]);
		      return this;
		    }
		    cache = this.__data__ = new MapCache(pairs);
		  }
		  cache.set(key, value);
		  return this;
		}
		
		module.exports = stackSet;
	
	
	/***/ },
	/* 371 */
	/***/ function(module, exports, __webpack_require__) {
	
		var reHasComplexSymbol = __webpack_require__(362);
		
		/** Used to compose unicode character classes. */
		var rsAstralRange = '\\ud800-\\udfff',
		    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
		    rsComboSymbolsRange = '\\u20d0-\\u20f0',
		    rsVarRange = '\\ufe0e\\ufe0f';
		
		/** Used to compose unicode capture groups. */
		var rsAstral = '[' + rsAstralRange + ']',
		    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
		    rsFitz = '\\ud83c[\\udffb-\\udfff]',
		    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
		    rsNonAstral = '[^' + rsAstralRange + ']',
		    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
		    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
		    rsZWJ = '\\u200d';
		
		/** Used to compose unicode regexes. */
		var reOptMod = rsModifier + '?',
		    rsOptVar = '[' + rsVarRange + ']?',
		    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
		    rsSeq = rsOptVar + reOptMod + rsOptJoin,
		    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
		
		/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
		var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
		
		/**
		 * Gets the number of symbols in `string`.
		 *
		 * @private
		 * @param {string} string The string to inspect.
		 * @returns {number} Returns the string size.
		 */
		function stringSize(string) {
		  if (!(string && reHasComplexSymbol.test(string))) {
		    return string.length;
		  }
		  var result = reComplexSymbol.lastIndex = 0;
		  while (reComplexSymbol.test(string)) {
		    result++;
		  }
		  return result;
		}
		
		module.exports = stringSize;
	
	
	/***/ },
	/* 372 */
	/***/ function(module, exports) {
	
		/** Used to compose unicode character classes. */
		var rsAstralRange = '\\ud800-\\udfff',
		    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
		    rsComboSymbolsRange = '\\u20d0-\\u20f0',
		    rsVarRange = '\\ufe0e\\ufe0f';
		
		/** Used to compose unicode capture groups. */
		var rsAstral = '[' + rsAstralRange + ']',
		    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
		    rsFitz = '\\ud83c[\\udffb-\\udfff]',
		    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
		    rsNonAstral = '[^' + rsAstralRange + ']',
		    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
		    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
		    rsZWJ = '\\u200d';
		
		/** Used to compose unicode regexes. */
		var reOptMod = rsModifier + '?',
		    rsOptVar = '[' + rsVarRange + ']?',
		    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
		    rsSeq = rsOptVar + reOptMod + rsOptJoin,
		    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
		
		/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
		var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
		
		/**
		 * Converts `string` to an array.
		 *
		 * @private
		 * @param {string} string The string to convert.
		 * @returns {Array} Returns the converted array.
		 */
		function stringToArray(string) {
		  return string.match(reComplexSymbol);
		}
		
		module.exports = stringToArray;
	
	
	/***/ },
	/* 373 */
	/***/ function(module, exports, __webpack_require__) {
	
		var memoize = __webpack_require__(174),
		    toString = __webpack_require__(86);
		
		/** Used to match property names within property paths. */
		var reLeadingDot = /^\./,
		    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
		
		/** Used to match backslashes in property paths. */
		var reEscapeChar = /\\(\\)?/g;
		
		/**
		 * Converts `string` to a property path array.
		 *
		 * @private
		 * @param {string} string The string to convert.
		 * @returns {Array} Returns the property path array.
		 */
		var stringToPath = memoize(function(string) {
		  string = toString(string);
		
		  var result = [];
		  if (reLeadingDot.test(string)) {
		    result.push('');
		  }
		  string.replace(rePropName, function(match, number, quote, string) {
		    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
		  });
		  return result;
		});
		
		module.exports = stringToPath;
	
	
	/***/ },
	/* 374 */
	/***/ function(module, exports, __webpack_require__) {
	
		var assignValue = __webpack_require__(75),
		    copyObject = __webpack_require__(52),
		    createAssigner = __webpack_require__(117),
		    isArrayLike = __webpack_require__(21),
		    isPrototype = __webpack_require__(81),
		    keys = __webpack_require__(9);
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/** Used to check objects for own properties. */
		var hasOwnProperty = objectProto.hasOwnProperty;
		
		/** Built-in value references. */
		var propertyIsEnumerable = objectProto.propertyIsEnumerable;
		
		/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
		var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');
		
		/**
		 * Assigns own enumerable string keyed properties of source objects to the
		 * destination object. Source objects are applied from left to right.
		 * Subsequent sources overwrite property assignments of previous sources.
		 *
		 * **Note:** This method mutates `object` and is loosely based on
		 * [`Object.assign`](https://mdn.io/Object/assign).
		 *
		 * @static
		 * @memberOf _
		 * @since 0.10.0
		 * @category Object
		 * @param {Object} object The destination object.
		 * @param {...Object} [sources] The source objects.
		 * @returns {Object} Returns `object`.
		 * @see _.assignIn
		 * @example
		 *
		 * function Foo() {
		 *   this.a = 1;
		 * }
		 *
		 * function Bar() {
		 *   this.c = 3;
		 * }
		 *
		 * Foo.prototype.b = 2;
		 * Bar.prototype.d = 4;
		 *
		 * _.assign({ 'a': 0 }, new Foo, new Bar);
		 * // => { 'a': 1, 'c': 3 }
		 */
		var assign = createAssigner(function(object, source) {
		  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
		    copyObject(source, keys(source), object);
		    return;
		  }
		  for (var key in source) {
		    if (hasOwnProperty.call(source, key)) {
		      assignValue(object, key, source[key]);
		    }
		  }
		});
		
		module.exports = assign;
	
	
	/***/ },
	/* 375 */
	/***/ function(module, exports, __webpack_require__) {
	
		var copyObject = __webpack_require__(52),
		    createAssigner = __webpack_require__(117),
		    keysIn = __webpack_require__(173);
		
		/**
		 * This method is like `_.assignIn` except that it accepts `customizer`
		 * which is invoked to produce the assigned values. If `customizer` returns
		 * `undefined`, assignment is handled by the method instead. The `customizer`
		 * is invoked with five arguments: (objValue, srcValue, key, object, source).
		 *
		 * **Note:** This method mutates `object`.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @alias extendWith
		 * @category Object
		 * @param {Object} object The destination object.
		 * @param {...Object} sources The source objects.
		 * @param {Function} [customizer] The function to customize assigned values.
		 * @returns {Object} Returns `object`.
		 * @see _.assignWith
		 * @example
		 *
		 * function customizer(objValue, srcValue) {
		 *   return _.isUndefined(objValue) ? srcValue : objValue;
		 * }
		 *
		 * var defaults = _.partialRight(_.assignInWith, customizer);
		 *
		 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		 * // => { 'a': 1, 'b': 2 }
		 */
		var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
		  copyObject(source, keysIn(source), object, customizer);
		});
		
		module.exports = assignInWith;
	
	
	/***/ },
	/* 376 */
	/***/ function(module, exports, __webpack_require__) {
	
		var copyObject = __webpack_require__(52),
		    createAssigner = __webpack_require__(117),
		    keys = __webpack_require__(9);
		
		/**
		 * This method is like `_.assign` except that it accepts `customizer`
		 * which is invoked to produce the assigned values. If `customizer` returns
		 * `undefined`, assignment is handled by the method instead. The `customizer`
		 * is invoked with five arguments: (objValue, srcValue, key, object, source).
		 *
		 * **Note:** This method mutates `object`.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Object
		 * @param {Object} object The destination object.
		 * @param {...Object} sources The source objects.
		 * @param {Function} [customizer] The function to customize assigned values.
		 * @returns {Object} Returns `object`.
		 * @see _.assignInWith
		 * @example
		 *
		 * function customizer(objValue, srcValue) {
		 *   return _.isUndefined(objValue) ? srcValue : objValue;
		 * }
		 *
		 * var defaults = _.partialRight(_.assignWith, customizer);
		 *
		 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		 * // => { 'a': 1, 'b': 2 }
		 */
		var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
		  copyObject(source, keys(source), object, customizer);
		});
		
		module.exports = assignWith;
	
	
	/***/ },
	/* 377 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseAt = __webpack_require__(284),
		    baseFlatten = __webpack_require__(77),
		    baseRest = __webpack_require__(38);
		
		/**
		 * Creates an array of values corresponding to `paths` of `object`.
		 *
		 * @static
		 * @memberOf _
		 * @since 1.0.0
		 * @category Object
		 * @param {Object} object The object to iterate over.
		 * @param {...(string|string[])} [paths] The property paths of elements to pick.
		 * @returns {Array} Returns the picked values.
		 * @example
		 *
		 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		 *
		 * _.at(object, ['a[0].b.c', 'a[1]']);
		 * // => [3, 4]
		 */
		var at = baseRest(function(object, paths) {
		  return baseAt(object, baseFlatten(paths, 1));
		});
		
		module.exports = at;
	
	
	/***/ },
	/* 378 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseClone = __webpack_require__(285);
		
		/**
		 * This method is like `_.clone` except that it recursively clones `value`.
		 *
		 * @static
		 * @memberOf _
		 * @since 1.0.0
		 * @category Lang
		 * @param {*} value The value to recursively clone.
		 * @returns {*} Returns the deep cloned value.
		 * @see _.clone
		 * @example
		 *
		 * var objects = [{ 'a': 1 }, { 'b': 2 }];
		 *
		 * var deep = _.cloneDeep(objects);
		 * console.log(deep[0] === objects[0]);
		 * // => false
		 */
		function cloneDeep(value) {
		  return baseClone(value, true, true);
		}
		
		module.exports = cloneDeep;
	
	
	/***/ },
	/* 379 */
	/***/ function(module, exports, __webpack_require__) {
	
		var apply = __webpack_require__(153),
		    assignInDefaults = __webpack_require__(282),
		    assignInWith = __webpack_require__(375),
		    baseRest = __webpack_require__(38);
		
		/**
		 * Assigns own and inherited enumerable string keyed properties of source
		 * objects to the destination object for all destination properties that
		 * resolve to `undefined`. Source objects are applied from left to right.
		 * Once a property is set, additional values of the same property are ignored.
		 *
		 * **Note:** This method mutates `object`.
		 *
		 * @static
		 * @since 0.1.0
		 * @memberOf _
		 * @category Object
		 * @param {Object} object The destination object.
		 * @param {...Object} [sources] The source objects.
		 * @returns {Object} Returns `object`.
		 * @see _.defaultsDeep
		 * @example
		 *
		 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		 * // => { 'a': 1, 'b': 2 }
		 */
		var defaults = baseRest(function(args) {
		  args.push(undefined, assignInDefaults);
		  return apply(assignInWith, undefined, args);
		});
		
		module.exports = defaults;
	
	
	/***/ },
	/* 380 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = __webpack_require__(407);
	
	
	/***/ },
	/* 381 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseFlatten = __webpack_require__(77);
		
		/**
		 * Flattens `array` a single level deep.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Array
		 * @param {Array} array The array to flatten.
		 * @returns {Array} Returns the new flattened array.
		 * @example
		 *
		 * _.flatten([1, [2, [3, [4]], 5]]);
		 * // => [1, 2, [3, [4]], 5]
		 */
		function flatten(array) {
		  var length = array ? array.length : 0;
		  return length ? baseFlatten(array, 1) : [];
		}
		
		module.exports = flatten;
	
	
	/***/ },
	/* 382 */
	/***/ function(module, exports) {
	
		/**
		 * The inverse of `_.toPairs`; this method returns an object composed
		 * from key-value `pairs`.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Array
		 * @param {Array} pairs The key-value pairs.
		 * @returns {Object} Returns the new object.
		 * @example
		 *
		 * _.fromPairs([['a', 1], ['b', 2]]);
		 * // => { 'a': 1, 'b': 2 }
		 */
		function fromPairs(pairs) {
		  var index = -1,
		      length = pairs ? pairs.length : 0,
		      result = {};
		
		  while (++index < length) {
		    var pair = pairs[index];
		    result[pair[0]] = pair[1];
		  }
		  return result;
		}
		
		module.exports = fromPairs;
	
	
	/***/ },
	/* 383 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseHasIn = __webpack_require__(293),
		    hasPath = __webpack_require__(338);
		
		/**
		 * Checks if `path` is a direct or inherited property of `object`.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Object
		 * @param {Object} object The object to query.
		 * @param {Array|string} path The path to check.
		 * @returns {boolean} Returns `true` if `path` exists, else `false`.
		 * @example
		 *
		 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
		 *
		 * _.hasIn(object, 'a');
		 * // => true
		 *
		 * _.hasIn(object, 'a.b');
		 * // => true
		 *
		 * _.hasIn(object, ['a', 'b']);
		 * // => true
		 *
		 * _.hasIn(object, 'b');
		 * // => false
		 */
		function hasIn(object, path) {
		  return object != null && hasPath(object, path, baseHasIn);
		}
		
		module.exports = hasIn;
	
	
	/***/ },
	/* 384 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseInRange = __webpack_require__(294),
		    toFinite = __webpack_require__(176),
		    toNumber = __webpack_require__(178);
		
		/**
		 * Checks if `n` is between `start` and up to, but not including, `end`. If
		 * `end` is not specified, it's set to `start` with `start` then set to `0`.
		 * If `start` is greater than `end` the params are swapped to support
		 * negative ranges.
		 *
		 * @static
		 * @memberOf _
		 * @since 3.3.0
		 * @category Number
		 * @param {number} number The number to check.
		 * @param {number} [start=0] The start of the range.
		 * @param {number} end The end of the range.
		 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		 * @see _.range, _.rangeRight
		 * @example
		 *
		 * _.inRange(3, 2, 4);
		 * // => true
		 *
		 * _.inRange(4, 8);
		 * // => true
		 *
		 * _.inRange(4, 2);
		 * // => false
		 *
		 * _.inRange(2, 2);
		 * // => false
		 *
		 * _.inRange(1.2, 2);
		 * // => true
		 *
		 * _.inRange(5.2, 4);
		 * // => false
		 *
		 * _.inRange(-3, -2, -6);
		 * // => true
		 */
		function inRange(number, start, end) {
		  start = toFinite(start);
		  if (end === undefined) {
		    end = start;
		    start = 0;
		  } else {
		    end = toFinite(end);
		  }
		  number = toNumber(number);
		  return baseInRange(number, start, end);
		}
		
		module.exports = inRange;
	
	
	/***/ },
	/* 385 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIndexOf = __webpack_require__(78),
		    isArrayLike = __webpack_require__(21),
		    isString = __webpack_require__(57),
		    toInteger = __webpack_require__(177),
		    values = __webpack_require__(180);
		
		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeMax = Math.max;
		
		/**
		 * Checks if `value` is in `collection`. If `collection` is a string, it's
		 * checked for a substring of `value`, otherwise
		 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		 * is used for equality comparisons. If `fromIndex` is negative, it's used as
		 * the offset from the end of `collection`.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Collection
		 * @param {Array|Object|string} collection The collection to search.
		 * @param {*} value The value to search for.
		 * @param {number} [fromIndex=0] The index to search from.
		 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		 * @returns {boolean} Returns `true` if `value` is found, else `false`.
		 * @example
		 *
		 * _.includes([1, 2, 3], 1);
		 * // => true
		 *
		 * _.includes([1, 2, 3], 1, 2);
		 * // => false
		 *
		 * _.includes({ 'a': 1, 'b': 2 }, 1);
		 * // => true
		 *
		 * _.includes('abcd', 'bc');
		 * // => true
		 */
		function includes(collection, value, fromIndex, guard) {
		  collection = isArrayLike(collection) ? collection : values(collection);
		  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
		
		  var length = collection.length;
		  if (fromIndex < 0) {
		    fromIndex = nativeMax(length + fromIndex, 0);
		  }
		  return isString(collection)
		    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
		    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
		}
		
		module.exports = includes;
	
	
	/***/ },
	/* 386 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(11),
		    stubFalse = __webpack_require__(406);
		
		/** Detect free variable `exports`. */
		var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
		
		/** Detect free variable `module`. */
		var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
		
		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;
		
		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined;
		
		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
		
		/**
		 * Checks if `value` is a buffer.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		 * @example
		 *
		 * _.isBuffer(new Buffer(2));
		 * // => true
		 *
		 * _.isBuffer(new Uint8Array(2));
		 * // => false
		 */
		var isBuffer = nativeIsBuffer || stubFalse;
		
		module.exports = isBuffer;
		
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(132)(module)))
	
	/***/ },
	/* 387 */
	/***/ function(module, exports, __webpack_require__) {
	
		var toInteger = __webpack_require__(177);
		
		/**
		 * Checks if `value` is an integer.
		 *
		 * **Note:** This method is based on
		 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
		 * @example
		 *
		 * _.isInteger(3);
		 * // => true
		 *
		 * _.isInteger(Number.MIN_VALUE);
		 * // => false
		 *
		 * _.isInteger(Infinity);
		 * // => false
		 *
		 * _.isInteger('3');
		 * // => false
		 */
		function isInteger(value) {
		  return typeof value == 'number' && value == toInteger(value);
		}
		
		module.exports = isInteger;
	
	
	/***/ },
	/* 388 */
	/***/ function(module, exports) {
	
		/**
		 * Checks if `value` is `null`.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
		 * @example
		 *
		 * _.isNull(null);
		 * // => true
		 *
		 * _.isNull(void 0);
		 * // => false
		 */
		function isNull(value) {
		  return value === null;
		}
		
		module.exports = isNull;
	
	
	/***/ },
	/* 389 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isObjectLike = __webpack_require__(18);
		
		/** `Object#toString` result references. */
		var numberTag = '[object Number]';
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
		
		/**
		 * Checks if `value` is classified as a `Number` primitive or object.
		 *
		 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
		 * classified as numbers, use the `_.isFinite` method.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
		 * @example
		 *
		 * _.isNumber(3);
		 * // => true
		 *
		 * _.isNumber(Number.MIN_VALUE);
		 * // => true
		 *
		 * _.isNumber(Infinity);
		 * // => true
		 *
		 * _.isNumber('3');
		 * // => false
		 */
		function isNumber(value) {
		  return typeof value == 'number' ||
		    (isObjectLike(value) && objectToString.call(value) == numberTag);
		}
		
		module.exports = isNumber;
	
	
	/***/ },
	/* 390 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIsSet = __webpack_require__(299),
		    baseUnary = __webpack_require__(162),
		    nodeUtil = __webpack_require__(169);
		
		/* Node.js helper references. */
		var nodeIsSet = nodeUtil && nodeUtil.isSet;
		
		/**
		 * Checks if `value` is classified as a `Set` object.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		 * @example
		 *
		 * _.isSet(new Set);
		 * // => true
		 *
		 * _.isSet(new WeakSet);
		 * // => false
		 */
		var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
		
		module.exports = isSet;
	
	
	/***/ },
	/* 391 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIsTypedArray = __webpack_require__(300),
		    baseUnary = __webpack_require__(162),
		    nodeUtil = __webpack_require__(169);
		
		/* Node.js helper references. */
		var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
		
		/**
		 * Checks if `value` is classified as a typed array.
		 *
		 * @static
		 * @memberOf _
		 * @since 3.0.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		 * @example
		 *
		 * _.isTypedArray(new Uint8Array);
		 * // => true
		 *
		 * _.isTypedArray([]);
		 * // => false
		 */
		var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
		
		module.exports = isTypedArray;
	
	
	/***/ },
	/* 392 */
	/***/ function(module, exports) {
	
		/**
		 * Checks if `value` is `undefined`.
		 *
		 * @static
		 * @since 0.1.0
		 * @memberOf _
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
		 * @example
		 *
		 * _.isUndefined(void 0);
		 * // => true
		 *
		 * _.isUndefined(null);
		 * // => false
		 */
		function isUndefined(value) {
		  return value === undefined;
		}
		
		module.exports = isUndefined;
	
	
	/***/ },
	/* 393 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isObjectLike = __webpack_require__(18);
		
		/** `Object#toString` result references. */
		var weakSetTag = '[object WeakSet]';
		
		/** Used for built-in method references. */
		var objectProto = Object.prototype;
		
		/**
		 * Used to resolve the
		 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
		 * of values.
		 */
		var objectToString = objectProto.toString;
		
		/**
		 * Checks if `value` is classified as a `WeakSet` object.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
		 * @example
		 *
		 * _.isWeakSet(new WeakSet);
		 * // => true
		 *
		 * _.isWeakSet(new Set);
		 * // => false
		 */
		function isWeakSet(value) {
		  return isObjectLike(value) && objectToString.call(value) == weakSetTag;
		}
		
		module.exports = isWeakSet;
	
	
	/***/ },
	/* 394 */
	/***/ function(module, exports, __webpack_require__) {
	
		var arrayMap = __webpack_require__(51),
		    baseIteratee = __webpack_require__(79),
		    baseMap = __webpack_require__(303),
		    isArray = __webpack_require__(8);
		
		/**
		 * Creates an array of values by running each element in `collection` thru
		 * `iteratee`. The iteratee is invoked with three arguments:
		 * (value, index|key, collection).
		 *
		 * Many lodash methods are guarded to work as iteratees for methods like
		 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
		 *
		 * The guarded methods are:
		 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
		 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
		 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
		 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Collection
		 * @param {Array|Object} collection The collection to iterate over.
		 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		 * @returns {Array} Returns the new mapped array.
		 * @example
		 *
		 * function square(n) {
		 *   return n * n;
		 * }
		 *
		 * _.map([4, 8], square);
		 * // => [16, 64]
		 *
		 * _.map({ 'a': 4, 'b': 8 }, square);
		 * // => [16, 64] (iteration order is not guaranteed)
		 *
		 * var users = [
		 *   { 'user': 'barney' },
		 *   { 'user': 'fred' }
		 * ];
		 *
		 * // The `_.property` iteratee shorthand.
		 * _.map(users, 'user');
		 * // => ['barney', 'fred']
		 */
		function map(collection, iteratee) {
		  var func = isArray(collection) ? arrayMap : baseMap;
		  return func(collection, baseIteratee(iteratee, 3));
		}
		
		module.exports = map;
	
	
	/***/ },
	/* 395 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseForOwn = __webpack_require__(155),
		    baseIteratee = __webpack_require__(79);
		
		/**
		 * Creates an object with the same keys as `object` and values generated
		 * by running each own enumerable string keyed property of `object` thru
		 * `iteratee`. The iteratee is invoked with three arguments:
		 * (value, key, object).
		 *
		 * @static
		 * @memberOf _
		 * @since 2.4.0
		 * @category Object
		 * @param {Object} object The object to iterate over.
		 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		 * @returns {Object} Returns the new mapped object.
		 * @see _.mapKeys
		 * @example
		 *
		 * var users = {
		 *   'fred':    { 'user': 'fred',    'age': 40 },
		 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
		 * };
		 *
		 * _.mapValues(users, function(o) { return o.age; });
		 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		 *
		 * // The `_.property` iteratee shorthand.
		 * _.mapValues(users, 'age');
		 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		 */
		function mapValues(object, iteratee) {
		  var result = {};
		  iteratee = baseIteratee(iteratee, 3);
		
		  baseForOwn(object, function(value, key, object) {
		    result[key] = iteratee(value, key, object);
		  });
		  return result;
		}
		
		module.exports = mapValues;
	
	
	/***/ },
	/* 396 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseExtremum = __webpack_require__(288),
		    baseGt = __webpack_require__(292),
		    identity = __webpack_require__(171);
		
		/**
		 * Computes the maximum value of `array`. If `array` is empty or falsey,
		 * `undefined` is returned.
		 *
		 * @static
		 * @since 0.1.0
		 * @memberOf _
		 * @category Math
		 * @param {Array} array The array to iterate over.
		 * @returns {*} Returns the maximum value.
		 * @example
		 *
		 * _.max([4, 2, 8, 6]);
		 * // => 8
		 *
		 * _.max([]);
		 * // => undefined
		 */
		function max(array) {
		  return (array && array.length)
		    ? baseExtremum(array, identity, baseGt)
		    : undefined;
		}
		
		module.exports = max;
	
	
	/***/ },
	/* 397 */
	/***/ function(module, exports) {
	
		/** Used as the `TypeError` message for "Functions" methods. */
		var FUNC_ERROR_TEXT = 'Expected a function';
		
		/**
		 * Creates a function that negates the result of the predicate `func`. The
		 * `func` predicate is invoked with the `this` binding and arguments of the
		 * created function.
		 *
		 * @static
		 * @memberOf _
		 * @since 3.0.0
		 * @category Function
		 * @param {Function} predicate The predicate to negate.
		 * @returns {Function} Returns the new negated function.
		 * @example
		 *
		 * function isEven(n) {
		 *   return n % 2 == 0;
		 * }
		 *
		 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
		 * // => [1, 3, 5]
		 */
		function negate(predicate) {
		  if (typeof predicate != 'function') {
		    throw new TypeError(FUNC_ERROR_TEXT);
		  }
		  return function() {
		    var args = arguments;
		    switch (args.length) {
		      case 0: return !predicate.call(this);
		      case 1: return !predicate.call(this, args[0]);
		      case 2: return !predicate.call(this, args[0], args[1]);
		      case 3: return !predicate.call(this, args[0], args[1], args[2]);
		    }
		    return !predicate.apply(this, args);
		  };
		}
		
		module.exports = negate;
	
	
	/***/ },
	/* 398 */
	/***/ function(module, exports) {
	
		/**
		 * This method returns `undefined`.
		 *
		 * @static
		 * @memberOf _
		 * @since 2.3.0
		 * @category Util
		 * @example
		 *
		 * _.times(2, _.noop);
		 * // => [undefined, undefined]
		 */
		function noop() {
		  // No operation performed.
		}
		
		module.exports = noop;
	
	
	/***/ },
	/* 399 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIteratee = __webpack_require__(79),
		    negate = __webpack_require__(397),
		    pickBy = __webpack_require__(402);
		
		/**
		 * The opposite of `_.pickBy`; this method creates an object composed of
		 * the own and inherited enumerable string keyed properties of `object` that
		 * `predicate` doesn't return truthy for. The predicate is invoked with two
		 * arguments: (value, key).
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Object
		 * @param {Object} object The source object.
		 * @param {Function} [predicate=_.identity] The function invoked per property.
		 * @returns {Object} Returns the new object.
		 * @example
		 *
		 * var object = { 'a': 1, 'b': '2', 'c': 3 };
		 *
		 * _.omitBy(object, _.isNumber);
		 * // => { 'b': '2' }
		 */
		function omitBy(object, predicate) {
		  return pickBy(object, negate(baseIteratee(predicate)));
		}
		
		module.exports = omitBy;
	
	
	/***/ },
	/* 400 */
	/***/ function(module, exports, __webpack_require__) {
	
		var root = __webpack_require__(11),
		    toString = __webpack_require__(86);
		
		/** Used to match leading and trailing whitespace. */
		var reTrim = /^\s+|\s+$/g;
		
		/** Used to detect hexadecimal string values. */
		var reHasHexPrefix = /^0x/i;
		
		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeParseInt = root.parseInt;
		
		/**
		 * Converts `string` to an integer of the specified radix. If `radix` is
		 * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
		 * hexadecimal, in which case a `radix` of `16` is used.
		 *
		 * **Note:** This method aligns with the
		 * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
		 *
		 * @static
		 * @memberOf _
		 * @since 1.1.0
		 * @category String
		 * @param {string} string The string to convert.
		 * @param {number} [radix=10] The radix to interpret `value` by.
		 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		 * @returns {number} Returns the converted integer.
		 * @example
		 *
		 * _.parseInt('08');
		 * // => 8
		 *
		 * _.map(['6', '08', '10'], _.parseInt);
		 * // => [6, 8, 10]
		 */
		function parseInt(string, radix, guard) {
		  // Chrome fails to trim leading <BOM> whitespace characters.
		  // See https://bugs.chromium.org/p/v8/issues/detail?id=3109 for more details.
		  if (guard || radix == null) {
		    radix = 0;
		  } else if (radix) {
		    radix = +radix;
		  }
		  string = toString(string).replace(reTrim, '');
		  return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
		}
		
		module.exports = parseInt;
	
	
	/***/ },
	/* 401 */
	/***/ function(module, exports, __webpack_require__) {
	
		var arrayMap = __webpack_require__(51),
		    baseFlatten = __webpack_require__(77),
		    basePick = __webpack_require__(306),
		    baseRest = __webpack_require__(38),
		    toKey = __webpack_require__(40);
		
		/**
		 * Creates an object composed of the picked `object` properties.
		 *
		 * @static
		 * @since 0.1.0
		 * @memberOf _
		 * @category Object
		 * @param {Object} object The source object.
		 * @param {...(string|string[])} [props] The property identifiers to pick.
		 * @returns {Object} Returns the new object.
		 * @example
		 *
		 * var object = { 'a': 1, 'b': '2', 'c': 3 };
		 *
		 * _.pick(object, ['a', 'c']);
		 * // => { 'a': 1, 'c': 3 }
		 */
		var pick = baseRest(function(object, props) {
		  return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
		});
		
		module.exports = pick;
	
	
	/***/ },
	/* 402 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseIteratee = __webpack_require__(79),
		    basePickBy = __webpack_require__(159),
		    getAllKeysIn = __webpack_require__(333);
		
		/**
		 * Creates an object composed of the `object` properties `predicate` returns
		 * truthy for. The predicate is invoked with two arguments: (value, key).
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @category Object
		 * @param {Object} object The source object.
		 * @param {Function} [predicate=_.identity] The function invoked per property.
		 * @returns {Object} Returns the new object.
		 * @example
		 *
		 * var object = { 'a': 1, 'b': '2', 'c': 3 };
		 *
		 * _.pickBy(object, _.isNumber);
		 * // => { 'a': 1, 'c': 3 }
		 */
		function pickBy(object, predicate) {
		  return object == null ? {} : basePickBy(object, getAllKeysIn(object), baseIteratee(predicate));
		}
		
		module.exports = pickBy;
	
	
	/***/ },
	/* 403 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseProperty = __webpack_require__(114),
		    basePropertyDeep = __webpack_require__(307),
		    isKey = __webpack_require__(55),
		    toKey = __webpack_require__(40);
		
		/**
		 * Creates a function that returns the value at `path` of a given object.
		 *
		 * @static
		 * @memberOf _
		 * @since 2.4.0
		 * @category Util
		 * @param {Array|string} path The path of the property to get.
		 * @returns {Function} Returns the new accessor function.
		 * @example
		 *
		 * var objects = [
		 *   { 'a': { 'b': 2 } },
		 *   { 'a': { 'b': 1 } }
		 * ];
		 *
		 * _.map(objects, _.property('a.b'));
		 * // => [2, 1]
		 *
		 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
		 * // => [1, 2]
		 */
		function property(path) {
		  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
		}
		
		module.exports = property;
	
	
	/***/ },
	/* 404 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseSet = __webpack_require__(308);
		
		/**
		 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
		 * it's created. Arrays are created for missing index properties while objects
		 * are created for all other missing properties. Use `_.setWith` to customize
		 * `path` creation.
		 *
		 * **Note:** This method mutates `object`.
		 *
		 * @static
		 * @memberOf _
		 * @since 3.7.0
		 * @category Object
		 * @param {Object} object The object to modify.
		 * @param {Array|string} path The path of the property to set.
		 * @param {*} value The value to set.
		 * @returns {Object} Returns `object`.
		 * @example
		 *
		 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		 *
		 * _.set(object, 'a[0].b.c', 4);
		 * console.log(object.a[0].b.c);
		 * // => 4
		 *
		 * _.set(object, ['x', '0', 'y', 'z'], 5);
		 * console.log(object.x[0].y.z);
		 * // => 5
		 */
		function set(object, path, value) {
		  return object == null ? object : baseSet(object, path, value);
		}
		
		module.exports = set;
	
	
	/***/ },
	/* 405 */
	/***/ function(module, exports, __webpack_require__) {
	
		var getTag = __webpack_require__(53),
		    isArrayLike = __webpack_require__(21),
		    isObjectLike = __webpack_require__(18),
		    isString = __webpack_require__(57),
		    keys = __webpack_require__(9),
		    stringSize = __webpack_require__(371);
		
		/** `Object#toString` result references. */
		var mapTag = '[object Map]',
		    setTag = '[object Set]';
		
		/**
		 * Gets the size of `collection` by returning its length for array-like
		 * values or the number of own enumerable string keyed properties for objects.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Collection
		 * @param {Array|Object} collection The collection to inspect.
		 * @returns {number} Returns the collection size.
		 * @example
		 *
		 * _.size([1, 2, 3]);
		 * // => 3
		 *
		 * _.size({ 'a': 1, 'b': 2 });
		 * // => 2
		 *
		 * _.size('pebbles');
		 * // => 7
		 */
		function size(collection) {
		  if (collection == null) {
		    return 0;
		  }
		  if (isArrayLike(collection)) {
		    var result = collection.length;
		    return (result && isString(collection)) ? stringSize(collection) : result;
		  }
		  if (isObjectLike(collection)) {
		    var tag = getTag(collection);
		    if (tag == mapTag || tag == setTag) {
		      return collection.size;
		    }
		  }
		  return keys(collection).length;
		}
		
		module.exports = size;
	
	
	/***/ },
	/* 406 */
	/***/ function(module, exports) {
	
		/**
		 * This method returns `false`.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.13.0
		 * @category Util
		 * @returns {boolean} Returns `false`.
		 * @example
		 *
		 * _.times(2, _.stubFalse);
		 * // => [false, false]
		 */
		function stubFalse() {
		  return false;
		}
		
		module.exports = stubFalse;
	
	
	/***/ },
	/* 407 */
	/***/ function(module, exports, __webpack_require__) {
	
		var createToPairs = __webpack_require__(329),
		    keys = __webpack_require__(9);
		
		/**
		 * Creates an array of own enumerable string keyed-value pairs for `object`
		 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
		 * entries are returned.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.0.0
		 * @alias entries
		 * @category Object
		 * @param {Object} object The object to query.
		 * @returns {Array} Returns the key-value pairs.
		 * @example
		 *
		 * function Foo() {
		 *   this.a = 1;
		 *   this.b = 2;
		 * }
		 *
		 * Foo.prototype.c = 3;
		 *
		 * _.toPairs(new Foo);
		 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
		 */
		var toPairs = createToPairs(keys);
		
		module.exports = toPairs;
	
	
	/***/ },
	/* 408 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseToString = __webpack_require__(161),
		    castSlice = __webpack_require__(313),
		    charsEndIndex = __webpack_require__(314),
		    charsStartIndex = __webpack_require__(315),
		    stringToArray = __webpack_require__(372),
		    toString = __webpack_require__(86);
		
		/** Used to match leading and trailing whitespace. */
		var reTrim = /^\s+|\s+$/g;
		
		/**
		 * Removes leading and trailing whitespace or specified characters from `string`.
		 *
		 * @static
		 * @memberOf _
		 * @since 3.0.0
		 * @category String
		 * @param {string} [string=''] The string to trim.
		 * @param {string} [chars=whitespace] The characters to trim.
		 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		 * @returns {string} Returns the trimmed string.
		 * @example
		 *
		 * _.trim('  abc  ');
		 * // => 'abc'
		 *
		 * _.trim('-_-abc-_-', '_-');
		 * // => 'abc'
		 *
		 * _.map(['  foo  ', '  bar  '], _.trim);
		 * // => ['foo', 'bar']
		 */
		function trim(string, chars, guard) {
		  string = toString(string);
		  if (string && (guard || chars === undefined)) {
		    return string.replace(reTrim, '');
		  }
		  if (!string || !(chars = baseToString(chars))) {
		    return string;
		  }
		  var strSymbols = stringToArray(string),
		      chrSymbols = stringToArray(chars),
		      start = charsStartIndex(strSymbols, chrSymbols),
		      end = charsEndIndex(strSymbols, chrSymbols) + 1;
		
		  return castSlice(strSymbols, start, end).join('');
		}
		
		module.exports = trim;
	
	
	/***/ },
	/* 409 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseFlatten = __webpack_require__(77),
		    baseRest = __webpack_require__(38),
		    baseUniq = __webpack_require__(163),
		    isArrayLikeObject = __webpack_require__(125);
		
		/**
		 * Creates an array of unique values, in order, from all given arrays using
		 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		 * for equality comparisons.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Array
		 * @param {...Array} [arrays] The arrays to inspect.
		 * @returns {Array} Returns the new array of combined values.
		 * @example
		 *
		 * _.union([2], [1, 2]);
		 * // => [2, 1]
		 */
		var union = baseRest(function(arrays) {
		  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
		});
		
		module.exports = union;
	
	
	/***/ },
	/* 410 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseUniq = __webpack_require__(163);
		
		/**
		 * Creates a duplicate-free version of an array, using
		 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
		 * for equality comparisons, in which only the first occurrence of each
		 * element is kept.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Array
		 * @param {Array} array The array to inspect.
		 * @returns {Array} Returns the new duplicate free array.
		 * @example
		 *
		 * _.uniq([2, 1, 2]);
		 * // => [2, 1]
		 */
		function uniq(array) {
		  return (array && array.length)
		    ? baseUniq(array)
		    : [];
		}
		
		module.exports = uniq;
	
	
	/***/ },
	/* 411 */
	/***/ function(module, exports, __webpack_require__) {
	
		var arrayFilter = __webpack_require__(278),
		    arrayMap = __webpack_require__(51),
		    baseProperty = __webpack_require__(114),
		    baseTimes = __webpack_require__(160),
		    isArrayLikeObject = __webpack_require__(125);
		
		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeMax = Math.max;
		
		/**
		 * This method is like `_.zip` except that it accepts an array of grouped
		 * elements and creates an array regrouping the elements to their pre-zip
		 * configuration.
		 *
		 * @static
		 * @memberOf _
		 * @since 1.2.0
		 * @category Array
		 * @param {Array} array The array of grouped elements to process.
		 * @returns {Array} Returns the new array of regrouped elements.
		 * @example
		 *
		 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
		 * // => [['a', 1, true], ['b', 2, false]]
		 *
		 * _.unzip(zipped);
		 * // => [['a', 'b'], [1, 2], [true, false]]
		 */
		function unzip(array) {
		  if (!(array && array.length)) {
		    return [];
		  }
		  var length = 0;
		  array = arrayFilter(array, function(group) {
		    if (isArrayLikeObject(group)) {
		      length = nativeMax(group.length, length);
		      return true;
		    }
		  });
		  return baseTimes(length, function(index) {
		    return arrayMap(array, baseProperty(index));
		  });
		}
		
		module.exports = unzip;
	
	
	/***/ },
	/* 412 */
	/***/ function(module, exports, __webpack_require__) {
	
		var baseRest = __webpack_require__(38),
		    unzip = __webpack_require__(411);
		
		/**
		 * Creates an array of grouped elements, the first of which contains the
		 * first elements of the given arrays, the second of which contains the
		 * second elements of the given arrays, and so on.
		 *
		 * @static
		 * @memberOf _
		 * @since 0.1.0
		 * @category Array
		 * @param {...Array} [arrays] The arrays to process.
		 * @returns {Array} Returns the new array of grouped elements.
		 * @example
		 *
		 * _.zip(['a', 'b'], [1, 2], [true, false]);
		 * // => [['a', 1, true], ['b', 2, false]]
		 */
		var zip = baseRest(unzip);
		
		module.exports = zip;
	
	
	/***/ },
	/* 413 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Subscriber_1 = __webpack_require__(13);
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var InnerSubscriber = (function (_super) {
		    __extends(InnerSubscriber, _super);
		    function InnerSubscriber(parent, outerValue, outerIndex) {
		        _super.call(this);
		        this.parent = parent;
		        this.outerValue = outerValue;
		        this.outerIndex = outerIndex;
		        this.index = 0;
		    }
		    InnerSubscriber.prototype._next = function (value) {
		        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
		    };
		    InnerSubscriber.prototype._error = function (error) {
		        this.parent.notifyError(error, this);
		        this.unsubscribe();
		    };
		    InnerSubscriber.prototype._complete = function () {
		        this.parent.notifyComplete(this);
		        this.unsubscribe();
		    };
		    return InnerSubscriber;
		}(Subscriber_1.Subscriber));
		exports.InnerSubscriber = InnerSubscriber;
		//# sourceMappingURL=InnerSubscriber.js.map
	
	/***/ },
	/* 414 */
	/***/ function(module, exports) {
	
		"use strict";
		exports.empty = {
		    isUnsubscribed: true,
		    next: function (value) { },
		    error: function (err) { throw err; },
		    complete: function () { }
		};
		//# sourceMappingURL=Observer.js.map
	
	/***/ },
	/* 415 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Subscription_1 = __webpack_require__(127);
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var SubjectSubscription = (function (_super) {
		    __extends(SubjectSubscription, _super);
		    function SubjectSubscription(subject, subscriber) {
		        _super.call(this);
		        this.subject = subject;
		        this.subscriber = subscriber;
		        this.isUnsubscribed = false;
		    }
		    SubjectSubscription.prototype.unsubscribe = function () {
		        if (this.isUnsubscribed) {
		            return;
		        }
		        this.isUnsubscribed = true;
		        var subject = this.subject;
		        var observers = subject.observers;
		        this.subject = null;
		        if (!observers || observers.length === 0 || subject.isStopped || subject.isUnsubscribed) {
		            return;
		        }
		        var subscriberIndex = observers.indexOf(this.subscriber);
		        if (subscriberIndex !== -1) {
		            observers.splice(subscriberIndex, 1);
		        }
		    };
		    return SubjectSubscription;
		}(Subscription_1.Subscription));
		exports.SubjectSubscription = SubjectSubscription;
		//# sourceMappingURL=SubjectSubscription.js.map
	
	/***/ },
	/* 416 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Observable_1 = __webpack_require__(22);
		var subscribeToResult_1 = __webpack_require__(43);
		var OuterSubscriber_1 = __webpack_require__(41);
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @extends {Ignored}
		 * @hide true
		 */
		var DeferObservable = (function (_super) {
		    __extends(DeferObservable, _super);
		    function DeferObservable(observableFactory) {
		        _super.call(this);
		        this.observableFactory = observableFactory;
		    }
		    /**
		     * Creates an Observable that, on subscribe, calls an Observable factory to
		     * make an Observable for each new Observer.
		     *
		     * <span class="informal">Creates the Observable lazily, that is, only when it
		     * is subscribed.
		     * </span>
		     *
		     * <img src="./img/defer.png" width="100%">
		     *
		     * `defer` allows you to create the Observable only when the Observer
		     * subscribes, and create a fresh Observable for each Observer. It waits until
		     * an Observer subscribes to it, and then it generates an Observable,
		     * typically with an Observable factory function. It does this afresh for each
		     * subscriber, so although each subscriber may think it is subscribing to the
		     * same Observable, in fact each subscriber gets its own individual
		     * Observable.
		     *
		     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
		     * var clicksOrInterval = Rx.Observable.defer(function () {
		     *   if (Math.random() > 0.5) {
		     *     return Rx.Observable.fromEvent(document, 'click');
		     *   } else {
		     *     return Rx.Observable.interval(1000);
		     *   }
		     * });
		     * clicksOrInterval.subscribe(x => console.log(x));
		     *
		     * @see {@link create}
		     *
		     * @param {function(): Observable|Promise} observableFactory The Observable
		     * factory function to invoke for each Observer that subscribes to the output
		     * Observable. May also return a Promise, which will be converted on the fly
		     * to an Observable.
		     * @return {Observable} An Observable whose Observers' subscriptions trigger
		     * an invocation of the given Observable factory function.
		     * @static true
		     * @name defer
		     * @owner Observable
		     */
		    DeferObservable.create = function (observableFactory) {
		        return new DeferObservable(observableFactory);
		    };
		    DeferObservable.prototype._subscribe = function (subscriber) {
		        return new DeferSubscriber(subscriber, this.observableFactory);
		    };
		    return DeferObservable;
		}(Observable_1.Observable));
		exports.DeferObservable = DeferObservable;
		var DeferSubscriber = (function (_super) {
		    __extends(DeferSubscriber, _super);
		    function DeferSubscriber(destination, factory) {
		        _super.call(this, destination);
		        this.factory = factory;
		        this.tryDefer();
		    }
		    DeferSubscriber.prototype.tryDefer = function () {
		        try {
		            this._callFactory();
		        }
		        catch (err) {
		            this._error(err);
		        }
		    };
		    DeferSubscriber.prototype._callFactory = function () {
		        var result = this.factory();
		        if (result) {
		            this.add(subscribeToResult_1.subscribeToResult(this, result));
		        }
		    };
		    return DeferSubscriber;
		}(OuterSubscriber_1.OuterSubscriber));
		//# sourceMappingURL=DeferObservable.js.map
	
	/***/ },
	/* 417 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Observable_1 = __webpack_require__(22);
		var noop_1 = __webpack_require__(432);
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @extends {Ignored}
		 * @hide true
		 */
		var NeverObservable = (function (_super) {
		    __extends(NeverObservable, _super);
		    function NeverObservable() {
		        _super.call(this);
		    }
		    /**
		     * Creates an Observable that emits no items to the Observer.
		     *
		     * <span class="informal">An Observable that never emits anything.</span>
		     *
		     * <img src="./img/never.png" width="100%">
		     *
		     * This static operator is useful for creating a simple Observable that emits
		     * neither values nor errors nor the completion notification. It can be used
		     * for testing purposes or for composing with other Observables. Please not
		     * that by never emitting a complete notification, this Observable keeps the
		     * subscription from being disposed automatically. Subscriptions need to be
		     * manually disposed.
		     *
		     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
		     * function info() {
		     *   console.log('Will not be called');
		     * }
		     * var result = Rx.Observable.never().startWith(7);
		     * result.subscribe(x => console.log(x), info, info);
		     *
		     * @see {@link create}
		     * @see {@link empty}
		     * @see {@link of}
		     * @see {@link throw}
		     *
		     * @return {Observable} A "never" Observable: never emits anything.
		     * @static true
		     * @name never
		     * @owner Observable
		     */
		    NeverObservable.create = function () {
		        return new NeverObservable();
		    };
		    NeverObservable.prototype._subscribe = function (subscriber) {
		        noop_1.noop();
		    };
		    return NeverObservable;
		}(Observable_1.Observable));
		exports.NeverObservable = NeverObservable;
		//# sourceMappingURL=NeverObservable.js.map
	
	/***/ },
	/* 418 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var DeferObservable_1 = __webpack_require__(416);
		exports.defer = DeferObservable_1.DeferObservable.create;
		//# sourceMappingURL=defer.js.map
	
	/***/ },
	/* 419 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var merge_1 = __webpack_require__(185);
		exports.merge = merge_1.mergeStatic;
		//# sourceMappingURL=merge.js.map
	
	/***/ },
	/* 420 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var NeverObservable_1 = __webpack_require__(417);
		exports.never = NeverObservable_1.NeverObservable.create;
		//# sourceMappingURL=never.js.map
	
	/***/ },
	/* 421 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var ArrayObservable_1 = __webpack_require__(60);
		var isArray_1 = __webpack_require__(88);
		var OuterSubscriber_1 = __webpack_require__(41);
		var subscribeToResult_1 = __webpack_require__(43);
		var none = {};
		/**
		 * Combines multiple Observables to create an Observable whose values are
		 * calculated from the latest values of each of its input Observables.
		 *
		 * <span class="informal">Whenever any input Observable emits a value, it
		 * computes a formula using the latest values from all the inputs, then emits
		 * the output of that formula.</span>
		 *
		 * <img src="./img/combineLatest.png" width="100%">
		 *
		 * `combineLatest` combines the values from this Observable with values from
		 * Observables passed as arguments. This is done by subscribing to each
		 * Observable, in order, and collecting an array of each of the most recent
		 * values any time any of the input Observables emits, then either taking that
		 * array and passing it as arguments to an optional `project` function and
		 * emitting the return value of that, or just emitting the array of recent
		 * values directly if there is no `project` function.
		 *
		 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
		 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
		 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
		 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
		 * bmi.subscribe(x => console.log('BMI is ' + x));
		 *
		 * @see {@link combineAll}
		 * @see {@link merge}
		 * @see {@link withLatestFrom}
		 *
		 * @param {Observable} other An input Observable to combine with the source
		 * Observable. More than one input Observables may be given as argument.
		 * @param {function} [project] An optional function to project the values from
		 * the combined latest values into a new value on the output Observable.
		 * @return {Observable} An Observable of projected values from the most recent
		 * values from each input Observable, or an array of the most recent values from
		 * each input Observable.
		 * @method combineLatest
		 * @owner Observable
		 */
		function combineLatest() {
		    var observables = [];
		    for (var _i = 0; _i < arguments.length; _i++) {
		        observables[_i - 0] = arguments[_i];
		    }
		    var project = null;
		    if (typeof observables[observables.length - 1] === 'function') {
		        project = observables.pop();
		    }
		    // if the first and only other argument besides the resultSelector is an array
		    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
		    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
		        observables = observables[0];
		    }
		    observables.unshift(this);
		    return new ArrayObservable_1.ArrayObservable(observables).lift(new CombineLatestOperator(project));
		}
		exports.combineLatest = combineLatest;
		/* tslint:enable:max-line-length */
		var CombineLatestOperator = (function () {
		    function CombineLatestOperator(project) {
		        this.project = project;
		    }
		    CombineLatestOperator.prototype.call = function (subscriber, source) {
		        return source._subscribe(new CombineLatestSubscriber(subscriber, this.project));
		    };
		    return CombineLatestOperator;
		}());
		exports.CombineLatestOperator = CombineLatestOperator;
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var CombineLatestSubscriber = (function (_super) {
		    __extends(CombineLatestSubscriber, _super);
		    function CombineLatestSubscriber(destination, project) {
		        _super.call(this, destination);
		        this.project = project;
		        this.active = 0;
		        this.values = [];
		        this.observables = [];
		    }
		    CombineLatestSubscriber.prototype._next = function (observable) {
		        this.values.push(none);
		        this.observables.push(observable);
		    };
		    CombineLatestSubscriber.prototype._complete = function () {
		        var observables = this.observables;
		        var len = observables.length;
		        if (len === 0) {
		            this.destination.complete();
		        }
		        else {
		            this.active = len;
		            this.toRespond = len;
		            for (var i = 0; i < len; i++) {
		                var observable = observables[i];
		                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
		            }
		        }
		    };
		    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
		        if ((this.active -= 1) === 0) {
		            this.destination.complete();
		        }
		    };
		    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
		        var values = this.values;
		        var oldVal = values[outerIndex];
		        var toRespond = !this.toRespond
		            ? 0
		            : oldVal === none ? --this.toRespond : this.toRespond;
		        values[outerIndex] = innerValue;
		        if (toRespond === 0) {
		            if (this.project) {
		                this._tryProject(values);
		            }
		            else {
		                this.destination.next(values);
		            }
		        }
		    };
		    CombineLatestSubscriber.prototype._tryProject = function (values) {
		        var result;
		        try {
		            result = this.project.apply(this, values);
		        }
		        catch (err) {
		            this.destination.error(err);
		            return;
		        }
		        this.destination.next(result);
		    };
		    return CombineLatestSubscriber;
		}(OuterSubscriber_1.OuterSubscriber));
		exports.CombineLatestSubscriber = CombineLatestSubscriber;
		//# sourceMappingURL=combineLatest.js.map
	
	/***/ },
	/* 422 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Subscriber_1 = __webpack_require__(13);
		var tryCatch_1 = __webpack_require__(190);
		var errorObject_1 = __webpack_require__(131);
		/**
		 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
		 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
		 * If a comparator function is not provided, an equality check is used by default.
		 * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.
		 * @return {Observable} an Observable that emits items from the source Observable with distinct values.
		 * @method distinctUntilChanged
		 * @owner Observable
		 */
		function distinctUntilChanged(compare, keySelector) {
		    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
		}
		exports.distinctUntilChanged = distinctUntilChanged;
		var DistinctUntilChangedOperator = (function () {
		    function DistinctUntilChangedOperator(compare, keySelector) {
		        this.compare = compare;
		        this.keySelector = keySelector;
		    }
		    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
		        return source._subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
		    };
		    return DistinctUntilChangedOperator;
		}());
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var DistinctUntilChangedSubscriber = (function (_super) {
		    __extends(DistinctUntilChangedSubscriber, _super);
		    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
		        _super.call(this, destination);
		        this.keySelector = keySelector;
		        this.hasKey = false;
		        if (typeof compare === 'function') {
		            this.compare = compare;
		        }
		    }
		    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
		        return x === y;
		    };
		    DistinctUntilChangedSubscriber.prototype._next = function (value) {
		        var keySelector = this.keySelector;
		        var key = value;
		        if (keySelector) {
		            key = tryCatch_1.tryCatch(this.keySelector)(value);
		            if (key === errorObject_1.errorObject) {
		                return this.destination.error(errorObject_1.errorObject.e);
		            }
		        }
		        var result = false;
		        if (this.hasKey) {
		            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
		            if (result === errorObject_1.errorObject) {
		                return this.destination.error(errorObject_1.errorObject.e);
		            }
		        }
		        else {
		            this.hasKey = true;
		        }
		        if (Boolean(result) === false) {
		            this.key = key;
		            this.destination.next(value);
		        }
		    };
		    return DistinctUntilChangedSubscriber;
		}(Subscriber_1.Subscriber));
		//# sourceMappingURL=distinctUntilChanged.js.map
	
	/***/ },
	/* 423 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Subscriber_1 = __webpack_require__(13);
		/**
		 * Perform a side effect for every emission on the source Observable, but return
		 * an Observable that is identical to the source.
		 *
		 * <span class="informal">Intercepts each emission on the source and runs a
		 * function, but returns an output which is identical to the source.</span>
		 *
		 * <img src="./img/do.png" width="100%">
		 *
		 * Returns a mirrored Observable of the source Observable, but modified so that
		 * the provided Observer is called to perform a side effect for every value,
		 * error, and completion emitted by the source. Any errors that are thrown in
		 * the aforementioned Observer or handlers are safely sent down the error path
		 * of the output Observable.
		 *
		 * This operator is useful for debugging your Observables for the correct values
		 * or performing other side effects.
		 *
		 * Note: this is different to a `subscribe` on the Observable. If the Observable
		 * returned by `do` is not subscribed, the side effects specified by the
		 * Observer will never happen. `do` therefore simply spies on existing
		 * execution, it does not trigger an execution to happen like `subscribe` does.
		 *
		 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
		 * var clicks = Rx.Observable.fromEvent(document, 'click');
		 * var positions = clicks
		 *   .do(ev => console.log(ev))
		 *   .map(ev => ev.clientX);
		 * positions.subscribe(x => console.log(x));
		 *
		 * @see {@link map}
		 * @see {@link subscribe}
		 *
		 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
		 * callback for `next`.
		 * @param {function} [error] Callback for errors in the source.
		 * @param {function} [complete] Callback for the completion of the source.
		 * @return {Observable} An Observable identical to the source, but runs the
		 * specified Observer or callback(s) for each item.
		 * @method do
		 * @name do
		 * @owner Observable
		 */
		function _do(nextOrObserver, error, complete) {
		    return this.lift(new DoOperator(nextOrObserver, error, complete));
		}
		exports._do = _do;
		var DoOperator = (function () {
		    function DoOperator(nextOrObserver, error, complete) {
		        this.nextOrObserver = nextOrObserver;
		        this.error = error;
		        this.complete = complete;
		    }
		    DoOperator.prototype.call = function (subscriber, source) {
		        return source._subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
		    };
		    return DoOperator;
		}());
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var DoSubscriber = (function (_super) {
		    __extends(DoSubscriber, _super);
		    function DoSubscriber(destination, nextOrObserver, error, complete) {
		        _super.call(this, destination);
		        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
		        safeSubscriber.syncErrorThrowable = true;
		        this.add(safeSubscriber);
		        this.safeSubscriber = safeSubscriber;
		    }
		    DoSubscriber.prototype._next = function (value) {
		        var safeSubscriber = this.safeSubscriber;
		        safeSubscriber.next(value);
		        if (safeSubscriber.syncErrorThrown) {
		            this.destination.error(safeSubscriber.syncErrorValue);
		        }
		        else {
		            this.destination.next(value);
		        }
		    };
		    DoSubscriber.prototype._error = function (err) {
		        var safeSubscriber = this.safeSubscriber;
		        safeSubscriber.error(err);
		        if (safeSubscriber.syncErrorThrown) {
		            this.destination.error(safeSubscriber.syncErrorValue);
		        }
		        else {
		            this.destination.error(err);
		        }
		    };
		    DoSubscriber.prototype._complete = function () {
		        var safeSubscriber = this.safeSubscriber;
		        safeSubscriber.complete();
		        if (safeSubscriber.syncErrorThrown) {
		            this.destination.error(safeSubscriber.syncErrorValue);
		        }
		        else {
		            this.destination.complete();
		        }
		    };
		    return DoSubscriber;
		}(Subscriber_1.Subscriber));
		//# sourceMappingURL=do.js.map
	
	/***/ },
	/* 424 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Subscriber_1 = __webpack_require__(13);
		/**
		 * Returns an Observable that skips `n` items emitted by an Observable.
		 *
		 * <img src="./img/skip.png" width="100%">
		 *
		 * @param {Number} the `n` of times, items emitted by source Observable should be skipped.
		 * @return {Observable} an Observable that skips values emitted by the source Observable.
		 *
		 * @method skip
		 * @owner Observable
		 */
		function skip(total) {
		    return this.lift(new SkipOperator(total));
		}
		exports.skip = skip;
		var SkipOperator = (function () {
		    function SkipOperator(total) {
		        this.total = total;
		    }
		    SkipOperator.prototype.call = function (subscriber, source) {
		        return source._subscribe(new SkipSubscriber(subscriber, this.total));
		    };
		    return SkipOperator;
		}());
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var SkipSubscriber = (function (_super) {
		    __extends(SkipSubscriber, _super);
		    function SkipSubscriber(destination, total) {
		        _super.call(this, destination);
		        this.total = total;
		        this.count = 0;
		    }
		    SkipSubscriber.prototype._next = function (x) {
		        if (++this.count > this.total) {
		            this.destination.next(x);
		        }
		    };
		    return SkipSubscriber;
		}(Subscriber_1.Subscriber));
		//# sourceMappingURL=skip.js.map
	
	/***/ },
	/* 425 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var Subscriber_1 = __webpack_require__(13);
		var ArgumentOutOfRangeError_1 = __webpack_require__(428);
		var EmptyObservable_1 = __webpack_require__(128);
		/**
		 * Emits only the first `count` values emitted by the source Observable.
		 *
		 * <span class="informal">Takes the first `count` values from the source, then
		 * completes.</span>
		 *
		 * <img src="./img/take.png" width="100%">
		 *
		 * `take` returns an Observable that emits only the first `count` values emitted
		 * by the source Observable. If the source emits fewer than `count` values then
		 * all of its values are emitted. After that, it completes, regardless if the
		 * source completes.
		 *
		 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
		 * var interval = Rx.Observable.interval(1000);
		 * var five = interval.take(5);
		 * five.subscribe(x => console.log(x));
		 *
		 * @see {@link takeLast}
		 * @see {@link takeUntil}
		 * @see {@link takeWhile}
		 * @see {@link skip}
		 *
		 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
		 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
		 *
		 * @param {number} count The maximum number of `next` values to emit.
		 * @return {Observable<T>} An Observable that emits only the first `count`
		 * values emitted by the source Observable, or all of the values from the source
		 * if the source emits fewer than `count` values.
		 * @method take
		 * @owner Observable
		 */
		function take(count) {
		    if (count === 0) {
		        return new EmptyObservable_1.EmptyObservable();
		    }
		    else {
		        return this.lift(new TakeOperator(count));
		    }
		}
		exports.take = take;
		var TakeOperator = (function () {
		    function TakeOperator(total) {
		        this.total = total;
		        if (this.total < 0) {
		            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
		        }
		    }
		    TakeOperator.prototype.call = function (subscriber, source) {
		        return source._subscribe(new TakeSubscriber(subscriber, this.total));
		    };
		    return TakeOperator;
		}());
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var TakeSubscriber = (function (_super) {
		    __extends(TakeSubscriber, _super);
		    function TakeSubscriber(destination, total) {
		        _super.call(this, destination);
		        this.total = total;
		        this.count = 0;
		    }
		    TakeSubscriber.prototype._next = function (value) {
		        var total = this.total;
		        if (++this.count <= total) {
		            this.destination.next(value);
		            if (this.count === total) {
		                this.destination.complete();
		                this.unsubscribe();
		            }
		        }
		    };
		    return TakeSubscriber;
		}(Subscriber_1.Subscriber));
		//# sourceMappingURL=take.js.map
	
	/***/ },
	/* 426 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		var OuterSubscriber_1 = __webpack_require__(41);
		var subscribeToResult_1 = __webpack_require__(43);
		/**
		 * Combines the source Observable with other Observables to create an Observable
		 * whose values are calculated from the latest values of each, only when the
		 * source emits.
		 *
		 * <span class="informal">Whenever the source Observable emits a value, it
		 * computes a formula using that value plus the latest values from other input
		 * Observables, then emits the output of that formula.</span>
		 *
		 * <img src="./img/withLatestFrom.png" width="100%">
		 *
		 * `withLatestFrom` combines each value from the source Observable (the
		 * instance) with the latest values from the other input Observables only when
		 * the source emits a value, optionally using a `project` function to determine
		 * the value to be emitted on the output Observable. All input Observables must
		 * emit at least one value before the output Observable will emit a value.
		 *
		 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
		 * var clicks = Rx.Observable.fromEvent(document, 'click');
		 * var timer = Rx.Observable.interval(1000);
		 * var result = clicks.withLatestFrom(timer);
		 * result.subscribe(x => console.log(x));
		 *
		 * @see {@link combineLatest}
		 *
		 * @param {Observable} other An input Observable to combine with the source
		 * Observable. More than one input Observables may be given as argument.
		 * @param {Function} [project] Projection function for combining values
		 * together. Receives all values in order of the Observables passed, where the
		 * first parameter is a value from the source Observable. (e.g.
		 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
		 * passed, arrays will be emitted on the output Observable.
		 * @return {Observable} An Observable of projected values from the most recent
		 * values from each input Observable, or an array of the most recent values from
		 * each input Observable.
		 * @method withLatestFrom
		 * @owner Observable
		 */
		function withLatestFrom() {
		    var args = [];
		    for (var _i = 0; _i < arguments.length; _i++) {
		        args[_i - 0] = arguments[_i];
		    }
		    var project;
		    if (typeof args[args.length - 1] === 'function') {
		        project = args.pop();
		    }
		    var observables = args;
		    return this.lift(new WithLatestFromOperator(observables, project));
		}
		exports.withLatestFrom = withLatestFrom;
		/* tslint:enable:max-line-length */
		var WithLatestFromOperator = (function () {
		    function WithLatestFromOperator(observables, project) {
		        this.observables = observables;
		        this.project = project;
		    }
		    WithLatestFromOperator.prototype.call = function (subscriber, source) {
		        return source._subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
		    };
		    return WithLatestFromOperator;
		}());
		/**
		 * We need this JSDoc comment for affecting ESDoc.
		 * @ignore
		 * @extends {Ignored}
		 */
		var WithLatestFromSubscriber = (function (_super) {
		    __extends(WithLatestFromSubscriber, _super);
		    function WithLatestFromSubscriber(destination, observables, project) {
		        _super.call(this, destination);
		        this.observables = observables;
		        this.project = project;
		        this.toRespond = [];
		        var len = observables.length;
		        this.values = new Array(len);
		        for (var i = 0; i < len; i++) {
		            this.toRespond.push(i);
		        }
		        for (var i = 0; i < len; i++) {
		            var observable = observables[i];
		            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
		        }
		    }
		    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
		        this.values[outerIndex] = innerValue;
		        var toRespond = this.toRespond;
		        if (toRespond.length > 0) {
		            var found = toRespond.indexOf(outerIndex);
		            if (found !== -1) {
		                toRespond.splice(found, 1);
		            }
		        }
		    };
		    WithLatestFromSubscriber.prototype.notifyComplete = function () {
		        // noop
		    };
		    WithLatestFromSubscriber.prototype._next = function (value) {
		        if (this.toRespond.length === 0) {
		            var args = [value].concat(this.values);
		            if (this.project) {
		                this._tryProject(args);
		            }
		            else {
		                this.destination.next(args);
		            }
		        }
		    };
		    WithLatestFromSubscriber.prototype._tryProject = function (args) {
		        var result;
		        try {
		            result = this.project.apply(this, args);
		        }
		        catch (err) {
		            this.destination.error(err);
		            return;
		        }
		        this.destination.next(result);
		    };
		    return WithLatestFromSubscriber;
		}(OuterSubscriber_1.OuterSubscriber));
		//# sourceMappingURL=withLatestFrom.js.map
	
	/***/ },
	/* 427 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var root_1 = __webpack_require__(89);
		var Symbol = root_1.root.Symbol;
		if (typeof Symbol === 'function') {
		    if (Symbol.iterator) {
		        exports.$$iterator = Symbol.iterator;
		    }
		    else if (typeof Symbol.for === 'function') {
		        exports.$$iterator = Symbol.for('iterator');
		    }
		}
		else {
		    if (root_1.root.Set && typeof new root_1.root.Set()['@@iterator'] === 'function') {
		        // Bug for mozilla version
		        exports.$$iterator = '@@iterator';
		    }
		    else if (root_1.root.Map) {
		        // es6-shim specific logic
		        var keys = Object.getOwnPropertyNames(root_1.root.Map.prototype);
		        for (var i = 0; i < keys.length; ++i) {
		            var key = keys[i];
		            if (key !== 'entries' && key !== 'size' && root_1.root.Map.prototype[key] === root_1.root.Map.prototype['entries']) {
		                exports.$$iterator = key;
		                break;
		            }
		        }
		    }
		    else {
		        exports.$$iterator = '@@iterator';
		    }
		}
		//# sourceMappingURL=iterator.js.map
	
	/***/ },
	/* 428 */
	/***/ function(module, exports) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		/**
		 * An error thrown when an element was queried at a certain index of an
		 * Observable, but no such index or position exists in that sequence.
		 *
		 * @see {@link elementAt}
		 * @see {@link take}
		 * @see {@link takeLast}
		 *
		 * @class ArgumentOutOfRangeError
		 */
		var ArgumentOutOfRangeError = (function (_super) {
		    __extends(ArgumentOutOfRangeError, _super);
		    function ArgumentOutOfRangeError() {
		        var err = _super.call(this, 'argument out of range');
		        this.name = err.name = 'ArgumentOutOfRangeError';
		        this.stack = err.stack;
		        this.message = err.message;
		    }
		    return ArgumentOutOfRangeError;
		}(Error));
		exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
		//# sourceMappingURL=ArgumentOutOfRangeError.js.map
	
	/***/ },
	/* 429 */
	/***/ function(module, exports) {
	
		"use strict";
		var __extends = (this && this.__extends) || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
		/**
		 * An error thrown when one or more errors have occurred during the
		 * `unsubscribe` of a {@link Subscription}.
		 */
		var UnsubscriptionError = (function (_super) {
		    __extends(UnsubscriptionError, _super);
		    function UnsubscriptionError(errors) {
		        _super.call(this);
		        this.errors = errors;
		        var err = Error.call(this, errors ?
		            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
		        this.name = err.name = 'UnsubscriptionError';
		        this.stack = err.stack;
		        this.message = err.message;
		    }
		    return UnsubscriptionError;
		}(Error));
		exports.UnsubscriptionError = UnsubscriptionError;
		//# sourceMappingURL=UnsubscriptionError.js.map
	
	/***/ },
	/* 430 */
	/***/ function(module, exports) {
	
		"use strict";
		function isObject(x) {
		    return x != null && typeof x === 'object';
		}
		exports.isObject = isObject;
		//# sourceMappingURL=isObject.js.map
	
	/***/ },
	/* 431 */
	/***/ function(module, exports) {
	
		"use strict";
		function isPromise(value) {
		    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
		}
		exports.isPromise = isPromise;
		//# sourceMappingURL=isPromise.js.map
	
	/***/ },
	/* 432 */
	/***/ function(module, exports) {
	
		"use strict";
		/* tslint:disable:no-empty */
		function noop() { }
		exports.noop = noop;
		//# sourceMappingURL=noop.js.map
	
	/***/ },
	/* 433 */
	/***/ function(module, exports) {
	
		"use strict";
		function throwError(e) { throw e; }
		exports.throwError = throwError;
		//# sourceMappingURL=throwError.js.map
	
	/***/ },
	/* 434 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		var Subscriber_1 = __webpack_require__(13);
		var rxSubscriber_1 = __webpack_require__(130);
		function toSubscriber(nextOrObserver, error, complete) {
		    if (nextOrObserver) {
		        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
		            return nextOrObserver;
		        }
		        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
		            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
		        }
		    }
		    if (!nextOrObserver && !error && !complete) {
		        return new Subscriber_1.Subscriber();
		    }
		    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
		}
		exports.toSubscriber = toSubscriber;
		//# sourceMappingURL=toSubscriber.js.map
	
	/***/ },
	/* 435 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _ponyfill = __webpack_require__(436);
		
		var _ponyfill2 = _interopRequireDefault(_ponyfill);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var root = undefined; /* global window */
		
		if (typeof global !== 'undefined') {
			root = global;
		} else if (typeof window !== 'undefined') {
			root = window;
		}
		
		var result = (0, _ponyfill2.default)(root);
		exports.default = result;
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 436 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.default = symbolObservablePonyfill;
		function symbolObservablePonyfill(root) {
			var result;
			var _Symbol = root.Symbol;
		
			if (typeof _Symbol === 'function') {
				if (_Symbol.observable) {
					result = _Symbol.observable;
				} else {
					result = _Symbol('observable');
					_Symbol.observable = result;
				}
			} else {
				result = '@@observable';
			}
		
			return result;
		};
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=open-physiology-model-minimal.js.map

/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(466);


/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign = __webpack_require__(11);
	var ContextTraversal = __webpack_require__(212);
	var LegacyContextTraversal = __webpack_require__(468);
	var StringWriter = __webpack_require__(469);
	var defaultOptions = __webpack_require__(467);
	var reduce = __webpack_require__(112);
	
	/**
	 * options.reducers [array]
	 * options.renderers [array]
	 * options.outputOffset [number]
	 * options.lineSeparator [string]
	 * options.legacy [boolean]
	 */
	function createFormatter (options) {
	    var formatterConfig = assign({}, defaultOptions(), options);
	    var reducers = formatterConfig.reducers || [];
	    var rendererConfigs = formatterConfig.renderers;
	    var len = rendererConfigs.length;
	
	    return function (powerAssertContext) {
	        var context = reduce(reducers, function (prevContext, reducer) {
	            return reducer(prevContext);
	        }, powerAssertContext);
	        var writer = new StringWriter(formatterConfig);
	        var traversal;
	        if (formatterConfig.legacy) {
	            traversal = new LegacyContextTraversal(context);
	            traversal.setWritable(writer);
	        } else {
	            traversal = new ContextTraversal(context);
	        }
	        for (var i = 0; i < len; i += 1) {
	            var RendererClass;
	            var renderer;
	            var config = rendererConfigs[i];
	            if (typeof config === 'object') {
	                RendererClass = config.ctor;
	                renderer = new RendererClass(config.options);
	            } else if (typeof config === 'function') {
	                RendererClass = config;
	                renderer = new RendererClass();
	            }
	            renderer.init(traversal);
	            if (typeof renderer.setWritable === 'function') {
	                renderer.setWritable(writer);
	            }
	        }
	        traversal.traverse();
	        writer.write('');
	        return writer.toString();
	    };
	}
	
	createFormatter.StringWriter = StringWriter;
	module.exports = createFormatter;


/***/ },
/* 467 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function defaultOptions () {
	    return {
	        reducers: [
	        ],
	        legacy: false,
	        outputOffset: 2,
	        lineSeparator: '\n'
	    };
	};


/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ContextTraversal = __webpack_require__(212);
	var inherits = __webpack_require__(30).inherits;
	var slice = Array.prototype.slice;
	
	function LegacyContextTraversal (powerAssertContext) {
	    ContextTraversal.call(this, powerAssertContext);
	}
	inherits(LegacyContextTraversal, ContextTraversal);
	
	LegacyContextTraversal.prototype.setWritable = function (writer) {
	    this.writer = writer;
	};
	
	LegacyContextTraversal.prototype.on = function () {
	    var args = slice.apply(arguments);
	    if (args[0] === 'render') {
	        args[0] = 'end';
	    }
	    ContextTraversal.prototype.on.apply(this, args);
	};
	
	LegacyContextTraversal.prototype.emit = function () {
	    var args = slice.apply(arguments);
	    if (args[0] === 'end') {
	        args[1] = this.writer;
	    }
	    ContextTraversal.prototype.emit.apply(this, args);
	};
	
	module.exports = LegacyContextTraversal;


/***/ },
/* 469 */
/***/ function(module, exports) {

	'use strict';
	
	function spacerStr (len) {
	    var str = '';
	    for(var i = 0; i < len; i += 1) {
	        str += ' ';
	    }
	    return str;
	}
	
	function StringWriter (config) {
	    this.lines = [];
	    this.lineSeparator = config.lineSeparator;
	    this.regex = new RegExp(this.lineSeparator, 'g');
	    this.spacer = spacerStr(config.outputOffset);
	}
	
	StringWriter.prototype.write = function (str) {
	    this.lines.push(this.spacer + str.replace(this.regex, this.lineSeparator + this.spacer));
	};
	
	StringWriter.prototype.toString = function () {
	    var str = this.lines.join(this.lineSeparator);
	    this.lines.length = 0;
	    return str;
	};
	
	module.exports = StringWriter;


/***/ },
/* 470 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var parser = __webpack_require__(240);
	__webpack_require__(239)(parser);
	var estraverse = __webpack_require__(126);
	var purifyAst = __webpack_require__(326).customize({extra: ['range']});
	var assign = __webpack_require__(11);
	
	module.exports = function (powerAssertContext) {
	    var source = powerAssertContext.source;
	    if (source.ast && source.tokens && source.visitorKeys) {
	        return powerAssertContext;
	    }
	    var astAndTokens = parse(source);
	    var newSource = assign({}, source, {
	        ast: purifyAst(astAndTokens.expression),
	        tokens: astAndTokens.tokens,
	        visitorKeys: estraverse.VisitorKeys
	    });
	    return assign({}, powerAssertContext, { source: newSource });
	};
	
	function parserOptions(tokens) {
	    return {
	        sourceType: 'module',
	        ecmaVersion: 7,
	        locations: true,
	        ranges: false,
	        onToken: tokens,
	        plugins: {asyncawait: true}
	    };
	}
	
	function parse (source) {
	    var code = source.content;
	    var ast, tokens;
	
	    function doParse(wrapper) {
	        var content = wrapper ? wrapper(code) : code;
	        var tokenBag = [];
	        ast = parser.parse(content, parserOptions(tokenBag));
	        if (wrapper) {
	            ast = ast.body[0].body;
	            tokens = tokenBag.slice(6, -2);
	        } else {
	            tokens = tokenBag.slice(0, -1);
	        }
	    }
	
	    if (source.async) {
	        doParse(wrappedInAsync);
	    } else if (source.generator) {
	        doParse(wrappedInGenerator);
	    } else {
	        doParse();
	    }
	
	    var exp = ast.body[0].expression;
	    var columnOffset = exp.loc.start.column;
	    var offsetTree = estraverse.replace(exp, {
	        keys: estraverse.VisitorKeys,
	        enter: function (eachNode) {
	            if (!eachNode.loc && eachNode.range) {
	                // skip already visited node
	                return eachNode;
	            }
	            eachNode.range = [
	                eachNode.loc.start.column - columnOffset,
	                eachNode.loc.end.column - columnOffset
	            ];
	            delete eachNode.loc;
	            return eachNode;
	        }
	    });
	
	    return {
	        tokens: offsetAndSlimDownTokens(tokens),
	        expression: offsetTree
	    };
	}
	
	function wrappedInGenerator (jsCode) {
	    return 'function *wrapper() { ' + jsCode + ' }';
	}
	
	function wrappedInAsync (jsCode) {
	    return 'async function wrapper() { ' + jsCode + ' }';
	}
	
	function offsetAndSlimDownTokens (tokens) {
	    var i, token, newToken, result = [];
	    var columnOffset;
	    for(i = 0; i < tokens.length; i += 1) {
	        token = tokens[i];
	        if (i === 0) {
	            columnOffset = token.loc.start.column;
	        }
	        newToken = {
	            type: {
	                label: token.type.label
	            }
	        };
	        if (typeof token.value !== 'undefined') {
	            newToken.value = token.value;
	        }
	        newToken.range = [
	            token.loc.start.column - columnOffset,
	            token.loc.end.column - columnOffset
	        ];
	        result.push(newToken);
	    }
	    return result;
	}


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var EventEmitter = __webpack_require__(331).EventEmitter;
	var inherits = __webpack_require__(30).inherits;
	var estraverse = __webpack_require__(126);
	var forEach = __webpack_require__(27);
	var reduce = __webpack_require__(112);
	var locationOf = __webpack_require__(472);
	var literalPattern = /^(?:String|Numeric|Null|Boolean|RegExp)?Literal$/;
	var assign = __webpack_require__(11);
	
	function ContextTraversal (powerAssertContext) {
	    this.powerAssertContext = powerAssertContext;
	    EventEmitter.call(this);
	}
	inherits(ContextTraversal, EventEmitter);
	
	ContextTraversal.prototype.traverse = function () {
	    var _this = this;
	    var source = _this.powerAssertContext.source;
	    parseIfJson(source, 'ast');
	    parseIfJson(source, 'tokens');
	    parseIfJson(source, 'visitorKeys');
	    _this.emit('start', this.powerAssertContext);
	    forEach(this.powerAssertContext.args, function (capturedArgument) {
	        onEachEsNode(capturedArgument, source, function (esNode) {
	            _this.emit('data', esNode);
	        });
	    });
	    _this.emit('end');
	};
	
	function parseIfJson (source, propName) {
	    if (typeof source[propName] === 'string') {
	        source[propName] = JSON.parse(source[propName]);
	    }
	}
	
	function onEachEsNode(capturedArgument, source, callback) {
	    var espathToValue = reduce(capturedArgument.events, function (accum, ev) {
	        accum[ev.espath] = ev.value;
	        return accum;
	    }, {});
	    var nodeStack = [];
	    estraverse.traverse(source.ast, {
	        keys: source.visitorKeys,
	        enter: function (currentNode, parentNode) {
	            var parentEsNode = (0 < nodeStack.length) ? nodeStack[nodeStack.length - 1] : null;
	            var esNode = createEsNode(this.path(), currentNode, espathToValue, source.content, source.tokens, parentEsNode);
	            nodeStack.push(esNode);
	            callback(esNode);
	        },
	        leave: function (currentNode, parentNode) {
	            nodeStack.pop();
	        }
	    });
	}
	
	function isLiteral (node) {
	    return literalPattern.test(node.type);
	}
	
	function createEsNode (path, currentNode, espathToValue, jsCode, tokens, parent) {
	    var espath = path ? path.join('/') : '';
	    return {
	        espath: espath,
	        parent: parent,
	        key: path ? path[path.length - 1] : null,
	        node: currentNode,
	        code: jsCode.slice(currentNode.range[0], currentNode.range[1]),
	        value: isLiteral(currentNode) ? currentNode.value : espathToValue[espath],
	        isCaptured: espathToValue.hasOwnProperty(espath),
	        range: locationOf(currentNode, tokens)
	    };
	}
	
	module.exports = ContextTraversal;


/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var syntax = __webpack_require__(126).Syntax;
	
	function locationOf(currentNode, tokens) {
	    switch(currentNode.type) {
	    case syntax.MemberExpression:
	        return propertyLocationOf(currentNode, tokens);
	    case syntax.CallExpression:
	        if (currentNode.callee.type === syntax.MemberExpression) {
	            return propertyLocationOf(currentNode.callee, tokens);
	        }
	        break;
	    case syntax.BinaryExpression:
	    case syntax.LogicalExpression:
	    case syntax.AssignmentExpression:
	        return infixOperatorLocationOf(currentNode, tokens);
	    default:
	        break;
	    }
	    return currentNode.range;
	}
	
	function propertyLocationOf(memberExpression, tokens) {
	    var prop = memberExpression.property;
	    var token;
	    if (!memberExpression.computed) {
	        return prop.range;
	    }
	    token = findLeftBracketTokenOf(memberExpression, tokens);
	    return token ? token.range : prop.range;
	}
	
	// calculate location of infix operator for BinaryExpression, AssignmentExpression and LogicalExpression.
	function infixOperatorLocationOf (expression, tokens) {
	    var token = findOperatorTokenOf(expression, tokens);
	    return token ? token.range : expression.left.range;
	}
	
	function findLeftBracketTokenOf(expression, tokens) {
	    var fromColumn = expression.property.range[0];
	    return searchToken(tokens, function (token, index) {
	        var prevToken;
	        if (token.range[0] === fromColumn) {
	            prevToken = tokens[index - 1];
	            // if (prevToken.type === 'Punctuator' && prevToken.value === '[') {  // esprima
	            if (prevToken.type.label === '[') {  // acorn
	                return prevToken;
	            }
	        }
	        return undefined;
	    });
	}
	
	function findOperatorTokenOf(expression, tokens) {
	    var fromColumn = expression.left.range[1];
	    var toColumn = expression.right.range[0];
	    return searchToken(tokens, function (token, index) {
	        if (fromColumn < token.range[0] &&
	            token.range[1] < toColumn &&
	            token.value === expression.operator) {
	            return token;
	        }
	        return undefined;
	    });
	}
	
	function searchToken(tokens, predicate) {
	    var i, token, found;
	    for(i = 0; i < tokens.length; i += 1) {
	        token = tokens[i];
	        found = predicate(token, i);
	        if (found) {
	            return found;
	        }
	    }
	    return undefined;
	}
	
	module.exports = locationOf;


/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * power-assert-formatter.js - Power Assert output formatter
	 *
	 * https://github.com/power-assert-js/power-assert-formatter
	 *
	 * Copyright (c) 2013-2016 Takuto Wada
	 * Licensed under the MIT license.
	 *   https://github.com/power-assert-js/power-assert-formatter/blob/master/MIT-LICENSE.txt
	 */
	'use strict';
	
	module.exports = __webpack_require__(142);


/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./create": 142,
		"./create.js": 142,
		"./default-options": 143,
		"./default-options.js": 143
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 474;


/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BaseRenderer = __webpack_require__(102);
	var inherits = __webpack_require__(30).inherits;
	
	function AssertionRenderer () {
	    BaseRenderer.call(this);
	}
	inherits(AssertionRenderer, BaseRenderer);
	
	AssertionRenderer.prototype.onStart = function (context) {
	    this.assertionLine = context.source.content;
	};
	
	AssertionRenderer.prototype.onEnd = function () {
	    this.write('');
	    this.write(this.assertionLine);
	};
	
	module.exports = AssertionRenderer;


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BaseRenderer = __webpack_require__(102);
	var inherits = __webpack_require__(30).inherits;
	var typeName = __webpack_require__(148);
	var keys = __webpack_require__(34);
	var forEach = __webpack_require__(27);
	var udiff = __webpack_require__(478);
	var stringifier = __webpack_require__(219);
	var assign = __webpack_require__(11);
	var defaultOptions = __webpack_require__(477);
	var literalPattern = /^(?:String|Numeric|Null|Boolean|RegExp)?Literal$/;
	
	function isLiteral (node) {
	    return literalPattern.test(node.type);
	}
	
	/**
	 * options.stringify [function]
	 * options.maxDepth [number]
	 * options.lineSeparator [string]
	 * options.anonymous [string]
	 * options.circular [string]
	 * 
	 * options.diff [function]
	 * options.lineDiffThreshold [number]
	 */
	function ComparisonRenderer (config) {
	    BaseRenderer.call(this);
	    this.config = assign({}, defaultOptions(), config);
	    if (typeof this.config.stringify === 'function') {
	        this.stringify = this.config.stringify;
	    } else {
	        this.stringify = stringifier(this.config);
	    }
	    if (typeof this.config.diff === 'function') {
	        this.diff = this.config.diff;
	    } else {
	        this.diff = udiff(this.config);
	    }
	    this.espathToPair = {};
	}
	inherits(ComparisonRenderer, BaseRenderer);
	
	ComparisonRenderer.prototype.onData = function (esNode) {
	    var pair;
	    if (!esNode.isCaptured) {
	        if (isTargetBinaryExpression(esNode.parent) && isLiteral(esNode.node)) {
	            this.espathToPair[esNode.parent.espath][esNode.key] = {code: esNode.code, value: esNode.value};
	        }
	        return;
	    }
	    if (isTargetBinaryExpression(esNode.parent)) {
	        this.espathToPair[esNode.parent.espath][esNode.key] = {code: esNode.code, value: esNode.value};
	    }
	    if (isTargetBinaryExpression(esNode)) {
	        pair = {
	            operator: esNode.node.operator,
	            value: esNode.value
	        };
	        this.espathToPair[esNode.espath] = pair;
	    }
	};
	
	ComparisonRenderer.prototype.onEnd = function () {
	    var _this = this;
	    var pairs = [];
	    forEach(keys(this.espathToPair), function (espath) {
	        var pair = _this.espathToPair[espath];
	        if (pair.left && pair.right) {
	            pairs.push(pair);
	        }
	    });
	    forEach(pairs, function (pair) {
	        _this.compare(pair);
	    });
	};
	
	ComparisonRenderer.prototype.compare = function (pair) {
	    if (isStringDiffTarget(pair)) {
	        this.showStringDiff(pair);
	    } else {
	        this.showExpectedAndActual(pair);
	    }
	};
	
	ComparisonRenderer.prototype.showExpectedAndActual = function (pair) {
	    this.write('');
	    this.write('[' + typeName(pair.right.value) + '] ' + pair.right.code);
	    this.write('=> ' + this.stringify(pair.right.value));
	    this.write('[' + typeName(pair.left.value)  + '] ' + pair.left.code);
	    this.write('=> ' + this.stringify(pair.left.value));
	};
	
	ComparisonRenderer.prototype.showStringDiff = function (pair) {
	    this.write('');
	    this.write('--- [string] ' + pair.right.code);
	    this.write('+++ [string] ' + pair.left.code);
	    this.write(this.diff(pair.right.value, pair.left.value, this.config));
	};
	
	function isTargetBinaryExpression (esNode) {
	    return esNode &&
	        esNode.node.type === 'BinaryExpression' &&
	        (esNode.node.operator === '===' || esNode.node.operator === '==') &&
	        esNode.isCaptured &&
	        !(esNode.value);
	}
	
	function isStringDiffTarget(pair) {
	    return typeof pair.left.value === 'string' && typeof pair.right.value === 'string';
	}
	
	ComparisonRenderer.udiff = udiff;
	module.exports = ComparisonRenderer;


/***/ },
/* 477 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function defaultOptions () {
	    return {
	        lineDiffThreshold: 5,
	        maxDepth: 2,
	        indent: null,
	        outputOffset: 2,
	        anonymous: 'Object',
	        circular: '#@Circular#',
	        lineSeparator: '\n'
	    };
	};


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var DiffMatchPatch = __webpack_require__(316);
	var dmp = new DiffMatchPatch();
	
	function udiff (config) {
	    return function diff (text1, text2) {
	        var patch;
	        if (config && shouldUseLineLevelDiff(text1, config)) {
	            patch = udiffLines(text1, text2);
	        } else {
	            patch = udiffChars(text1, text2);
	        }
	        return decodeURIComponent(patch);
	    };
	}
	
	function shouldUseLineLevelDiff (text, config) {
	    return config.lineDiffThreshold < text.split(/\r\n|\r|\n/).length;
	}
	
	function udiffLines(text1, text2) {
	    /*jshint camelcase: false */
	    var a = dmp.diff_linesToChars_(text1, text2);
	    var diffs = dmp.diff_main(a.chars1, a.chars2, false);
	    dmp.diff_charsToLines_(diffs, a.lineArray);
	    dmp.diff_cleanupSemantic(diffs);
	    return dmp.patch_toText(dmp.patch_make(text1, diffs));
	}
	
	function udiffChars (text1, text2) {
	    /*jshint camelcase: false */
	    var diffs = dmp.diff_main(text1, text2, false);
	    dmp.diff_cleanupSemantic(diffs);
	    return dmp.patch_toText(dmp.patch_make(text1, diffs));
	}
	
	module.exports = udiff;


/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BaseRenderer = __webpack_require__(102);
	var inherits = __webpack_require__(30).inherits;
	var forEach = __webpack_require__(27);
	var stringifier = __webpack_require__(219);
	var stringWidth = __webpack_require__(481);
	var assign = __webpack_require__(11);
	var defaultOptions = __webpack_require__(480);
	
	/**
	 * options.stringify [function]
	 * options.maxDepth [number]
	 * options.lineSeparator [string]
	 * options.anonymous [string]
	 * options.circular [string]
	 * 
	 * options.widthOf [function]
	 * options.ambiguousEastAsianCharWidth [number]
	 */
	function DiagramRenderer (config) {
	    BaseRenderer.call(this);
	    this.config = assign({}, defaultOptions(), config);
	    this.events = [];
	    if (typeof this.config.stringify === 'function') {
	        this.stringify = this.config.stringify;
	    } else {
	        this.stringify = stringifier(this.config);
	    }
	    if (typeof this.config.widthOf === 'function') {
	        this.widthOf = this.config.widthOf;
	    } else {
	        this.widthOf = stringWidth(this.config);
	    }
	    this.initialVertivalBarLength = 1;
	}
	inherits(DiagramRenderer, BaseRenderer);
	
	DiagramRenderer.prototype.onStart = function (context) {
	    this.assertionLine = context.source.content;
	    this.initializeRows();
	};
	
	DiagramRenderer.prototype.onData = function (esNode) {
	    if (!esNode.isCaptured) {
	        return;
	    }
	    this.events.push({value: esNode.value, leftIndex: esNode.range[0]});
	};
	
	DiagramRenderer.prototype.onEnd = function () {
	    this.events.sort(rightToLeft);
	    this.constructRows(this.events);
	    var _this = this;
	    forEach(this.rows, function (columns) {
	        _this.write(columns.join(''));
	    });
	};
	
	DiagramRenderer.prototype.initializeRows = function () {
	    this.rows = [];
	    for (var i = 0; i <= this.initialVertivalBarLength; i += 1) {
	        this.addOneMoreRow();
	    }
	};
	
	DiagramRenderer.prototype.newRowFor = function (assertionLine) {
	    return createRow(this.widthOf(assertionLine), ' ');
	};
	
	DiagramRenderer.prototype.addOneMoreRow = function () {
	    this.rows.push(this.newRowFor(this.assertionLine));
	};
	
	DiagramRenderer.prototype.lastRow = function () {
	    return this.rows[this.rows.length - 1];
	};
	
	DiagramRenderer.prototype.renderVerticalBarAt = function (columnIndex) {
	    var i, lastRowIndex = this.rows.length - 1;
	    for (i = 0; i < lastRowIndex; i += 1) {
	        this.rows[i].splice(columnIndex, 1, '|');
	    }
	};
	
	DiagramRenderer.prototype.renderValueAt = function (columnIndex, dumpedValue) {
	    var i, width = this.widthOf(dumpedValue);
	    for (i = 0; i < width; i += 1) {
	        this.lastRow().splice(columnIndex + i, 1, dumpedValue.charAt(i));
	    }
	};
	
	DiagramRenderer.prototype.isOverlapped = function (prevCapturing, nextCaputuring, dumpedValue) {
	    return (typeof prevCapturing !== 'undefined') && this.startColumnFor(prevCapturing) <= (this.startColumnFor(nextCaputuring) + this.widthOf(dumpedValue));
	};
	
	DiagramRenderer.prototype.constructRows = function (capturedEvents) {
	    var that = this;
	    var prevCaptured;
	    forEach(capturedEvents, function (captured) {
	        var dumpedValue = that.stringify(captured.value);
	        if (that.isOverlapped(prevCaptured, captured, dumpedValue)) {
	            that.addOneMoreRow();
	        }
	        that.renderVerticalBarAt(that.startColumnFor(captured));
	        that.renderValueAt(that.startColumnFor(captured), dumpedValue);
	        prevCaptured = captured;
	    });
	};
	
	DiagramRenderer.prototype.startColumnFor = function (captured) {
	    return this.widthOf(this.assertionLine.slice(0, captured.leftIndex));
	};
	
	function createRow (numCols, initial) {
	    var row = [], i;
	    for(i = 0; i < numCols; i += 1) {
	        row[i] = initial;
	    }
	    return row;
	}
	
	function rightToLeft (a, b) {
	    return b.leftIndex - a.leftIndex;
	}
	
	DiagramRenderer.stringWidth = stringWidth;
	module.exports = DiagramRenderer;


/***/ },
/* 480 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function defaultOptions () {
	    return {
	        ambiguousEastAsianCharWidth: 2,
	        maxDepth: 2,
	        indent: null,
	        outputOffset: 2,
	        anonymous: 'Object',
	        circular: '#@Circular#',
	        lineSeparator: '\n'
	    };
	};


/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var eaw = __webpack_require__(317);
	
	function stringWidth (config) {
	    var ambiguousCharWidth = (config && config.ambiguousEastAsianCharWidth) || 1;
	    return function widthOf (str) {
	        var i, code, width = 0;
	        for(i = 0; i < str.length; i+=1) {
	            code = eaw.eastAsianWidth(str.charAt(i));
	            switch(code) {
	            case 'F':
	            case 'W':
	                width += 2;
	                break;
	            case 'H':
	            case 'Na':
	            case 'N':
	                width += 1;
	                break;
	            case 'A':
	                width += ambiguousCharWidth;
	                break;
	            }
	        }
	        return width;
	    };
	}
	
	module.exports = stringWidth;


/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BaseRenderer = __webpack_require__(102);
	var inherits = __webpack_require__(30).inherits;
	
	function FileRenderer () {
	    BaseRenderer.call(this);
	}
	inherits(FileRenderer, BaseRenderer);
	
	FileRenderer.prototype.onStart = function (context) {
	    this.filepath = context.source.filepath;
	    this.lineNumber = context.source.line;
	};
	
	FileRenderer.prototype.onEnd = function () {
	    if (this.filepath) {
	        this.write('# ' + [this.filepath, this.lineNumber].join(':'));
	    } else {
	        this.write('# at line: ' + this.lineNumber);
	    }
	};
	
	module.exports = FileRenderer;


/***/ },
/* 483 */
/***/ function(module, exports) {

	/**
	 * @author Roman Ditchuk
	 * @email me@ototak.net
	 * @license MIT
	 */
	
	(function() {
	    var rearg = {
	        is: function(val, sym) {
	            switch(sym) {
	                case 'n':
	                    return typeof val == 'number';
	                case 's':
	                    return typeof val == 'string';
	                case 'b':
	                    return typeof val == 'boolean';
	                case 'f':
	                    return typeof val == 'function';
	                case 'O':
	                    return typeof val == 'object';
	                case 'a':
	                    return val instanceof Array;
	                case 'd':
	                    return val instanceof Date;
	                case 'r':
	                    return val instanceof RegExp;
	                case 'o':
	                    return typeof val == 'object'  &&  !(val instanceof Array)  &&  !(val instanceof Date)  &&  !(val instanceof RegExp);
	            }
	        },
	        reorder: function(pattern, func) {
	            this.reorderCheckPattern(pattern);
	            var self = this;
	            return function() {
	                return func.apply(this, self.reorderList(pattern, arguments));
	            }
	        },
	        reorderCheckPattern: function(pattern) {
	            var usedAnyObject = pattern.indexOf('O') != -1;
	            var objectTypes = 'adro';
	            var allowedSyms = 'nsbfOadro';
	            var used = '';
	            for(var i = pattern.length-1; i >= 0; i--) {
	                if(allowedSyms.indexOf(pattern[i]) == -1) {
	                    throw new Error('Unexpected symbol "'+pattern[i]+'" in reorder pattern');
	                }
	                if(used.indexOf(pattern[i]) != -1) {
	                    throw new Error('Type symbol "'+pattern[i]+'" occurs more than once in reorder pattern');
	                }
	                if(usedAnyObject  &&  objectTypes.indexOf(pattern[i]) != -1) {
	                    throw new Error('You cann\'t use type symbol "'+pattern[i]+'" with type symbol "O" (any Object) in reorder pattern. Try to use "o" (other Object).');
	                }
	                used += pattern[i];
	            }
	        },
	        reorderList: function(pattern, list) {
	            var args = Array(pattern.length);
	            for(var i = list.length-1; i >= 0; i--) {
	                var j = pattern.length-1;
	                for(; j >= 0; j--) {
	                    if(this.is(list[i], pattern[j])) {
	                        break;
	                    }
	                }
	                if(j != -1) {
	                    args[j] = list[i];
	                }
	            }
	            return args;
	        },
	        expand: function(pattern, func) {
	            this.expandCheckPattern(pattern);
	            var self = this;
	            return function() {
	                return func.apply(this, self.expandList(pattern, arguments));
	            }
	        },
	        expandCheckPattern: function(pattern) {
	            var wasOptional = false;
	            var last = {};
	            var allowedSyms = 'nsbfOadro';
	            var objectTypes = 'adro';
	            for(var i = 0; i < pattern.length; i++) {
	                if(allowedSyms.indexOf(pattern[i]) == -1) {
	                    throw new Error('Unexpected symbol "'+pattern[i]+'" in expand pattern');
	                }
	                if(pattern[i+1] == '?') {
	                    wasOptional = true;
	                    last[pattern[i]] = true;
	                    i++;
	                } else {
	                    if(wasOptional  &&  (last[pattern[i]]  ||  (last['O']  &&  objectTypes.indexOf(pattern[i]) != -1)  ||  (pattern[i] == 'O' && (last.a || last.d || last.r || last.o)))) {
	                        throw new Error('You cann\'t use required argument after optional arguments sequence which include the same or similar type in expand pattern');
	                    }
	                    wasOptional = false;
	                    last = {};
	                }
	            }
	        },
	        expandList: function(pattern, list) {
	            var args = [];
	            var j = 0;
	            for(var i = 0; i < pattern.length; i++) {
	                if(this.is(list[j], pattern[i])) {
	                    args.push(list[j++]);
	                    if(pattern[i+1] == '?') {
	                        i++;
	                    }
	                    continue;
	                }
	                if(pattern[i+1] == '?') {
	                    args.push(undefined);
	                    i++;
	                    continue;
	                }
	                throw new Error('Passed arguments list doesn\'t match expected pattern');
	            }
	            if(j < list.length-1) {
	                args.push.apply(args, Array.prototype.slice.call(list, j));
	            }
	            return args;
	        }
	    };
	
	    // define for browsers
	    if(typeof window != 'undefined') {
	        window.rearg = rearg;
	    }
	
	    // define for CommonJS
	    if(typeof module != 'undefined'  &&  module.exports) {
	        module.exports = rearg;
	    }
	})();

/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerSubscriber = (function (_super) {
	    __extends(InnerSubscriber, _super);
	    function InnerSubscriber(parent, outerValue, outerIndex) {
	        _super.call(this);
	        this.parent = parent;
	        this.outerValue = outerValue;
	        this.outerIndex = outerIndex;
	        this.index = 0;
	    }
	    InnerSubscriber.prototype._next = function (value) {
	        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
	    };
	    InnerSubscriber.prototype._error = function (error) {
	        this.parent.notifyError(error, this);
	        this.unsubscribe();
	    };
	    InnerSubscriber.prototype._complete = function () {
	        this.parent.notifyComplete(this);
	        this.unsubscribe();
	    };
	    return InnerSubscriber;
	}(Subscriber_1.Subscriber));
	exports.InnerSubscriber = InnerSubscriber;
	//# sourceMappingURL=InnerSubscriber.js.map

/***/ },
/* 485 */
/***/ function(module, exports) {

	"use strict";
	exports.empty = {
	    isUnsubscribed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(70);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, subscriber) {
	        _super.call(this);
	        this.subject = subject;
	        this.subscriber = subscriber;
	        this.isUnsubscribed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isStopped || subject.isUnsubscribed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.subscriber);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1.Subscription));
	exports.SubjectSubscription = SubjectSubscription;
	//# sourceMappingURL=SubjectSubscription.js.map

/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(20);
	var do_1 = __webpack_require__(493);
	Observable_1.Observable.prototype.do = do_1._do;
	//# sourceMappingURL=do.js.map

/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(20);
	var tryCatch_1 = __webpack_require__(147);
	var errorObject_1 = __webpack_require__(103);
	var Subscription_1 = __webpack_require__(70);
	function isNodeStyleEventEmmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
	}
	function isJQueryStyleEventEmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
	}
	function isNodeList(sourceObj) {
	    return !!sourceObj && sourceObj.toString() === '[object NodeList]';
	}
	function isHTMLCollection(sourceObj) {
	    return !!sourceObj && sourceObj.toString() === '[object HTMLCollection]';
	}
	function isEventTarget(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
	}
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromEventObservable = (function (_super) {
	    __extends(FromEventObservable, _super);
	    function FromEventObservable(sourceObj, eventName, selector) {
	        _super.call(this);
	        this.sourceObj = sourceObj;
	        this.eventName = eventName;
	        this.selector = selector;
	    }
	    /**
	     * Creates an Observable that emits events of a specific type coming from the
	     * given event target.
	     *
	     * <span class="informal">Creates an Observable from DOM events, or Node
	     * EventEmitter events or others.</span>
	     *
	     * <img src="./img/fromEvent.png" width="100%">
	     *
	     * Creates an Observable by attaching an event listener to an "event target",
	     * which may be an object with `addEventListener` and `removeEventListener`,
	     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
	     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
	     * the output Observable is subscribed, and removed when the Subscription is
	     * unsubscribed.
	     *
	     * @example <caption>Emits clicks happening on the DOM document</caption>
	     * var clicks = Rx.Observable.fromEvent(document, 'click');
	     * clicks.subscribe(x => console.log(x));
	     *
	     * @see {@link from}
	     * @see {@link fromEventPattern}
	     *
	     * @param {EventTargetLike} target The DOMElement, event target, Node.js
	     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
	     * @param {string} eventName The event name of interest, being emitted by the
	     * `target`.
	     * @param {function(...args: any): T} [selector] An optional function to
	     * post-process results. It takes the arguments from the event handler and
	     * should return a single value.
	     * @return {Observable<T>}
	     * @static true
	     * @name fromEvent
	     * @owner Observable
	     */
	    FromEventObservable.create = function (target, eventName, selector) {
	        return new FromEventObservable(target, eventName, selector);
	    };
	    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber) {
	        var unsubscribe;
	        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
	            for (var i = 0, len = sourceObj.length; i < len; i++) {
	                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);
	            }
	        }
	        else if (isEventTarget(sourceObj)) {
	            var source_1 = sourceObj;
	            sourceObj.addEventListener(eventName, handler);
	            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };
	        }
	        else if (isJQueryStyleEventEmitter(sourceObj)) {
	            var source_2 = sourceObj;
	            sourceObj.on(eventName, handler);
	            unsubscribe = function () { return source_2.off(eventName, handler); };
	        }
	        else if (isNodeStyleEventEmmitter(sourceObj)) {
	            var source_3 = sourceObj;
	            sourceObj.addListener(eventName, handler);
	            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
	        }
	        subscriber.add(new Subscription_1.Subscription(unsubscribe));
	    };
	    FromEventObservable.prototype._subscribe = function (subscriber) {
	        var sourceObj = this.sourceObj;
	        var eventName = this.eventName;
	        var selector = this.selector;
	        var handler = selector ? function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
	            if (result === errorObject_1.errorObject) {
	                subscriber.error(errorObject_1.errorObject.e);
	            }
	            else {
	                subscriber.next(result);
	            }
	        } : function (e) { return subscriber.next(e); };
	        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);
	    };
	    return FromEventObservable;
	}(Observable_1.Observable));
	exports.FromEventObservable = FromEventObservable;
	//# sourceMappingURL=FromEventObservable.js.map

/***/ },
/* 489 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(20);
	var noop_1 = __webpack_require__(504);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var NeverObservable = (function (_super) {
	    __extends(NeverObservable, _super);
	    function NeverObservable() {
	        _super.call(this);
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer.
	     *
	     * <span class="informal">An Observable that never emits anything.</span>
	     *
	     * <img src="./img/never.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that emits
	     * neither values nor errors nor the completion notification. It can be used
	     * for testing purposes or for composing with other Observables. Please not
	     * that by never emitting a complete notification, this Observable keeps the
	     * subscription from being disposed automatically. Subscriptions need to be
	     * manually disposed.
	     *
	     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
	     * function info() {
	     *   console.log('Will not be called');
	     * }
	     * var result = Rx.Observable.never().startWith(7);
	     * result.subscribe(x => console.log(x), info, info);
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @return {Observable} A "never" Observable: never emits anything.
	     * @static true
	     * @name never
	     * @owner Observable
	     */
	    NeverObservable.create = function () {
	        return new NeverObservable();
	    };
	    NeverObservable.prototype._subscribe = function (subscriber) {
	        noop_1.noop();
	    };
	    return NeverObservable;
	}(Observable_1.Observable));
	exports.NeverObservable = NeverObservable;
	//# sourceMappingURL=NeverObservable.js.map

/***/ },
/* 490 */,
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var NeverObservable_1 = __webpack_require__(489);
	exports.never = NeverObservable_1.NeverObservable.create;
	//# sourceMappingURL=never.js.map

/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ArrayObservable_1 = __webpack_require__(47);
	var isArray_1 = __webpack_require__(104);
	var OuterSubscriber_1 = __webpack_require__(46);
	var subscribeToResult_1 = __webpack_require__(50);
	var none = {};
	/**
	 * Combines multiple Observables to create an Observable whose values are
	 * calculated from the latest values of each of its input Observables.
	 *
	 * <span class="informal">Whenever any input Observable emits a value, it
	 * computes a formula using the latest values from all the inputs, then emits
	 * the output of that formula.</span>
	 *
	 * <img src="./img/combineLatest.png" width="100%">
	 *
	 * `combineLatest` combines the values from this Observable with values from
	 * Observables passed as arguments. This is done by subscribing to each
	 * Observable, in order, and collecting an array of each of the most recent
	 * values any time any of the input Observables emits, then either taking that
	 * array and passing it as arguments to an optional `project` function and
	 * emitting the return value of that, or just emitting the array of recent
	 * values directly if there is no `project` function.
	 *
	 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
	 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
	 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
	 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
	 * bmi.subscribe(x => console.log('BMI is ' + x));
	 *
	 * @see {@link combineAll}
	 * @see {@link merge}
	 * @see {@link withLatestFrom}
	 *
	 * @param {Observable} other An input Observable to combine with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {function} [project] An optional function to project the values from
	 * the combined latest values into a new value on the output Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @method combineLatest
	 * @owner Observable
	 */
	function combineLatest() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = null;
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    // if the first and only other argument besides the resultSelector is an array
	    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
	    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    observables.unshift(this);
	    return new ArrayObservable_1.ArrayObservable(observables).lift(new CombineLatestOperator(project));
	}
	exports.combineLatest = combineLatest;
	/* tslint:enable:max-line-length */
	var CombineLatestOperator = (function () {
	    function CombineLatestOperator(project) {
	        this.project = project;
	    }
	    CombineLatestOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new CombineLatestSubscriber(subscriber, this.project));
	    };
	    return CombineLatestOperator;
	}());
	exports.CombineLatestOperator = CombineLatestOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CombineLatestSubscriber = (function (_super) {
	    __extends(CombineLatestSubscriber, _super);
	    function CombineLatestSubscriber(destination, project) {
	        _super.call(this, destination);
	        this.project = project;
	        this.active = 0;
	        this.values = [];
	        this.observables = [];
	    }
	    CombineLatestSubscriber.prototype._next = function (observable) {
	        this.values.push(none);
	        this.observables.push(observable);
	    };
	    CombineLatestSubscriber.prototype._complete = function () {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        }
	        else {
	            this.active = len;
	            this.toRespond = len;
	            for (var i = 0; i < len; i++) {
	                var observable = observables[i];
	                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
	        if ((this.active -= 1) === 0) {
	            this.destination.complete();
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var values = this.values;
	        var oldVal = values[outerIndex];
	        var toRespond = !this.toRespond
	            ? 0
	            : oldVal === none ? --this.toRespond : this.toRespond;
	        values[outerIndex] = innerValue;
	        if (toRespond === 0) {
	            if (this.project) {
	                this._tryProject(values);
	            }
	            else {
	                this.destination.next(values);
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype._tryProject = function (values) {
	        var result;
	        try {
	            result = this.project.apply(this, values);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return CombineLatestSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.CombineLatestSubscriber = CombineLatestSubscriber;
	//# sourceMappingURL=combineLatest.js.map

/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Perform a side effect for every emission on the source Observable, but return
	 * an Observable that is identical to the source.
	 *
	 * <span class="informal">Intercepts each emission on the source and runs a
	 * function, but returns an output which is identical to the source.</span>
	 *
	 * <img src="./img/do.png" width="100%">
	 *
	 * Returns a mirrored Observable of the source Observable, but modified so that
	 * the provided Observer is called to perform a side effect for every value,
	 * error, and completion emitted by the source. Any errors that are thrown in
	 * the aforementioned Observer or handlers are safely sent down the error path
	 * of the output Observable.
	 *
	 * This operator is useful for debugging your Observables for the correct values
	 * or performing other side effects.
	 *
	 * Note: this is different to a `subscribe` on the Observable. If the Observable
	 * returned by `do` is not subscribed, the side effects specified by the
	 * Observer will never happen. `do` therefore simply spies on existing
	 * execution, it does not trigger an execution to happen like `subscribe` does.
	 *
	 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks
	 *   .do(ev => console.log(ev))
	 *   .map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 * @see {@link subscribe}
	 *
	 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
	 * callback for `next`.
	 * @param {function} [error] Callback for errors in the source.
	 * @param {function} [complete] Callback for the completion of the source.
	 * @return {Observable} An Observable identical to the source, but runs the
	 * specified Observer or callback(s) for each item.
	 * @method do
	 * @name do
	 * @owner Observable
	 */
	function _do(nextOrObserver, error, complete) {
	    return this.lift(new DoOperator(nextOrObserver, error, complete));
	}
	exports._do = _do;
	var DoOperator = (function () {
	    function DoOperator(nextOrObserver, error, complete) {
	        this.nextOrObserver = nextOrObserver;
	        this.error = error;
	        this.complete = complete;
	    }
	    DoOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
	    };
	    return DoOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DoSubscriber = (function (_super) {
	    __extends(DoSubscriber, _super);
	    function DoSubscriber(destination, nextOrObserver, error, complete) {
	        _super.call(this, destination);
	        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	        safeSubscriber.syncErrorThrowable = true;
	        this.add(safeSubscriber);
	        this.safeSubscriber = safeSubscriber;
	    }
	    DoSubscriber.prototype._next = function (value) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.next(value);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.next(value);
	        }
	    };
	    DoSubscriber.prototype._error = function (err) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.error(err);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.error(err);
	        }
	    };
	    DoSubscriber.prototype._complete = function () {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.complete();
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    return DoSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=do.js.map

/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var subscribeToResult_1 = __webpack_require__(50);
	var OuterSubscriber_1 = __webpack_require__(46);
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link mergeAll}.</span>
	 *
	 * <img src="./img/mergeMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an Observable, and then merging those resulting Observables and
	 * emitting the results of this merger.
	 *
	 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
	 * var letters = Rx.Observable.of('a', 'b', 'c');
	 * var result = letters.mergeMap(x =>
	 *   Rx.Observable.interval(1000).map(i => x+i)
	 * );
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link merge}
	 * @see {@link mergeAll}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): Observable} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and merging the results of the Observables obtained
	 * from this transformation.
	 * @method mergeMap
	 * @owner Observable
	 */
	function mergeMap(project, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	        resultSelector = null;
	    }
	    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
	}
	exports.mergeMap = mergeMap;
	var MergeMapOperator = (function () {
	    function MergeMapOperator(project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	    MergeMapOperator.prototype.call = function (observer, source) {
	        return source._subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
	    };
	    return MergeMapOperator;
	}());
	exports.MergeMapOperator = MergeMapOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeMapSubscriber = (function (_super) {
	    __extends(MergeMapSubscriber, _super);
	    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeMapSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            this._tryNext(value);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapSubscriber.prototype._tryNext = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.active++;
	        this._innerSub(result, value, index);
	    };
	    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
	        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
	    };
	    MergeMapSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeMapSubscriber = MergeMapSubscriber;
	//# sourceMappingURL=mergeMap.js.map

/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var not_1 = __webpack_require__(505);
	var filter_1 = __webpack_require__(16);
	/**
	 * Splits the source Observable into two, one with values that satisfy a
	 * predicate, and another with values that don't satisfy the predicate.
	 *
	 * <span class="informal">It's like {@link filter}, but returns two Observables:
	 * one like the output of {@link filter}, and the other with values that did not
	 * pass the condition.</span>
	 *
	 * <img src="./img/partition.png" width="100%">
	 *
	 * `partition` outputs an array with two Observables that partition the values
	 * from the source Observable through the given `predicate` function. The first
	 * Observable in that array emits source values for which the predicate argument
	 * returns true. The second Observable emits source values for which the
	 * predicate returns false. The first behaves like {@link filter} and the second
	 * behaves like {@link filter} with the predicate negated.
	 *
	 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
	 * var clicksOnDivs = parts[0];
	 * var clicksElsewhere = parts[1];
	 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
	 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
	 *
	 * @see {@link filter}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted on the first Observable in the returned array, if
	 * `false` the value is emitted on the second Observable in the array. The
	 * `index` parameter is the number `i` for the i-th source emission that has
	 * happened since the subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
	 * with values that passed the predicate, and another with values that did not
	 * pass the predicate.
	 * @method partition
	 * @owner Observable
	 */
	function partition(predicate, thisArg) {
	    return [
	        filter_1.filter.call(this, predicate),
	        filter_1.filter.call(this, not_1.not(predicate, thisArg))
	    ];
	}
	exports.partition = partition;
	//# sourceMappingURL=partition.js.map

/***/ },
/* 496 */,
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Returns an Observable that skips `n` items emitted by an Observable.
	 *
	 * <img src="./img/skip.png" width="100%">
	 *
	 * @param {Number} the `n` of times, items emitted by source Observable should be skipped.
	 * @return {Observable} an Observable that skips values emitted by the source Observable.
	 *
	 * @method skip
	 * @owner Observable
	 */
	function skip(total) {
	    return this.lift(new SkipOperator(total));
	}
	exports.skip = skip;
	var SkipOperator = (function () {
	    function SkipOperator(total) {
	        this.total = total;
	    }
	    SkipOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SkipSubscriber(subscriber, this.total));
	    };
	    return SkipOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipSubscriber = (function (_super) {
	    __extends(SkipSubscriber, _super);
	    function SkipSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.count = 0;
	    }
	    SkipSubscriber.prototype._next = function (x) {
	        if (++this.count > this.total) {
	            this.destination.next(x);
	        }
	    };
	    return SkipSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=skip.js.map

/***/ },
/* 498 */,
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(54);
	var Symbol = root_1.root.Symbol;
	if (typeof Symbol === 'function') {
	    if (Symbol.iterator) {
	        exports.$$iterator = Symbol.iterator;
	    }
	    else if (typeof Symbol.for === 'function') {
	        exports.$$iterator = Symbol.for('iterator');
	    }
	}
	else {
	    if (root_1.root.Set && typeof new root_1.root.Set()['@@iterator'] === 'function') {
	        // Bug for mozilla version
	        exports.$$iterator = '@@iterator';
	    }
	    else if (root_1.root.Map) {
	        // es6-shim specific logic
	        var keys = Object.getOwnPropertyNames(root_1.root.Map.prototype);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (key !== 'entries' && key !== 'size' && root_1.root.Map.prototype[key] === root_1.root.Map.prototype['entries']) {
	                exports.$$iterator = key;
	                break;
	            }
	        }
	    }
	    else {
	        exports.$$iterator = '@@iterator';
	    }
	}
	//# sourceMappingURL=iterator.js.map

/***/ },
/* 500 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an element was queried at a certain index of an
	 * Observable, but no such index or position exists in that sequence.
	 *
	 * @see {@link elementAt}
	 * @see {@link take}
	 * @see {@link takeLast}
	 *
	 * @class ArgumentOutOfRangeError
	 */
	var ArgumentOutOfRangeError = (function (_super) {
	    __extends(ArgumentOutOfRangeError, _super);
	    function ArgumentOutOfRangeError() {
	        var err = _super.call(this, 'argument out of range');
	        this.name = err.name = 'ArgumentOutOfRangeError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ArgumentOutOfRangeError;
	}(Error));
	exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
	//# sourceMappingURL=ArgumentOutOfRangeError.js.map

/***/ },
/* 501 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ },
/* 502 */
/***/ function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ },
/* 503 */
/***/ function(module, exports) {

	"use strict";
	function isPromise(value) {
	    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
	}
	exports.isPromise = isPromise;
	//# sourceMappingURL=isPromise.js.map

/***/ },
/* 504 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:no-empty */
	function noop() { }
	exports.noop = noop;
	//# sourceMappingURL=noop.js.map

/***/ },
/* 505 */
/***/ function(module, exports) {

	"use strict";
	function not(pred, thisArg) {
	    function notPred() {
	        return !(notPred.pred.apply(notPred.thisArg, arguments));
	    }
	    notPred.pred = pred;
	    notPred.thisArg = thisArg;
	    return notPred;
	}
	exports.not = not;
	//# sourceMappingURL=not.js.map

/***/ },
/* 506 */
/***/ function(module, exports) {

	"use strict";
	function throwError(e) { throw e; }
	exports.throwError = throwError;
	//# sourceMappingURL=throwError.js.map

/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(9);
	var rxSubscriber_1 = __webpack_require__(146);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber();
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ },
/* 508 */
/***/ function(module, exports) {

	/* globals Snap, document, navigator */
	
	/**
	 *  snapsvg-zpd.js: A zoom/pan/drag plugin for Snap.svg
	 * ==================================================
	 *
	 *  Usage
	 * =======
	 * var paper = Snap();
	 * var bigCircle = paper.circle(150, 150, 100);
	 * paper.zpd();
	 *
	 * // or settings and callback
	 * paper.zpd({ zoom: false }), function (err, paper) { });
	 *
	 * // or callback
	 * paper.zpd(function (err, paper) { });
	 *
	 * // destroy
	 * paper.zpd('destroy');
	 *
	 * // save
	 * paper.zpd('save');
	 *
	 * // load
	 * // paper.zpd({ load: SVGMatrix {} });
	 *
	 * // origin
	 * paper.zpd('origin');
	 *
	 * // zoomTo
	 * paper.zoomTo(1);
	 *
	 * // panTo
	 * paper.panTo(0, 0); // original location
	 * paper.panTo('+10', 0); // move right
	 *
	 * // rotate
	 * paper.rotate(15); // rotate 15 deg
	 *
	 *  Notice
	 * ========
	 * This usually use on present view only. Not for Storing, modifying the paper.
	 *
	 * Reason:
	 * Usually <pan> <zoom> => <svg transform="matrix(a,b,c,d,e,f)"></svg>
	 *
	 * But if you need to store the <drag> location, (for storing)
	 * we have to use <circle cx="x" cy="y"></circle> not <circle tranform="matrix(a,b,c,d,e,f)"></circle>
	 *
	 *  License
	 * =========
	 * This code is licensed under the following BSD license:
	 *
	 * Copyright 2014 Huei Tan <huei90@gmail.com> (Snap.svg integration). All rights reserved.
	 * Copyright 2009-2010 Andrea Leofreddi <a.leofreddi@itcharm.com> (original author). All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification, are
	 * permitted provided that the following conditions are met:
	 *
	 *    1. Redistributions of source code must retain the above copyright notice, this list of
	 *       conditions and the following disclaimer.
	 *
	 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
	 *       of conditions and the following disclaimer in the documentation and/or other materials
	 *       provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY Andrea Leofreddi ``AS IS'' AND ANY EXPRESS OR IMPLIED
	 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
	 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Andrea Leofreddi OR
	 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
	 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 * The views and conclusions contained in the software and documentation are those of the
	 * authors and should not be interpreted as representing official policies, either expressed
	 * or implied, of Andrea Leofreddi.
	 */
	
	SVGElement.prototype.getTransformToElement = SVGElement.prototype.getTransformToElement || function(elem) {
		return elem.getScreenCTM().inverse().multiply(this.getScreenCTM());
	};
	
	
	(function (Snap) {
	    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	
	        /**
	         * Global variable for snap.svg.zpd plugin
	         */
	        var snapsvgzpd = {
	            uniqueIdPrefix: 'snapsvg-zpd-',     // prefix for the unique ids created for zpd
	            dataStore: {},                      // "global" storage for all our zpd elements
	            enable: true                        // By default, snapsvgzpd should enable, zpd('toggle') to toggle enable or disable
	        };
	
	        /**
	         * Global variable to store root of the svg element
	         */
	        var rootSvgObject;
	
	        /**
	         * remove node parent but keep children
	         */
	        var _removeNodeKeepChildren = function removeNodeKeepChildren(node) {
	            if (!node.parentNode) {
	                return;
	            }
	            while (node.firstChild) {
	                node.parentNode.insertBefore(node.firstChild, node);
	            }
	            node.parentNode.removeChild(node);
	        };
	
	        /**
	         * Detect is +1 -1 or 1
	         * increase decrease or just number
	         */
	        var _increaseDecreaseOrNumber = function increaseDecreaseOrNumber(defaultValue, input) {
	            if (input === undefined) {
	                return parseInt(defaultValue);
	            } else if (input[0] == '+') {
	                return defaultValue + parseInt(input.split('+')[1]);
	            } else if (input[0] == '-') {
	                return defaultValue - parseInt(input.split('-')[1]);
	            } else {
	                return parseInt(input);
	            }
	        };
	
	        /**
	         * Sets the current transform matrix of an element.
	         */
	        var _setCTM = function setCTM(element, matrix, threshold) {
	            if (threshold && typeof threshold === 'object') { // array [0.5,2]
	                var oldMatrix = Snap(element).transform().globalMatrix;
	
	                if (matrix.a < oldMatrix.a && matrix.a < threshold[0]) {
	                    return;
	                } else if (matrix.a > oldMatrix.a && matrix.a > threshold[1]) {
	                    return;
	                }
	
	                if (matrix.d < oldMatrix.d && matrix.d < threshold[0]) {
	                    return;
	                } else if (matrix.d > oldMatrix.d && matrix.d > threshold[1]) {
	                    return;
	                }
	            }
	            var s = "matrix(" + matrix.a + "," + matrix.b + "," + matrix.c + "," + matrix.d + "," + matrix.e + "," + matrix.f + ")";
	            element.setAttribute("transform", s);
	        };
	
	        /**
	         * Dumps a matrix to a string (useful for debug).
	         */
	        var _dumpMatrix = function dumpMatrix(matrix) {
	            var s = "[ " + matrix.a + ", " + matrix.c + ", " + matrix.e + "\n  " + matrix.b + ", " + matrix.d + ", " + matrix.f + "\n  0, 0, 1 ]";
	            return s;
	        };
	
	        /**
	         * Instance an SVGPoint object with given event coordinates.
	         */
	         var _findPos = function findPos(obj) {
	           var curleft = curtop = 0;
	           if (obj.offsetParent) {
	               do {
	                   curleft += obj.offsetLeft;
	                   curtop += obj.offsetTop;
	               } while(obj = obj.offsetParent);
	           }
	           return [curleft,curtop];
	        };
	        var _getEventPoint = function getEventPoint(event, svgNode) {
	
	            var p = svgNode.node.createSVGPoint(),
	            svgPos = _findPos(svgNode.node);
	
	            p.x = event.clientX - svgPos[0];
	            p.y = event.clientY - svgPos[1];
	
	            return p;
	        };
	
	        /**
	         * Get an svg transformation matrix as string representation
	         */
	        var _getSvgMatrixAsString = function _getMatrixAsString (matrix) {
	
	            return 'matrix(' + matrix.a + ',' + matrix.b + ',' + matrix.c + ',' + matrix.d + ',' + matrix.e + ',' + matrix.f + ')';
	        };
	
	        /**
	         * add a new <g> element to the paper
	         * add paper nodes into <g> element (Snapsvg Element)
	         * and give the nodes an unique id like 'snapsvg-zpd-12345'
	         * and let this <g> Element to global snapsvgzpd.dataStore['snapsvg-zpd-12345']
	         * and
	         * <svg>
	         *     <def>something</def>
	         *     <circle cx="10" cy="10" r="100"></circle>
	         * </svg>
	         *
	         * transform to =>
	         *
	         * <svg>
	         *     <g id="snapsvg-zpd-12345">
	         *         <def>something</def>
	         *         <circle cx="10" cy="10" r="100"></circle>
	         *     </g>
	         * </svg>
	         */
	        var _initZpdElement = function initAndGetZpdElement (svgObject, options) {
	
	            // get root of svg object
	            rootSvgObject = svgObject.node;
	
	            // get all child nodes in our svg element
	            var rootChildNodes = svgObject.node.childNodes;
	
	            // create a new graphics element in our svg element
	            var gElement = svgObject.g();
	            var gNode = gElement.node;
	
	            // add our unique id to the element
	            gNode.id = snapsvgzpd.uniqueIdPrefix + svgObject.id;
	
	            // check if a matrix has been supplied to initialize the drawing
	            if (options.load && typeof options.load === 'object') {
	
	                var matrix = options.load;
	
	                // create a matrix string from our supplied matrix
	                var matrixString = "matrix(" + matrix.a + "," + matrix.b + "," + matrix.c + "," + matrix.d + "," + matrix.e + "," + matrix.f + ")";
	
	                // load <g> transform matrix
	                gElement.transform(matrixString);
	
	            } else {
	                // initial set <g transform="matrix(1,0,0,1,0,0)">
	                gElement.transform('matrix');
	            }
	
	            // initialize our index counter for child nodes
	            var index = 0;
	
	            // get the number of child nodes in our root node
	            // substract -1 to exclude our <g> element
	            var noOfChildNodes = rootChildNodes.length - 1;
	
	            // go through all child elements
	            // (except the last one, which is our <g> element)
	            while (index < noOfChildNodes) {
	                gNode.appendChild(rootChildNodes[0]);
	                index += 1;
	            }
	
	            // define some data to be used in the function internally
	            var data = {
	                svg: svgObject,
	                root: svgObject.node,        // get paper svg
	                state: 'none',
	                stateTarget: null,
	                stateOrigin: null,
	                stateTf: null
	            };
	
	            // create an element with all required properties
	            var item = {
	                "element": gElement,
	                "data": data,
	                "options": options,
	            };
	
	            // create some mouse event handlers for our item
	            // store them globally for optional removal later on
	            item.handlerFunctions = _getHandlerFunctions(item);
	
	            // return our element
	            return item;
	        };
	
	        /**
	         * create some handler functions for our mouse actions
	         * we will take advantace of closures to preserve some data
	         */
	        var _getHandlerFunctions = function getHandlerFunctions(zpdElement) {
	
	            var handleMouseUp = function handleMouseUp (event) {
	
	                if (event.preventDefault) {
	                    event.preventDefault();
	                }
	
	                if (!snapsvgzpd.enable) return;
	
	                event.returnValue = false;
	
	                if (zpdElement.data.state == 'pan' || zpdElement.data.state == 'drag') {
	
	                    // quit pan mode
	                    zpdElement.data.state = '';
	
	                }
	
	            };
	
	            var handleMouseDown = function handleMouseDown (event) {
	
	                if (event.preventDefault) {
	                    event.preventDefault();
	                }
	
	                if (!snapsvgzpd.enable) return;
	
	                event.returnValue = false;
	
	                var g = zpdElement.element.node;
	
	                if (
	                    event.target.tagName == "svg" || !zpdElement.options.drag // Pan anyway when drag is disabled and the user clicked on an element
	                ) {
	                    // Pan mode
	                    zpdElement.data.state = 'pan';
	
	                    zpdElement.data.stateTf = g.getCTM().inverse();
	
	                    zpdElement.data.stateOrigin = _getEventPoint(event, zpdElement.data.svg).matrixTransform(zpdElement.data.stateTf);
	
	                } else {
	
	                    // Drag mode
	                    zpdElement.data.state = 'drag';
	
	                    zpdElement.data.stateTarget = event.target;
	
	                    zpdElement.data.stateTf = g.getCTM().inverse();
	
	                    zpdElement.data.stateOrigin = _getEventPoint(event, zpdElement.data.svg).matrixTransform(zpdElement.data.stateTf);
	
	                }
	            };
	
	            var handleMouseMove = function handleMouseMove (event) {
	
	                if (event.preventDefault) {
	                    event.preventDefault();
	                }
	
	                if (!snapsvgzpd.enable) return;
	
	                event.returnValue = false;
	
	                var g = zpdElement.element.node;
	
	                if (zpdElement.data.state == 'pan' && zpdElement.options.pan) {
	
	                    // Pan mode
	                    var p = _getEventPoint(event, zpdElement.data.svg).matrixTransform(zpdElement.data.stateTf);
	
	                    _setCTM(g, zpdElement.data.stateTf.inverse().translate(p.x - zpdElement.data.stateOrigin.x, p.y - zpdElement.data.stateOrigin.y), zpdElement.options.zoomThreshold);
	
	                } else if (zpdElement.data.state == 'drag' && zpdElement.options.drag) {
	
	                    // Drag mode
	                    var dragPoint = _getEventPoint(event, zpdElement.data.svg).matrixTransform(g.getCTM().inverse());
	
	                    _setCTM(zpdElement.data.stateTarget,
	                            zpdElement.data.root.createSVGMatrix()
	                            .translate(dragPoint.x - zpdElement.data.stateOrigin.x, dragPoint.y - zpdElement.data.stateOrigin.y)
	                            .multiply(g.getCTM().inverse())
	                            .multiply(zpdElement.data.stateTarget.getCTM()),
	                            zpdElement.options.zoomThreshold);
	
	                    zpdElement.data.stateOrigin = dragPoint;
	                }
	            };
	
	            var handleMouseWheel = function handleMouseWheel (event) {
	
	                if (!zpdElement.options.zoom) {
	                    return;
	                }
	
	                if (event.preventDefault) {
	                    event.preventDefault();
	                }
	
	                if (!snapsvgzpd.enable) return;
	
	                event.returnValue = false;
	
	                var delta = 0;
	
	                if (event.wheelDelta) {
	                    delta = event.wheelDelta / 360;  // Chrome/Safari
	                }
	                else {
	                    delta = event.detail / -9;       // Mozilla
	                }
	
	                var z = Math.pow(1 + zpdElement.options.zoomScale, delta);
	
	                var g = zpdElement.element.node;
	
	                var p = _getEventPoint(event, zpdElement.data.svg);
	
	                p = p.matrixTransform(g.getCTM().inverse());
	
	                // Compute new scale matrix in current mouse position
	                var k = zpdElement.data.root.createSVGMatrix().translate(p.x, p.y).scale(z).translate(-p.x, -p.y);
	
	                _setCTM(g, g.getCTM().multiply(k), zpdElement.options.zoomThreshold);
	
	                if (typeof(stateTf) == 'undefined') {
	                    zpdElement.data.stateTf = g.getCTM().inverse();
	                }
	
	                zpdElement.data.stateTf = zpdElement.data.stateTf.multiply(k.inverse());
	            };
	
	            return {
	                "mouseUp": handleMouseUp,
	                "mouseDown": handleMouseDown,
	                "mouseMove": handleMouseMove,
	                "mouseWheel": handleMouseWheel
	            };
	        };
	
	
	        /**
	         * Register handlers
	         * desktop and mobile (?)
	         */
	        var _setupHandlers = function setupHandlers(svgElement, handlerFunctions) {
	
	            // mobile
	            // (?)
	
	            // desktop
	            if ('onmouseup' in document.documentElement) {
	
	                // IE < 9 would need to use the event onmouseup, but they do not support svg anyway..
	                svgElement.addEventListener('mouseup', handlerFunctions.mouseUp, false);
	                svgElement.addEventListener('mousedown', handlerFunctions.mouseDown, false);
	                svgElement.addEventListener('mousemove', handlerFunctions.mouseMove, false);
	
	                if (navigator.userAgent.toLowerCase().indexOf('webkit') >= 0 ||
	                    navigator.userAgent.toLowerCase().indexOf('trident') >= 0) {
	                    svgElement.addEventListener('mousewheel', handlerFunctions.mouseWheel, false); // Chrome/Safari
	                }
	                else {
	                    svgElement.addEventListener('DOMMouseScroll', handlerFunctions.mouseWheel, false); // Others
	                }
	
	            }
	        };
	
	        /**
	         * remove event handlers
	         */
	        var _tearDownHandlers = function tearDownHandlers(svgElement, handlerFunctions) {
	
	            svgElement.removeEventListener('mouseup', handlerFunctions.mouseUp, false);
	            svgElement.removeEventListener('mousedown', handlerFunctions.mouseDown, false);
	            svgElement.removeEventListener('mousemove', handlerFunctions.mouseMove, false);
	
	            if (navigator.userAgent.toLowerCase().indexOf('webkit') >= 0 ||
	                navigator.userAgent.toLowerCase().indexOf('trident') >= 0) {
	                svgElement.removeEventListener('mousewheel', handlerFunctions.mouseWheel, false);
	            }
	            else {
	                svgElement.removeEventListener('DOMMouseScroll', handlerFunctions.mouseWheel, false);
	            }
	        };
	
	        /* our global zpd function */
	        var zpd = function (options, callbackFunc) {
	
	            // get a reference to the current element
	            var self = this;
	
	            // define some custom options
	            var zpdOptions = {
	                pan: true,          // enable or disable panning (default enabled)
	                zoom: true,         // enable or disable zooming (default enabled)
	                drag: false,        // enable or disable dragging (default disabled)
	                zoomScale: 0.2,     // define zoom sensitivity
	                zoomThreshold: null // define zoom threshold
	            };
	
	            // the situation event of zpd, may be init, reinit, destroy, save, origin, toggle
	            var situation,
	                situationState = {
	                    init: 'init',
	                    reinit: 'reinit',
	                    destroy: 'destroy',
	                    save: 'save',
	                    origin: 'origin',
	                    callback: 'callback',
	                    toggle: 'toggle'
	                };
	
	            var zpdElement = null;
	
	            // it is also possible to only specify a callback function without any options
	            if (typeof options === 'function') {
	                callbackFunc = options;
	                situation = situationState.callback;
	            }
	
	            // check if element was already initialized
	            if (snapsvgzpd.dataStore.hasOwnProperty(self.id)) {
	
	                // return existing element
	                zpdElement =  snapsvgzpd.dataStore[self.id];
	
	                // adapt the stored options, with the options passed in
	                if (typeof options === 'object') {
	                    for (var prop in options) {
	                        zpdElement.options[prop] = options[prop];
	                    }
	                    situation = situationState.reinit;
	                } else if (typeof options === 'string') {
	                    situation = options;
	                }
	            }
	            else {
	
	                // adapt the default options
	                if (typeof options === 'object') {
	                    for (var prop2 in options) {
	                        zpdOptions[prop2] = options[prop2];
	                    }
	                    situation = situationState.init;
	                } else if (typeof options === 'string') {
	                    situation = options;
	                }
	
	                // initialize a new element and save it to our global storage
	                zpdElement = _initZpdElement(self, zpdOptions);
	
	                // setup the handlers for our svg-canvas
	                _setupHandlers(self.node, zpdElement.handlerFunctions);
	
	                snapsvgzpd.dataStore[self.id] = zpdElement;
	            }
	
	            switch (situation) {
	
	                case situationState.init:
	                case situationState.reinit:
	                case situationState.callback:
	
	                    // callback
	                    if (callbackFunc) {
	                        callbackFunc(null, zpdElement);
	                    }
	
	                    return;
	
	                case situationState.destroy:
	
	                    // remove event handlers
	                    _tearDownHandlers(self.node, zpdElement.handlerFunctions);
	
	                    // remove our custom <g> element
	                    _removeNodeKeepChildren(self.node.firstChild);
	
	                    // remove the object from our internal storage
	                    delete snapsvgzpd.dataStore[self.id];
	
	                    // callback
	                    if (callbackFunc) {
	                        callbackFunc(null, zpdElement);
	                    }
	
	                    return; // exit all
	
	                case situationState.save:
	
	                    var g = document.getElementById(snapsvgzpd.uniqueIdPrefix + self.id);
	
	                    var returnValue = g.getCTM();
	
	                    // callback
	                    if (callbackFunc) {
	                        callbackFunc(null, returnValue);
	                    }
	
	                    return returnValue;
	
	                case situationState.origin:
	
	                    // back to origin location
	                    self.zoomTo(1, 1000);
	
	                    // callback
	                    if (callbackFunc) {
	                        callbackFunc(null, zpdElement);
	                    }
	
	                    return;
	
	                case situationState.toggle:
	
	                    // toggle enabled
	                    snapsvgzpd.enable = !snapsvgzpd.enable;
	
	                    // callback
	                    if (callbackFunc) {
	                        callbackFunc(null, snapsvgzpd.enable);
	                    }
	
	                    return;
	            }
	        };
	
	
	
	        /**
	         * zoom element to a certain zoom factor
	         */
	        var zoomTo = function (zoom, interval, ease, callbackFunction) {
	
	            if (zoom < 0 || typeof zoom !== 'number') {
	                console.error('zoomTo(arg) should be a number and greater than 0');
	                return;
	            }
	
	            if (typeof interval !== 'number') {
	                interval = 3000;
	            }
	
	            var self = this;
	
	            // check if we have this element in our zpd data storage
	            if (snapsvgzpd.dataStore.hasOwnProperty(self.id)) {
	
	                // get a reference to the element
	                var zpdElement = snapsvgzpd.dataStore[self.id].element;
	
	                var currentTransformMatrix = zpdElement.node.getTransformToElement(rootSvgObject);
	                var currentZoom = currentTransformMatrix.a;
	                var originX = currentTransformMatrix.e;
	                var originY = currentTransformMatrix.f;
	
	                var boundingBox = zpdElement.getBBox();
	                var deltaX = parseFloat(boundingBox.width) / 2.0;
	                var deltaY = parseFloat(boundingBox.height) / 2.0;
	
	                Snap.animate(currentZoom, zoom, function (value) {
	
	                    // calculate difference of zooming value to initial zoom
	                    var deltaZoom = value / currentZoom;
	
	                    if (value !== currentZoom) {
	
	                        // calculate new translation
	                        currentTransformMatrix.e = originX - ((deltaX * deltaZoom - deltaX));
	                        currentTransformMatrix.f = originY - ((deltaY * deltaZoom - deltaY));
	
	                        // add new scaling
	                        currentTransformMatrix.a = value;
	                        currentTransformMatrix.d = value;
	
	                        // apply transformation to our element
	                        zpdElement.node.setAttribute('transform', _getSvgMatrixAsString(currentTransformMatrix));
	                    }
	
	                }, interval, ease, callbackFunction);
	            }
	        };
	
	
	        /**
	         * move the element to a certain position
	         */
	        var panTo = function (x, y, interval, ease, cb) {
	
	            // get a reference to the current element
	            var self = this;
	
	            // check if we have this element in our zpd data storage
	            if (snapsvgzpd.dataStore.hasOwnProperty(self.id)) {
	
	                var zpdElement = snapsvgzpd.dataStore[self.id].element;
	
	                var gMatrix = zpdElement.node.getCTM(),
	                    matrixX = _increaseDecreaseOrNumber(gMatrix.e, x),
	                    matrixY = _increaseDecreaseOrNumber(gMatrix.f, y),
	                    matrixString = "matrix(" + gMatrix.a + "," + gMatrix.b + "," + gMatrix.c + "," + gMatrix.d + "," + matrixX + "," + matrixY + ")";
	
	                // dataStore[me.id].transform(matrixString); // load <g> transform matrix
	                zpdElement.animate({ transform: matrixString }, interval || 10, ease || null, function () {
	                    if (cb) {
	                        cb(null, zpdElement);
	                    }
	                });
	
	            }
	        };
	
	        /**
	         * rotate the element to a certain rotation
	         */
	        var rotate = function (a, x, y, interval, ease, cb) {
	            // get a reference to the current element
	            var self = this;
	
	            // check if we have this element in our zpd data storage
	            if (snapsvgzpd.dataStore.hasOwnProperty(self.id)) {
	
	                var zpdElement = snapsvgzpd.dataStore[self.id].element;
	
	                var gMatrix = zpdElement.node.getCTM(),
	                    matrixString = "matrix(" + gMatrix.a + "," + gMatrix.b + "," + gMatrix.c + "," + gMatrix.d + "," + gMatrix.e + "," + gMatrix.f + ")";
	
	                if (!x || typeof x !== 'number') {
	                    x = self.node.offsetWidth / 2;
	                }
	                if (!y || typeof y !== 'number') {
	                    y = self.node.offsetHeight / 2;
	                }
	
	                // dataStore[me.id].transform(matrixString); // load <g> transform matrix
	                zpdElement.animate({ transform: new Snap.Matrix(gMatrix).rotate(a, x, y) }, interval || 10, ease || null, function () {
	                    if (cb) {
	                        cb(null, zpdElement);
	                    }
	                });
	
	            }
	        };
	
	        Paper.prototype.zpd = zpd;
	        Paper.prototype.zoomTo = zoomTo;
	        Paper.prototype.panTo = panTo;
	        Paper.prototype.rotate = rotate;
	
	        /** More Features to add (click event) help me if you can **/
	        // Element.prototype.panToCenter = panToCenter; // arg (ease, interval, cb)
	
	
	        /** UI for zpdr **/
	
	    });
	
	})(Snap);


/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	window.eve = __webpack_require__(330)
	
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	var mina = (function (eve) {
	    var animations = {},
	    requestAnimFrame = window.requestAnimationFrame       ||
	                       window.webkitRequestAnimationFrame ||
	                       window.mozRequestAnimationFrame    ||
	                       window.oRequestAnimationFrame      ||
	                       window.msRequestAnimationFrame     ||
	                       function (callback) {
	                           setTimeout(callback, 16);
	                       },
	    isArray = Array.isArray || function (a) {
	        return a instanceof Array ||
	            Object.prototype.toString.call(a) == "[object Array]";
	    },
	    idgen = 0,
	    idprefix = "M" + (+new Date).toString(36),
	    ID = function () {
	        return idprefix + (idgen++).toString(36);
	    },
	    diff = function (a, b, A, B) {
	        if (isArray(a)) {
	            res = [];
	            for (var i = 0, ii = a.length; i < ii; i++) {
	                res[i] = diff(a[i], b, A[i], B);
	            }
	            return res;
	        }
	        var dif = (A - a) / (B - b);
	        return function (bb) {
	            return a + dif * (bb - b);
	        };
	    },
	    timer = Date.now || function () {
	        return +new Date;
	    },
	    sta = function (val) {
	        var a = this;
	        if (val == null) {
	            return a.s;
	        }
	        var ds = a.s - val;
	        a.b += a.dur * ds;
	        a.B += a.dur * ds;
	        a.s = val;
	    },
	    speed = function (val) {
	        var a = this;
	        if (val == null) {
	            return a.spd;
	        }
	        a.spd = val;
	    },
	    duration = function (val) {
	        var a = this;
	        if (val == null) {
	            return a.dur;
	        }
	        a.s = a.s * val / a.dur;
	        a.dur = val;
	    },
	    stopit = function () {
	        var a = this;
	        delete animations[a.id];
	        a.update();
	        eve("mina.stop." + a.id, a);
	    },
	    pause = function () {
	        var a = this;
	        if (a.pdif) {
	            return;
	        }
	        delete animations[a.id];
	        a.update();
	        a.pdif = a.get() - a.b;
	    },
	    resume = function () {
	        var a = this;
	        if (!a.pdif) {
	            return;
	        }
	        a.b = a.get() - a.pdif;
	        delete a.pdif;
	        animations[a.id] = a;
	    },
	    update = function () {
	        var a = this,
	            res;
	        if (isArray(a.start)) {
	            res = [];
	            for (var j = 0, jj = a.start.length; j < jj; j++) {
	                res[j] = +a.start[j] +
	                    (a.end[j] - a.start[j]) * a.easing(a.s);
	            }
	        } else {
	            res = +a.start + (a.end - a.start) * a.easing(a.s);
	        }
	        a.set(res);
	    },
	    frame = function () {
	        var len = 0;
	        for (var i in animations) if (animations.hasOwnProperty(i)) {
	            var a = animations[i],
	                b = a.get(),
	                res;
	            len++;
	            a.s = (b - a.b) / (a.dur / a.spd);
	            if (a.s >= 1) {
	                delete animations[i];
	                a.s = 1;
	                len--;
	                (function (a) {
	                    setTimeout(function () {
	                        eve("mina.finish." + a.id, a);
	                    });
	                }(a));
	            }
	            a.update();
	        }
	        len && requestAnimFrame(frame);
	    },
	    /*\
	     * mina
	     [ method ]
	     **
	     * Generic animation of numbers
	     **
	     - a (number) start _slave_ number
	     - A (number) end _slave_ number
	     - b (number) start _master_ number (start time in general case)
	     - B (number) end _master_ number (end time in gereal case)
	     - get (function) getter of _master_ number (see @mina.time)
	     - set (function) setter of _slave_ number
	     - easing (function) #optional easing function, default is @mina.linear
	     = (object) animation descriptor
	     o {
	     o         id (string) animation id,
	     o         start (number) start _slave_ number,
	     o         end (number) end _slave_ number,
	     o         b (number) start _master_ number,
	     o         s (number) animation status (0..1),
	     o         dur (number) animation duration,
	     o         spd (number) animation speed,
	     o         get (function) getter of _master_ number (see @mina.time),
	     o         set (function) setter of _slave_ number,
	     o         easing (function) easing function, default is @mina.linear,
	     o         status (function) status getter/setter,
	     o         speed (function) speed getter/setter,
	     o         duration (function) duration getter/setter,
	     o         stop (function) animation stopper
	     o         pause (function) pauses the animation
	     o         resume (function) resumes the animation
	     o         update (function) calles setter with the right value of the animation
	     o }
	    \*/
	    mina = function (a, A, b, B, get, set, easing) {
	        var anim = {
	            id: ID(),
	            start: a,
	            end: A,
	            b: b,
	            s: 0,
	            dur: B - b,
	            spd: 1,
	            get: get,
	            set: set,
	            easing: easing || mina.linear,
	            status: sta,
	            speed: speed,
	            duration: duration,
	            stop: stopit,
	            pause: pause,
	            resume: resume,
	            update: update
	        };
	        animations[anim.id] = anim;
	        var len = 0, i;
	        for (i in animations) if (animations.hasOwnProperty(i)) {
	            len++;
	            if (len == 2) {
	                break;
	            }
	        }
	        len == 1 && requestAnimFrame(frame);
	        return anim;
	    };
	    /*\
	     * mina.time
	     [ method ]
	     **
	     * Returns the current time. Equivalent to:
	     | function () {
	     |     return (new Date).getTime();
	     | }
	    \*/
	    mina.time = timer;
	    /*\
	     * mina.getById
	     [ method ]
	     **
	     * Returns an animation by its id
	     - id (string) animation's id
	     = (object) See @mina
	    \*/
	    mina.getById = function (id) {
	        return animations[id] || null;
	    };
	
	    /*\
	     * mina.linear
	     [ method ]
	     **
	     * Default linear easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.linear = function (n) {
	        return n;
	    };
	    /*\
	     * mina.easeout
	     [ method ]
	     **
	     * Easeout easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.easeout = function (n) {
	        return Math.pow(n, 1.7);
	    };
	    /*\
	     * mina.easein
	     [ method ]
	     **
	     * Easein easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.easein = function (n) {
	        return Math.pow(n, .48);
	    };
	    /*\
	     * mina.easeinout
	     [ method ]
	     **
	     * Easeinout easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.easeinout = function (n) {
	        if (n == 1) {
	            return 1;
	        }
	        if (n == 0) {
	            return 0;
	        }
	        var q = .48 - n / 1.04,
	            Q = Math.sqrt(.1734 + q * q),
	            x = Q - q,
	            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),
	            y = -Q - q,
	            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),
	            t = X + Y + .5;
	        return (1 - t) * 3 * t * t + t * t * t;
	    };
	    /*\
	     * mina.backin
	     [ method ]
	     **
	     * Backin easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.backin = function (n) {
	        if (n == 1) {
	            return 1;
	        }
	        var s = 1.70158;
	        return n * n * ((s + 1) * n - s);
	    };
	    /*\
	     * mina.backout
	     [ method ]
	     **
	     * Backout easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.backout = function (n) {
	        if (n == 0) {
	            return 0;
	        }
	        n = n - 1;
	        var s = 1.70158;
	        return n * n * ((s + 1) * n + s) + 1;
	    };
	    /*\
	     * mina.elastic
	     [ method ]
	     **
	     * Elastic easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.elastic = function (n) {
	        if (n == !!n) {
	            return n;
	        }
	        return Math.pow(2, -10 * n) * Math.sin((n - .075) *
	            (2 * Math.PI) / .3) + 1;
	    };
	    /*\
	     * mina.bounce
	     [ method ]
	     **
	     * Bounce easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.bounce = function (n) {
	        var s = 7.5625,
	            p = 2.75,
	            l;
	        if (n < (1 / p)) {
	            l = s * n * n;
	        } else {
	            if (n < (2 / p)) {
	                n -= (1.5 / p);
	                l = s * n * n + .75;
	            } else {
	                if (n < (2.5 / p)) {
	                    n -= (2.25 / p);
	                    l = s * n * n + .9375;
	                } else {
	                    n -= (2.625 / p);
	                    l = s * n * n + .984375;
	                }
	            }
	        }
	        return l;
	    };
	    window.mina = mina;
	    return mina;
	})(typeof eve == "undefined" ? function () {} : eve);
	// Copyright (c) 2013 - 2015 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	
	var Snap = (function(root) {
	Snap.version = "0.4.0";
	/*\
	 * Snap
	 [ method ]
	 **
	 * Creates a drawing surface or wraps existing SVG element.
	 **
	 - width (number|string) width of surface
	 - height (number|string) height of surface
	 * or
	 - DOM (SVGElement) element to be wrapped into Snap structure
	 * or
	 - array (array) array of elements (will return set of elements)
	 * or
	 - query (string) CSS query selector
	 = (object) @Element
	\*/
	function Snap(w, h) {
	    if (w) {
	        if (w.nodeType) {
	            return wrap(w);
	        }
	        if (is(w, "array") && Snap.set) {
	            return Snap.set.apply(Snap, w);
	        }
	        if (w instanceof Element) {
	            return w;
	        }
	        if (h == null) {
	            w = glob.doc.querySelector(String(w));
	            return wrap(w);
	        }
	    }
	    w = w == null ? "100%" : w;
	    h = h == null ? "100%" : h;
	    return new Paper(w, h);
	}
	Snap.toString = function () {
	    return "Snap v" + this.version;
	};
	Snap._ = {};
	var glob = {
	    win: root.window,
	    doc: root.window.document
	};
	Snap._.glob = glob;
	var has = "hasOwnProperty",
	    Str = String,
	    toFloat = parseFloat,
	    toInt = parseInt,
	    math = Math,
	    mmax = math.max,
	    mmin = math.min,
	    abs = math.abs,
	    pow = math.pow,
	    PI = math.PI,
	    round = math.round,
	    E = "",
	    S = " ",
	    objectToString = Object.prototype.toString,
	    ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
	    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,
	    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
	    reURLValue = /^url\(#?([^)]+)\)$/,
	    separator = Snap._.separator = /[,\s]+/,
	    whitespace = /[\s]/g,
	    commaSpaces = /[\s]*,[\s]*/,
	    hsrg = {hs: 1, rg: 1},
	    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
	    tCommand = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
	    pathValues = /(-?\d*\.?\d*(?:e[\-+]?\\d+)?)[\s]*,?[\s]*/ig,
	    idgen = 0,
	    idprefix = "S" + (+new Date).toString(36),
	    ID = function (el) {
	        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);
	    },
	    xlink = "http://www.w3.org/1999/xlink",
	    xmlns = "http://www.w3.org/2000/svg",
	    hub = {},
	    URL = Snap.url = function (url) {
	        return "url('#" + url + "')";
	    };
	
	function $(el, attr) {
	    if (attr) {
	        if (el == "#text") {
	            el = glob.doc.createTextNode(attr.text || attr["#text"] || "");
	        }
	        if (el == "#comment") {
	            el = glob.doc.createComment(attr.text || attr["#text"] || "");
	        }
	        if (typeof el == "string") {
	            el = $(el);
	        }
	        if (typeof attr == "string") {
	            if (el.nodeType == 1) {
	                if (attr.substring(0, 6) == "xlink:") {
	                    return el.getAttributeNS(xlink, attr.substring(6));
	                }
	                if (attr.substring(0, 4) == "xml:") {
	                    return el.getAttributeNS(xmlns, attr.substring(4));
	                }
	                return el.getAttribute(attr);
	            } else if (attr == "text") {
	                return el.nodeValue;
	            } else {
	                return null;
	            }
	        }
	        if (el.nodeType == 1) {
	            for (var key in attr) if (attr[has](key)) {
	                var val = Str(attr[key]);
	                if (val) {
	                    if (key.substring(0, 6) == "xlink:") {
	                        el.setAttributeNS(xlink, key.substring(6), val);
	                    } else if (key.substring(0, 4) == "xml:") {
	                        el.setAttributeNS(xmlns, key.substring(4), val);
	                    } else {
	                        el.setAttribute(key, val);
	                    }
	                } else {
	                    el.removeAttribute(key);
	                }
	            }
	        } else if ("text" in attr) {
	            el.nodeValue = attr.text;
	        }
	    } else {
	        el = glob.doc.createElementNS(xmlns, el);
	    }
	    return el;
	}
	Snap._.$ = $;
	Snap._.id = ID;
	function getAttrs(el) {
	    var attrs = el.attributes,
	        name,
	        out = {};
	    for (var i = 0; i < attrs.length; i++) {
	        if (attrs[i].namespaceURI == xlink) {
	            name = "xlink:";
	        } else {
	            name = "";
	        }
	        name += attrs[i].name;
	        out[name] = attrs[i].textContent;
	    }
	    return out;
	}
	function is(o, type) {
	    type = Str.prototype.toLowerCase.call(type);
	    if (type == "finite") {
	        return isFinite(o);
	    }
	    if (type == "array" &&
	        (o instanceof Array || Array.isArray && Array.isArray(o))) {
	        return true;
	    }
	    return  (type == "null" && o === null) ||
	            (type == typeof o && o !== null) ||
	            (type == "object" && o === Object(o)) ||
	            objectToString.call(o).slice(8, -1).toLowerCase() == type;
	}
	/*\
	 * Snap.format
	 [ method ]
	 **
	 * Replaces construction of type `{<name>}` to the corresponding argument
	 **
	 - token (string) string to format
	 - json (object) object which properties are used as a replacement
	 = (string) formatted string
	 > Usage
	 | // this draws a rectangular shape equivalent to "M10,20h40v50h-40z"
	 | paper.path(Snap.format("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
	 |     x: 10,
	 |     y: 20,
	 |     dim: {
	 |         width: 40,
	 |         height: 50,
	 |         "negative width": -40
	 |     }
	 | }));
	\*/
	Snap.format = (function () {
	    var tokenRegex = /\{([^\}]+)\}/g,
	        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
	        replacer = function (all, key, obj) {
	            var res = obj;
	            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
	                name = name || quotedName;
	                if (res) {
	                    if (name in res) {
	                        res = res[name];
	                    }
	                    typeof res == "function" && isFunc && (res = res());
	                }
	            });
	            res = (res == null || res == obj ? all : res) + "";
	            return res;
	        };
	    return function (str, obj) {
	        return Str(str).replace(tokenRegex, function (all, key) {
	            return replacer(all, key, obj);
	        });
	    };
	})();
	function clone(obj) {
	    if (typeof obj == "function" || Object(obj) !== obj) {
	        return obj;
	    }
	    var res = new obj.constructor;
	    for (var key in obj) if (obj[has](key)) {
	        res[key] = clone(obj[key]);
	    }
	    return res;
	}
	Snap._.clone = clone;
	function repush(array, item) {
	    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
	        return array.push(array.splice(i, 1)[0]);
	    }
	}
	function cacher(f, scope, postprocessor) {
	    function newf() {
	        var arg = Array.prototype.slice.call(arguments, 0),
	            args = arg.join("\u2400"),
	            cache = newf.cache = newf.cache || {},
	            count = newf.count = newf.count || [];
	        if (cache[has](args)) {
	            repush(count, args);
	            return postprocessor ? postprocessor(cache[args]) : cache[args];
	        }
	        count.length >= 1e3 && delete cache[count.shift()];
	        count.push(args);
	        cache[args] = f.apply(scope, arg);
	        return postprocessor ? postprocessor(cache[args]) : cache[args];
	    }
	    return newf;
	}
	Snap._.cacher = cacher;
	function angle(x1, y1, x2, y2, x3, y3) {
	    if (x3 == null) {
	        var x = x1 - x2,
	            y = y1 - y2;
	        if (!x && !y) {
	            return 0;
	        }
	        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
	    } else {
	        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);
	    }
	}
	function rad(deg) {
	    return deg % 360 * PI / 180;
	}
	function deg(rad) {
	    return rad * 180 / PI % 360;
	}
	function x_y() {
	    return this.x + S + this.y;
	}
	function x_y_w_h() {
	    return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
	}
	
	/*\
	 * Snap.rad
	 [ method ]
	 **
	 * Transform angle to radians
	 - deg (number) angle in degrees
	 = (number) angle in radians
	\*/
	Snap.rad = rad;
	/*\
	 * Snap.deg
	 [ method ]
	 **
	 * Transform angle to degrees
	 - rad (number) angle in radians
	 = (number) angle in degrees
	\*/
	Snap.deg = deg;
	/*\
	 * Snap.sin
	 [ method ]
	 **
	 * Equivalent to `Math.sin()` only works with degrees, not radians.
	 - angle (number) angle in degrees
	 = (number) sin
	\*/
	Snap.sin = function (angle) {
	    return math.sin(Snap.rad(angle));
	};
	/*\
	 * Snap.tan
	 [ method ]
	 **
	 * Equivalent to `Math.tan()` only works with degrees, not radians.
	 - angle (number) angle in degrees
	 = (number) tan
	\*/
	Snap.tan = function (angle) {
	    return math.tan(Snap.rad(angle));
	};
	/*\
	 * Snap.cos
	 [ method ]
	 **
	 * Equivalent to `Math.cos()` only works with degrees, not radians.
	 - angle (number) angle in degrees
	 = (number) cos
	\*/
	Snap.cos = function (angle) {
	    return math.cos(Snap.rad(angle));
	};
	/*\
	 * Snap.asin
	 [ method ]
	 **
	 * Equivalent to `Math.asin()` only works with degrees, not radians.
	 - num (number) value
	 = (number) asin in degrees
	\*/
	Snap.asin = function (num) {
	    return Snap.deg(math.asin(num));
	};
	/*\
	 * Snap.acos
	 [ method ]
	 **
	 * Equivalent to `Math.acos()` only works with degrees, not radians.
	 - num (number) value
	 = (number) acos in degrees
	\*/
	Snap.acos = function (num) {
	    return Snap.deg(math.acos(num));
	};
	/*\
	 * Snap.atan
	 [ method ]
	 **
	 * Equivalent to `Math.atan()` only works with degrees, not radians.
	 - num (number) value
	 = (number) atan in degrees
	\*/
	Snap.atan = function (num) {
	    return Snap.deg(math.atan(num));
	};
	/*\
	 * Snap.atan2
	 [ method ]
	 **
	 * Equivalent to `Math.atan2()` only works with degrees, not radians.
	 - num (number) value
	 = (number) atan2 in degrees
	\*/
	Snap.atan2 = function (num) {
	    return Snap.deg(math.atan2(num));
	};
	/*\
	 * Snap.angle
	 [ method ]
	 **
	 * Returns an angle between two or three points
	 > Parameters
	 - x1 (number) x coord of first point
	 - y1 (number) y coord of first point
	 - x2 (number) x coord of second point
	 - y2 (number) y coord of second point
	 - x3 (number) #optional x coord of third point
	 - y3 (number) #optional y coord of third point
	 = (number) angle in degrees
	\*/
	Snap.angle = angle;
	/*\
	 * Snap.len
	 [ method ]
	 **
	 * Returns distance between two points
	 > Parameters
	 - x1 (number) x coord of first point
	 - y1 (number) y coord of first point
	 - x2 (number) x coord of second point
	 - y2 (number) y coord of second point
	 = (number) distance
	\*/
	Snap.len = function (x1, y1, x2, y2) {
	    return Math.sqrt(Snap.len2(x1, y1, x2, y2));
	};
	/*\
	 * Snap.len2
	 [ method ]
	 **
	 * Returns squared distance between two points
	 > Parameters
	 - x1 (number) x coord of first point
	 - y1 (number) y coord of first point
	 - x2 (number) x coord of second point
	 - y2 (number) y coord of second point
	 = (number) distance
	\*/
	Snap.len2 = function (x1, y1, x2, y2) {
	    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	};
	/*\
	 * Snap.closestPoint
	 [ method ]
	 **
	 * Returns closest point to a given one on a given path.
	 > Parameters
	 - path (Element) path element
	 - x (number) x coord of a point
	 - y (number) y coord of a point
	 = (object) in format
	 {
	    x (number) x coord of the point on the path
	    y (number) y coord of the point on the path
	    length (number) length of the path to the point
	    distance (number) distance from the given point to the path
	 }
	\*/
	// Copied from http://bl.ocks.org/mbostock/8027637
	Snap.closestPoint = function (path, x, y) {
	    function distance2(p) {
	        var dx = p.x - x,
	            dy = p.y - y;
	        return dx * dx + dy * dy;
	    }
	    var pathNode = path.node,
	        pathLength = pathNode.getTotalLength(),
	        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,
	        best,
	        bestLength,
	        bestDistance = Infinity;
	
	    // linear scan for coarse approximation
	    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
	        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
	            best = scan, bestLength = scanLength, bestDistance = scanDistance;
	        }
	    }
	
	    // binary search for precise estimate
	    precision *= .5;
	    while (precision > .5) {
	        var before,
	            after,
	            beforeLength,
	            afterLength,
	            beforeDistance,
	            afterDistance;
	        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
	            best = before, bestLength = beforeLength, bestDistance = beforeDistance;
	        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
	            best = after, bestLength = afterLength, bestDistance = afterDistance;
	        } else {
	            precision *= .5;
	        }
	    }
	
	    best = {
	        x: best.x,
	        y: best.y,
	        length: bestLength,
	        distance: Math.sqrt(bestDistance)
	    };
	    return best;
	}
	/*\
	 * Snap.is
	 [ method ]
	 **
	 * Handy replacement for the `typeof` operator
	 - o (…) any object or primitive
	 - type (string) name of the type, e.g., `string`, `function`, `number`, etc.
	 = (boolean) `true` if given value is of given type
	\*/
	Snap.is = is;
	/*\
	 * Snap.snapTo
	 [ method ]
	 **
	 * Snaps given value to given grid
	 - values (array|number) given array of values or step of the grid
	 - value (number) value to adjust
	 - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.
	 = (number) adjusted value
	\*/
	Snap.snapTo = function (values, value, tolerance) {
	    tolerance = is(tolerance, "finite") ? tolerance : 10;
	    if (is(values, "array")) {
	        var i = values.length;
	        while (i--) if (abs(values[i] - value) <= tolerance) {
	            return values[i];
	        }
	    } else {
	        values = +values;
	        var rem = value % values;
	        if (rem < tolerance) {
	            return value - rem;
	        }
	        if (rem > values - tolerance) {
	            return value - rem + values;
	        }
	    }
	    return value;
	};
	// Colour
	/*\
	 * Snap.getRGB
	 [ method ]
	 **
	 * Parses color string as RGB object
	 - color (string) color string in one of the following formats:
	 # <ul>
	 #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
	 #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>
	 #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>
	 #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
	 #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>
	 #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
	 #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>
	 #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
	 #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>
	 #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
	 #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>
	 #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>
	 #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>
	 #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
	 #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>
	 # </ul>
	 * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.
	 = (object) RGB object in the following format:
	 o {
	 o     r (number) red,
	 o     g (number) green,
	 o     b (number) blue,
	 o     hex (string) color in HTML/CSS format: #••••••,
	 o     error (boolean) true if string can't be parsed
	 o }
	\*/
	Snap.getRGB = cacher(function (colour) {
	    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
	        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
	    }
	    if (colour == "none") {
	        return {r: -1, g: -1, b: -1, hex: "none", toString: rgbtoString};
	    }
	    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
	    if (!colour) {
	        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
	    }
	    var res,
	        red,
	        green,
	        blue,
	        opacity,
	        t,
	        values,
	        rgb = colour.match(colourRegExp);
	    if (rgb) {
	        if (rgb[2]) {
	            blue = toInt(rgb[2].substring(5), 16);
	            green = toInt(rgb[2].substring(3, 5), 16);
	            red = toInt(rgb[2].substring(1, 3), 16);
	        }
	        if (rgb[3]) {
	            blue = toInt((t = rgb[3].charAt(3)) + t, 16);
	            green = toInt((t = rgb[3].charAt(2)) + t, 16);
	            red = toInt((t = rgb[3].charAt(1)) + t, 16);
	        }
	        if (rgb[4]) {
	            values = rgb[4].split(commaSpaces);
	            red = toFloat(values[0]);
	            values[0].slice(-1) == "%" && (red *= 2.55);
	            green = toFloat(values[1]);
	            values[1].slice(-1) == "%" && (green *= 2.55);
	            blue = toFloat(values[2]);
	            values[2].slice(-1) == "%" && (blue *= 2.55);
	            rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
	            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
	        }
	        if (rgb[5]) {
	            values = rgb[5].split(commaSpaces);
	            red = toFloat(values[0]);
	            values[0].slice(-1) == "%" && (red /= 100);
	            green = toFloat(values[1]);
	            values[1].slice(-1) == "%" && (green /= 100);
	            blue = toFloat(values[2]);
	            values[2].slice(-1) == "%" && (blue /= 100);
	            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
	            rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
	            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
	            return Snap.hsb2rgb(red, green, blue, opacity);
	        }
	        if (rgb[6]) {
	            values = rgb[6].split(commaSpaces);
	            red = toFloat(values[0]);
	            values[0].slice(-1) == "%" && (red /= 100);
	            green = toFloat(values[1]);
	            values[1].slice(-1) == "%" && (green /= 100);
	            blue = toFloat(values[2]);
	            values[2].slice(-1) == "%" && (blue /= 100);
	            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
	            rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
	            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
	            return Snap.hsl2rgb(red, green, blue, opacity);
	        }
	        red = mmin(math.round(red), 255);
	        green = mmin(math.round(green), 255);
	        blue = mmin(math.round(blue), 255);
	        opacity = mmin(mmax(opacity, 0), 1);
	        rgb = {r: red, g: green, b: blue, toString: rgbtoString};
	        rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
	        rgb.opacity = is(opacity, "finite") ? opacity : 1;
	        return rgb;
	    }
	    return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
	}, Snap);
	/*\
	 * Snap.hsb
	 [ method ]
	 **
	 * Converts HSB values to a hex representation of the color
	 - h (number) hue
	 - s (number) saturation
	 - b (number) value or brightness
	 = (string) hex representation of the color
	\*/
	Snap.hsb = cacher(function (h, s, b) {
	    return Snap.hsb2rgb(h, s, b).hex;
	});
	/*\
	 * Snap.hsl
	 [ method ]
	 **
	 * Converts HSL values to a hex representation of the color
	 - h (number) hue
	 - s (number) saturation
	 - l (number) luminosity
	 = (string) hex representation of the color
	\*/
	Snap.hsl = cacher(function (h, s, l) {
	    return Snap.hsl2rgb(h, s, l).hex;
	});
	/*\
	 * Snap.rgb
	 [ method ]
	 **
	 * Converts RGB values to a hex representation of the color
	 - r (number) red
	 - g (number) green
	 - b (number) blue
	 = (string) hex representation of the color
	\*/
	Snap.rgb = cacher(function (r, g, b, o) {
	    if (is(o, "finite")) {
	        var round = math.round;
	        return "rgba(" + [round(r), round(g), round(b), +o.toFixed(2)] + ")";
	    }
	    return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
	});
	var toHex = function (color) {
	    var i = glob.doc.getElementsByTagName("head")[0] || glob.doc.getElementsByTagName("svg")[0],
	        red = "rgb(255, 0, 0)";
	    toHex = cacher(function (color) {
	        if (color.toLowerCase() == "red") {
	            return red;
	        }
	        i.style.color = red;
	        i.style.color = color;
	        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
	        return out == red ? null : out;
	    });
	    return toHex(color);
	},
	hsbtoString = function () {
	    return "hsb(" + [this.h, this.s, this.b] + ")";
	},
	hsltoString = function () {
	    return "hsl(" + [this.h, this.s, this.l] + ")";
	},
	rgbtoString = function () {
	    return this.opacity == 1 || this.opacity == null ?
	            this.hex :
	            "rgba(" + [this.r, this.g, this.b, this.opacity] + ")";
	},
	prepareRGB = function (r, g, b) {
	    if (g == null && is(r, "object") && "r" in r && "g" in r && "b" in r) {
	        b = r.b;
	        g = r.g;
	        r = r.r;
	    }
	    if (g == null && is(r, string)) {
	        var clr = Snap.getRGB(r);
	        r = clr.r;
	        g = clr.g;
	        b = clr.b;
	    }
	    if (r > 1 || g > 1 || b > 1) {
	        r /= 255;
	        g /= 255;
	        b /= 255;
	    }
	
	    return [r, g, b];
	},
	packageRGB = function (r, g, b, o) {
	    r = math.round(r * 255);
	    g = math.round(g * 255);
	    b = math.round(b * 255);
	    var rgb = {
	        r: r,
	        g: g,
	        b: b,
	        opacity: is(o, "finite") ? o : 1,
	        hex: Snap.rgb(r, g, b),
	        toString: rgbtoString
	    };
	    is(o, "finite") && (rgb.opacity = o);
	    return rgb;
	};
	/*\
	 * Snap.color
	 [ method ]
	 **
	 * Parses the color string and returns an object featuring the color's component values
	 - clr (string) color string in one of the supported formats (see @Snap.getRGB)
	 = (object) Combined RGB/HSB object in the following format:
	 o {
	 o     r (number) red,
	 o     g (number) green,
	 o     b (number) blue,
	 o     hex (string) color in HTML/CSS format: #••••••,
	 o     error (boolean) `true` if string can't be parsed,
	 o     h (number) hue,
	 o     s (number) saturation,
	 o     v (number) value (brightness),
	 o     l (number) lightness
	 o }
	\*/
	Snap.color = function (clr) {
	    var rgb;
	    if (is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
	        rgb = Snap.hsb2rgb(clr);
	        clr.r = rgb.r;
	        clr.g = rgb.g;
	        clr.b = rgb.b;
	        clr.opacity = 1;
	        clr.hex = rgb.hex;
	    } else if (is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
	        rgb = Snap.hsl2rgb(clr);
	        clr.r = rgb.r;
	        clr.g = rgb.g;
	        clr.b = rgb.b;
	        clr.opacity = 1;
	        clr.hex = rgb.hex;
	    } else {
	        if (is(clr, "string")) {
	            clr = Snap.getRGB(clr);
	        }
	        if (is(clr, "object") && "r" in clr && "g" in clr && "b" in clr && !("error" in clr)) {
	            rgb = Snap.rgb2hsl(clr);
	            clr.h = rgb.h;
	            clr.s = rgb.s;
	            clr.l = rgb.l;
	            rgb = Snap.rgb2hsb(clr);
	            clr.v = rgb.b;
	        } else {
	            clr = {hex: "none"};
	            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
	            clr.error = 1;
	        }
	    }
	    clr.toString = rgbtoString;
	    return clr;
	};
	/*\
	 * Snap.hsb2rgb
	 [ method ]
	 **
	 * Converts HSB values to an RGB object
	 - h (number) hue
	 - s (number) saturation
	 - v (number) value or brightness
	 = (object) RGB object in the following format:
	 o {
	 o     r (number) red,
	 o     g (number) green,
	 o     b (number) blue,
	 o     hex (string) color in HTML/CSS format: #••••••
	 o }
	\*/
	Snap.hsb2rgb = function (h, s, v, o) {
	    if (is(h, "object") && "h" in h && "s" in h && "b" in h) {
	        v = h.b;
	        s = h.s;
	        o = h.o;
	        h = h.h;
	    }
	    h *= 360;
	    var R, G, B, X, C;
	    h = (h % 360) / 60;
	    C = v * s;
	    X = C * (1 - abs(h % 2 - 1));
	    R = G = B = v - C;
	
	    h = ~~h;
	    R += [C, X, 0, 0, X, C][h];
	    G += [X, C, C, X, 0, 0][h];
	    B += [0, 0, X, C, C, X][h];
	    return packageRGB(R, G, B, o);
	};
	/*\
	 * Snap.hsl2rgb
	 [ method ]
	 **
	 * Converts HSL values to an RGB object
	 - h (number) hue
	 - s (number) saturation
	 - l (number) luminosity
	 = (object) RGB object in the following format:
	 o {
	 o     r (number) red,
	 o     g (number) green,
	 o     b (number) blue,
	 o     hex (string) color in HTML/CSS format: #••••••
	 o }
	\*/
	Snap.hsl2rgb = function (h, s, l, o) {
	    if (is(h, "object") && "h" in h && "s" in h && "l" in h) {
	        l = h.l;
	        s = h.s;
	        h = h.h;
	    }
	    if (h > 1 || s > 1 || l > 1) {
	        h /= 360;
	        s /= 100;
	        l /= 100;
	    }
	    h *= 360;
	    var R, G, B, X, C;
	    h = (h % 360) / 60;
	    C = 2 * s * (l < .5 ? l : 1 - l);
	    X = C * (1 - abs(h % 2 - 1));
	    R = G = B = l - C / 2;
	
	    h = ~~h;
	    R += [C, X, 0, 0, X, C][h];
	    G += [X, C, C, X, 0, 0][h];
	    B += [0, 0, X, C, C, X][h];
	    return packageRGB(R, G, B, o);
	};
	/*\
	 * Snap.rgb2hsb
	 [ method ]
	 **
	 * Converts RGB values to an HSB object
	 - r (number) red
	 - g (number) green
	 - b (number) blue
	 = (object) HSB object in the following format:
	 o {
	 o     h (number) hue,
	 o     s (number) saturation,
	 o     b (number) brightness
	 o }
	\*/
	Snap.rgb2hsb = function (r, g, b) {
	    b = prepareRGB(r, g, b);
	    r = b[0];
	    g = b[1];
	    b = b[2];
	
	    var H, S, V, C;
	    V = mmax(r, g, b);
	    C = V - mmin(r, g, b);
	    H = (C == 0 ? null :
	         V == r ? (g - b) / C :
	         V == g ? (b - r) / C + 2 :
	                  (r - g) / C + 4
	        );
	    H = ((H + 360) % 6) * 60 / 360;
	    S = C == 0 ? 0 : C / V;
	    return {h: H, s: S, b: V, toString: hsbtoString};
	};
	/*\
	 * Snap.rgb2hsl
	 [ method ]
	 **
	 * Converts RGB values to an HSL object
	 - r (number) red
	 - g (number) green
	 - b (number) blue
	 = (object) HSL object in the following format:
	 o {
	 o     h (number) hue,
	 o     s (number) saturation,
	 o     l (number) luminosity
	 o }
	\*/
	Snap.rgb2hsl = function (r, g, b) {
	    b = prepareRGB(r, g, b);
	    r = b[0];
	    g = b[1];
	    b = b[2];
	
	    var H, S, L, M, m, C;
	    M = mmax(r, g, b);
	    m = mmin(r, g, b);
	    C = M - m;
	    H = (C == 0 ? null :
	         M == r ? (g - b) / C :
	         M == g ? (b - r) / C + 2 :
	                  (r - g) / C + 4);
	    H = ((H + 360) % 6) * 60 / 360;
	    L = (M + m) / 2;
	    S = (C == 0 ? 0 :
	         L < .5 ? C / (2 * L) :
	                  C / (2 - 2 * L));
	    return {h: H, s: S, l: L, toString: hsltoString};
	};
	
	// Transformations
	/*\
	 * Snap.parsePathString
	 [ method ]
	 **
	 * Utility method
	 **
	 * Parses given path string into an array of arrays of path segments
	 - pathString (string|array) path string or array of segments (in the last case it is returned straight away)
	 = (array) array of segments
	\*/
	Snap.parsePathString = function (pathString) {
	    if (!pathString) {
	        return null;
	    }
	    var pth = Snap.path(pathString);
	    if (pth.arr) {
	        return Snap.path.clone(pth.arr);
	    }
	
	    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},
	        data = [];
	    if (is(pathString, "array") && is(pathString[0], "array")) { // rough assumption
	        data = Snap.path.clone(pathString);
	    }
	    if (!data.length) {
	        Str(pathString).replace(pathCommand, function (a, b, c) {
	            var params = [],
	                name = b.toLowerCase();
	            c.replace(pathValues, function (a, b) {
	                b && params.push(+b);
	            });
	            if (name == "m" && params.length > 2) {
	                data.push([b].concat(params.splice(0, 2)));
	                name = "l";
	                b = b == "m" ? "l" : "L";
	            }
	            if (name == "o" && params.length == 1) {
	                data.push([b, params[0]]);
	            }
	            if (name == "r") {
	                data.push([b].concat(params));
	            } else while (params.length >= paramCounts[name]) {
	                data.push([b].concat(params.splice(0, paramCounts[name])));
	                if (!paramCounts[name]) {
	                    break;
	                }
	            }
	        });
	    }
	    data.toString = Snap.path.toString;
	    pth.arr = Snap.path.clone(data);
	    return data;
	};
	/*\
	 * Snap.parseTransformString
	 [ method ]
	 **
	 * Utility method
	 **
	 * Parses given transform string into an array of transformations
	 - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)
	 = (array) array of transformations
	\*/
	var parseTransformString = Snap.parseTransformString = function (TString) {
	    if (!TString) {
	        return null;
	    }
	    var paramCounts = {r: 3, s: 4, t: 2, m: 6},
	        data = [];
	    if (is(TString, "array") && is(TString[0], "array")) { // rough assumption
	        data = Snap.path.clone(TString);
	    }
	    if (!data.length) {
	        Str(TString).replace(tCommand, function (a, b, c) {
	            var params = [],
	                name = b.toLowerCase();
	            c.replace(pathValues, function (a, b) {
	                b && params.push(+b);
	            });
	            data.push([b].concat(params));
	        });
	    }
	    data.toString = Snap.path.toString;
	    return data;
	};
	function svgTransform2string(tstr) {
	    var res = [];
	    tstr = tstr.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g, function (all, name, params) {
	        params = params.split(/\s*,\s*|\s+/);
	        if (name == "rotate" && params.length == 1) {
	            params.push(0, 0);
	        }
	        if (name == "scale") {
	            if (params.length > 2) {
	                params = params.slice(0, 2);
	            } else if (params.length == 2) {
	                params.push(0, 0);
	            }
	            if (params.length == 1) {
	                params.push(params[0], 0, 0);
	            }
	        }
	        if (name == "skewX") {
	            res.push(["m", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);
	        } else if (name == "skewY") {
	            res.push(["m", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);
	        } else {
	            res.push([name.charAt(0)].concat(params));
	        }
	        return all;
	    });
	    return res;
	}
	Snap._.svgTransform2string = svgTransform2string;
	Snap._.rgTransform = /^[a-z][\s]*-?\.?\d/i;
	function transform2matrix(tstr, bbox) {
	    var tdata = parseTransformString(tstr),
	        m = new Snap.Matrix;
	    if (tdata) {
	        for (var i = 0, ii = tdata.length; i < ii; i++) {
	            var t = tdata[i],
	                tlen = t.length,
	                command = Str(t[0]).toLowerCase(),
	                absolute = t[0] != command,
	                inver = absolute ? m.invert() : 0,
	                x1,
	                y1,
	                x2,
	                y2,
	                bb;
	            if (command == "t" && tlen == 2){
	                m.translate(t[1], 0);
	            } else if (command == "t" && tlen == 3) {
	                if (absolute) {
	                    x1 = inver.x(0, 0);
	                    y1 = inver.y(0, 0);
	                    x2 = inver.x(t[1], t[2]);
	                    y2 = inver.y(t[1], t[2]);
	                    m.translate(x2 - x1, y2 - y1);
	                } else {
	                    m.translate(t[1], t[2]);
	                }
	            } else if (command == "r") {
	                if (tlen == 2) {
	                    bb = bb || bbox;
	                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
	                } else if (tlen == 4) {
	                    if (absolute) {
	                        x2 = inver.x(t[2], t[3]);
	                        y2 = inver.y(t[2], t[3]);
	                        m.rotate(t[1], x2, y2);
	                    } else {
	                        m.rotate(t[1], t[2], t[3]);
	                    }
	                }
	            } else if (command == "s") {
	                if (tlen == 2 || tlen == 3) {
	                    bb = bb || bbox;
	                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
	                } else if (tlen == 4) {
	                    if (absolute) {
	                        x2 = inver.x(t[2], t[3]);
	                        y2 = inver.y(t[2], t[3]);
	                        m.scale(t[1], t[1], x2, y2);
	                    } else {
	                        m.scale(t[1], t[1], t[2], t[3]);
	                    }
	                } else if (tlen == 5) {
	                    if (absolute) {
	                        x2 = inver.x(t[3], t[4]);
	                        y2 = inver.y(t[3], t[4]);
	                        m.scale(t[1], t[2], x2, y2);
	                    } else {
	                        m.scale(t[1], t[2], t[3], t[4]);
	                    }
	                }
	            } else if (command == "m" && tlen == 7) {
	                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
	            }
	        }
	    }
	    return m;
	}
	Snap._.transform2matrix = transform2matrix;
	Snap._unit2px = unit2px;
	var contains = glob.doc.contains || glob.doc.compareDocumentPosition ?
	    function (a, b) {
	        var adown = a.nodeType == 9 ? a.documentElement : a,
	            bup = b && b.parentNode;
	            return a == bup || !!(bup && bup.nodeType == 1 && (
	                adown.contains ?
	                    adown.contains(bup) :
	                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
	            ));
	    } :
	    function (a, b) {
	        if (b) {
	            while (b) {
	                b = b.parentNode;
	                if (b == a) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    };
	function getSomeDefs(el) {
	    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||
	            (el.node.parentNode && wrap(el.node.parentNode)) ||
	            Snap.select("svg") ||
	            Snap(0, 0),
	        pdefs = p.select("defs"),
	        defs  = pdefs == null ? false : pdefs.node;
	    if (!defs) {
	        defs = make("defs", p.node).node;
	    }
	    return defs;
	}
	function getSomeSVG(el) {
	    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select("svg");
	}
	Snap._.getSomeDefs = getSomeDefs;
	Snap._.getSomeSVG = getSomeSVG;
	function unit2px(el, name, value) {
	    var svg = getSomeSVG(el).node,
	        out = {},
	        mgr = svg.querySelector(".svg---mgr");
	    if (!mgr) {
	        mgr = $("rect");
	        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, "class": "svg---mgr", fill: "none"});
	        svg.appendChild(mgr);
	    }
	    function getW(val) {
	        if (val == null) {
	            return E;
	        }
	        if (val == +val) {
	            return val;
	        }
	        $(mgr, {width: val});
	        try {
	            return mgr.getBBox().width;
	        } catch (e) {
	            return 0;
	        }
	    }
	    function getH(val) {
	        if (val == null) {
	            return E;
	        }
	        if (val == +val) {
	            return val;
	        }
	        $(mgr, {height: val});
	        try {
	            return mgr.getBBox().height;
	        } catch (e) {
	            return 0;
	        }
	    }
	    function set(nam, f) {
	        if (name == null) {
	            out[nam] = f(el.attr(nam) || 0);
	        } else if (nam == name) {
	            out = f(value == null ? el.attr(nam) || 0 : value);
	        }
	    }
	    switch (el.type) {
	        case "rect":
	            set("rx", getW);
	            set("ry", getH);
	        case "image":
	            set("width", getW);
	            set("height", getH);
	        case "text":
	            set("x", getW);
	            set("y", getH);
	        break;
	        case "circle":
	            set("cx", getW);
	            set("cy", getH);
	            set("r", getW);
	        break;
	        case "ellipse":
	            set("cx", getW);
	            set("cy", getH);
	            set("rx", getW);
	            set("ry", getH);
	        break;
	        case "line":
	            set("x1", getW);
	            set("x2", getW);
	            set("y1", getH);
	            set("y2", getH);
	        break;
	        case "marker":
	            set("refX", getW);
	            set("markerWidth", getW);
	            set("refY", getH);
	            set("markerHeight", getH);
	        break;
	        case "radialGradient":
	            set("fx", getW);
	            set("fy", getH);
	        break;
	        case "tspan":
	            set("dx", getW);
	            set("dy", getH);
	        break;
	        default:
	            set(name, getW);
	    }
	    svg.removeChild(mgr);
	    return out;
	}
	/*\
	 * Snap.select
	 [ method ]
	 **
	 * Wraps a DOM element specified by CSS selector as @Element
	 - query (string) CSS selector of the element
	 = (Element) the current element
	\*/
	Snap.select = function (query) {
	    query = Str(query).replace(/([^\\]):/g, "$1\\:");
	    return wrap(glob.doc.querySelector(query));
	};
	/*\
	 * Snap.selectAll
	 [ method ]
	 **
	 * Wraps DOM elements specified by CSS selector as set or array of @Element
	 - query (string) CSS selector of the element
	 = (Element) the current element
	\*/
	Snap.selectAll = function (query) {
	    var nodelist = glob.doc.querySelectorAll(query),
	        set = (Snap.set || Array)();
	    for (var i = 0; i < nodelist.length; i++) {
	        set.push(wrap(nodelist[i]));
	    }
	    return set;
	};
	
	function add2group(list) {
	    if (!is(list, "array")) {
	        list = Array.prototype.slice.call(arguments, 0);
	    }
	    var i = 0,
	        j = 0,
	        node = this.node;
	    while (this[i]) delete this[i++];
	    for (i = 0; i < list.length; i++) {
	        if (list[i].type == "set") {
	            list[i].forEach(function (el) {
	                node.appendChild(el.node);
	            });
	        } else {
	            node.appendChild(list[i].node);
	        }
	    }
	    var children = node.childNodes;
	    for (i = 0; i < children.length; i++) {
	        this[j++] = wrap(children[i]);
	    }
	    return this;
	}
	// Hub garbage collector every 10s
	setInterval(function () {
	    for (var key in hub) if (hub[has](key)) {
	        var el = hub[key],
	            node = el.node;
	        if (el.type != "svg" && !node.ownerSVGElement || el.type == "svg" && (!node.parentNode || "ownerSVGElement" in node.parentNode && !node.ownerSVGElement)) {
	            delete hub[key];
	        }
	    }
	}, 1e4);
	function Element(el) {
	    if (el.snap in hub) {
	        return hub[el.snap];
	    }
	    var svg;
	    try {
	        svg = el.ownerSVGElement;
	    } catch(e) {}
	    /*\
	     * Element.node
	     [ property (object) ]
	     **
	     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
	     > Usage
	     | // draw a circle at coordinate 10,10 with radius of 10
	     | var c = paper.circle(10, 10, 10);
	     | c.node.onclick = function () {
	     |     c.attr("fill", "red");
	     | };
	    \*/
	    this.node = el;
	    if (svg) {
	        this.paper = new Paper(svg);
	    }
	    /*\
	     * Element.type
	     [ property (string) ]
	     **
	     * SVG tag name of the given element.
	    \*/
	    this.type = el.tagName || el.nodeName;
	    var id = this.id = ID(this);
	    this.anims = {};
	    this._ = {
	        transform: []
	    };
	    el.snap = id;
	    hub[id] = this;
	    if (this.type == "g") {
	        this.add = add2group;
	    }
	    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {
	        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {
	            this[method] = Paper.prototype[method];
	        }
	    }
	}
	   /*\
	     * Element.attr
	     [ method ]
	     **
	     * Gets or sets given attributes of the element.
	     **
	     - params (object) contains key-value pairs of attributes you want to set
	     * or
	     - param (string) name of the attribute
	     = (Element) the current element
	     * or
	     = (string) value of attribute
	     > Usage
	     | el.attr({
	     |     fill: "#fc0",
	     |     stroke: "#000",
	     |     strokeWidth: 2, // CamelCase...
	     |     "fill-opacity": 0.5, // or dash-separated names
	     |     width: "*=2" // prefixed values
	     | });
	     | console.log(el.attr("fill")); // #fc0
	     * Prefixed values in format `"+=10"` supported. All four operations
	     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`
	     * and `-`: `"+=2em"`.
	    \*/
	    Element.prototype.attr = function (params, value) {
	        var el = this,
	            node = el.node;
	        if (!params) {
	            if (node.nodeType != 1) {
	                return {
	                    text: node.nodeValue
	                };
	            }
	            var attr = node.attributes,
	                out = {};
	            for (var i = 0, ii = attr.length; i < ii; i++) {
	                out[attr[i].nodeName] = attr[i].nodeValue;
	            }
	            return out;
	        }
	        if (is(params, "string")) {
	            if (arguments.length > 1) {
	                var json = {};
	                json[params] = value;
	                params = json;
	            } else {
	                return eve("snap.util.getattr." + params, el).firstDefined();
	            }
	        }
	        for (var att in params) {
	            if (params[has](att)) {
	                eve("snap.util.attr." + att, el, params[att]);
	            }
	        }
	        return el;
	    };
	/*\
	 * Snap.parse
	 [ method ]
	 **
	 * Parses SVG fragment and converts it into a @Fragment
	 **
	 - svg (string) SVG string
	 = (Fragment) the @Fragment
	\*/
	Snap.parse = function (svg) {
	    var f = glob.doc.createDocumentFragment(),
	        full = true,
	        div = glob.doc.createElement("div");
	    svg = Str(svg);
	    if (!svg.match(/^\s*<\s*svg(?:\s|>)/)) {
	        svg = "<svg>" + svg + "</svg>";
	        full = false;
	    }
	    div.innerHTML = svg;
	    svg = div.getElementsByTagName("svg")[0];
	    if (svg) {
	        if (full) {
	            f = svg;
	        } else {
	            while (svg.firstChild) {
	                f.appendChild(svg.firstChild);
	            }
	        }
	    }
	    return new Fragment(f);
	};
	function Fragment(frag) {
	    this.node = frag;
	}
	/*\
	 * Snap.fragment
	 [ method ]
	 **
	 * Creates a DOM fragment from a given list of elements or strings
	 **
	 - varargs (…) SVG string
	 = (Fragment) the @Fragment
	\*/
	Snap.fragment = function () {
	    var args = Array.prototype.slice.call(arguments, 0),
	        f = glob.doc.createDocumentFragment();
	    for (var i = 0, ii = args.length; i < ii; i++) {
	        var item = args[i];
	        if (item.node && item.node.nodeType) {
	            f.appendChild(item.node);
	        }
	        if (item.nodeType) {
	            f.appendChild(item);
	        }
	        if (typeof item == "string") {
	            f.appendChild(Snap.parse(item).node);
	        }
	    }
	    return new Fragment(f);
	};
	
	function make(name, parent) {
	    var res = $(name);
	    parent.appendChild(res);
	    var el = wrap(res);
	    return el;
	}
	function Paper(w, h) {
	    var res,
	        desc,
	        defs,
	        proto = Paper.prototype;
	    if (w && w.tagName == "svg") {
	        if (w.snap in hub) {
	            return hub[w.snap];
	        }
	        var doc = w.ownerDocument;
	        res = new Element(w);
	        desc = w.getElementsByTagName("desc")[0];
	        defs = w.getElementsByTagName("defs")[0];
	        if (!desc) {
	            desc = $("desc");
	            desc.appendChild(doc.createTextNode("Created with Snap"));
	            res.node.appendChild(desc);
	        }
	        if (!defs) {
	            defs = $("defs");
	            res.node.appendChild(defs);
	        }
	        res.defs = defs;
	        for (var key in proto) if (proto[has](key)) {
	            res[key] = proto[key];
	        }
	        res.paper = res.root = res;
	    } else {
	        res = make("svg", glob.doc.body);
	        $(res.node, {
	            height: h,
	            version: 1.1,
	            width: w,
	            xmlns: xmlns
	        });
	    }
	    return res;
	}
	function wrap(dom) {
	    if (!dom) {
	        return dom;
	    }
	    if (dom instanceof Element || dom instanceof Fragment) {
	        return dom;
	    }
	    if (dom.tagName && dom.tagName.toLowerCase() == "svg") {
	        return new Paper(dom);
	    }
	    if (dom.tagName && dom.tagName.toLowerCase() == "object" && dom.type == "image/svg+xml") {
	        return new Paper(dom.contentDocument.getElementsByTagName("svg")[0]);
	    }
	    return new Element(dom);
	}
	
	Snap._.make = make;
	Snap._.wrap = wrap;
	/*\
	 * Paper.el
	 [ method ]
	 **
	 * Creates an element on paper with a given name and no attributes
	 **
	 - name (string) tag name
	 - attr (object) attributes
	 = (Element) the current element
	 > Usage
	 | var c = paper.circle(10, 10, 10); // is the same as...
	 | var c = paper.el("circle").attr({
	 |     cx: 10,
	 |     cy: 10,
	 |     r: 10
	 | });
	 | // and the same as
	 | var c = paper.el("circle", {
	 |     cx: 10,
	 |     cy: 10,
	 |     r: 10
	 | });
	\*/
	Paper.prototype.el = function (name, attr) {
	    var el = make(name, this.node);
	    attr && el.attr(attr);
	    return el;
	};
	/*\
	 * Element.children
	 [ method ]
	 **
	 * Returns array of all the children of the element.
	 = (array) array of Elements
	\*/
	Element.prototype.children = function () {
	    var out = [],
	        ch = this.node.childNodes;
	    for (var i = 0, ii = ch.length; i < ii; i++) {
	        out[i] = Snap(ch[i]);
	    }
	    return out;
	};
	function jsonFiller(root, o) {
	    for (var i = 0, ii = root.length; i < ii; i++) {
	        var item = {
	                type: root[i].type,
	                attr: root[i].attr()
	            },
	            children = root[i].children();
	        o.push(item);
	        if (children.length) {
	            jsonFiller(children, item.childNodes = []);
	        }
	    }
	}
	/*\
	 * Element.toJSON
	 [ method ]
	 **
	 * Returns object representation of the given element and all its children.
	 = (object) in format
	 o {
	 o     type (string) this.type,
	 o     attr (object) attributes map,
	 o     childNodes (array) optional array of children in the same format
	 o }
	\*/
	Element.prototype.toJSON = function () {
	    var out = [];
	    jsonFiller([this], out);
	    return out[0];
	};
	// default
	eve.on("snap.util.getattr", function () {
	    var att = eve.nt();
	    att = att.substring(att.lastIndexOf(".") + 1);
	    var css = att.replace(/[A-Z]/g, function (letter) {
	        return "-" + letter.toLowerCase();
	    });
	    if (cssAttr[has](css)) {
	        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);
	    } else {
	        return $(this.node, att);
	    }
	});
	var cssAttr = {
	    "alignment-baseline": 0,
	    "baseline-shift": 0,
	    "clip": 0,
	    "clip-path": 0,
	    "clip-rule": 0,
	    "color": 0,
	    "color-interpolation": 0,
	    "color-interpolation-filters": 0,
	    "color-profile": 0,
	    "color-rendering": 0,
	    "cursor": 0,
	    "direction": 0,
	    "display": 0,
	    "dominant-baseline": 0,
	    "enable-background": 0,
	    "fill": 0,
	    "fill-opacity": 0,
	    "fill-rule": 0,
	    "filter": 0,
	    "flood-color": 0,
	    "flood-opacity": 0,
	    "font": 0,
	    "font-family": 0,
	    "font-size": 0,
	    "font-size-adjust": 0,
	    "font-stretch": 0,
	    "font-style": 0,
	    "font-variant": 0,
	    "font-weight": 0,
	    "glyph-orientation-horizontal": 0,
	    "glyph-orientation-vertical": 0,
	    "image-rendering": 0,
	    "kerning": 0,
	    "letter-spacing": 0,
	    "lighting-color": 0,
	    "marker": 0,
	    "marker-end": 0,
	    "marker-mid": 0,
	    "marker-start": 0,
	    "mask": 0,
	    "opacity": 0,
	    "overflow": 0,
	    "pointer-events": 0,
	    "shape-rendering": 0,
	    "stop-color": 0,
	    "stop-opacity": 0,
	    "stroke": 0,
	    "stroke-dasharray": 0,
	    "stroke-dashoffset": 0,
	    "stroke-linecap": 0,
	    "stroke-linejoin": 0,
	    "stroke-miterlimit": 0,
	    "stroke-opacity": 0,
	    "stroke-width": 0,
	    "text-anchor": 0,
	    "text-decoration": 0,
	    "text-rendering": 0,
	    "unicode-bidi": 0,
	    "visibility": 0,
	    "word-spacing": 0,
	    "writing-mode": 0
	};
	
	eve.on("snap.util.attr", function (value) {
	    var att = eve.nt(),
	        attr = {};
	    att = att.substring(att.lastIndexOf(".") + 1);
	    attr[att] = value;
	    var style = att.replace(/-(\w)/gi, function (all, letter) {
	            return letter.toUpperCase();
	        }),
	        css = att.replace(/[A-Z]/g, function (letter) {
	            return "-" + letter.toLowerCase();
	        });
	    if (cssAttr[has](css)) {
	        this.node.style[style] = value == null ? E : value;
	    } else {
	        $(this.node, attr);
	    }
	});
	(function (proto) {}(Paper.prototype));
	
	// simple ajax
	/*\
	 * Snap.ajax
	 [ method ]
	 **
	 * Simple implementation of Ajax
	 **
	 - url (string) URL
	 - postData (object|string) data for post request
	 - callback (function) callback
	 - scope (object) #optional scope of callback
	 * or
	 - url (string) URL
	 - callback (function) callback
	 - scope (object) #optional scope of callback
	 = (XMLHttpRequest) the XMLHttpRequest object, just in case
	\*/
	Snap.ajax = function (url, postData, callback, scope){
	    var req = new XMLHttpRequest,
	        id = ID();
	    if (req) {
	        if (is(postData, "function")) {
	            scope = callback;
	            callback = postData;
	            postData = null;
	        } else if (is(postData, "object")) {
	            var pd = [];
	            for (var key in postData) if (postData.hasOwnProperty(key)) {
	                pd.push(encodeURIComponent(key) + "=" + encodeURIComponent(postData[key]));
	            }
	            postData = pd.join("&");
	        }
	        req.open((postData ? "POST" : "GET"), url, true);
	        if (postData) {
	            req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
	            req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
	        }
	        if (callback) {
	            eve.once("snap.ajax." + id + ".0", callback);
	            eve.once("snap.ajax." + id + ".200", callback);
	            eve.once("snap.ajax." + id + ".304", callback);
	        }
	        req.onreadystatechange = function() {
	            if (req.readyState != 4) return;
	            eve("snap.ajax." + id + "." + req.status, scope, req);
	        };
	        if (req.readyState == 4) {
	            return req;
	        }
	        req.send(postData);
	        return req;
	    }
	};
	/*\
	 * Snap.load
	 [ method ]
	 **
	 * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)
	 **
	 - url (string) URL
	 - callback (function) callback
	 - scope (object) #optional scope of callback
	\*/
	Snap.load = function (url, callback, scope) {
	    Snap.ajax(url, function (req) {
	        var f = Snap.parse(req.responseText);
	        scope ? callback.call(scope, f) : callback(f);
	    });
	};
	var getOffset = function (elem) {
	    var box = elem.getBoundingClientRect(),
	        doc = elem.ownerDocument,
	        body = doc.body,
	        docElem = doc.documentElement,
	        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
	        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
	        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
	    return {
	        y: top,
	        x: left
	    };
	};
	/*\
	 * Snap.getElementByPoint
	 [ method ]
	 **
	 * Returns you topmost element under given point.
	 **
	 = (object) Snap element object
	 - x (number) x coordinate from the top left corner of the window
	 - y (number) y coordinate from the top left corner of the window
	 > Usage
	 | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
	\*/
	Snap.getElementByPoint = function (x, y) {
	    var paper = this,
	        svg = paper.canvas,
	        target = glob.doc.elementFromPoint(x, y);
	    if (glob.win.opera && target.tagName == "svg") {
	        var so = getOffset(target),
	            sr = target.createSVGRect();
	        sr.x = x - so.x;
	        sr.y = y - so.y;
	        sr.width = sr.height = 1;
	        var hits = target.getIntersectionList(sr, null);
	        if (hits.length) {
	            target = hits[hits.length - 1];
	        }
	    }
	    if (!target) {
	        return null;
	    }
	    return wrap(target);
	};
	/*\
	 * Snap.plugin
	 [ method ]
	 **
	 * Let you write plugins. You pass in a function with five arguments, like this:
	 | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {
	 |     Snap.newmethod = function () {};
	 |     Element.prototype.newmethod = function () {};
	 |     Paper.prototype.newmethod = function () {};
	 | });
	 * Inside the function you have access to all main objects (and their
	 * prototypes). This allow you to extend anything you want.
	 **
	 - f (function) your plugin body
	\*/
	Snap.plugin = function (f) {
	    f(Snap, Element, Paper, glob, Fragment);
	};
	glob.win.Snap = Snap;
	return Snap;
	}(window || this));
	
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var elproto = Element.prototype,
	        is = Snap.is,
	        Str = String,
	        unit2px = Snap._unit2px,
	        $ = Snap._.$,
	        make = Snap._.make,
	        getSomeDefs = Snap._.getSomeDefs,
	        has = "hasOwnProperty",
	        wrap = Snap._.wrap;
	    /*\
	     * Element.getBBox
	     [ method ]
	     **
	     * Returns the bounding box descriptor for the given element
	     **
	     = (object) bounding box descriptor:
	     o {
	     o     cx: (number) x of the center,
	     o     cy: (number) x of the center,
	     o     h: (number) height,
	     o     height: (number) height,
	     o     path: (string) path command for the box,
	     o     r0: (number) radius of a circle that fully encloses the box,
	     o     r1: (number) radius of the smallest circle that can be enclosed,
	     o     r2: (number) radius of the largest circle that can be enclosed,
	     o     vb: (string) box as a viewbox command,
	     o     w: (number) width,
	     o     width: (number) width,
	     o     x2: (number) x of the right side,
	     o     x: (number) x of the left side,
	     o     y2: (number) y of the bottom edge,
	     o     y: (number) y of the top edge
	     o }
	    \*/
	    elproto.getBBox = function (isWithoutTransform) {
	        if (!Snap.Matrix || !Snap.path) {
	            return this.node.getBBox();
	        }
	        var el = this,
	            m = new Snap.Matrix;
	        if (el.removed) {
	            return Snap._.box();
	        }
	        while (el.type == "use") {
	            if (!isWithoutTransform) {
	                m = m.add(el.transform().localMatrix.translate(el.attr("x") || 0, el.attr("y") || 0));
	            }
	            if (el.original) {
	                el = el.original;
	            } else {
	                var href = el.attr("xlink:href");
	                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf("#") + 1));
	            }
	        }
	        var _ = el._,
	            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;
	        try {
	            if (isWithoutTransform) {
	                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());
	                return Snap._.box(_.bboxwt);
	            } else {
	                el.realPath = pathfinder(el);
	                el.matrix = el.transform().localMatrix;
	                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));
	                return Snap._.box(_.bbox);
	            }
	        } catch (e) {
	            // Firefox doesn’t give you bbox of hidden element
	            return Snap._.box();
	        }
	    };
	    var propString = function () {
	        return this.string;
	    };
	    function extractTransform(el, tstr) {
	        if (tstr == null) {
	            var doReturn = true;
	            if (el.type == "linearGradient" || el.type == "radialGradient") {
	                tstr = el.node.getAttribute("gradientTransform");
	            } else if (el.type == "pattern") {
	                tstr = el.node.getAttribute("patternTransform");
	            } else {
	                tstr = el.node.getAttribute("transform");
	            }
	            if (!tstr) {
	                return new Snap.Matrix;
	            }
	            tstr = Snap._.svgTransform2string(tstr);
	        } else {
	            if (!Snap._.rgTransform.test(tstr)) {
	                tstr = Snap._.svgTransform2string(tstr);
	            } else {
	                tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
	            }
	            if (is(tstr, "array")) {
	                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);
	            }
	            el._.transform = tstr;
	        }
	        var m = Snap._.transform2matrix(tstr, el.getBBox(1));
	        if (doReturn) {
	            return m;
	        } else {
	            el.matrix = m;
	        }
	    }
	    /*\
	     * Element.transform
	     [ method ]
	     **
	     * Gets or sets transformation of the element
	     **
	     - tstr (string) transform string in Snap or SVG format
	     = (Element) the current element
	     * or
	     = (object) transformation descriptor:
	     o {
	     o     string (string) transform string,
	     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,
	     o     localMatrix (Matrix) matrix of transformations applied only to the element,
	     o     diffMatrix (Matrix) matrix of difference between global and local transformations,
	     o     global (string) global transformation as string,
	     o     local (string) local transformation as string,
	     o     toString (function) returns `string` property
	     o }
	    \*/
	    elproto.transform = function (tstr) {
	        var _ = this._;
	        if (tstr == null) {
	            var papa = this,
	                global = new Snap.Matrix(this.node.getCTM()),
	                local = extractTransform(this),
	                ms = [local],
	                m = new Snap.Matrix,
	                i,
	                localString = local.toTransformString(),
	                string = Str(local) == Str(this.matrix) ?
	                            Str(_.transform) : localString;
	            while (papa.type != "svg" && (papa = papa.parent())) {
	                ms.push(extractTransform(papa));
	            }
	            i = ms.length;
	            while (i--) {
	                m.add(ms[i]);
	            }
	            return {
	                string: string,
	                globalMatrix: global,
	                totalMatrix: m,
	                localMatrix: local,
	                diffMatrix: global.clone().add(local.invert()),
	                global: global.toTransformString(),
	                total: m.toTransformString(),
	                local: localString,
	                toString: propString
	            };
	        }
	        if (tstr instanceof Snap.Matrix) {
	            this.matrix = tstr;
	            this._.transform = tstr.toTransformString();
	        } else {
	            extractTransform(this, tstr);
	        }
	
	        if (this.node) {
	            if (this.type == "linearGradient" || this.type == "radialGradient") {
	                $(this.node, {gradientTransform: this.matrix});
	            } else if (this.type == "pattern") {
	                $(this.node, {patternTransform: this.matrix});
	            } else {
	                $(this.node, {transform: this.matrix});
	            }
	        }
	
	        return this;
	    };
	    /*\
	     * Element.parent
	     [ method ]
	     **
	     * Returns the element's parent
	     **
	     = (Element) the parent element
	    \*/
	    elproto.parent = function () {
	        return wrap(this.node.parentNode);
	    };
	    /*\
	     * Element.append
	     [ method ]
	     **
	     * Appends the given element to current one
	     **
	     - el (Element|Set) element to append
	     = (Element) the parent element
	    \*/
	    /*\
	     * Element.add
	     [ method ]
	     **
	     * See @Element.append
	    \*/
	    elproto.append = elproto.add = function (el) {
	        if (el) {
	            if (el.type == "set") {
	                var it = this;
	                el.forEach(function (el) {
	                    it.add(el);
	                });
	                return this;
	            }
	            el = wrap(el);
	            this.node.appendChild(el.node);
	            el.paper = this.paper;
	        }
	        return this;
	    };
	    /*\
	     * Element.appendTo
	     [ method ]
	     **
	     * Appends the current element to the given one
	     **
	     - el (Element) parent element to append to
	     = (Element) the child element
	    \*/
	    elproto.appendTo = function (el) {
	        if (el) {
	            el = wrap(el);
	            el.append(this);
	        }
	        return this;
	    };
	    /*\
	     * Element.prepend
	     [ method ]
	     **
	     * Prepends the given element to the current one
	     **
	     - el (Element) element to prepend
	     = (Element) the parent element
	    \*/
	    elproto.prepend = function (el) {
	        if (el) {
	            if (el.type == "set") {
	                var it = this,
	                    first;
	                el.forEach(function (el) {
	                    if (first) {
	                        first.after(el);
	                    } else {
	                        it.prepend(el);
	                    }
	                    first = el;
	                });
	                return this;
	            }
	            el = wrap(el);
	            var parent = el.parent();
	            this.node.insertBefore(el.node, this.node.firstChild);
	            this.add && this.add();
	            el.paper = this.paper;
	            this.parent() && this.parent().add();
	            parent && parent.add();
	        }
	        return this;
	    };
	    /*\
	     * Element.prependTo
	     [ method ]
	     **
	     * Prepends the current element to the given one
	     **
	     - el (Element) parent element to prepend to
	     = (Element) the child element
	    \*/
	    elproto.prependTo = function (el) {
	        el = wrap(el);
	        el.prepend(this);
	        return this;
	    };
	    /*\
	     * Element.before
	     [ method ]
	     **
	     * Inserts given element before the current one
	     **
	     - el (Element) element to insert
	     = (Element) the parent element
	    \*/
	    elproto.before = function (el) {
	        if (el.type == "set") {
	            var it = this;
	            el.forEach(function (el) {
	                var parent = el.parent();
	                it.node.parentNode.insertBefore(el.node, it.node);
	                parent && parent.add();
	            });
	            this.parent().add();
	            return this;
	        }
	        el = wrap(el);
	        var parent = el.parent();
	        this.node.parentNode.insertBefore(el.node, this.node);
	        this.parent() && this.parent().add();
	        parent && parent.add();
	        el.paper = this.paper;
	        return this;
	    };
	    /*\
	     * Element.after
	     [ method ]
	     **
	     * Inserts given element after the current one
	     **
	     - el (Element) element to insert
	     = (Element) the parent element
	    \*/
	    elproto.after = function (el) {
	        el = wrap(el);
	        var parent = el.parent();
	        if (this.node.nextSibling) {
	            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);
	        } else {
	            this.node.parentNode.appendChild(el.node);
	        }
	        this.parent() && this.parent().add();
	        parent && parent.add();
	        el.paper = this.paper;
	        return this;
	    };
	    /*\
	     * Element.insertBefore
	     [ method ]
	     **
	     * Inserts the element after the given one
	     **
	     - el (Element) element next to whom insert to
	     = (Element) the parent element
	    \*/
	    elproto.insertBefore = function (el) {
	        el = wrap(el);
	        var parent = this.parent();
	        el.node.parentNode.insertBefore(this.node, el.node);
	        this.paper = el.paper;
	        parent && parent.add();
	        el.parent() && el.parent().add();
	        return this;
	    };
	    /*\
	     * Element.insertAfter
	     [ method ]
	     **
	     * Inserts the element after the given one
	     **
	     - el (Element) element next to whom insert to
	     = (Element) the parent element
	    \*/
	    elproto.insertAfter = function (el) {
	        el = wrap(el);
	        var parent = this.parent();
	        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);
	        this.paper = el.paper;
	        parent && parent.add();
	        el.parent() && el.parent().add();
	        return this;
	    };
	    /*\
	     * Element.remove
	     [ method ]
	     **
	     * Removes element from the DOM
	     = (Element) the detached element
	    \*/
	    elproto.remove = function () {
	        var parent = this.parent();
	        this.node.parentNode && this.node.parentNode.removeChild(this.node);
	        delete this.paper;
	        this.removed = true;
	        parent && parent.add();
	        return this;
	    };
	    /*\
	     * Element.select
	     [ method ]
	     **
	     * Gathers the nested @Element matching the given set of CSS selectors
	     **
	     - query (string) CSS selector
	     = (Element) result of query selection
	    \*/
	    elproto.select = function (query) {
	        query = Str(query).replace(/([^\\]):/g, "$1\\:");
	        return wrap(this.node.querySelector(query));
	    };
	    /*\
	     * Element.selectAll
	     [ method ]
	     **
	     * Gathers nested @Element objects matching the given set of CSS selectors
	     **
	     - query (string) CSS selector
	     = (Set|array) result of query selection
	    \*/
	    elproto.selectAll = function (query) {
	        var nodelist = this.node.querySelectorAll(query),
	            set = (Snap.set || Array)();
	        for (var i = 0; i < nodelist.length; i++) {
	            set.push(wrap(nodelist[i]));
	        }
	        return set;
	    };
	    /*\
	     * Element.asPX
	     [ method ]
	     **
	     * Returns given attribute of the element as a `px` value (not %, em, etc.)
	     **
	     - attr (string) attribute name
	     - value (string) #optional attribute value
	     = (Element) result of query selection
	    \*/
	    elproto.asPX = function (attr, value) {
	        if (value == null) {
	            value = this.attr(attr);
	        }
	        return +unit2px(this, attr, value);
	    };
	    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.
	    /*\
	     * Element.use
	     [ method ]
	     **
	     * Creates a `<use>` element linked to the current element
	     **
	     = (Element) the `<use>` element
	    \*/
	    elproto.use = function () {
	        var use,
	            id = this.node.id;
	        if (!id) {
	            id = this.id;
	            $(this.node, {
	                id: id
	            });
	        }
	        if (this.type == "linearGradient" || this.type == "radialGradient" ||
	            this.type == "pattern") {
	            use = make(this.type, this.node.parentNode);
	        } else {
	            use = make("use", this.node.parentNode);
	        }
	        $(use.node, {
	            "xlink:href": "#" + id
	        });
	        use.original = this;
	        return use;
	    };
	    function fixids(el) {
	        var els = el.selectAll("*"),
	            it,
	            url = /^\s*url\(("|'|)(.*)\1\)\s*$/,
	            ids = [],
	            uses = {};
	        function urltest(it, name) {
	            var val = $(it.node, name);
	            val = val && val.match(url);
	            val = val && val[2];
	            if (val && val.charAt() == "#") {
	                val = val.substring(1);
	            } else {
	                return;
	            }
	            if (val) {
	                uses[val] = (uses[val] || []).concat(function (id) {
	                    var attr = {};
	                    attr[name] = URL(id);
	                    $(it.node, attr);
	                });
	            }
	        }
	        function linktest(it) {
	            var val = $(it.node, "xlink:href");
	            if (val && val.charAt() == "#") {
	                val = val.substring(1);
	            } else {
	                return;
	            }
	            if (val) {
	                uses[val] = (uses[val] || []).concat(function (id) {
	                    it.attr("xlink:href", "#" + id);
	                });
	            }
	        }
	        for (var i = 0, ii = els.length; i < ii; i++) {
	            it = els[i];
	            urltest(it, "fill");
	            urltest(it, "stroke");
	            urltest(it, "filter");
	            urltest(it, "mask");
	            urltest(it, "clip-path");
	            linktest(it);
	            var oldid = $(it.node, "id");
	            if (oldid) {
	                $(it.node, {id: it.id});
	                ids.push({
	                    old: oldid,
	                    id: it.id
	                });
	            }
	        }
	        for (i = 0, ii = ids.length; i < ii; i++) {
	            var fs = uses[ids[i].old];
	            if (fs) {
	                for (var j = 0, jj = fs.length; j < jj; j++) {
	                    fs[j](ids[i].id);
	                }
	            }
	        }
	    }
	    /*\
	     * Element.clone
	     [ method ]
	     **
	     * Creates a clone of the element and inserts it after the element
	     **
	     = (Element) the clone
	    \*/
	    elproto.clone = function () {
	        var clone = wrap(this.node.cloneNode(true));
	        if ($(clone.node, "id")) {
	            $(clone.node, {id: clone.id});
	        }
	        fixids(clone);
	        clone.insertAfter(this);
	        return clone;
	    };
	    /*\
	     * Element.toDefs
	     [ method ]
	     **
	     * Moves element to the shared `<defs>` area
	     **
	     = (Element) the element
	    \*/
	    elproto.toDefs = function () {
	        var defs = getSomeDefs(this);
	        defs.appendChild(this.node);
	        return this;
	    };
	    /*\
	     * Element.toPattern
	     [ method ]
	     **
	     * Creates a `<pattern>` element from the current element
	     **
	     * To create a pattern you have to specify the pattern rect:
	     - x (string|number)
	     - y (string|number)
	     - width (string|number)
	     - height (string|number)
	     = (Element) the `<pattern>` element
	     * You can use pattern later on as an argument for `fill` attribute:
	     | var p = paper.path("M10-5-10,15M15,0,0,15M0-5-20,15").attr({
	     |         fill: "none",
	     |         stroke: "#bada55",
	     |         strokeWidth: 5
	     |     }).pattern(0, 0, 10, 10),
	     |     c = paper.circle(200, 200, 100);
	     | c.attr({
	     |     fill: p
	     | });
	    \*/
	    elproto.pattern = elproto.toPattern = function (x, y, width, height) {
	        var p = make("pattern", getSomeDefs(this));
	        if (x == null) {
	            x = this.getBBox();
	        }
	        if (is(x, "object") && "x" in x) {
	            y = x.y;
	            width = x.width;
	            height = x.height;
	            x = x.x;
	        }
	        $(p.node, {
	            x: x,
	            y: y,
	            width: width,
	            height: height,
	            patternUnits: "userSpaceOnUse",
	            id: p.id,
	            viewBox: [x, y, width, height].join(" ")
	        });
	        p.node.appendChild(this.node);
	        return p;
	    };
	// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.
	// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?
	    /*\
	     * Element.marker
	     [ method ]
	     **
	     * Creates a `<marker>` element from the current element
	     **
	     * To create a marker you have to specify the bounding rect and reference point:
	     - x (number)
	     - y (number)
	     - width (number)
	     - height (number)
	     - refX (number)
	     - refY (number)
	     = (Element) the `<marker>` element
	     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.
	    \*/
	    // TODO add usage for markers
	    elproto.marker = function (x, y, width, height, refX, refY) {
	        var p = make("marker", getSomeDefs(this));
	        if (x == null) {
	            x = this.getBBox();
	        }
	        if (is(x, "object") && "x" in x) {
	            y = x.y;
	            width = x.width;
	            height = x.height;
	            refX = x.refX || x.cx;
	            refY = x.refY || x.cy;
	            x = x.x;
	        }
	        $(p.node, {
	            viewBox: [x, y, width, height].join(" "),
	            markerWidth: width,
	            markerHeight: height,
	            orient: "auto",
	            refX: refX || 0,
	            refY: refY || 0,
	            id: p.id
	        });
	        p.node.appendChild(this.node);
	        return p;
	    };
	    // animation
	    function slice(from, to, f) {
	        return function (arr) {
	            var res = arr.slice(from, to);
	            if (res.length == 1) {
	                res = res[0];
	            }
	            return f ? f(res) : res;
	        };
	    }
	    var Animation = function (attr, ms, easing, callback) {
	        if (typeof easing == "function" && !easing.length) {
	            callback = easing;
	            easing = mina.linear;
	        }
	        this.attr = attr;
	        this.dur = ms;
	        easing && (this.easing = easing);
	        callback && (this.callback = callback);
	    };
	    Snap._.Animation = Animation;
	    /*\
	     * Snap.animation
	     [ method ]
	     **
	     * Creates an animation object
	     **
	     - attr (object) attributes of final destination
	     - duration (number) duration of the animation, in milliseconds
	     - easing (function) #optional one of easing functions of @mina or custom one
	     - callback (function) #optional callback function that fires when animation ends
	     = (object) animation object
	    \*/
	    Snap.animation = function (attr, ms, easing, callback) {
	        return new Animation(attr, ms, easing, callback);
	    };
	    /*\
	     * Element.inAnim
	     [ method ]
	     **
	     * Returns a set of animations that may be able to manipulate the current element
	     **
	     = (object) in format:
	     o {
	     o     anim (object) animation object,
	     o     mina (object) @mina object,
	     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,
	     o     status (function) gets or sets the status of the animation,
	     o     stop (function) stops the animation
	     o }
	    \*/
	    elproto.inAnim = function () {
	        var el = this,
	            res = [];
	        for (var id in el.anims) if (el.anims[has](id)) {
	            (function (a) {
	                res.push({
	                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),
	                    mina: a,
	                    curStatus: a.status(),
	                    status: function (val) {
	                        return a.status(val);
	                    },
	                    stop: function () {
	                        a.stop();
	                    }
	                });
	            }(el.anims[id]));
	        }
	        return res;
	    };
	    /*\
	     * Snap.animate
	     [ method ]
	     **
	     * Runs generic animation of one number into another with a caring function
	     **
	     - from (number|array) number or array of numbers
	     - to (number|array) number or array of numbers
	     - setter (function) caring function that accepts one number argument
	     - duration (number) duration, in milliseconds
	     - easing (function) #optional easing function from @mina or custom
	     - callback (function) #optional callback function to execute when animation ends
	     = (object) animation object in @mina format
	     o {
	     o     id (string) animation id, consider it read-only,
	     o     duration (function) gets or sets the duration of the animation,
	     o     easing (function) easing,
	     o     speed (function) gets or sets the speed of the animation,
	     o     status (function) gets or sets the status of the animation,
	     o     stop (function) stops the animation
	     o }
	     | var rect = Snap().rect(0, 0, 10, 10);
	     | Snap.animate(0, 10, function (val) {
	     |     rect.attr({
	     |         x: val
	     |     });
	     | }, 1000);
	     | // in given context is equivalent to
	     | rect.animate({x: 10}, 1000);
	    \*/
	    Snap.animate = function (from, to, setter, ms, easing, callback) {
	        if (typeof easing == "function" && !easing.length) {
	            callback = easing;
	            easing = mina.linear;
	        }
	        var now = mina.time(),
	            anim = mina(from, to, now, now + ms, mina.time, setter, easing);
	        callback && eve.once("mina.finish." + anim.id, callback);
	        return anim;
	    };
	    /*\
	     * Element.stop
	     [ method ]
	     **
	     * Stops all the animations for the current element
	     **
	     = (Element) the current element
	    \*/
	    elproto.stop = function () {
	        var anims = this.inAnim();
	        for (var i = 0, ii = anims.length; i < ii; i++) {
	            anims[i].stop();
	        }
	        return this;
	    };
	    /*\
	     * Element.animate
	     [ method ]
	     **
	     * Animates the given attributes of the element
	     **
	     - attrs (object) key-value pairs of destination attributes
	     - duration (number) duration of the animation in milliseconds
	     - easing (function) #optional easing function from @mina or custom
	     - callback (function) #optional callback function that executes when the animation ends
	     = (Element) the current element
	    \*/
	    elproto.animate = function (attrs, ms, easing, callback) {
	        if (typeof easing == "function" && !easing.length) {
	            callback = easing;
	            easing = mina.linear;
	        }
	        if (attrs instanceof Animation) {
	            callback = attrs.callback;
	            easing = attrs.easing;
	            ms = easing.dur;
	            attrs = attrs.attr;
	        }
	        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,
	            el = this;
	        for (var key in attrs) if (attrs[has](key)) {
	            if (el.equal) {
	                eq = el.equal(key, Str(attrs[key]));
	                from = eq.from;
	                to = eq.to;
	                f = eq.f;
	            } else {
	                from = +el.attr(key);
	                to = +attrs[key];
	            }
	            var len = is(from, "array") ? from.length : 1;
	            keys[key] = slice(fkeys.length, fkeys.length + len, f);
	            fkeys = fkeys.concat(from);
	            tkeys = tkeys.concat(to);
	        }
	        var now = mina.time(),
	            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {
	                var attr = {};
	                for (var key in keys) if (keys[has](key)) {
	                    attr[key] = keys[key](val);
	                }
	                el.attr(attr);
	            }, easing);
	        el.anims[anim.id] = anim;
	        anim._attrs = attrs;
	        anim._callback = callback;
	        eve("snap.animcreated." + el.id, anim);
	        eve.once("mina.finish." + anim.id, function () {
	            delete el.anims[anim.id];
	            callback && callback.call(el);
	        });
	        eve.once("mina.stop." + anim.id, function () {
	            delete el.anims[anim.id];
	        });
	        return el;
	    };
	    var eldata = {};
	    /*\
	     * Element.data
	     [ method ]
	     **
	     * Adds or retrieves given value associated with given key. (Don’t confuse
	     * with `data-` attributes)
	     *
	     * See also @Element.removeData
	     - key (string) key to store data
	     - value (any) #optional value to store
	     = (object) @Element
	     * or, if value is not specified:
	     = (any) value
	     > Usage
	     | for (var i = 0, i < 5, i++) {
	     |     paper.circle(10 + 15 * i, 10, 10)
	     |          .attr({fill: "#000"})
	     |          .data("i", i)
	     |          .click(function () {
	     |             alert(this.data("i"));
	     |          });
	     | }
	    \*/
	    elproto.data = function (key, value) {
	        var data = eldata[this.id] = eldata[this.id] || {};
	        if (arguments.length == 0){
	            eve("snap.data.get." + this.id, this, data, null);
	            return data;
	        }
	        if (arguments.length == 1) {
	            if (Snap.is(key, "object")) {
	                for (var i in key) if (key[has](i)) {
	                    this.data(i, key[i]);
	                }
	                return this;
	            }
	            eve("snap.data.get." + this.id, this, data[key], key);
	            return data[key];
	        }
	        data[key] = value;
	        eve("snap.data.set." + this.id, this, value, key);
	        return this;
	    };
	    /*\
	     * Element.removeData
	     [ method ]
	     **
	     * Removes value associated with an element by given key.
	     * If key is not provided, removes all the data of the element.
	     - key (string) #optional key
	     = (object) @Element
	    \*/
	    elproto.removeData = function (key) {
	        if (key == null) {
	            eldata[this.id] = {};
	        } else {
	            eldata[this.id] && delete eldata[this.id][key];
	        }
	        return this;
	    };
	    /*\
	     * Element.outerSVG
	     [ method ]
	     **
	     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.
	     *
	     * See also @Element.innerSVG
	     = (string) SVG code for the element
	    \*/
	    /*\
	     * Element.toString
	     [ method ]
	     **
	     * See @Element.outerSVG
	    \*/
	    elproto.outerSVG = elproto.toString = toString(1);
	    /*\
	     * Element.innerSVG
	     [ method ]
	     **
	     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`
	     = (string) SVG code for the element
	    \*/
	    elproto.innerSVG = toString();
	    function toString(type) {
	        return function () {
	            var res = type ? "<" + this.type : "",
	                attr = this.node.attributes,
	                chld = this.node.childNodes;
	            if (type) {
	                for (var i = 0, ii = attr.length; i < ii; i++) {
	                    res += " " + attr[i].name + '="' +
	                            attr[i].value.replace(/"/g, '\\"') + '"';
	                }
	            }
	            if (chld.length) {
	                type && (res += ">");
	                for (i = 0, ii = chld.length; i < ii; i++) {
	                    if (chld[i].nodeType == 3) {
	                        res += chld[i].nodeValue;
	                    } else if (chld[i].nodeType == 1) {
	                        res += wrap(chld[i]).toString();
	                    }
	                }
	                type && (res += "</" + this.type + ">");
	            } else {
	                type && (res += "/>");
	            }
	            return res;
	        };
	    }
	    elproto.toDataURL = function () {
	        if (window && window.btoa) {
	            var bb = this.getBBox(),
	                svg = Snap.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>', {
	                x: +bb.x.toFixed(3),
	                y: +bb.y.toFixed(3),
	                width: +bb.width.toFixed(3),
	                height: +bb.height.toFixed(3),
	                contents: this.outerSVG()
	            });
	            return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
	        }
	    };
	    /*\
	     * Fragment.select
	     [ method ]
	     **
	     * See @Element.select
	    \*/
	    Fragment.prototype.select = elproto.select;
	    /*\
	     * Fragment.selectAll
	     [ method ]
	     **
	     * See @Element.selectAll
	    \*/
	    Fragment.prototype.selectAll = elproto.selectAll;
	});
	
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var objectToString = Object.prototype.toString,
	        Str = String,
	        math = Math,
	        E = "";
	    function Matrix(a, b, c, d, e, f) {
	        if (b == null && objectToString.call(a) == "[object SVGMatrix]") {
	            this.a = a.a;
	            this.b = a.b;
	            this.c = a.c;
	            this.d = a.d;
	            this.e = a.e;
	            this.f = a.f;
	            return;
	        }
	        if (a != null) {
	            this.a = +a;
	            this.b = +b;
	            this.c = +c;
	            this.d = +d;
	            this.e = +e;
	            this.f = +f;
	        } else {
	            this.a = 1;
	            this.b = 0;
	            this.c = 0;
	            this.d = 1;
	            this.e = 0;
	            this.f = 0;
	        }
	    }
	    (function (matrixproto) {
	        /*\
	         * Matrix.add
	         [ method ]
	         **
	         * Adds the given matrix to existing one
	         - a (number)
	         - b (number)
	         - c (number)
	         - d (number)
	         - e (number)
	         - f (number)
	         * or
	         - matrix (object) @Matrix
	        \*/
	        matrixproto.add = function (a, b, c, d, e, f) {
	            var out = [[], [], []],
	                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
	                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
	                x, y, z, res;
	
	            if (a && a instanceof Matrix) {
	                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
	            }
	
	            for (x = 0; x < 3; x++) {
	                for (y = 0; y < 3; y++) {
	                    res = 0;
	                    for (z = 0; z < 3; z++) {
	                        res += m[x][z] * matrix[z][y];
	                    }
	                    out[x][y] = res;
	                }
	            }
	            this.a = out[0][0];
	            this.b = out[1][0];
	            this.c = out[0][1];
	            this.d = out[1][1];
	            this.e = out[0][2];
	            this.f = out[1][2];
	            return this;
	        };
	        /*\
	         * Matrix.invert
	         [ method ]
	         **
	         * Returns an inverted version of the matrix
	         = (object) @Matrix
	        \*/
	        matrixproto.invert = function () {
	            var me = this,
	                x = me.a * me.d - me.b * me.c;
	            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
	        };
	        /*\
	         * Matrix.clone
	         [ method ]
	         **
	         * Returns a copy of the matrix
	         = (object) @Matrix
	        \*/
	        matrixproto.clone = function () {
	            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
	        };
	        /*\
	         * Matrix.translate
	         [ method ]
	         **
	         * Translate the matrix
	         - x (number) horizontal offset distance
	         - y (number) vertical offset distance
	        \*/
	        matrixproto.translate = function (x, y) {
	            return this.add(1, 0, 0, 1, x, y);
	        };
	        /*\
	         * Matrix.scale
	         [ method ]
	         **
	         * Scales the matrix
	         - x (number) amount to be scaled, with `1` resulting in no change
	         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
	         - cx (number) #optional horizontal origin point from which to scale
	         - cy (number) #optional vertical origin point from which to scale
	         * Default cx, cy is the middle point of the element.
	        \*/
	        matrixproto.scale = function (x, y, cx, cy) {
	            y == null && (y = x);
	            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
	            this.add(x, 0, 0, y, 0, 0);
	            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
	            return this;
	        };
	        /*\
	         * Matrix.rotate
	         [ method ]
	         **
	         * Rotates the matrix
	         - a (number) angle of rotation, in degrees
	         - x (number) horizontal origin point from which to rotate
	         - y (number) vertical origin point from which to rotate
	        \*/
	        matrixproto.rotate = function (a, x, y) {
	            a = Snap.rad(a);
	            x = x || 0;
	            y = y || 0;
	            var cos = +math.cos(a).toFixed(9),
	                sin = +math.sin(a).toFixed(9);
	            this.add(cos, sin, -sin, cos, x, y);
	            return this.add(1, 0, 0, 1, -x, -y);
	        };
	        /*\
	         * Matrix.x
	         [ method ]
	         **
	         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y
	         - x (number)
	         - y (number)
	         = (number) x
	        \*/
	        matrixproto.x = function (x, y) {
	            return x * this.a + y * this.c + this.e;
	        };
	        /*\
	         * Matrix.y
	         [ method ]
	         **
	         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x
	         - x (number)
	         - y (number)
	         = (number) y
	        \*/
	        matrixproto.y = function (x, y) {
	            return x * this.b + y * this.d + this.f;
	        };
	        matrixproto.get = function (i) {
	            return +this[Str.fromCharCode(97 + i)].toFixed(4);
	        };
	        matrixproto.toString = function () {
	            return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
	        };
	        matrixproto.offset = function () {
	            return [this.e.toFixed(4), this.f.toFixed(4)];
	        };
	        function norm(a) {
	            return a[0] * a[0] + a[1] * a[1];
	        }
	        function normalize(a) {
	            var mag = math.sqrt(norm(a));
	            a[0] && (a[0] /= mag);
	            a[1] && (a[1] /= mag);
	        }
	        /*\
	         * Matrix.determinant
	         [ method ]
	         **
	         * Finds determinant of the given matrix.
	         = (number) determinant
	        \*/
	        matrixproto.determinant = function () {
	            return this.a * this.d - this.b * this.c;
	        };
	        /*\
	         * Matrix.split
	         [ method ]
	         **
	         * Splits matrix into primitive transformations
	         = (object) in format:
	         o dx (number) translation by x
	         o dy (number) translation by y
	         o scalex (number) scale by x
	         o scaley (number) scale by y
	         o shear (number) shear
	         o rotate (number) rotation in deg
	         o isSimple (boolean) could it be represented via simple transformations
	        \*/
	        matrixproto.split = function () {
	            var out = {};
	            // translation
	            out.dx = this.e;
	            out.dy = this.f;
	
	            // scale and shear
	            var row = [[this.a, this.c], [this.b, this.d]];
	            out.scalex = math.sqrt(norm(row[0]));
	            normalize(row[0]);
	
	            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
	            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];
	
	            out.scaley = math.sqrt(norm(row[1]));
	            normalize(row[1]);
	            out.shear /= out.scaley;
	
	            if (this.determinant() < 0) {
	                out.scalex = -out.scalex;
	            }
	
	            // rotation
	            var sin = -row[0][1],
	                cos = row[1][1];
	            if (cos < 0) {
	                out.rotate = Snap.deg(math.acos(cos));
	                if (sin < 0) {
	                    out.rotate = 360 - out.rotate;
	                }
	            } else {
	                out.rotate = Snap.deg(math.asin(sin));
	            }
	
	            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
	            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
	            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
	            return out;
	        };
	        /*\
	         * Matrix.toTransformString
	         [ method ]
	         **
	         * Returns transform string that represents given matrix
	         = (string) transform string
	        \*/
	        matrixproto.toTransformString = function (shorter) {
	            var s = shorter || this.split();
	            if (!+s.shear.toFixed(9)) {
	                s.scalex = +s.scalex.toFixed(4);
	                s.scaley = +s.scaley.toFixed(4);
	                s.rotate = +s.rotate.toFixed(4);
	                return  (s.dx || s.dy ? "t" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) +
	                        (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
	                        (s.rotate ? "r" + [+s.rotate.toFixed(4), 0, 0] : E);
	            } else {
	                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
	            }
	        };
	    })(Matrix.prototype);
	    /*\
	     * Snap.Matrix
	     [ method ]
	     **
	     * Matrix constructor, extend on your own risk.
	     * To create matrices use @Snap.matrix.
	    \*/
	    Snap.Matrix = Matrix;
	    /*\
	     * Snap.matrix
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns a matrix based on the given parameters
	     - a (number)
	     - b (number)
	     - c (number)
	     - d (number)
	     - e (number)
	     - f (number)
	     * or
	     - svgMatrix (SVGMatrix)
	     = (object) @Matrix
	    \*/
	    Snap.matrix = function (a, b, c, d, e, f) {
	        return new Matrix(a, b, c, d, e, f);
	    };
	});
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var has = "hasOwnProperty",
	        make = Snap._.make,
	        wrap = Snap._.wrap,
	        is = Snap.is,
	        getSomeDefs = Snap._.getSomeDefs,
	        reURLValue = /^url\(#?([^)]+)\)$/,
	        $ = Snap._.$,
	        URL = Snap.url,
	        Str = String,
	        separator = Snap._.separator,
	        E = "";
	    // Attributes event handlers
	    eve.on("snap.util.attr.mask", function (value) {
	        if (value instanceof Element || value instanceof Fragment) {
	            eve.stop();
	            if (value instanceof Fragment && value.node.childNodes.length == 1) {
	                value = value.node.firstChild;
	                getSomeDefs(this).appendChild(value);
	                value = wrap(value);
	            }
	            if (value.type == "mask") {
	                var mask = value;
	            } else {
	                mask = make("mask", getSomeDefs(this));
	                mask.node.appendChild(value.node);
	            }
	            !mask.node.id && $(mask.node, {
	                id: mask.id
	            });
	            $(this.node, {
	                mask: URL(mask.id)
	            });
	        }
	    });
	    (function (clipIt) {
	        eve.on("snap.util.attr.clip", clipIt);
	        eve.on("snap.util.attr.clip-path", clipIt);
	        eve.on("snap.util.attr.clipPath", clipIt);
	    }(function (value) {
	        if (value instanceof Element || value instanceof Fragment) {
	            eve.stop();
	            if (value.type == "clipPath") {
	                var clip = value;
	            } else {
	                clip = make("clipPath", getSomeDefs(this));
	                clip.node.appendChild(value.node);
	                !clip.node.id && $(clip.node, {
	                    id: clip.id
	                });
	            }
	            $(this.node, {
	                "clip-path": URL(clip.node.id || clip.id)
	            });
	        }
	    }));
	    function fillStroke(name) {
	        return function (value) {
	            eve.stop();
	            if (value instanceof Fragment && value.node.childNodes.length == 1 &&
	                (value.node.firstChild.tagName == "radialGradient" ||
	                value.node.firstChild.tagName == "linearGradient" ||
	                value.node.firstChild.tagName == "pattern")) {
	                value = value.node.firstChild;
	                getSomeDefs(this).appendChild(value);
	                value = wrap(value);
	            }
	            if (value instanceof Element) {
	                if (value.type == "radialGradient" || value.type == "linearGradient"
	                   || value.type == "pattern") {
	                    if (!value.node.id) {
	                        $(value.node, {
	                            id: value.id
	                        });
	                    }
	                    var fill = URL(value.node.id);
	                } else {
	                    fill = value.attr(name);
	                }
	            } else {
	                fill = Snap.color(value);
	                if (fill.error) {
	                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);
	                    if (grad) {
	                        if (!grad.node.id) {
	                            $(grad.node, {
	                                id: grad.id
	                            });
	                        }
	                        fill = URL(grad.node.id);
	                    } else {
	                        fill = value;
	                    }
	                } else {
	                    fill = Str(fill);
	                }
	            }
	            var attrs = {};
	            attrs[name] = fill;
	            $(this.node, attrs);
	            this.node.style[name] = E;
	        };
	    }
	    eve.on("snap.util.attr.fill", fillStroke("fill"));
	    eve.on("snap.util.attr.stroke", fillStroke("stroke"));
	    var gradrg = /^([lr])(?:\(([^)]*)\))?(.*)$/i;
	    eve.on("snap.util.grad.parse", function parseGrad(string) {
	        string = Str(string);
	        var tokens = string.match(gradrg);
	        if (!tokens) {
	            return null;
	        }
	        var type = tokens[1],
	            params = tokens[2],
	            stops = tokens[3];
	        params = params.split(/\s*,\s*/).map(function (el) {
	            return +el == el ? +el : el;
	        });
	        if (params.length == 1 && params[0] == 0) {
	            params = [];
	        }
	        stops = stops.split("-");
	        stops = stops.map(function (el) {
	            el = el.split(":");
	            var out = {
	                color: el[0]
	            };
	            if (el[1]) {
	                out.offset = parseFloat(el[1]);
	            }
	            return out;
	        });
	        return {
	            type: type,
	            params: params,
	            stops: stops
	        };
	    });
	
	    eve.on("snap.util.attr.d", function (value) {
	        eve.stop();
	        if (is(value, "array") && is(value[0], "array")) {
	            value = Snap.path.toString.call(value);
	        }
	        value = Str(value);
	        if (value.match(/[ruo]/i)) {
	            value = Snap.path.toAbsolute(value);
	        }
	        $(this.node, {d: value});
	    })(-1);
	    eve.on("snap.util.attr.#text", function (value) {
	        eve.stop();
	        value = Str(value);
	        var txt = glob.doc.createTextNode(value);
	        while (this.node.firstChild) {
	            this.node.removeChild(this.node.firstChild);
	        }
	        this.node.appendChild(txt);
	    })(-1);
	    eve.on("snap.util.attr.path", function (value) {
	        eve.stop();
	        this.attr({d: value});
	    })(-1);
	    eve.on("snap.util.attr.class", function (value) {
	        eve.stop();
	        this.node.className.baseVal = value;
	    })(-1);
	    eve.on("snap.util.attr.viewBox", function (value) {
	        var vb;
	        if (is(value, "object") && "x" in value) {
	            vb = [value.x, value.y, value.width, value.height].join(" ");
	        } else if (is(value, "array")) {
	            vb = value.join(" ");
	        } else {
	            vb = value;
	        }
	        $(this.node, {
	            viewBox: vb
	        });
	        eve.stop();
	    })(-1);
	    eve.on("snap.util.attr.transform", function (value) {
	        this.transform(value);
	        eve.stop();
	    })(-1);
	    eve.on("snap.util.attr.r", function (value) {
	        if (this.type == "rect") {
	            eve.stop();
	            $(this.node, {
	                rx: value,
	                ry: value
	            });
	        }
	    })(-1);
	    eve.on("snap.util.attr.textpath", function (value) {
	        eve.stop();
	        if (this.type == "text") {
	            var id, tp, node;
	            if (!value && this.textPath) {
	                tp = this.textPath;
	                while (tp.node.firstChild) {
	                    this.node.appendChild(tp.node.firstChild);
	                }
	                tp.remove();
	                delete this.textPath;
	                return;
	            }
	            if (is(value, "string")) {
	                var defs = getSomeDefs(this),
	                    path = wrap(defs.parentNode).path(value);
	                defs.appendChild(path.node);
	                id = path.id;
	                path.attr({id: id});
	            } else {
	                value = wrap(value);
	                if (value instanceof Element) {
	                    id = value.attr("id");
	                    if (!id) {
	                        id = value.id;
	                        value.attr({id: id});
	                    }
	                }
	            }
	            if (id) {
	                tp = this.textPath;
	                node = this.node;
	                if (tp) {
	                    tp.attr({"xlink:href": "#" + id});
	                } else {
	                    tp = $("textPath", {
	                        "xlink:href": "#" + id
	                    });
	                    while (node.firstChild) {
	                        tp.appendChild(node.firstChild);
	                    }
	                    node.appendChild(tp);
	                    this.textPath = wrap(tp);
	                }
	            }
	        }
	    })(-1);
	    eve.on("snap.util.attr.text", function (value) {
	        if (this.type == "text") {
	            var i = 0,
	                node = this.node,
	                tuner = function (chunk) {
	                    var out = $("tspan");
	                    if (is(chunk, "array")) {
	                        for (var i = 0; i < chunk.length; i++) {
	                            out.appendChild(tuner(chunk[i]));
	                        }
	                    } else {
	                        out.appendChild(glob.doc.createTextNode(chunk));
	                    }
	                    out.normalize && out.normalize();
	                    return out;
	                };
	            while (node.firstChild) {
	                node.removeChild(node.firstChild);
	            }
	            var tuned = tuner(value);
	            while (tuned.firstChild) {
	                node.appendChild(tuned.firstChild);
	            }
	        }
	        eve.stop();
	    })(-1);
	    function setFontSize(value) {
	        eve.stop();
	        if (value == +value) {
	            value += "px";
	        }
	        this.node.style.fontSize = value;
	    }
	    eve.on("snap.util.attr.fontSize", setFontSize)(-1);
	    eve.on("snap.util.attr.font-size", setFontSize)(-1);
	
	
	    eve.on("snap.util.getattr.transform", function () {
	        eve.stop();
	        return this.transform();
	    })(-1);
	    eve.on("snap.util.getattr.textpath", function () {
	        eve.stop();
	        return this.textPath;
	    })(-1);
	    // Markers
	    (function () {
	        function getter(end) {
	            return function () {
	                eve.stop();
	                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue("marker-" + end);
	                if (style == "none") {
	                    return style;
	                } else {
	                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));
	                }
	            };
	        }
	        function setter(end) {
	            return function (value) {
	                eve.stop();
	                var name = "marker" + end.charAt(0).toUpperCase() + end.substring(1);
	                if (value == "" || !value) {
	                    this.node.style[name] = "none";
	                    return;
	                }
	                if (value.type == "marker") {
	                    var id = value.node.id;
	                    if (!id) {
	                        $(value.node, {id: value.id});
	                    }
	                    this.node.style[name] = URL(id);
	                    return;
	                }
	            };
	        }
	        eve.on("snap.util.getattr.marker-end", getter("end"))(-1);
	        eve.on("snap.util.getattr.markerEnd", getter("end"))(-1);
	        eve.on("snap.util.getattr.marker-start", getter("start"))(-1);
	        eve.on("snap.util.getattr.markerStart", getter("start"))(-1);
	        eve.on("snap.util.getattr.marker-mid", getter("mid"))(-1);
	        eve.on("snap.util.getattr.markerMid", getter("mid"))(-1);
	        eve.on("snap.util.attr.marker-end", setter("end"))(-1);
	        eve.on("snap.util.attr.markerEnd", setter("end"))(-1);
	        eve.on("snap.util.attr.marker-start", setter("start"))(-1);
	        eve.on("snap.util.attr.markerStart", setter("start"))(-1);
	        eve.on("snap.util.attr.marker-mid", setter("mid"))(-1);
	        eve.on("snap.util.attr.markerMid", setter("mid"))(-1);
	    }());
	    eve.on("snap.util.getattr.r", function () {
	        if (this.type == "rect" && $(this.node, "rx") == $(this.node, "ry")) {
	            eve.stop();
	            return $(this.node, "rx");
	        }
	    })(-1);
	    function textExtract(node) {
	        var out = [];
	        var children = node.childNodes;
	        for (var i = 0, ii = children.length; i < ii; i++) {
	            var chi = children[i];
	            if (chi.nodeType == 3) {
	                out.push(chi.nodeValue);
	            }
	            if (chi.tagName == "tspan") {
	                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {
	                    out.push(chi.firstChild.nodeValue);
	                } else {
	                    out.push(textExtract(chi));
	                }
	            }
	        }
	        return out;
	    }
	    eve.on("snap.util.getattr.text", function () {
	        if (this.type == "text" || this.type == "tspan") {
	            eve.stop();
	            var out = textExtract(this.node);
	            return out.length == 1 ? out[0] : out;
	        }
	    })(-1);
	    eve.on("snap.util.getattr.#text", function () {
	        return this.node.textContent;
	    })(-1);
	    eve.on("snap.util.getattr.viewBox", function () {
	        eve.stop();
	        var vb = $(this.node, "viewBox");
	        if (vb) {
	            vb = vb.split(separator);
	            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);
	        } else {
	            return;
	        }
	    })(-1);
	    eve.on("snap.util.getattr.points", function () {
	        var p = $(this.node, "points");
	        eve.stop();
	        if (p) {
	            return p.split(separator);
	        } else {
	            return;
	        }
	    })(-1);
	    eve.on("snap.util.getattr.path", function () {
	        var p = $(this.node, "d");
	        eve.stop();
	        return p;
	    })(-1);
	    eve.on("snap.util.getattr.class", function () {
	        return this.node.className.baseVal;
	    })(-1);
	    function getFontSize() {
	        eve.stop();
	        return this.node.style.fontSize;
	    }
	    eve.on("snap.util.getattr.fontSize", getFontSize)(-1);
	    eve.on("snap.util.getattr.font-size", getFontSize)(-1);
	});
	
	// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var rgNotSpace = /\S+/g,
	        rgBadSpace = /[\t\r\n\f]/g,
	        rgTrim = /(^\s+|\s+$)/g,
	        Str = String,
	        elproto = Element.prototype;
	    /*\
	     * Element.addClass
	     [ method ]
	     **
	     * Adds given class name or list of class names to the element.
	     - value (string) class name or space separated list of class names
	     **
	     = (Element) original element.
	    \*/
	    elproto.addClass = function (value) {
	        var classes = Str(value || "").match(rgNotSpace) || [],
	            elem = this.node,
	            className = elem.className.baseVal,
	            curClasses = className.match(rgNotSpace) || [],
	            j,
	            pos,
	            clazz,
	            finalValue;
	
	        if (classes.length) {
	            j = 0;
	            while ((clazz = classes[j++])) {
	                pos = curClasses.indexOf(clazz);
	                if (!~pos) {
	                    curClasses.push(clazz);
	                }
	            }
	
	            finalValue = curClasses.join(" ");
	            if (className != finalValue) {
	                elem.className.baseVal = finalValue;
	            }
	        }
	        return this;
	    };
	    /*\
	     * Element.removeClass
	     [ method ]
	     **
	     * Removes given class name or list of class names from the element.
	     - value (string) class name or space separated list of class names
	     **
	     = (Element) original element.
	    \*/
	    elproto.removeClass = function (value) {
	        var classes = Str(value || "").match(rgNotSpace) || [],
	            elem = this.node,
	            className = elem.className.baseVal,
	            curClasses = className.match(rgNotSpace) || [],
	            j,
	            pos,
	            clazz,
	            finalValue;
	        if (curClasses.length) {
	            j = 0;
	            while ((clazz = classes[j++])) {
	                pos = curClasses.indexOf(clazz);
	                if (~pos) {
	                    curClasses.splice(pos, 1);
	                }
	            }
	
	            finalValue = curClasses.join(" ");
	            if (className != finalValue) {
	                elem.className.baseVal = finalValue;
	            }
	        }
	        return this;
	    };
	    /*\
	     * Element.hasClass
	     [ method ]
	     **
	     * Checks if the element has a given class name in the list of class names applied to it.
	     - value (string) class name
	     **
	     = (boolean) `true` if the element has given class
	    \*/
	    elproto.hasClass = function (value) {
	        var elem = this.node,
	            className = elem.className.baseVal,
	            curClasses = className.match(rgNotSpace) || [];
	        return !!~curClasses.indexOf(value);
	    };
	    /*\
	     * Element.toggleClass
	     [ method ]
	     **
	     * Add or remove one or more classes from the element, depending on either
	     * the class’s presence or the value of the `flag` argument.
	     - value (string) class name or space separated list of class names
	     - flag (boolean) value to determine whether the class should be added or removed
	     **
	     = (Element) original element.
	    \*/
	    elproto.toggleClass = function (value, flag) {
	        if (flag != null) {
	            if (flag) {
	                return this.addClass(value);
	            } else {
	                return this.removeClass(value);
	            }
	        }
	        var classes = (value || "").match(rgNotSpace) || [],
	            elem = this.node,
	            className = elem.className.baseVal,
	            curClasses = className.match(rgNotSpace) || [],
	            j,
	            pos,
	            clazz,
	            finalValue;
	        j = 0;
	        while ((clazz = classes[j++])) {
	            pos = curClasses.indexOf(clazz);
	            if (~pos) {
	                curClasses.splice(pos, 1);
	            } else {
	                curClasses.push(clazz);
	            }
	        }
	
	        finalValue = curClasses.join(" ");
	        if (className != finalValue) {
	            elem.className.baseVal = finalValue;
	        }
	        return this;
	    };
	});
	
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var operators = {
	            "+": function (x, y) {
	                    return x + y;
	                },
	            "-": function (x, y) {
	                    return x - y;
	                },
	            "/": function (x, y) {
	                    return x / y;
	                },
	            "*": function (x, y) {
	                    return x * y;
	                }
	        },
	        Str = String,
	        reUnit = /[a-z]+$/i,
	        reAddon = /^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;
	    function getNumber(val) {
	        return val;
	    }
	    function getUnit(unit) {
	        return function (val) {
	            return +val.toFixed(3) + unit;
	        };
	    }
	    eve.on("snap.util.attr", function (val) {
	        var plus = Str(val).match(reAddon);
	        if (plus) {
	            var evnt = eve.nt(),
	                name = evnt.substring(evnt.lastIndexOf(".") + 1),
	                a = this.attr(name),
	                atr = {};
	            eve.stop();
	            var unit = plus[3] || "",
	                aUnit = a.match(reUnit),
	                op = operators[plus[1]];
	            if (aUnit && aUnit == unit) {
	                val = op(parseFloat(a), +plus[2]);
	            } else {
	                a = this.asPX(name);
	                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));
	            }
	            if (isNaN(a) || isNaN(val)) {
	                return;
	            }
	            atr[name] = val;
	            this.attr(atr);
	        }
	    })(-10);
	    eve.on("snap.util.equal", function (name, b) {
	        var A, B, a = Str(this.attr(name) || ""),
	            el = this,
	            bplus = Str(b).match(reAddon);
	        if (bplus) {
	            eve.stop();
	            var unit = bplus[3] || "",
	                aUnit = a.match(reUnit),
	                op = operators[bplus[1]];
	            if (aUnit && aUnit == unit) {
	                return {
	                    from: parseFloat(a),
	                    to: op(parseFloat(a), +bplus[2]),
	                    f: getUnit(aUnit)
	                };
	            } else {
	                a = this.asPX(name);
	                return {
	                    from: a,
	                    to: op(a, this.asPX(name, bplus[2] + unit)),
	                    f: getNumber
	                };
	            }
	        }
	    })(-10);
	});
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var proto = Paper.prototype,
	        is = Snap.is;
	    /*\
	     * Paper.rect
	     [ method ]
	     *
	     * Draws a rectangle
	     **
	     - x (number) x coordinate of the top left corner
	     - y (number) y coordinate of the top left corner
	     - width (number) width
	     - height (number) height
	     - rx (number) #optional horizontal radius for rounded corners, default is 0
	     - ry (number) #optional vertical radius for rounded corners, default is rx or 0
	     = (object) the `rect` element
	     **
	     > Usage
	     | // regular rectangle
	     | var c = paper.rect(10, 10, 50, 50);
	     | // rectangle with rounded corners
	     | var c = paper.rect(40, 40, 50, 50, 10);
	    \*/
	    proto.rect = function (x, y, w, h, rx, ry) {
	        var attr;
	        if (ry == null) {
	            ry = rx;
	        }
	        if (is(x, "object") && x == "[object Object]") {
	            attr = x;
	        } else if (x != null) {
	            attr = {
	                x: x,
	                y: y,
	                width: w,
	                height: h
	            };
	            if (rx != null) {
	                attr.rx = rx;
	                attr.ry = ry;
	            }
	        }
	        return this.el("rect", attr);
	    };
	    /*\
	     * Paper.circle
	     [ method ]
	     **
	     * Draws a circle
	     **
	     - x (number) x coordinate of the centre
	     - y (number) y coordinate of the centre
	     - r (number) radius
	     = (object) the `circle` element
	     **
	     > Usage
	     | var c = paper.circle(50, 50, 40);
	    \*/
	    proto.circle = function (cx, cy, r) {
	        var attr;
	        if (is(cx, "object") && cx == "[object Object]") {
	            attr = cx;
	        } else if (cx != null) {
	            attr = {
	                cx: cx,
	                cy: cy,
	                r: r
	            };
	        }
	        return this.el("circle", attr);
	    };
	
	    var preload = (function () {
	        function onerror() {
	            this.parentNode.removeChild(this);
	        }
	        return function (src, f) {
	            var img = glob.doc.createElement("img"),
	                body = glob.doc.body;
	            img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
	            img.onload = function () {
	                f.call(img);
	                img.onload = img.onerror = null;
	                body.removeChild(img);
	            };
	            img.onerror = onerror;
	            body.appendChild(img);
	            img.src = src;
	        };
	    }());
	
	    /*\
	     * Paper.image
	     [ method ]
	     **
	     * Places an image on the surface
	     **
	     - src (string) URI of the source image
	     - x (number) x offset position
	     - y (number) y offset position
	     - width (number) width of the image
	     - height (number) height of the image
	     = (object) the `image` element
	     * or
	     = (object) Snap element object with type `image`
	     **
	     > Usage
	     | var c = paper.image("apple.png", 10, 10, 80, 80);
	    \*/
	    proto.image = function (src, x, y, width, height) {
	        var el = this.el("image");
	        if (is(src, "object") && "src" in src) {
	            el.attr(src);
	        } else if (src != null) {
	            var set = {
	                "xlink:href": src,
	                preserveAspectRatio: "none"
	            };
	            if (x != null && y != null) {
	                set.x = x;
	                set.y = y;
	            }
	            if (width != null && height != null) {
	                set.width = width;
	                set.height = height;
	            } else {
	                preload(src, function () {
	                    Snap._.$(el.node, {
	                        width: this.offsetWidth,
	                        height: this.offsetHeight
	                    });
	                });
	            }
	            Snap._.$(el.node, set);
	        }
	        return el;
	    };
	    /*\
	     * Paper.ellipse
	     [ method ]
	     **
	     * Draws an ellipse
	     **
	     - x (number) x coordinate of the centre
	     - y (number) y coordinate of the centre
	     - rx (number) horizontal radius
	     - ry (number) vertical radius
	     = (object) the `ellipse` element
	     **
	     > Usage
	     | var c = paper.ellipse(50, 50, 40, 20);
	    \*/
	    proto.ellipse = function (cx, cy, rx, ry) {
	        var attr;
	        if (is(cx, "object") && cx == "[object Object]") {
	            attr = cx;
	        } else if (cx != null) {
	            attr ={
	                cx: cx,
	                cy: cy,
	                rx: rx,
	                ry: ry
	            };
	        }
	        return this.el("ellipse", attr);
	    };
	    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.
	    /*\
	     * Paper.path
	     [ method ]
	     **
	     * Creates a `<path>` element using the given string as the path's definition
	     - pathString (string) #optional path string in SVG format
	     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:
	     | "M10,20L30,40"
	     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.
	     *
	     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a> or <a href="https://developer.mozilla.org/en/SVG/Tutorial/Paths">article about path strings at MDN</a>.</p>
	     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
	     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
	     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
	     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
	     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
	     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
	     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
	     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
	     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
	     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
	     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
	     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
	     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.
	     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.
	     > Usage
	     | var c = paper.path("M10 10L90 90");
	     | // draw a diagonal line:
	     | // move to 10,10, line to 90,90
	    \*/
	    proto.path = function (d) {
	        var attr;
	        if (is(d, "object") && !is(d, "array")) {
	            attr = d;
	        } else if (d) {
	            attr = {d: d};
	        }
	        return this.el("path", attr);
	    };
	    /*\
	     * Paper.g
	     [ method ]
	     **
	     * Creates a group element
	     **
	     - varargs (…) #optional elements to nest within the group
	     = (object) the `g` element
	     **
	     > Usage
	     | var c1 = paper.circle(),
	     |     c2 = paper.rect(),
	     |     g = paper.g(c2, c1); // note that the order of elements is different
	     * or
	     | var c1 = paper.circle(),
	     |     c2 = paper.rect(),
	     |     g = paper.g();
	     | g.add(c2, c1);
	    \*/
	    /*\
	     * Paper.group
	     [ method ]
	     **
	     * See @Paper.g
	    \*/
	    proto.group = proto.g = function (first) {
	        var attr,
	            el = this.el("g");
	        if (arguments.length == 1 && first && !first.type) {
	            el.attr(first);
	        } else if (arguments.length) {
	            el.add(Array.prototype.slice.call(arguments, 0));
	        }
	        return el;
	    };
	    /*\
	     * Paper.svg
	     [ method ]
	     **
	     * Creates a nested SVG element.
	     - x (number) @optional X of the element
	     - y (number) @optional Y of the element
	     - width (number) @optional width of the element
	     - height (number) @optional height of the element
	     - vbx (number) @optional viewbox X
	     - vby (number) @optional viewbox Y
	     - vbw (number) @optional viewbox width
	     - vbh (number) @optional viewbox height
	     **
	     = (object) the `svg` element
	     **
	    \*/
	    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {
	        var attrs = {};
	        if (is(x, "object") && y == null) {
	            attrs = x;
	        } else {
	            if (x != null) {
	                attrs.x = x;
	            }
	            if (y != null) {
	                attrs.y = y;
	            }
	            if (width != null) {
	                attrs.width = width;
	            }
	            if (height != null) {
	                attrs.height = height;
	            }
	            if (vbx != null && vby != null && vbw != null && vbh != null) {
	                attrs.viewBox = [vbx, vby, vbw, vbh];
	            }
	        }
	        return this.el("svg", attrs);
	    };
	    /*\
	     * Paper.mask
	     [ method ]
	     **
	     * Equivalent in behaviour to @Paper.g, except it’s a mask.
	     **
	     = (object) the `mask` element
	     **
	    \*/
	    proto.mask = function (first) {
	        var attr,
	            el = this.el("mask");
	        if (arguments.length == 1 && first && !first.type) {
	            el.attr(first);
	        } else if (arguments.length) {
	            el.add(Array.prototype.slice.call(arguments, 0));
	        }
	        return el;
	    };
	    /*\
	     * Paper.ptrn
	     [ method ]
	     **
	     * Equivalent in behaviour to @Paper.g, except it’s a pattern.
	     - x (number) @optional X of the element
	     - y (number) @optional Y of the element
	     - width (number) @optional width of the element
	     - height (number) @optional height of the element
	     - vbx (number) @optional viewbox X
	     - vby (number) @optional viewbox Y
	     - vbw (number) @optional viewbox width
	     - vbh (number) @optional viewbox height
	     **
	     = (object) the `pattern` element
	     **
	    \*/
	    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {
	        if (is(x, "object")) {
	            var attr = x;
	        } else {
	            attr = {patternUnits: "userSpaceOnUse"};
	            if (x) {
	                attr.x = x;
	            }
	            if (y) {
	                attr.y = y;
	            }
	            if (width != null) {
	                attr.width = width;
	            }
	            if (height != null) {
	                attr.height = height;
	            }
	            if (vx != null && vy != null && vw != null && vh != null) {
	                attr.viewBox = [vx, vy, vw, vh];
	            } else {
	                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];
	            }
	        }
	        return this.el("pattern", attr);
	    };
	    /*\
	     * Paper.use
	     [ method ]
	     **
	     * Creates a <use> element.
	     - id (string) @optional id of element to link
	     * or
	     - id (Element) @optional element to link
	     **
	     = (object) the `use` element
	     **
	    \*/
	    proto.use = function (id) {
	        if (id != null) {
	            if (id instanceof Element) {
	                if (!id.attr("id")) {
	                    id.attr({id: Snap._.id(id)});
	                }
	                id = id.attr("id");
	            }
	            if (String(id).charAt() == "#") {
	                id = id.substring(1);
	            }
	            return this.el("use", {"xlink:href": "#" + id});
	        } else {
	            return Element.prototype.use.call(this);
	        }
	    };
	    /*\
	     * Paper.symbol
	     [ method ]
	     **
	     * Creates a <symbol> element.
	     - vbx (number) @optional viewbox X
	     - vby (number) @optional viewbox Y
	     - vbw (number) @optional viewbox width
	     - vbh (number) @optional viewbox height
	     = (object) the `symbol` element
	     **
	    \*/
	    proto.symbol = function (vx, vy, vw, vh) {
	        var attr = {};
	        if (vx != null && vy != null && vw != null && vh != null) {
	            attr.viewBox = [vx, vy, vw, vh];
	        }
	
	        return this.el("symbol", attr);
	    };
	    /*\
	     * Paper.text
	     [ method ]
	     **
	     * Draws a text string
	     **
	     - x (number) x coordinate position
	     - y (number) y coordinate position
	     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements
	     = (object) the `text` element
	     **
	     > Usage
	     | var t1 = paper.text(50, 50, "Snap");
	     | var t2 = paper.text(50, 50, ["S","n","a","p"]);
	     | // Text path usage
	     | t1.attr({textpath: "M10,10L100,100"});
	     | // or
	     | var pth = paper.path("M10,10L100,100");
	     | t1.attr({textpath: pth});
	    \*/
	    proto.text = function (x, y, text) {
	        var attr = {};
	        if (is(x, "object")) {
	            attr = x;
	        } else if (x != null) {
	            attr = {
	                x: x,
	                y: y,
	                text: text || ""
	            };
	        }
	        return this.el("text", attr);
	    };
	    /*\
	     * Paper.line
	     [ method ]
	     **
	     * Draws a line
	     **
	     - x1 (number) x coordinate position of the start
	     - y1 (number) y coordinate position of the start
	     - x2 (number) x coordinate position of the end
	     - y2 (number) y coordinate position of the end
	     = (object) the `line` element
	     **
	     > Usage
	     | var t1 = paper.line(50, 50, 100, 100);
	    \*/
	    proto.line = function (x1, y1, x2, y2) {
	        var attr = {};
	        if (is(x1, "object")) {
	            attr = x1;
	        } else if (x1 != null) {
	            attr = {
	                x1: x1,
	                x2: x2,
	                y1: y1,
	                y2: y2
	            };
	        }
	        return this.el("line", attr);
	    };
	    /*\
	     * Paper.polyline
	     [ method ]
	     **
	     * Draws a polyline
	     **
	     - points (array) array of points
	     * or
	     - varargs (…) points
	     = (object) the `polyline` element
	     **
	     > Usage
	     | var p1 = paper.polyline([10, 10, 100, 100]);
	     | var p2 = paper.polyline(10, 10, 100, 100);
	    \*/
	    proto.polyline = function (points) {
	        if (arguments.length > 1) {
	            points = Array.prototype.slice.call(arguments, 0);
	        }
	        var attr = {};
	        if (is(points, "object") && !is(points, "array")) {
	            attr = points;
	        } else if (points != null) {
	            attr = {points: points};
	        }
	        return this.el("polyline", attr);
	    };
	    /*\
	     * Paper.polygon
	     [ method ]
	     **
	     * Draws a polygon. See @Paper.polyline
	    \*/
	    proto.polygon = function (points) {
	        if (arguments.length > 1) {
	            points = Array.prototype.slice.call(arguments, 0);
	        }
	        var attr = {};
	        if (is(points, "object") && !is(points, "array")) {
	            attr = points;
	        } else if (points != null) {
	            attr = {points: points};
	        }
	        return this.el("polygon", attr);
	    };
	    // gradients
	    (function () {
	        var $ = Snap._.$;
	        // gradients' helpers
	        function Gstops() {
	            return this.selectAll("stop");
	        }
	        function GaddStop(color, offset) {
	            var stop = $("stop"),
	                attr = {
	                    offset: +offset + "%"
	                };
	            color = Snap.color(color);
	            attr["stop-color"] = color.hex;
	            if (color.opacity < 1) {
	                attr["stop-opacity"] = color.opacity;
	            }
	            $(stop, attr);
	            this.node.appendChild(stop);
	            return this;
	        }
	        function GgetBBox() {
	            if (this.type == "linearGradient") {
	                var x1 = $(this.node, "x1") || 0,
	                    x2 = $(this.node, "x2") || 1,
	                    y1 = $(this.node, "y1") || 0,
	                    y2 = $(this.node, "y2") || 0;
	                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));
	            } else {
	                var cx = this.node.cx || .5,
	                    cy = this.node.cy || .5,
	                    r = this.node.r || 0;
	                return Snap._.box(cx - r, cy - r, r * 2, r * 2);
	            }
	        }
	        function gradient(defs, str) {
	            var grad = eve("snap.util.grad.parse", null, str).firstDefined(),
	                el;
	            if (!grad) {
	                return null;
	            }
	            grad.params.unshift(defs);
	            if (grad.type.toLowerCase() == "l") {
	                el = gradientLinear.apply(0, grad.params);
	            } else {
	                el = gradientRadial.apply(0, grad.params);
	            }
	            if (grad.type != grad.type.toLowerCase()) {
	                $(el.node, {
	                    gradientUnits: "userSpaceOnUse"
	                });
	            }
	            var stops = grad.stops,
	                len = stops.length,
	                start = 0,
	                j = 0;
	            function seed(i, end) {
	                var step = (end - start) / (i - j);
	                for (var k = j; k < i; k++) {
	                    stops[k].offset = +(+start + step * (k - j)).toFixed(2);
	                }
	                j = i;
	                start = end;
	            }
	            len--;
	            for (var i = 0; i < len; i++) if ("offset" in stops[i]) {
	                seed(i, stops[i].offset);
	            }
	            stops[len].offset = stops[len].offset || 100;
	            seed(len, stops[len].offset);
	            for (i = 0; i <= len; i++) {
	                var stop = stops[i];
	                el.addStop(stop.color, stop.offset);
	            }
	            return el;
	        }
	        function gradientLinear(defs, x1, y1, x2, y2) {
	            var el = Snap._.make("linearGradient", defs);
	            el.stops = Gstops;
	            el.addStop = GaddStop;
	            el.getBBox = GgetBBox;
	            if (x1 != null) {
	                $(el.node, {
	                    x1: x1,
	                    y1: y1,
	                    x2: x2,
	                    y2: y2
	                });
	            }
	            return el;
	        }
	        function gradientRadial(defs, cx, cy, r, fx, fy) {
	            var el = Snap._.make("radialGradient", defs);
	            el.stops = Gstops;
	            el.addStop = GaddStop;
	            el.getBBox = GgetBBox;
	            if (cx != null) {
	                $(el.node, {
	                    cx: cx,
	                    cy: cy,
	                    r: r
	                });
	            }
	            if (fx != null && fy != null) {
	                $(el.node, {
	                    fx: fx,
	                    fy: fy
	                });
	            }
	            return el;
	        }
	        /*\
	         * Paper.gradient
	         [ method ]
	         **
	         * Creates a gradient element
	         **
	         - gradient (string) gradient descriptor
	         > Gradient Descriptor
	         * The gradient descriptor is an expression formatted as
	         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be
	         * either linear or radial.  The uppercase `L` or `R` letters
	         * indicate absolute coordinates offset from the SVG surface.
	         * Lowercase `l` or `r` letters indicate coordinates
	         * calculated relative to the element to which the gradient is
	         * applied.  Coordinates specify a linear gradient vector as
	         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,
	         * `r` and optional `fx`, `fy` specifying a focal point away
	         * from the center of the circle. Specify `<colors>` as a list
	         * of dash-separated CSS color values.  Each color may be
	         * followed by a custom offset value, separated with a colon
	         * character.
	         > Examples
	         * Linear gradient, relative from top-left corner to bottom-right
	         * corner, from black through red to white:
	         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
	         * Linear gradient, absolute from (0, 0) to (100, 100), from black
	         * through red at 25% to white:
	         | var g = paper.gradient("L(0, 0, 100, 100)#000-#f00:25-#fff");
	         * Radial gradient, relative from the center of the element with radius
	         * half the width, from black to white:
	         | var g = paper.gradient("r(0.5, 0.5, 0.5)#000-#fff");
	         * To apply the gradient:
	         | paper.circle(50, 50, 40).attr({
	         |     fill: g
	         | });
	         = (object) the `gradient` element
	        \*/
	        proto.gradient = function (str) {
	            return gradient(this.defs, str);
	        };
	        proto.gradientLinear = function (x1, y1, x2, y2) {
	            return gradientLinear(this.defs, x1, y1, x2, y2);
	        };
	        proto.gradientRadial = function (cx, cy, r, fx, fy) {
	            return gradientRadial(this.defs, cx, cy, r, fx, fy);
	        };
	        /*\
	         * Paper.toString
	         [ method ]
	         **
	         * Returns SVG code for the @Paper
	         = (string) SVG code for the @Paper
	        \*/
	        proto.toString = function () {
	            var doc = this.node.ownerDocument,
	                f = doc.createDocumentFragment(),
	                d = doc.createElement("div"),
	                svg = this.node.cloneNode(true),
	                res;
	            f.appendChild(d);
	            d.appendChild(svg);
	            Snap._.$(svg, {xmlns: "http://www.w3.org/2000/svg"});
	            res = d.innerHTML;
	            f.removeChild(f.firstChild);
	            return res;
	        };
	        /*\
	         * Paper.toDataURL
	         [ method ]
	         **
	         * Returns SVG code for the @Paper as Data URI string.
	         = (string) Data URI string
	        \*/
	        proto.toDataURL = function () {
	            if (window && window.btoa) {
	                return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(this)));
	            }
	        };
	        /*\
	         * Paper.clear
	         [ method ]
	         **
	         * Removes all child nodes of the paper, except <defs>.
	        \*/
	        proto.clear = function () {
	            var node = this.node.firstChild,
	                next;
	            while (node) {
	                next = node.nextSibling;
	                if (node.tagName != "defs") {
	                    node.parentNode.removeChild(node);
	                } else {
	                    proto.clear.call({node: node});
	                }
	                node = next;
	            }
	        };
	    }());
	});
	
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob) {
	    var elproto = Element.prototype,
	        is = Snap.is,
	        clone = Snap._.clone,
	        has = "hasOwnProperty",
	        p2s = /,?([a-z]),?/gi,
	        toFloat = parseFloat,
	        math = Math,
	        PI = math.PI,
	        mmin = math.min,
	        mmax = math.max,
	        pow = math.pow,
	        abs = math.abs;
	    function paths(ps) {
	        var p = paths.ps = paths.ps || {};
	        if (p[ps]) {
	            p[ps].sleep = 100;
	        } else {
	            p[ps] = {
	                sleep: 100
	            };
	        }
	        setTimeout(function () {
	            for (var key in p) if (p[has](key) && key != ps) {
	                p[key].sleep--;
	                !p[key].sleep && delete p[key];
	            }
	        });
	        return p[ps];
	    }
	    function box(x, y, width, height) {
	        if (x == null) {
	            x = y = width = height = 0;
	        }
	        if (y == null) {
	            y = x.y;
	            width = x.width;
	            height = x.height;
	            x = x.x;
	        }
	        return {
	            x: x,
	            y: y,
	            width: width,
	            w: width,
	            height: height,
	            h: height,
	            x2: x + width,
	            y2: y + height,
	            cx: x + width / 2,
	            cy: y + height / 2,
	            r1: math.min(width, height) / 2,
	            r2: math.max(width, height) / 2,
	            r0: math.sqrt(width * width + height * height) / 2,
	            path: rectPath(x, y, width, height),
	            vb: [x, y, width, height].join(" ")
	        };
	    }
	    function toString() {
	        return this.join(",").replace(p2s, "$1");
	    }
	    function pathClone(pathArray) {
	        var res = clone(pathArray);
	        res.toString = toString;
	        return res;
	    }
	    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
	        if (length == null) {
	            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
	        } else {
	            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,
	                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
	        }
	    }
	    function getLengthFactory(istotal, subpath) {
	        function O(val) {
	            return +(+val).toFixed(3);
	        }
	        return Snap._.cacher(function (path, length, onlystart) {
	            if (path instanceof Element) {
	                path = path.attr("d");
	            }
	            path = path2curve(path);
	            var x, y, p, l, sp = "", subpaths = {}, point,
	                len = 0;
	            for (var i = 0, ii = path.length; i < ii; i++) {
	                p = path[i];
	                if (p[0] == "M") {
	                    x = +p[1];
	                    y = +p[2];
	                } else {
	                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
	                    if (len + l > length) {
	                        if (subpath && !subpaths.start) {
	                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
	                            sp += [
	                                "C" + O(point.start.x),
	                                O(point.start.y),
	                                O(point.m.x),
	                                O(point.m.y),
	                                O(point.x),
	                                O(point.y)
	                            ];
	                            if (onlystart) {return sp;}
	                            subpaths.start = sp;
	                            sp = [
	                                "M" + O(point.x),
	                                O(point.y) + "C" + O(point.n.x),
	                                O(point.n.y),
	                                O(point.end.x),
	                                O(point.end.y),
	                                O(p[5]),
	                                O(p[6])
	                            ].join();
	                            len += l;
	                            x = +p[5];
	                            y = +p[6];
	                            continue;
	                        }
	                        if (!istotal && !subpath) {
	                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
	                            return point;
	                        }
	                    }
	                    len += l;
	                    x = +p[5];
	                    y = +p[6];
	                }
	                sp += p.shift() + p;
	            }
	            subpaths.end = sp;
	            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
	            return point;
	        }, null, Snap._.clone);
	    }
	    var getTotalLength = getLengthFactory(1),
	        getPointAtLength = getLengthFactory(),
	        getSubpathsAtLength = getLengthFactory(0, 1);
	    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
	        var t1 = 1 - t,
	            t13 = pow(t1, 3),
	            t12 = pow(t1, 2),
	            t2 = t * t,
	            t3 = t2 * t,
	            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
	            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
	            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
	            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
	            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
	            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
	            ax = t1 * p1x + t * c1x,
	            ay = t1 * p1y + t * c1y,
	            cx = t1 * c2x + t * p2x,
	            cy = t1 * c2y + t * p2y,
	            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
	        // (mx > nx || my < ny) && (alpha += 180);
	        return {
	            x: x,
	            y: y,
	            m: {x: mx, y: my},
	            n: {x: nx, y: ny},
	            start: {x: ax, y: ay},
	            end: {x: cx, y: cy},
	            alpha: alpha
	        };
	    }
	    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
	        if (!Snap.is(p1x, "array")) {
	            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
	        }
	        var bbox = curveDim.apply(null, p1x);
	        return box(
	            bbox.min.x,
	            bbox.min.y,
	            bbox.max.x - bbox.min.x,
	            bbox.max.y - bbox.min.y
	        );
	    }
	    function isPointInsideBBox(bbox, x, y) {
	        return  x >= bbox.x &&
	                x <= bbox.x + bbox.width &&
	                y >= bbox.y &&
	                y <= bbox.y + bbox.height;
	    }
	    function isBBoxIntersect(bbox1, bbox2) {
	        bbox1 = box(bbox1);
	        bbox2 = box(bbox2);
	        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
	            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
	            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
	            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
	            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
	            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
	            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
	            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
	            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
	                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
	            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
	                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
	    }
	    function base3(t, p1, p2, p3, p4) {
	        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
	            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
	        return t * t2 - 3 * p1 + 3 * p2;
	    }
	    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
	        if (z == null) {
	            z = 1;
	        }
	        z = z > 1 ? 1 : z < 0 ? 0 : z;
	        var z2 = z / 2,
	            n = 12,
	            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],
	            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
	            sum = 0;
	        for (var i = 0; i < n; i++) {
	            var ct = z2 * Tvalues[i] + z2,
	                xbase = base3(ct, x1, x2, x3, x4),
	                ybase = base3(ct, y1, y2, y3, y4),
	                comb = xbase * xbase + ybase * ybase;
	            sum += Cvalues[i] * math.sqrt(comb);
	        }
	        return z2 * sum;
	    }
	    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
	        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
	            return;
	        }
	        var t = 1,
	            step = t / 2,
	            t2 = t - step,
	            l,
	            e = .01;
	        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
	        while (abs(l - ll) > e) {
	            step /= 2;
	            t2 += (l < ll ? 1 : -1) * step;
	            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
	        }
	        return t2;
	    }
	    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
	        if (
	            mmax(x1, x2) < mmin(x3, x4) ||
	            mmin(x1, x2) > mmax(x3, x4) ||
	            mmax(y1, y2) < mmin(y3, y4) ||
	            mmin(y1, y2) > mmax(y3, y4)
	        ) {
	            return;
	        }
	        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
	            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
	            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
	
	        if (!denominator) {
	            return;
	        }
	        var px = nx / denominator,
	            py = ny / denominator,
	            px2 = +px.toFixed(2),
	            py2 = +py.toFixed(2);
	        if (
	            px2 < +mmin(x1, x2).toFixed(2) ||
	            px2 > +mmax(x1, x2).toFixed(2) ||
	            px2 < +mmin(x3, x4).toFixed(2) ||
	            px2 > +mmax(x3, x4).toFixed(2) ||
	            py2 < +mmin(y1, y2).toFixed(2) ||
	            py2 > +mmax(y1, y2).toFixed(2) ||
	            py2 < +mmin(y3, y4).toFixed(2) ||
	            py2 > +mmax(y3, y4).toFixed(2)
	        ) {
	            return;
	        }
	        return {x: px, y: py};
	    }
	    function inter(bez1, bez2) {
	        return interHelper(bez1, bez2);
	    }
	    function interCount(bez1, bez2) {
	        return interHelper(bez1, bez2, 1);
	    }
	    function interHelper(bez1, bez2, justCount) {
	        var bbox1 = bezierBBox(bez1),
	            bbox2 = bezierBBox(bez2);
	        if (!isBBoxIntersect(bbox1, bbox2)) {
	            return justCount ? 0 : [];
	        }
	        var l1 = bezlen.apply(0, bez1),
	            l2 = bezlen.apply(0, bez2),
	            n1 = ~~(l1 / 8),
	            n2 = ~~(l2 / 8),
	            dots1 = [],
	            dots2 = [],
	            xy = {},
	            res = justCount ? 0 : [];
	        for (var i = 0; i < n1 + 1; i++) {
	            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
	            dots1.push({x: p.x, y: p.y, t: i / n1});
	        }
	        for (i = 0; i < n2 + 1; i++) {
	            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
	            dots2.push({x: p.x, y: p.y, t: i / n2});
	        }
	        for (i = 0; i < n1; i++) {
	            for (var j = 0; j < n2; j++) {
	                var di = dots1[i],
	                    di1 = dots1[i + 1],
	                    dj = dots2[j],
	                    dj1 = dots2[j + 1],
	                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
	                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
	                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
	                if (is) {
	                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
	                        continue;
	                    }
	                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
	                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
	                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
	                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
	                        if (justCount) {
	                            res++;
	                        } else {
	                            res.push({
	                                x: is.x,
	                                y: is.y,
	                                t1: t1,
	                                t2: t2
	                            });
	                        }
	                    }
	                }
	            }
	        }
	        return res;
	    }
	    function pathIntersection(path1, path2) {
	        return interPathHelper(path1, path2);
	    }
	    function pathIntersectionNumber(path1, path2) {
	        return interPathHelper(path1, path2, 1);
	    }
	    function interPathHelper(path1, path2, justCount) {
	        path1 = path2curve(path1);
	        path2 = path2curve(path2);
	        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
	            res = justCount ? 0 : [];
	        for (var i = 0, ii = path1.length; i < ii; i++) {
	            var pi = path1[i];
	            if (pi[0] == "M") {
	                x1 = x1m = pi[1];
	                y1 = y1m = pi[2];
	            } else {
	                if (pi[0] == "C") {
	                    bez1 = [x1, y1].concat(pi.slice(1));
	                    x1 = bez1[6];
	                    y1 = bez1[7];
	                } else {
	                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
	                    x1 = x1m;
	                    y1 = y1m;
	                }
	                for (var j = 0, jj = path2.length; j < jj; j++) {
	                    var pj = path2[j];
	                    if (pj[0] == "M") {
	                        x2 = x2m = pj[1];
	                        y2 = y2m = pj[2];
	                    } else {
	                        if (pj[0] == "C") {
	                            bez2 = [x2, y2].concat(pj.slice(1));
	                            x2 = bez2[6];
	                            y2 = bez2[7];
	                        } else {
	                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
	                            x2 = x2m;
	                            y2 = y2m;
	                        }
	                        var intr = interHelper(bez1, bez2, justCount);
	                        if (justCount) {
	                            res += intr;
	                        } else {
	                            for (var k = 0, kk = intr.length; k < kk; k++) {
	                                intr[k].segment1 = i;
	                                intr[k].segment2 = j;
	                                intr[k].bez1 = bez1;
	                                intr[k].bez2 = bez2;
	                            }
	                            res = res.concat(intr);
	                        }
	                    }
	                }
	            }
	        }
	        return res;
	    }
	    function isPointInsidePath(path, x, y) {
	        var bbox = pathBBox(path);
	        return isPointInsideBBox(bbox, x, y) &&
	               interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
	    }
	    function pathBBox(path) {
	        var pth = paths(path);
	        if (pth.bbox) {
	            return clone(pth.bbox);
	        }
	        if (!path) {
	            return box();
	        }
	        path = path2curve(path);
	        var x = 0,
	            y = 0,
	            X = [],
	            Y = [],
	            p;
	        for (var i = 0, ii = path.length; i < ii; i++) {
	            p = path[i];
	            if (p[0] == "M") {
	                x = p[1];
	                y = p[2];
	                X.push(x);
	                Y.push(y);
	            } else {
	                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
	                X = X.concat(dim.min.x, dim.max.x);
	                Y = Y.concat(dim.min.y, dim.max.y);
	                x = p[5];
	                y = p[6];
	            }
	        }
	        var xmin = mmin.apply(0, X),
	            ymin = mmin.apply(0, Y),
	            xmax = mmax.apply(0, X),
	            ymax = mmax.apply(0, Y),
	            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);
	        pth.bbox = clone(bb);
	        return bb;
	    }
	    function rectPath(x, y, w, h, r) {
	        if (r) {
	            return [
	                ["M", +x + (+r), y],
	                ["l", w - r * 2, 0],
	                ["a", r, r, 0, 0, 1, r, r],
	                ["l", 0, h - r * 2],
	                ["a", r, r, 0, 0, 1, -r, r],
	                ["l", r * 2 - w, 0],
	                ["a", r, r, 0, 0, 1, -r, -r],
	                ["l", 0, r * 2 - h],
	                ["a", r, r, 0, 0, 1, r, -r],
	                ["z"]
	            ];
	        }
	        var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
	        res.toString = toString;
	        return res;
	    }
	    function ellipsePath(x, y, rx, ry, a) {
	        if (a == null && ry == null) {
	            ry = rx;
	        }
	        x = +x;
	        y = +y;
	        rx = +rx;
	        ry = +ry;
	        if (a != null) {
	            var rad = Math.PI / 180,
	                x1 = x + rx * Math.cos(-ry * rad),
	                x2 = x + rx * Math.cos(-a * rad),
	                y1 = y + rx * Math.sin(-ry * rad),
	                y2 = y + rx * Math.sin(-a * rad),
	                res = [["M", x1, y1], ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
	        } else {
	            res = [
	                ["M", x, y],
	                ["m", 0, -ry],
	                ["a", rx, ry, 0, 1, 1, 0, 2 * ry],
	                ["a", rx, ry, 0, 1, 1, 0, -2 * ry],
	                ["z"]
	            ];
	        }
	        res.toString = toString;
	        return res;
	    }
	    var unit2px = Snap._unit2px,
	        getPath = {
	        path: function (el) {
	            return el.attr("path");
	        },
	        circle: function (el) {
	            var attr = unit2px(el);
	            return ellipsePath(attr.cx, attr.cy, attr.r);
	        },
	        ellipse: function (el) {
	            var attr = unit2px(el);
	            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);
	        },
	        rect: function (el) {
	            var attr = unit2px(el);
	            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);
	        },
	        image: function (el) {
	            var attr = unit2px(el);
	            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);
	        },
	        line: function (el) {
	            return "M" + [el.attr("x1") || 0, el.attr("y1") || 0, el.attr("x2"), el.attr("y2")];
	        },
	        polyline: function (el) {
	            return "M" + el.attr("points");
	        },
	        polygon: function (el) {
	            return "M" + el.attr("points") + "z";
	        },
	        deflt: function (el) {
	            var bbox = el.node.getBBox();
	            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
	        }
	    };
	    function pathToRelative(pathArray) {
	        var pth = paths(pathArray),
	            lowerCase = String.prototype.toLowerCase;
	        if (pth.rel) {
	            return pathClone(pth.rel);
	        }
	        if (!Snap.is(pathArray, "array") || !Snap.is(pathArray && pathArray[0], "array")) {
	            pathArray = Snap.parsePathString(pathArray);
	        }
	        var res = [],
	            x = 0,
	            y = 0,
	            mx = 0,
	            my = 0,
	            start = 0;
	        if (pathArray[0][0] == "M") {
	            x = pathArray[0][1];
	            y = pathArray[0][2];
	            mx = x;
	            my = y;
	            start++;
	            res.push(["M", x, y]);
	        }
	        for (var i = start, ii = pathArray.length; i < ii; i++) {
	            var r = res[i] = [],
	                pa = pathArray[i];
	            if (pa[0] != lowerCase.call(pa[0])) {
	                r[0] = lowerCase.call(pa[0]);
	                switch (r[0]) {
	                    case "a":
	                        r[1] = pa[1];
	                        r[2] = pa[2];
	                        r[3] = pa[3];
	                        r[4] = pa[4];
	                        r[5] = pa[5];
	                        r[6] = +(pa[6] - x).toFixed(3);
	                        r[7] = +(pa[7] - y).toFixed(3);
	                        break;
	                    case "v":
	                        r[1] = +(pa[1] - y).toFixed(3);
	                        break;
	                    case "m":
	                        mx = pa[1];
	                        my = pa[2];
	                    default:
	                        for (var j = 1, jj = pa.length; j < jj; j++) {
	                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
	                        }
	                }
	            } else {
	                r = res[i] = [];
	                if (pa[0] == "m") {
	                    mx = pa[1] + x;
	                    my = pa[2] + y;
	                }
	                for (var k = 0, kk = pa.length; k < kk; k++) {
	                    res[i][k] = pa[k];
	                }
	            }
	            var len = res[i].length;
	            switch (res[i][0]) {
	                case "z":
	                    x = mx;
	                    y = my;
	                    break;
	                case "h":
	                    x += +res[i][len - 1];
	                    break;
	                case "v":
	                    y += +res[i][len - 1];
	                    break;
	                default:
	                    x += +res[i][len - 2];
	                    y += +res[i][len - 1];
	            }
	        }
	        res.toString = toString;
	        pth.rel = pathClone(res);
	        return res;
	    }
	    function pathToAbsolute(pathArray) {
	        var pth = paths(pathArray);
	        if (pth.abs) {
	            return pathClone(pth.abs);
	        }
	        if (!is(pathArray, "array") || !is(pathArray && pathArray[0], "array")) { // rough assumption
	            pathArray = Snap.parsePathString(pathArray);
	        }
	        if (!pathArray || !pathArray.length) {
	            return [["M", 0, 0]];
	        }
	        var res = [],
	            x = 0,
	            y = 0,
	            mx = 0,
	            my = 0,
	            start = 0,
	            pa0;
	        if (pathArray[0][0] == "M") {
	            x = +pathArray[0][1];
	            y = +pathArray[0][2];
	            mx = x;
	            my = y;
	            start++;
	            res[0] = ["M", x, y];
	        }
	        var crz = pathArray.length == 3 &&
	            pathArray[0][0] == "M" &&
	            pathArray[1][0].toUpperCase() == "R" &&
	            pathArray[2][0].toUpperCase() == "Z";
	        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
	            res.push(r = []);
	            pa = pathArray[i];
	            pa0 = pa[0];
	            if (pa0 != pa0.toUpperCase()) {
	                r[0] = pa0.toUpperCase();
	                switch (r[0]) {
	                    case "A":
	                        r[1] = pa[1];
	                        r[2] = pa[2];
	                        r[3] = pa[3];
	                        r[4] = pa[4];
	                        r[5] = pa[5];
	                        r[6] = +pa[6] + x;
	                        r[7] = +pa[7] + y;
	                        break;
	                    case "V":
	                        r[1] = +pa[1] + y;
	                        break;
	                    case "H":
	                        r[1] = +pa[1] + x;
	                        break;
	                    case "R":
	                        var dots = [x, y].concat(pa.slice(1));
	                        for (var j = 2, jj = dots.length; j < jj; j++) {
	                            dots[j] = +dots[j] + x;
	                            dots[++j] = +dots[j] + y;
	                        }
	                        res.pop();
	                        res = res.concat(catmullRom2bezier(dots, crz));
	                        break;
	                    case "O":
	                        res.pop();
	                        dots = ellipsePath(x, y, pa[1], pa[2]);
	                        dots.push(dots[0]);
	                        res = res.concat(dots);
	                        break;
	                    case "U":
	                        res.pop();
	                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
	                        r = ["U"].concat(res[res.length - 1].slice(-2));
	                        break;
	                    case "M":
	                        mx = +pa[1] + x;
	                        my = +pa[2] + y;
	                    default:
	                        for (j = 1, jj = pa.length; j < jj; j++) {
	                            r[j] = +pa[j] + ((j % 2) ? x : y);
	                        }
	                }
	            } else if (pa0 == "R") {
	                dots = [x, y].concat(pa.slice(1));
	                res.pop();
	                res = res.concat(catmullRom2bezier(dots, crz));
	                r = ["R"].concat(pa.slice(-2));
	            } else if (pa0 == "O") {
	                res.pop();
	                dots = ellipsePath(x, y, pa[1], pa[2]);
	                dots.push(dots[0]);
	                res = res.concat(dots);
	            } else if (pa0 == "U") {
	                res.pop();
	                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
	                r = ["U"].concat(res[res.length - 1].slice(-2));
	            } else {
	                for (var k = 0, kk = pa.length; k < kk; k++) {
	                    r[k] = pa[k];
	                }
	            }
	            pa0 = pa0.toUpperCase();
	            if (pa0 != "O") {
	                switch (r[0]) {
	                    case "Z":
	                        x = +mx;
	                        y = +my;
	                        break;
	                    case "H":
	                        x = r[1];
	                        break;
	                    case "V":
	                        y = r[1];
	                        break;
	                    case "M":
	                        mx = r[r.length - 2];
	                        my = r[r.length - 1];
	                    default:
	                        x = r[r.length - 2];
	                        y = r[r.length - 1];
	                }
	            }
	        }
	        res.toString = toString;
	        pth.abs = pathClone(res);
	        return res;
	    }
	    function l2c(x1, y1, x2, y2) {
	        return [x1, y1, x2, y2, x2, y2];
	    }
	    function q2c(x1, y1, ax, ay, x2, y2) {
	        var _13 = 1 / 3,
	            _23 = 2 / 3;
	        return [
	                _13 * x1 + _23 * ax,
	                _13 * y1 + _23 * ay,
	                _13 * x2 + _23 * ax,
	                _13 * y2 + _23 * ay,
	                x2,
	                y2
	            ];
	    }
	    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
	        // for more information of where this math came from visit:
	        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	        var _120 = PI * 120 / 180,
	            rad = PI / 180 * (+angle || 0),
	            res = [],
	            xy,
	            rotate = Snap._.cacher(function (x, y, rad) {
	                var X = x * math.cos(rad) - y * math.sin(rad),
	                    Y = x * math.sin(rad) + y * math.cos(rad);
	                return {x: X, y: Y};
	            });
	        if (!recursive) {
	            xy = rotate(x1, y1, -rad);
	            x1 = xy.x;
	            y1 = xy.y;
	            xy = rotate(x2, y2, -rad);
	            x2 = xy.x;
	            y2 = xy.y;
	            var cos = math.cos(PI / 180 * angle),
	                sin = math.sin(PI / 180 * angle),
	                x = (x1 - x2) / 2,
	                y = (y1 - y2) / 2;
	            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
	            if (h > 1) {
	                h = math.sqrt(h);
	                rx = h * rx;
	                ry = h * ry;
	            }
	            var rx2 = rx * rx,
	                ry2 = ry * ry,
	                k = (large_arc_flag == sweep_flag ? -1 : 1) *
	                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
	                cx = k * rx * y / ry + (x1 + x2) / 2,
	                cy = k * -ry * x / rx + (y1 + y2) / 2,
	                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
	                f2 = math.asin(((y2 - cy) / ry).toFixed(9));
	
	            f1 = x1 < cx ? PI - f1 : f1;
	            f2 = x2 < cx ? PI - f2 : f2;
	            f1 < 0 && (f1 = PI * 2 + f1);
	            f2 < 0 && (f2 = PI * 2 + f2);
	            if (sweep_flag && f1 > f2) {
	                f1 = f1 - PI * 2;
	            }
	            if (!sweep_flag && f2 > f1) {
	                f2 = f2 - PI * 2;
	            }
	        } else {
	            f1 = recursive[0];
	            f2 = recursive[1];
	            cx = recursive[2];
	            cy = recursive[3];
	        }
	        var df = f2 - f1;
	        if (abs(df) > _120) {
	            var f2old = f2,
	                x2old = x2,
	                y2old = y2;
	            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
	            x2 = cx + rx * math.cos(f2);
	            y2 = cy + ry * math.sin(f2);
	            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
	        }
	        df = f2 - f1;
	        var c1 = math.cos(f1),
	            s1 = math.sin(f1),
	            c2 = math.cos(f2),
	            s2 = math.sin(f2),
	            t = math.tan(df / 4),
	            hx = 4 / 3 * rx * t,
	            hy = 4 / 3 * ry * t,
	            m1 = [x1, y1],
	            m2 = [x1 + hx * s1, y1 - hy * c1],
	            m3 = [x2 + hx * s2, y2 - hy * c2],
	            m4 = [x2, y2];
	        m2[0] = 2 * m1[0] - m2[0];
	        m2[1] = 2 * m1[1] - m2[1];
	        if (recursive) {
	            return [m2, m3, m4].concat(res);
	        } else {
	            res = [m2, m3, m4].concat(res).join().split(",");
	            var newres = [];
	            for (var i = 0, ii = res.length; i < ii; i++) {
	                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
	            }
	            return newres;
	        }
	    }
	    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
	        var t1 = 1 - t;
	        return {
	            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
	            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
	        };
	    }
	
	    // Returns bounding box of cubic bezier curve.
	    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
	    // Original version: NISHIO Hirokazu
	    // Modifications: https://github.com/timo22345
	    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
	        var tvalues = [],
	            bounds = [[], []],
	            a, b, c, t, t1, t2, b2ac, sqrtb2ac;
	        for (var i = 0; i < 2; ++i) {
	            if (i == 0) {
	                b = 6 * x0 - 12 * x1 + 6 * x2;
	                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
	                c = 3 * x1 - 3 * x0;
	            } else {
	                b = 6 * y0 - 12 * y1 + 6 * y2;
	                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
	                c = 3 * y1 - 3 * y0;
	            }
	            if (abs(a) < 1e-12) {
	                if (abs(b) < 1e-12) {
	                    continue;
	                }
	                t = -c / b;
	                if (0 < t && t < 1) {
	                    tvalues.push(t);
	                }
	                continue;
	            }
	            b2ac = b * b - 4 * c * a;
	            sqrtb2ac = math.sqrt(b2ac);
	            if (b2ac < 0) {
	                continue;
	            }
	            t1 = (-b + sqrtb2ac) / (2 * a);
	            if (0 < t1 && t1 < 1) {
	                tvalues.push(t1);
	            }
	            t2 = (-b - sqrtb2ac) / (2 * a);
	            if (0 < t2 && t2 < 1) {
	                tvalues.push(t2);
	            }
	        }
	
	        var x, y, j = tvalues.length,
	            jlen = j,
	            mt;
	        while (j--) {
	            t = tvalues[j];
	            mt = 1 - t;
	            bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
	            bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
	        }
	
	        bounds[0][jlen] = x0;
	        bounds[1][jlen] = y0;
	        bounds[0][jlen + 1] = x3;
	        bounds[1][jlen + 1] = y3;
	        bounds[0].length = bounds[1].length = jlen + 2;
	
	
	        return {
	          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},
	          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}
	        };
	    }
	
	    function path2curve(path, path2) {
	        var pth = !path2 && paths(path);
	        if (!path2 && pth.curve) {
	            return pathClone(pth.curve);
	        }
	        var p = pathToAbsolute(path),
	            p2 = path2 && pathToAbsolute(path2),
	            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
	            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
	            processPath = function (path, d, pcom) {
	                var nx, ny;
	                if (!path) {
	                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
	                }
	                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);
	                switch (path[0]) {
	                    case "M":
	                        d.X = path[1];
	                        d.Y = path[2];
	                        break;
	                    case "A":
	                        path = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
	                        break;
	                    case "S":
	                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
	                            nx = d.x * 2 - d.bx;          // And reflect the previous
	                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
	                        }
	                        else {                            // or some else or nothing
	                            nx = d.x;
	                            ny = d.y;
	                        }
	                        path = ["C", nx, ny].concat(path.slice(1));
	                        break;
	                    case "T":
	                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
	                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
	                            d.qy = d.y * 2 - d.qy;        // to case "S".
	                        }
	                        else {                            // or something else or nothing
	                            d.qx = d.x;
	                            d.qy = d.y;
	                        }
	                        path = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
	                        break;
	                    case "Q":
	                        d.qx = path[1];
	                        d.qy = path[2];
	                        path = ["C"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
	                        break;
	                    case "L":
	                        path = ["C"].concat(l2c(d.x, d.y, path[1], path[2]));
	                        break;
	                    case "H":
	                        path = ["C"].concat(l2c(d.x, d.y, path[1], d.y));
	                        break;
	                    case "V":
	                        path = ["C"].concat(l2c(d.x, d.y, d.x, path[1]));
	                        break;
	                    case "Z":
	                        path = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
	                        break;
	                }
	                return path;
	            },
	            fixArc = function (pp, i) {
	                if (pp[i].length > 7) {
	                    pp[i].shift();
	                    var pi = pp[i];
	                    while (pi.length) {
	                        pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
	                        p2 && (pcoms2[i] = "A"); // the same as above
	                        pp.splice(i++, 0, ["C"].concat(pi.splice(0, 6)));
	                    }
	                    pp.splice(i, 1);
	                    ii = mmax(p.length, p2 && p2.length || 0);
	                }
	            },
	            fixM = function (path1, path2, a1, a2, i) {
	                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
	                    path2.splice(i, 0, ["M", a2.x, a2.y]);
	                    a1.bx = 0;
	                    a1.by = 0;
	                    a1.x = path1[i][1];
	                    a1.y = path1[i][2];
	                    ii = mmax(p.length, p2 && p2.length || 0);
	                }
	            },
	            pcoms1 = [], // path commands of original path p
	            pcoms2 = [], // path commands of original path p2
	            pfirst = "", // temporary holder for original path command
	            pcom = ""; // holder for previous path command of original path
	        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
	            p[i] && (pfirst = p[i][0]); // save current path command
	
	            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
	            {
	                pcoms1[i] = pfirst; // Save current path command
	                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom
	            }
	            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath
	
	            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
	            // which may produce multiple C:s
	            // so we have to make sure that C is also C in original path
	
	            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1
	
	            if (p2) { // the same procedures is done to p2
	                p2[i] && (pfirst = p2[i][0]);
	                if (pfirst != "C") {
	                    pcoms2[i] = pfirst;
	                    i && (pcom = pcoms2[i - 1]);
	                }
	                p2[i] = processPath(p2[i], attrs2, pcom);
	
	                if (pcoms2[i] != "A" && pfirst == "C") {
	                    pcoms2[i] = "C";
	                }
	
	                fixArc(p2, i);
	            }
	            fixM(p, p2, attrs, attrs2, i);
	            fixM(p2, p, attrs2, attrs, i);
	            var seg = p[i],
	                seg2 = p2 && p2[i],
	                seglen = seg.length,
	                seg2len = p2 && seg2.length;
	            attrs.x = seg[seglen - 2];
	            attrs.y = seg[seglen - 1];
	            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
	            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
	            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
	            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
	            attrs2.x = p2 && seg2[seg2len - 2];
	            attrs2.y = p2 && seg2[seg2len - 1];
	        }
	        if (!p2) {
	            pth.curve = pathClone(p);
	        }
	        return p2 ? [p, p2] : p;
	    }
	    function mapPath(path, matrix) {
	        if (!matrix) {
	            return path;
	        }
	        var x, y, i, j, ii, jj, pathi;
	        path = path2curve(path);
	        for (i = 0, ii = path.length; i < ii; i++) {
	            pathi = path[i];
	            for (j = 1, jj = pathi.length; j < jj; j += 2) {
	                x = matrix.x(pathi[j], pathi[j + 1]);
	                y = matrix.y(pathi[j], pathi[j + 1]);
	                pathi[j] = x;
	                pathi[j + 1] = y;
	            }
	        }
	        return path;
	    }
	
	    // http://schepers.cc/getting-to-the-point
	    function catmullRom2bezier(crp, z) {
	        var d = [];
	        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
	            var p = [
	                        {x: +crp[i - 2], y: +crp[i - 1]},
	                        {x: +crp[i],     y: +crp[i + 1]},
	                        {x: +crp[i + 2], y: +crp[i + 3]},
	                        {x: +crp[i + 4], y: +crp[i + 5]}
	                    ];
	            if (z) {
	                if (!i) {
	                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
	                } else if (iLen - 4 == i) {
	                    p[3] = {x: +crp[0], y: +crp[1]};
	                } else if (iLen - 2 == i) {
	                    p[2] = {x: +crp[0], y: +crp[1]};
	                    p[3] = {x: +crp[2], y: +crp[3]};
	                }
	            } else {
	                if (iLen - 4 == i) {
	                    p[3] = p[2];
	                } else if (!i) {
	                    p[0] = {x: +crp[i], y: +crp[i + 1]};
	                }
	            }
	            d.push(["C",
	                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,
	                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,
	                  (p[1].x + 6 * p[2].x - p[3].x) / 6,
	                  (p[1].y + 6*p[2].y - p[3].y) / 6,
	                  p[2].x,
	                  p[2].y
	            ]);
	        }
	
	        return d;
	    }
	
	    // export
	    Snap.path = paths;
	
	    /*\
	     * Snap.path.getTotalLength
	     [ method ]
	     **
	     * Returns the length of the given path in pixels
	     **
	     - path (string) SVG path string
	     **
	     = (number) length
	    \*/
	    Snap.path.getTotalLength = getTotalLength;
	    /*\
	     * Snap.path.getPointAtLength
	     [ method ]
	     **
	     * Returns the coordinates of the point located at the given length along the given path
	     **
	     - path (string) SVG path string
	     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
	     **
	     = (object) representation of the point:
	     o {
	     o     x: (number) x coordinate,
	     o     y: (number) y coordinate,
	     o     alpha: (number) angle of derivative
	     o }
	    \*/
	    Snap.path.getPointAtLength = getPointAtLength;
	    /*\
	     * Snap.path.getSubpath
	     [ method ]
	     **
	     * Returns the subpath of a given path between given start and end lengths
	     **
	     - path (string) SVG path string
	     - from (number) length, in pixels, from the start of the path to the start of the segment
	     - to (number) length, in pixels, from the start of the path to the end of the segment
	     **
	     = (string) path string definition for the segment
	    \*/
	    Snap.path.getSubpath = function (path, from, to) {
	        if (this.getTotalLength(path) - to < 1e-6) {
	            return getSubpathsAtLength(path, from).end;
	        }
	        var a = getSubpathsAtLength(path, to, 1);
	        return from ? getSubpathsAtLength(a, from).end : a;
	    };
	    /*\
	     * Element.getTotalLength
	     [ method ]
	     **
	     * Returns the length of the path in pixels (only works for `path` elements)
	     = (number) length
	    \*/
	    elproto.getTotalLength = function () {
	        if (this.node.getTotalLength) {
	            return this.node.getTotalLength();
	        }
	    };
	    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?
	    /*\
	     * Element.getPointAtLength
	     [ method ]
	     **
	     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)
	     **
	     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
	     **
	     = (object) representation of the point:
	     o {
	     o     x: (number) x coordinate,
	     o     y: (number) y coordinate,
	     o     alpha: (number) angle of derivative
	     o }
	    \*/
	    elproto.getPointAtLength = function (length) {
	        return getPointAtLength(this.attr("d"), length);
	    };
	    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.
	    /*\
	     * Element.getSubpath
	     [ method ]
	     **
	     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)
	     **
	     - from (number) length, in pixels, from the start of the path to the start of the segment
	     - to (number) length, in pixels, from the start of the path to the end of the segment
	     **
	     = (string) path string definition for the segment
	    \*/
	    elproto.getSubpath = function (from, to) {
	        return Snap.path.getSubpath(this.attr("d"), from, to);
	    };
	    Snap._.box = box;
	    /*\
	     * Snap.path.findDotsAtSegment
	     [ method ]
	     **
	     * Utility method
	     **
	     * Finds dot coordinates on the given cubic beziér curve at the given t
	     - p1x (number) x of the first point of the curve
	     - p1y (number) y of the first point of the curve
	     - c1x (number) x of the first anchor of the curve
	     - c1y (number) y of the first anchor of the curve
	     - c2x (number) x of the second anchor of the curve
	     - c2y (number) y of the second anchor of the curve
	     - p2x (number) x of the second point of the curve
	     - p2y (number) y of the second point of the curve
	     - t (number) position on the curve (0..1)
	     = (object) point information in format:
	     o {
	     o     x: (number) x coordinate of the point,
	     o     y: (number) y coordinate of the point,
	     o     m: {
	     o         x: (number) x coordinate of the left anchor,
	     o         y: (number) y coordinate of the left anchor
	     o     },
	     o     n: {
	     o         x: (number) x coordinate of the right anchor,
	     o         y: (number) y coordinate of the right anchor
	     o     },
	     o     start: {
	     o         x: (number) x coordinate of the start of the curve,
	     o         y: (number) y coordinate of the start of the curve
	     o     },
	     o     end: {
	     o         x: (number) x coordinate of the end of the curve,
	     o         y: (number) y coordinate of the end of the curve
	     o     },
	     o     alpha: (number) angle of the curve derivative at the point
	     o }
	    \*/
	    Snap.path.findDotsAtSegment = findDotsAtSegment;
	    /*\
	     * Snap.path.bezierBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns the bounding box of a given cubic beziér curve
	     - p1x (number) x of the first point of the curve
	     - p1y (number) y of the first point of the curve
	     - c1x (number) x of the first anchor of the curve
	     - c1y (number) y of the first anchor of the curve
	     - c2x (number) x of the second anchor of the curve
	     - c2y (number) y of the second anchor of the curve
	     - p2x (number) x of the second point of the curve
	     - p2y (number) y of the second point of the curve
	     * or
	     - bez (array) array of six points for beziér curve
	     = (object) bounding box
	     o {
	     o     x: (number) x coordinate of the left top point of the box,
	     o     y: (number) y coordinate of the left top point of the box,
	     o     x2: (number) x coordinate of the right bottom point of the box,
	     o     y2: (number) y coordinate of the right bottom point of the box,
	     o     width: (number) width of the box,
	     o     height: (number) height of the box
	     o }
	    \*/
	    Snap.path.bezierBBox = bezierBBox;
	    /*\
	     * Snap.path.isPointInsideBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if given point is inside bounding box
	     - bbox (string) bounding box
	     - x (string) x coordinate of the point
	     - y (string) y coordinate of the point
	     = (boolean) `true` if point is inside
	    \*/
	    Snap.path.isPointInsideBBox = isPointInsideBBox;
	    Snap.closest = function (x, y, X, Y) {
	        var r = 100,
	            b = box(x - r / 2, y - r / 2, r, r),
	            inside = [],
	            getter = X[0].hasOwnProperty("x") ? function (i) {
	                return {
	                    x: X[i].x,
	                    y: X[i].y
	                };
	            } : function (i) {
	                return {
	                    x: X[i],
	                    y: Y[i]
	                };
	            },
	            found = 0;
	        while (r <= 1e6 && !found) {
	            for (var i = 0, ii = X.length; i < ii; i++) {
	                var xy = getter(i);
	                if (isPointInsideBBox(b, xy.x, xy.y)) {
	                    found++;
	                    inside.push(xy);
	                    break;
	                }
	            }
	            if (!found) {
	                r *= 2;
	                b = box(x - r / 2, y - r / 2, r, r)
	            }
	        }
	        if (r == 1e6) {
	            return;
	        }
	        var len = Infinity,
	            res;
	        for (i = 0, ii = inside.length; i < ii; i++) {
	            var l = Snap.len(x, y, inside[i].x, inside[i].y);
	            if (len > l) {
	                len = l;
	                inside[i].len = l;
	                res = inside[i];
	            }
	        }
	        return res;
	    };
	    /*\
	     * Snap.path.isBBoxIntersect
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if two bounding boxes intersect
	     - bbox1 (string) first bounding box
	     - bbox2 (string) second bounding box
	     = (boolean) `true` if bounding boxes intersect
	    \*/
	    Snap.path.isBBoxIntersect = isBBoxIntersect;
	    /*\
	     * Snap.path.intersection
	     [ method ]
	     **
	     * Utility method
	     **
	     * Finds intersections of two paths
	     - path1 (string) path string
	     - path2 (string) path string
	     = (array) dots of intersection
	     o [
	     o     {
	     o         x: (number) x coordinate of the point,
	     o         y: (number) y coordinate of the point,
	     o         t1: (number) t value for segment of path1,
	     o         t2: (number) t value for segment of path2,
	     o         segment1: (number) order number for segment of path1,
	     o         segment2: (number) order number for segment of path2,
	     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,
	     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
	     o     }
	     o ]
	    \*/
	    Snap.path.intersection = pathIntersection;
	    Snap.path.intersectionNumber = pathIntersectionNumber;
	    /*\
	     * Snap.path.isPointInside
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if given point is inside a given closed path.
	     *
	     * Note: fill mode doesn’t affect the result of this method.
	     - path (string) path string
	     - x (number) x of the point
	     - y (number) y of the point
	     = (boolean) `true` if point is inside the path
	    \*/
	    Snap.path.isPointInside = isPointInsidePath;
	    /*\
	     * Snap.path.getBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns the bounding box of a given path
	     - path (string) path string
	     = (object) bounding box
	     o {
	     o     x: (number) x coordinate of the left top point of the box,
	     o     y: (number) y coordinate of the left top point of the box,
	     o     x2: (number) x coordinate of the right bottom point of the box,
	     o     y2: (number) y coordinate of the right bottom point of the box,
	     o     width: (number) width of the box,
	     o     height: (number) height of the box
	     o }
	    \*/
	    Snap.path.getBBox = pathBBox;
	    Snap.path.get = getPath;
	    /*\
	     * Snap.path.toRelative
	     [ method ]
	     **
	     * Utility method
	     **
	     * Converts path coordinates into relative values
	     - path (string) path string
	     = (array) path string
	    \*/
	    Snap.path.toRelative = pathToRelative;
	    /*\
	     * Snap.path.toAbsolute
	     [ method ]
	     **
	     * Utility method
	     **
	     * Converts path coordinates into absolute values
	     - path (string) path string
	     = (array) path string
	    \*/
	    Snap.path.toAbsolute = pathToAbsolute;
	    /*\
	     * Snap.path.toCubic
	     [ method ]
	     **
	     * Utility method
	     **
	     * Converts path to a new path where all segments are cubic beziér curves
	     - pathString (string|array) path string or array of segments
	     = (array) array of segments
	    \*/
	    Snap.path.toCubic = path2curve;
	    /*\
	     * Snap.path.map
	     [ method ]
	     **
	     * Transform the path string with the given matrix
	     - path (string) path string
	     - matrix (object) see @Matrix
	     = (string) transformed path string
	    \*/
	    Snap.path.map = mapPath;
	    Snap.path.toString = toString;
	    Snap.path.clone = pathClone;
	});
	
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob) {
	    var mmax = Math.max,
	        mmin = Math.min;
	
	    // Set
	    var Set = function (items) {
	        this.items = [];
		this.bindings = {};
	        this.length = 0;
	        this.type = "set";
	        if (items) {
	            for (var i = 0, ii = items.length; i < ii; i++) {
	                if (items[i]) {
	                    this[this.items.length] = this.items[this.items.length] = items[i];
	                    this.length++;
	                }
	            }
	        }
	    },
	    setproto = Set.prototype;
	    /*\
	     * Set.push
	     [ method ]
	     **
	     * Adds each argument to the current set
	     = (object) original element
	    \*/
	    setproto.push = function () {
	        var item,
	            len;
	        for (var i = 0, ii = arguments.length; i < ii; i++) {
	            item = arguments[i];
	            if (item) {
	                len = this.items.length;
	                this[len] = this.items[len] = item;
	                this.length++;
	            }
	        }
	        return this;
	    };
	    /*\
	     * Set.pop
	     [ method ]
	     **
	     * Removes last element and returns it
	     = (object) element
	    \*/
	    setproto.pop = function () {
	        this.length && delete this[this.length--];
	        return this.items.pop();
	    };
	    /*\
	     * Set.forEach
	     [ method ]
	     **
	     * Executes given function for each element in the set
	     *
	     * If the function returns `false`, the loop stops running.
	     **
	     - callback (function) function to run
	     - thisArg (object) context object for the callback
	     = (object) Set object
	    \*/
	    setproto.forEach = function (callback, thisArg) {
	        for (var i = 0, ii = this.items.length; i < ii; i++) {
	            if (callback.call(thisArg, this.items[i], i) === false) {
	                return this;
	            }
	        }
	        return this;
	    };
	    /*\
	     * Set.animate
	     [ method ]
	     **
	     * Animates each element in set in sync.
	     *
	     **
	     - attrs (object) key-value pairs of destination attributes
	     - duration (number) duration of the animation in milliseconds
	     - easing (function) #optional easing function from @mina or custom
	     - callback (function) #optional callback function that executes when the animation ends
	     * or
	     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`
	     > Usage
	     | // animate all elements in set to radius 10
	     | set.animate({r: 10}, 500, mina.easein);
	     | // or
	     | // animate first element to radius 10, but second to radius 20 and in different time
	     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);
	     = (Element) the current element
	    \*/
	    setproto.animate = function (attrs, ms, easing, callback) {
	        if (typeof easing == "function" && !easing.length) {
	            callback = easing;
	            easing = mina.linear;
	        }
	        if (attrs instanceof Snap._.Animation) {
	            callback = attrs.callback;
	            easing = attrs.easing;
	            ms = easing.dur;
	            attrs = attrs.attr;
	        }
	        var args = arguments;
	        if (Snap.is(attrs, "array") && Snap.is(args[args.length - 1], "array")) {
	            var each = true;
	        }
	        var begin,
	            handler = function () {
	                if (begin) {
	                    this.b = begin;
	                } else {
	                    begin = this.b;
	                }
	            },
	            cb = 0,
	            set = this,
	            callbacker = callback && function () {
	                if (++cb == set.length) {
	                    callback.call(this);
	                }
	            };
	        return this.forEach(function (el, i) {
	            eve.once("snap.animcreated." + el.id, handler);
	            if (each) {
	                args[i] && el.animate.apply(el, args[i]);
	            } else {
	                el.animate(attrs, ms, easing, callbacker);
	            }
	        });
	    };
	    setproto.remove = function () {
	        while (this.length) {
	            this.pop().remove();
	        }
	        return this;
	    };
	    /*\
	     * Set.bind
	     [ method ]
	     **
	     * Specifies how to handle a specific attribute when applied
	     * to a set.
	     *
	     **
	     - attr (string) attribute name
	     - callback (function) function to run
	     * or
	     - attr (string) attribute name
	     - element (Element) specific element in the set to apply the attribute to
	     * or
	     - attr (string) attribute name
	     - element (Element) specific element in the set to apply the attribute to
	     - eattr (string) attribute on the element to bind the attribute to
	     = (object) Set object
	    \*/
	    setproto.bind = function (attr, a, b) {
	        var data = {};
	        if (typeof a == "function") {
	            this.bindings[attr] = a;
	        } else {
	            var aname = b || attr;
	            this.bindings[attr] = function (v) {
	                data[aname] = v;
	                a.attr(data);
	            };
	        }
	        return this;
	    };
	    setproto.attr = function (value) {
	        var unbound = {};
	        for (var k in value) {
	            if (this.bindings[k]) {
	                this.bindings[k](value[k]);
	            } else {
	                unbound[k] = value[k];
	            }
	        }
	        for (var i = 0, ii = this.items.length; i < ii; i++) {
	            this.items[i].attr(unbound);
	        }
	        return this;
	    };
	    /*\
	     * Set.clear
	     [ method ]
	     **
	     * Removes all elements from the set
	    \*/
	    setproto.clear = function () {
	        while (this.length) {
	            this.pop();
	        }
	    };
	    /*\
	     * Set.splice
	     [ method ]
	     **
	     * Removes range of elements from the set
	     **
	     - index (number) position of the deletion
	     - count (number) number of element to remove
	     - insertion… (object) #optional elements to insert
	     = (object) set elements that were deleted
	    \*/
	    setproto.splice = function (index, count, insertion) {
	        index = index < 0 ? mmax(this.length + index, 0) : index;
	        count = mmax(0, mmin(this.length - index, count));
	        var tail = [],
	            todel = [],
	            args = [],
	            i;
	        for (i = 2; i < arguments.length; i++) {
	            args.push(arguments[i]);
	        }
	        for (i = 0; i < count; i++) {
	            todel.push(this[index + i]);
	        }
	        for (; i < this.length - index; i++) {
	            tail.push(this[index + i]);
	        }
	        var arglen = args.length;
	        for (i = 0; i < arglen + tail.length; i++) {
	            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
	        }
	        i = this.items.length = this.length -= count - arglen;
	        while (this[i]) {
	            delete this[i++];
	        }
	        return new Set(todel);
	    };
	    /*\
	     * Set.exclude
	     [ method ]
	     **
	     * Removes given element from the set
	     **
	     - element (object) element to remove
	     = (boolean) `true` if object was found and removed from the set
	    \*/
	    setproto.exclude = function (el) {
	        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
	            this.splice(i, 1);
	            return true;
	        }
	        return false;
	    };
	    setproto.insertAfter = function (el) {
	        var i = this.items.length;
	        while (i--) {
	            this.items[i].insertAfter(el);
	        }
	        return this;
	    };
	    setproto.getBBox = function () {
	        var x = [],
	            y = [],
	            x2 = [],
	            y2 = [];
	        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
	            var box = this.items[i].getBBox();
	            x.push(box.x);
	            y.push(box.y);
	            x2.push(box.x + box.width);
	            y2.push(box.y + box.height);
	        }
	        x = mmin.apply(0, x);
	        y = mmin.apply(0, y);
	        x2 = mmax.apply(0, x2);
	        y2 = mmax.apply(0, y2);
	        return {
	            x: x,
	            y: y,
	            x2: x2,
	            y2: y2,
	            width: x2 - x,
	            height: y2 - y,
	            cx: x + (x2 - x) / 2,
	            cy: y + (y2 - y) / 2
	        };
	    };
	    setproto.clone = function (s) {
	        s = new Set;
	        for (var i = 0, ii = this.items.length; i < ii; i++) {
	            s.push(this.items[i].clone());
	        }
	        return s;
	    };
	    setproto.toString = function () {
	        return "Snap\u2018s set";
	    };
	    setproto.type = "set";
	    // export
	    Snap.Set = Set;
	    Snap.set = function () {
	        var set = new Set;
	        if (arguments.length) {
	            set.push.apply(set, Array.prototype.slice.call(arguments, 0));
	        }
	        return set;
	    };
	});
	
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob) {
	    var names = {},
	        reUnit = /[a-z]+$/i,
	        Str = String;
	    names.stroke = names.fill = "colour";
	    function getEmpty(item) {
	        var l = item[0];
	        switch (l.toLowerCase()) {
	            case "t": return [l, 0, 0];
	            case "m": return [l, 1, 0, 0, 1, 0, 0];
	            case "r": if (item.length == 4) {
	                return [l, 0, item[2], item[3]];
	            } else {
	                return [l, 0];
	            }
	            case "s": if (item.length == 5) {
	                return [l, 1, 1, item[3], item[4]];
	            } else if (item.length == 3) {
	                return [l, 1, 1];
	            } else {
	                return [l, 1];
	            }
	        }
	    }
	    function equaliseTransform(t1, t2, getBBox) {
	        t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
	        t1 = Snap.parseTransformString(t1) || [];
	        t2 = Snap.parseTransformString(t2) || [];
	        var maxlength = Math.max(t1.length, t2.length),
	            from = [],
	            to = [],
	            i = 0, j, jj,
	            tt1, tt2;
	        for (; i < maxlength; i++) {
	            tt1 = t1[i] || getEmpty(t2[i]);
	            tt2 = t2[i] || getEmpty(tt1);
	            if ((tt1[0] != tt2[0]) ||
	                (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
	                (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
	                ) {
	                    t1 = Snap._.transform2matrix(t1, getBBox());
	                    t2 = Snap._.transform2matrix(t2, getBBox());
	                    from = [["m", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];
	                    to = [["m", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];
	                    break;
	            }
	            from[i] = [];
	            to[i] = [];
	            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {
	                j in tt1 && (from[i][j] = tt1[j]);
	                j in tt2 && (to[i][j] = tt2[j]);
	            }
	        }
	        return {
	            from: path2array(from),
	            to: path2array(to),
	            f: getPath(from)
	        };
	    }
	    function getNumber(val) {
	        return val;
	    }
	    function getUnit(unit) {
	        return function (val) {
	            return +val.toFixed(3) + unit;
	        };
	    }
	    function getViewBox(val) {
	        return val.join(" ");
	    }
	    function getColour(clr) {
	        return Snap.rgb(clr[0], clr[1], clr[2]);
	    }
	    function getPath(path) {
	        var k = 0, i, ii, j, jj, out, a, b = [];
	        for (i = 0, ii = path.length; i < ii; i++) {
	            out = "[";
	            a = ['"' + path[i][0] + '"'];
	            for (j = 1, jj = path[i].length; j < jj; j++) {
	                a[j] = "val[" + (k++) + "]";
	            }
	            out += a + "]";
	            b[i] = out;
	        }
	        return Function("val", "return Snap.path.toString.call([" + b + "])");
	    }
	    function path2array(path) {
	        var out = [];
	        for (var i = 0, ii = path.length; i < ii; i++) {
	            for (var j = 1, jj = path[i].length; j < jj; j++) {
	                out.push(path[i][j]);
	            }
	        }
	        return out;
	    }
	    function isNumeric(obj) {
	        return isFinite(parseFloat(obj));
	    }
	    function arrayEqual(arr1, arr2) {
	        if (!Snap.is(arr1, "array") || !Snap.is(arr2, "array")) {
	            return false;
	        }
	        return arr1.toString() == arr2.toString();
	    }
	    Element.prototype.equal = function (name, b) {
	        return eve("snap.util.equal", this, name, b).firstDefined();
	    };
	    eve.on("snap.util.equal", function (name, b) {
	        var A, B, a = Str(this.attr(name) || ""),
	            el = this;
	        if (isNumeric(a) && isNumeric(b)) {
	            return {
	                from: parseFloat(a),
	                to: parseFloat(b),
	                f: getNumber
	            };
	        }
	        if (names[name] == "colour") {
	            A = Snap.color(a);
	            B = Snap.color(b);
	            return {
	                from: [A.r, A.g, A.b, A.opacity],
	                to: [B.r, B.g, B.b, B.opacity],
	                f: getColour
	            };
	        }
	        if (name == "viewBox") {
	            A = this.attr(name).vb.split(" ").map(Number);
	            B = b.split(" ").map(Number);
	            return {
	                from: A,
	                to: B,
	                f: getViewBox
	            };
	        }
	        if (name == "transform" || name == "gradientTransform" || name == "patternTransform") {
	            if (b instanceof Snap.Matrix) {
	                b = b.toTransformString();
	            }
	            if (!Snap._.rgTransform.test(b)) {
	                b = Snap._.svgTransform2string(b);
	            }
	            return equaliseTransform(a, b, function () {
	                return el.getBBox(1);
	            });
	        }
	        if (name == "d" || name == "path") {
	            A = Snap.path.toCubic(a, b);
	            return {
	                from: path2array(A[0]),
	                to: path2array(A[1]),
	                f: getPath(A[0])
	            };
	        }
	        if (name == "points") {
	            A = Str(a).split(Snap._.separator);
	            B = Str(b).split(Snap._.separator);
	            return {
	                from: A,
	                to: B,
	                f: function (val) { return val; }
	            };
	        }
	        var aUnit = a.match(reUnit),
	            bUnit = Str(b).match(reUnit);
	        if (aUnit && arrayEqual(aUnit, bUnit)) {
	            return {
	                from: parseFloat(a),
	                to: parseFloat(b),
	                f: getUnit(aUnit)
	            };
	        } else {
	            return {
	                from: this.asPX(name),
	                to: this.asPX(name, b),
	                f: getNumber
	            };
	        }
	    });
	});
	
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob) {
	    var elproto = Element.prototype,
	    has = "hasOwnProperty",
	    supportsTouch = "createTouch" in glob.doc,
	    events = [
	        "click", "dblclick", "mousedown", "mousemove", "mouseout",
	        "mouseover", "mouseup", "touchstart", "touchmove", "touchend",
	        "touchcancel"
	    ],
	    touchMap = {
	        mousedown: "touchstart",
	        mousemove: "touchmove",
	        mouseup: "touchend"
	    },
	    getScroll = function (xy, el) {
	        var name = xy == "y" ? "scrollTop" : "scrollLeft",
	            doc = el && el.node ? el.node.ownerDocument : glob.doc;
	        return doc[name in doc.documentElement ? "documentElement" : "body"][name];
	    },
	    preventDefault = function () {
	        this.returnValue = false;
	    },
	    preventTouch = function () {
	        return this.originalEvent.preventDefault();
	    },
	    stopPropagation = function () {
	        this.cancelBubble = true;
	    },
	    stopTouch = function () {
	        return this.originalEvent.stopPropagation();
	    },
	    addEvent = function (obj, type, fn, element) {
	        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
	            f = function (e) {
	                var scrollY = getScroll("y", element),
	                    scrollX = getScroll("x", element);
	                if (supportsTouch && touchMap[has](type)) {
	                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
	                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {
	                            var olde = e;
	                            e = e.targetTouches[i];
	                            e.originalEvent = olde;
	                            e.preventDefault = preventTouch;
	                            e.stopPropagation = stopTouch;
	                            break;
	                        }
	                    }
	                }
	                var x = e.clientX + scrollX,
	                    y = e.clientY + scrollY;
	                return fn.call(element, e, x, y);
	            };
	
	        if (type !== realName) {
	            obj.addEventListener(type, f, false);
	        }
	
	        obj.addEventListener(realName, f, false);
	
	        return function () {
	            if (type !== realName) {
	                obj.removeEventListener(type, f, false);
	            }
	
	            obj.removeEventListener(realName, f, false);
	            return true;
	        };
	    },
	    drag = [],
	    dragMove = function (e) {
	        var x = e.clientX,
	            y = e.clientY,
	            scrollY = getScroll("y"),
	            scrollX = getScroll("x"),
	            dragi,
	            j = drag.length;
	        while (j--) {
	            dragi = drag[j];
	            if (supportsTouch) {
	                var i = e.touches && e.touches.length,
	                    touch;
	                while (i--) {
	                    touch = e.touches[i];
	                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {
	                        x = touch.clientX;
	                        y = touch.clientY;
	                        (e.originalEvent ? e.originalEvent : e).preventDefault();
	                        break;
	                    }
	                }
	            } else {
	                e.preventDefault();
	            }
	            var node = dragi.el.node,
	                o,
	                next = node.nextSibling,
	                parent = node.parentNode,
	                display = node.style.display;
	            // glob.win.opera && parent.removeChild(node);
	            // node.style.display = "none";
	            // o = dragi.el.paper.getElementByPoint(x, y);
	            // node.style.display = display;
	            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
	            // o && eve("snap.drag.over." + dragi.el.id, dragi.el, o);
	            x += scrollX;
	            y += scrollY;
	            eve("snap.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
	        }
	    },
	    dragUp = function (e) {
	        Snap.unmousemove(dragMove).unmouseup(dragUp);
	        var i = drag.length,
	            dragi;
	        while (i--) {
	            dragi = drag[i];
	            dragi.el._drag = {};
	            eve("snap.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
	            eve.off("snap.drag.*." + dragi.el.id);
	        }
	        drag = [];
	    };
	    /*\
	     * Element.click
	     [ method ]
	     **
	     * Adds a click event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unclick
	     [ method ]
	     **
	     * Removes a click event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	
	    /*\
	     * Element.dblclick
	     [ method ]
	     **
	     * Adds a double click event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.undblclick
	     [ method ]
	     **
	     * Removes a double click event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	
	    /*\
	     * Element.mousedown
	     [ method ]
	     **
	     * Adds a mousedown event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unmousedown
	     [ method ]
	     **
	     * Removes a mousedown event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	
	    /*\
	     * Element.mousemove
	     [ method ]
	     **
	     * Adds a mousemove event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unmousemove
	     [ method ]
	     **
	     * Removes a mousemove event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	
	    /*\
	     * Element.mouseout
	     [ method ]
	     **
	     * Adds a mouseout event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unmouseout
	     [ method ]
	     **
	     * Removes a mouseout event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	
	    /*\
	     * Element.mouseover
	     [ method ]
	     **
	     * Adds a mouseover event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unmouseover
	     [ method ]
	     **
	     * Removes a mouseover event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	
	    /*\
	     * Element.mouseup
	     [ method ]
	     **
	     * Adds a mouseup event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unmouseup
	     [ method ]
	     **
	     * Removes a mouseup event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	
	    /*\
	     * Element.touchstart
	     [ method ]
	     **
	     * Adds a touchstart event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.untouchstart
	     [ method ]
	     **
	     * Removes a touchstart event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	
	    /*\
	     * Element.touchmove
	     [ method ]
	     **
	     * Adds a touchmove event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.untouchmove
	     [ method ]
	     **
	     * Removes a touchmove event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	
	    /*\
	     * Element.touchend
	     [ method ]
	     **
	     * Adds a touchend event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.untouchend
	     [ method ]
	     **
	     * Removes a touchend event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	
	    /*\
	     * Element.touchcancel
	     [ method ]
	     **
	     * Adds a touchcancel event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.untouchcancel
	     [ method ]
	     **
	     * Removes a touchcancel event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    for (var i = events.length; i--;) {
	        (function (eventName) {
	            Snap[eventName] = elproto[eventName] = function (fn, scope) {
	                if (Snap.is(fn, "function")) {
	                    this.events = this.events || [];
	                    this.events.push({
	                        name: eventName,
	                        f: fn,
	                        unbind: addEvent(this.node || document, eventName, fn, scope || this)
	                    });
	                } else {
	                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {
	                        try {
	                            this.events[i].f.call(this);
	                        } catch (e) {}
	                    }
	                }
	                return this;
	            };
	            Snap["un" + eventName] =
	            elproto["un" + eventName] = function (fn) {
	                var events = this.events || [],
	                    l = events.length;
	                while (l--) if (events[l].name == eventName &&
	                               (events[l].f == fn || !fn)) {
	                    events[l].unbind();
	                    events.splice(l, 1);
	                    !events.length && delete this.events;
	                    return this;
	                }
	                return this;
	            };
	        })(events[i]);
	    }
	    /*\
	     * Element.hover
	     [ method ]
	     **
	     * Adds hover event handlers to the element
	     - f_in (function) handler for hover in
	     - f_out (function) handler for hover out
	     - icontext (object) #optional context for hover in handler
	     - ocontext (object) #optional context for hover out handler
	     = (object) @Element
	    \*/
	    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
	        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
	    };
	    /*\
	     * Element.unhover
	     [ method ]
	     **
	     * Removes hover event handlers from the element
	     - f_in (function) handler for hover in
	     - f_out (function) handler for hover out
	     = (object) @Element
	    \*/
	    elproto.unhover = function (f_in, f_out) {
	        return this.unmouseover(f_in).unmouseout(f_out);
	    };
	    var draggable = [];
	    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.
	    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?
	    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.
	    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?
	    /*\
	     * Element.drag
	     [ method ]
	     **
	     * Adds event handlers for an element's drag gesture
	     **
	     - onmove (function) handler for moving
	     - onstart (function) handler for drag start
	     - onend (function) handler for drag end
	     - mcontext (object) #optional context for moving handler
	     - scontext (object) #optional context for drag start handler
	     - econtext (object) #optional context for drag end handler
	     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start,
	     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element
	     * `drag.over.<id>` fires as well.
	     *
	     * Start event and start handler are called in specified context or in context of the element with following parameters:
	     o x (number) x position of the mouse
	     o y (number) y position of the mouse
	     o event (object) DOM event object
	     * Move event and move handler are called in specified context or in context of the element with following parameters:
	     o dx (number) shift by x from the start point
	     o dy (number) shift by y from the start point
	     o x (number) x position of the mouse
	     o y (number) y position of the mouse
	     o event (object) DOM event object
	     * End event and end handler are called in specified context or in context of the element with following parameters:
	     o event (object) DOM event object
	     = (object) @Element
	    \*/
	    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
	        var el = this;
	        if (!arguments.length) {
	            var origTransform;
	            return el.drag(function (dx, dy) {
	                this.attr({
	                    transform: origTransform + (origTransform ? "T" : "t") + [dx, dy]
	                });
	            }, function () {
	                origTransform = this.transform().local;
	            });
	        }
	        function start(e, x, y) {
	            (e.originalEvent || e).preventDefault();
	            el._drag.x = x;
	            el._drag.y = y;
	            el._drag.id = e.identifier;
	            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);
	            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
	            onstart && eve.on("snap.drag.start." + el.id, onstart);
	            onmove && eve.on("snap.drag.move." + el.id, onmove);
	            onend && eve.on("snap.drag.end." + el.id, onend);
	            eve("snap.drag.start." + el.id, start_scope || move_scope || el, x, y, e);
	        }
	        function init(e, x, y) {
	            eve("snap.draginit." + el.id, el, e, x, y);
	        }
	        eve.on("snap.draginit." + el.id, start);
	        el._drag = {};
	        draggable.push({el: el, start: start, init: init});
	        el.mousedown(init);
	        return el;
	    };
	    /*
	     * Element.onDragOver
	     [ method ]
	     **
	     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)
	     - f (function) handler for event, first argument would be the element you are dragging over
	    \*/
	    // elproto.onDragOver = function (f) {
	    //     f ? eve.on("snap.drag.over." + this.id, f) : eve.unbind("snap.drag.over." + this.id);
	    // };
	    /*\
	     * Element.undrag
	     [ method ]
	     **
	     * Removes all drag event handlers from the given element
	    \*/
	    elproto.undrag = function () {
	        var i = draggable.length;
	        while (i--) if (draggable[i].el == this) {
	            this.unmousedown(draggable[i].init);
	            draggable.splice(i, 1);
	            eve.unbind("snap.drag.*." + this.id);
	            eve.unbind("snap.draginit." + this.id);
	        }
	        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);
	        return this;
	    };
	});
	
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob) {
	    var elproto = Element.prototype,
	        pproto = Paper.prototype,
	        rgurl = /^\s*url\((.+)\)/,
	        Str = String,
	        $ = Snap._.$;
	    Snap.filter = {};
	    /*\
	     * Paper.filter
	     [ method ]
	     **
	     * Creates a `<filter>` element
	     **
	     - filstr (string) SVG fragment of filter provided as a string
	     = (object) @Element
	     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.
	     > Usage
	     | var f = paper.filter('<feGaussianBlur stdDeviation="2"/>'),
	     |     c = paper.circle(10, 10, 10).attr({
	     |         filter: f
	     |     });
	    \*/
	    pproto.filter = function (filstr) {
	        var paper = this;
	        if (paper.type != "svg") {
	            paper = paper.paper;
	        }
	        var f = Snap.parse(Str(filstr)),
	            id = Snap._.id(),
	            width = paper.node.offsetWidth,
	            height = paper.node.offsetHeight,
	            filter = $("filter");
	        $(filter, {
	            id: id,
	            filterUnits: "userSpaceOnUse"
	        });
	        filter.appendChild(f.node);
	        paper.defs.appendChild(filter);
	        return new Element(filter);
	    };
	
	    eve.on("snap.util.getattr.filter", function () {
	        eve.stop();
	        var p = $(this.node, "filter");
	        if (p) {
	            var match = Str(p).match(rgurl);
	            return match && Snap.select(match[1]);
	        }
	    });
	    eve.on("snap.util.attr.filter", function (value) {
	        if (value instanceof Element && value.type == "filter") {
	            eve.stop();
	            var id = value.node.id;
	            if (!id) {
	                $(value.node, {id: value.id});
	                id = value.id;
	            }
	            $(this.node, {
	                filter: Snap.url(id)
	            });
	        }
	        if (!value || value == "none") {
	            eve.stop();
	            this.node.removeAttribute("filter");
	        }
	    });
	    /*\
	     * Snap.filter.blur
	     [ method ]
	     **
	     * Returns an SVG markup string for the blur filter
	     **
	     - x (number) amount of horizontal blur, in pixels
	     - y (number) #optional amount of vertical blur, in pixels
	     = (string) filter representation
	     > Usage
	     | var f = paper.filter(Snap.filter.blur(5, 10)),
	     |     c = paper.circle(10, 10, 10).attr({
	     |         filter: f
	     |     });
	    \*/
	    Snap.filter.blur = function (x, y) {
	        if (x == null) {
	            x = 2;
	        }
	        var def = y == null ? x : [x, y];
	        return Snap.format('\<feGaussianBlur stdDeviation="{def}"/>', {
	            def: def
	        });
	    };
	    Snap.filter.blur.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.shadow
	     [ method ]
	     **
	     * Returns an SVG markup string for the shadow filter
	     **
	     - dx (number) #optional horizontal shift of the shadow, in pixels
	     - dy (number) #optional vertical shift of the shadow, in pixels
	     - blur (number) #optional amount of blur
	     - color (string) #optional color of the shadow
	     - opacity (number) #optional `0..1` opacity of the shadow
	     * or
	     - dx (number) #optional horizontal shift of the shadow, in pixels
	     - dy (number) #optional vertical shift of the shadow, in pixels
	     - color (string) #optional color of the shadow
	     - opacity (number) #optional `0..1` opacity of the shadow
	     * which makes blur default to `4`. Or
	     - dx (number) #optional horizontal shift of the shadow, in pixels
	     - dy (number) #optional vertical shift of the shadow, in pixels
	     - opacity (number) #optional `0..1` opacity of the shadow
	     = (string) filter representation
	     > Usage
	     | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),
	     |     c = paper.circle(10, 10, 10).attr({
	     |         filter: f
	     |     });
	    \*/
	    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {
	        if (typeof blur == "string") {
	            color = blur;
	            opacity = color;
	            blur = 4;
	        }
	        if (typeof color != "string") {
	            opacity = color;
	            color = "#000";
	        }
	        color = color || "#000";
	        if (blur == null) {
	            blur = 4;
	        }
	        if (opacity == null) {
	            opacity = 1;
	        }
	        if (dx == null) {
	            dx = 0;
	            dy = 2;
	        }
	        if (dy == null) {
	            dy = dx;
	        }
	        color = Snap.color(color);
	        return Snap.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>', {
	            color: color,
	            dx: dx,
	            dy: dy,
	            blur: blur,
	            opacity: opacity
	        });
	    };
	    Snap.filter.shadow.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.grayscale
	     [ method ]
	     **
	     * Returns an SVG markup string for the grayscale filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.grayscale = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>', {
	            a: 0.2126 + 0.7874 * (1 - amount),
	            b: 0.7152 - 0.7152 * (1 - amount),
	            c: 0.0722 - 0.0722 * (1 - amount),
	            d: 0.2126 - 0.2126 * (1 - amount),
	            e: 0.7152 + 0.2848 * (1 - amount),
	            f: 0.0722 - 0.0722 * (1 - amount),
	            g: 0.2126 - 0.2126 * (1 - amount),
	            h: 0.0722 + 0.9278 * (1 - amount)
	        });
	    };
	    Snap.filter.grayscale.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.sepia
	     [ method ]
	     **
	     * Returns an SVG markup string for the sepia filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.sepia = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>', {
	            a: 0.393 + 0.607 * (1 - amount),
	            b: 0.769 - 0.769 * (1 - amount),
	            c: 0.189 - 0.189 * (1 - amount),
	            d: 0.349 - 0.349 * (1 - amount),
	            e: 0.686 + 0.314 * (1 - amount),
	            f: 0.168 - 0.168 * (1 - amount),
	            g: 0.272 - 0.272 * (1 - amount),
	            h: 0.534 - 0.534 * (1 - amount),
	            i: 0.131 + 0.869 * (1 - amount)
	        });
	    };
	    Snap.filter.sepia.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.saturate
	     [ method ]
	     **
	     * Returns an SVG markup string for the saturate filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.saturate = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	        return Snap.format('<feColorMatrix type="saturate" values="{amount}"/>', {
	            amount: 1 - amount
	        });
	    };
	    Snap.filter.saturate.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.hueRotate
	     [ method ]
	     **
	     * Returns an SVG markup string for the hue-rotate filter
	     **
	     - angle (number) angle of rotation
	     = (string) filter representation
	    \*/
	    Snap.filter.hueRotate = function (angle) {
	        angle = angle || 0;
	        return Snap.format('<feColorMatrix type="hueRotate" values="{angle}"/>', {
	            angle: angle
	        });
	    };
	    Snap.filter.hueRotate.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.invert
	     [ method ]
	     **
	     * Returns an SVG markup string for the invert filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.invert = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	//        <feColorMatrix type="matrix" values="-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0" color-interpolation-filters="sRGB"/>
	        return Snap.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>', {
	            amount: amount,
	            amount2: 1 - amount
	        });
	    };
	    Snap.filter.invert.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.brightness
	     [ method ]
	     **
	     * Returns an SVG markup string for the brightness filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.brightness = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>', {
	            amount: amount
	        });
	    };
	    Snap.filter.brightness.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.contrast
	     [ method ]
	     **
	     * Returns an SVG markup string for the contrast filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.contrast = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>', {
	            amount: amount,
	            amount2: .5 - amount / 2
	        });
	    };
	    Snap.filter.contrast.toString = function () {
	        return this();
	    };
	});
	
	// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var box = Snap._.box,
	        is = Snap.is,
	        firstLetter = /^[^a-z]*([tbmlrc])/i,
	        toString = function () {
	            return "T" + this.dx + "," + this.dy;
	        };
	    /*\
	     * Element.getAlign
	     [ method ]
	     **
	     * Returns shift needed to align the element relatively to given element.
	     * If no elements specified, parent `<svg>` container will be used.
	     - el (object) @optional alignment element
	     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
	     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string
	     > Usage
	     | el.transform(el.getAlign(el2, "top"));
	     * or
	     | var dy = el.getAlign(el2, "top").dy;
	    \*/
	    Element.prototype.getAlign = function (el, way) {
	        if (way == null && is(el, "string")) {
	            way = el;
	            el = null;
	        }
	        el = el || this.paper;
	        var bx = el.getBBox ? el.getBBox() : box(el),
	            bb = this.getBBox(),
	            out = {};
	        way = way && way.match(firstLetter);
	        way = way ? way[1].toLowerCase() : "c";
	        switch (way) {
	            case "t":
	                out.dx = 0;
	                out.dy = bx.y - bb.y;
	            break;
	            case "b":
	                out.dx = 0;
	                out.dy = bx.y2 - bb.y2;
	            break;
	            case "m":
	                out.dx = 0;
	                out.dy = bx.cy - bb.cy;
	            break;
	            case "l":
	                out.dx = bx.x - bb.x;
	                out.dy = 0;
	            break;
	            case "r":
	                out.dx = bx.x2 - bb.x2;
	                out.dy = 0;
	            break;
	            default:
	                out.dx = bx.cx - bb.cx;
	                out.dy = 0;
	            break;
	        }
	        out.toString = toString;
	        return out;
	    };
	    /*\
	     * Element.align
	     [ method ]
	     **
	     * Aligns the element relatively to given one via transformation.
	     * If no elements specified, parent `<svg>` container will be used.
	     - el (object) @optional alignment element
	     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
	     = (object) this element
	     > Usage
	     | el.align(el2, "top");
	     * or
	     | el.align("middle");
	    \*/
	    Element.prototype.align = function (el, way) {
	        return this.transform("..." + this.getAlign(el, way));
	    };
	});
	
	module.exports = Snap


/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var typeName = __webpack_require__(148);
	var forEach = __webpack_require__(27);
	var arrayFilter = __webpack_require__(164);
	var reduceRight = __webpack_require__(257);
	var indexOf = __webpack_require__(165);
	var slice = Array.prototype.slice;
	var END = {};
	var ITERATE = {};
	
	// arguments should end with end or iterate
	function compose () {
	    var filters = slice.apply(arguments);
	    return reduceRight(filters, function(right, left) {
	        return left(right);
	    });
	}
	
	// skip children
	function end () {
	    return function (acc, x) {
	        acc.context.keys = [];
	        return END;
	    };
	}
	
	// iterate children
	function iterate () {
	    return function (acc, x) {
	        return ITERATE;
	    };
	}
	
	function filter (predicate) {
	    return function (next) {
	        return function (acc, x) {
	            var toBeIterated;
	            var isIteratingArray = (typeName(x) === 'Array');
	            if (typeName(predicate) === 'function') {
	                toBeIterated = [];
	                forEach(acc.context.keys, function (key) {
	                    var indexOrKey = isIteratingArray ? parseInt(key, 10) : key;
	                    var kvp = {
	                        key: indexOrKey,
	                        value: x[key]
	                    };
	                    var decision = predicate(kvp);
	                    if (decision) {
	                        toBeIterated.push(key);
	                    }
	                    if (typeName(decision) === 'number') {
	                        truncateByKey(decision, key, acc);
	                    }
	                    if (typeName(decision) === 'function') {
	                        customizeStrategyForKey(decision, key, acc);
	                    }
	                });
	                acc.context.keys = toBeIterated;
	            }
	            return next(acc, x);
	        };
	    };
	}
	
	function customizeStrategyForKey (strategy, key, acc) {
	    acc.handlers[currentPath(key, acc)] = strategy;
	}
	
	function truncateByKey (size, key, acc) {
	    acc.handlers[currentPath(key, acc)] = size;
	}
	
	function currentPath (key, acc) {
	    var pathToCurrentNode = [''].concat(acc.context.path);
	    if (typeName(key) !== 'undefined') {
	        pathToCurrentNode.push(key);
	    }
	    return pathToCurrentNode.join('/');
	}
	
	function allowedKeys (orderedWhiteList) {
	    return function (next) {
	        return function (acc, x) {
	            var isIteratingArray = (typeName(x) === 'Array');
	            if (!isIteratingArray && typeName(orderedWhiteList) === 'Array') {
	                acc.context.keys = arrayFilter(orderedWhiteList, function (propKey) {
	                    return indexOf(acc.context.keys, propKey) !== -1;
	                });
	            }
	            return next(acc, x);
	        };
	    };
	}
	
	function safeKeys () {
	    return function (next) {
	        return function (acc, x) {
	            if (typeName(x) !== 'Array') {
	                acc.context.keys = arrayFilter(acc.context.keys, function (propKey) {
	                    // Error handling for unsafe property access.
	                    // For example, on PhantomJS,
	                    // accessing HTMLInputElement.selectionEnd causes TypeError
	                    try {
	                        var val = x[propKey];
	                        return true;
	                    } catch (e) {
	                        // skip unsafe key
	                        return false;
	                    }
	                });
	            }
	            return next(acc, x);
	        };
	    };
	}
	
	function arrayIndicesToKeys () {
	    return function (next) {
	        return function (acc, x) {
	            if (typeName(x) === 'Array' && 0 < x.length) {
	                var indices = Array(x.length);
	                for(var i = 0; i < x.length; i += 1) {
	                    indices[i] = String(i); // traverse uses strings as keys
	                }
	                acc.context.keys = indices;
	            }
	            return next(acc, x);
	        };
	    };
	}
	
	function when (guard, then) {
	    return function (next) {
	        return function (acc, x) {
	            var kvp = {
	                key: acc.context.key,
	                value: x
	            };
	            if (guard(kvp, acc)) {
	                return then(acc, x);
	            }
	            return next(acc, x);
	        };
	    };
	}
	
	function truncate (size) {
	    return function (next) {
	        return function (acc, x) {
	            var orig = acc.push;
	            var ret;
	            acc.push = function (str) {
	                var savings = str.length - size;
	                var truncated;
	                if (savings <= size) {
	                    orig.call(acc, str);
	                } else {
	                    truncated = str.substring(0, size);
	                    orig.call(acc, truncated + acc.options.snip);
	                }
	            };
	            ret = next(acc, x);
	            acc.push = orig;
	            return ret;
	        };
	    };
	}
	
	function constructorName () {
	    return function (next) {
	        return function (acc, x) {
	            var name = acc.options.typeFun(x);
	            if (name === '') {
	                name = acc.options.anonymous;
	            }
	            acc.push(name);
	            return next(acc, x);
	        };
	    };
	}
	
	function always (str) {
	    return function (next) {
	        return function (acc, x) {
	            acc.push(str);
	            return next(acc, x);
	        };
	    };
	}
	
	function optionValue (key) {
	    return function (next) {
	        return function (acc, x) {
	            acc.push(acc.options[key]);
	            return next(acc, x);
	        };
	    };
	}
	
	function json (replacer) {
	    return function (next) {
	        return function (acc, x) {
	            acc.push(JSON.stringify(x, replacer));
	            return next(acc, x);
	        };
	    };
	}
	
	function toStr () {
	    return function (next) {
	        return function (acc, x) {
	            acc.push(x.toString());
	            return next(acc, x);
	        };
	    };
	}
	
	function decorateArray () {
	    return function (next) {
	        return function (acc, x) {
	            acc.context.before(function (node) {
	                acc.push('[');
	            });
	            acc.context.after(function (node) {
	                afterAllChildren(this, acc.push, acc.options);
	                acc.push(']');
	            });
	            acc.context.pre(function (val, key) {
	                beforeEachChild(this, acc.push, acc.options);
	            });
	            acc.context.post(function (childContext) {
	                afterEachChild(childContext, acc.push);
	            });
	            return next(acc, x);
	        };
	    };
	}
	
	function decorateObject () {
	    return function (next) {
	        return function (acc, x) {
	            acc.context.before(function (node) {
	                acc.push('{');
	            });
	            acc.context.after(function (node) {
	                afterAllChildren(this, acc.push, acc.options);
	                acc.push('}');
	            });
	            acc.context.pre(function (val, key) {
	                beforeEachChild(this, acc.push, acc.options);
	                acc.push(sanitizeKey(key) + (acc.options.indent ? ': ' : ':'));
	            });
	            acc.context.post(function (childContext) {
	                afterEachChild(childContext, acc.push);
	            });
	            return next(acc, x);
	        };
	    };
	}
	
	function sanitizeKey (key) {
	    return /^[A-Za-z_]+$/.test(key) ? key : JSON.stringify(key);
	}
	
	function afterAllChildren (context, push, options) {
	    if (options.indent && 0 < context.keys.length) {
	        push(options.lineSeparator);
	        for(var i = 0; i < context.level; i += 1) { // indent level - 1
	            push(options.indent);
	        }
	    }
	}
	
	function beforeEachChild (context, push, options) {
	    if (options.indent) {
	        push(options.lineSeparator);
	        for(var i = 0; i <= context.level; i += 1) {
	            push(options.indent);
	        }
	    }
	}
	
	function afterEachChild (childContext, push) {
	    if (!childContext.isLast) {
	        push(',');
	    }
	}
	
	function nan (kvp, acc) {
	    return kvp.value !== kvp.value;
	}
	
	function positiveInfinity (kvp, acc) {
	    return !isFinite(kvp.value) && kvp.value === Infinity;
	}
	
	function negativeInfinity (kvp, acc) {
	    return !isFinite(kvp.value) && kvp.value !== Infinity;
	}
	
	function circular (kvp, acc) {
	    return acc.context.circular;
	}
	
	function maxDepth (kvp, acc) {
	    return (acc.options.maxDepth && acc.options.maxDepth <= acc.context.level);
	}
	
	var prune = compose(
	    always('#'),
	    constructorName(),
	    always('#'),
	    end()
	);
	var omitNaN = when(nan, compose(
	    always('NaN'),
	    end()
	));
	var omitPositiveInfinity = when(positiveInfinity, compose(
	    always('Infinity'),
	    end()
	));
	var omitNegativeInfinity = when(negativeInfinity, compose(
	    always('-Infinity'),
	    end()
	));
	var omitCircular = when(circular, compose(
	    optionValue('circular'),
	    end()
	));
	var omitMaxDepth = when(maxDepth, prune);
	
	module.exports = {
	    filters: {
	        always: always,
	        optionValue: optionValue,
	        constructorName: constructorName,
	        json: json,
	        toStr: toStr,
	        prune: prune,
	        truncate: truncate,
	        decorateArray: decorateArray,
	        decorateObject: decorateObject
	    },
	    flow: {
	        compose: compose,
	        when: when,
	        allowedKeys: allowedKeys,
	        safeKeys: safeKeys,
	        arrayIndicesToKeys: arrayIndicesToKeys,
	        filter: filter,
	        iterate: iterate,
	        end: end
	    },
	    symbols: {
	        END: END,
	        ITERATE: ITERATE
	    },
	    always: function (str) {
	        return compose(always(str), end());
	    },
	    json: function () {
	        return compose(json(), end());
	    },
	    toStr: function () {
	        return compose(toStr(), end());
	    },
	    prune: function () {
	        return prune;
	    },
	    number: function () {
	        return compose(
	            omitNaN,
	            omitPositiveInfinity,
	            omitNegativeInfinity,
	            json(),
	            end()
	        );
	    },
	    newLike: function () {
	        return compose(
	            always('new '),
	            constructorName(),
	            always('('),
	            json(),
	            always(')'),
	            end()
	        );
	    },
	    array: function (predicate) {
	        return compose(
	            omitCircular,
	            omitMaxDepth,
	            decorateArray(),
	            arrayIndicesToKeys(),
	            filter(predicate),
	            iterate()
	        );
	    },
	    object: function (predicate, orderedWhiteList) {
	        return compose(
	            omitCircular,
	            omitMaxDepth,
	            constructorName(),
	            decorateObject(),
	            allowedKeys(orderedWhiteList),
	            safeKeys(),
	            filter(predicate),
	            iterate()
	        );
	    }
	};


/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _ponyfill = __webpack_require__(512);
	
	var _ponyfill2 = _interopRequireDefault(_ponyfill);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var root = undefined; /* global window */
	
	if (typeof global !== 'undefined') {
		root = global;
	} else if (typeof window !== 'undefined') {
		root = window;
	}
	
	var result = (0, _ponyfill2.default)(root);
	exports.default = result;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 512 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = symbolObservablePonyfill;
	function symbolObservablePonyfill(root) {
		var result;
		var _Symbol = root.Symbol;
	
		if (typeof _Symbol === 'function') {
			if (_Symbol.observable) {
				result = _Symbol.observable;
			} else {
				result = _Symbol('observable');
				_Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};

/***/ },
/* 513 */
/***/ function(module, exports) {

	var traverse = module.exports = function (obj) {
	    return new Traverse(obj);
	};
	
	function Traverse (obj) {
	    this.value = obj;
	}
	
	Traverse.prototype.get = function (ps) {
	    var node = this.value;
	    for (var i = 0; i < ps.length; i ++) {
	        var key = ps[i];
	        if (!node || !hasOwnProperty.call(node, key)) {
	            node = undefined;
	            break;
	        }
	        node = node[key];
	    }
	    return node;
	};
	
	Traverse.prototype.has = function (ps) {
	    var node = this.value;
	    for (var i = 0; i < ps.length; i ++) {
	        var key = ps[i];
	        if (!node || !hasOwnProperty.call(node, key)) {
	            return false;
	        }
	        node = node[key];
	    }
	    return true;
	};
	
	Traverse.prototype.set = function (ps, value) {
	    var node = this.value;
	    for (var i = 0; i < ps.length - 1; i ++) {
	        var key = ps[i];
	        if (!hasOwnProperty.call(node, key)) node[key] = {};
	        node = node[key];
	    }
	    node[ps[i]] = value;
	    return value;
	};
	
	Traverse.prototype.map = function (cb) {
	    return walk(this.value, cb, true);
	};
	
	Traverse.prototype.forEach = function (cb) {
	    this.value = walk(this.value, cb, false);
	    return this.value;
	};
	
	Traverse.prototype.reduce = function (cb, init) {
	    var skip = arguments.length === 1;
	    var acc = skip ? this.value : init;
	    this.forEach(function (x) {
	        if (!this.isRoot || !skip) {
	            acc = cb.call(this, acc, x);
	        }
	    });
	    return acc;
	};
	
	Traverse.prototype.paths = function () {
	    var acc = [];
	    this.forEach(function (x) {
	        acc.push(this.path); 
	    });
	    return acc;
	};
	
	Traverse.prototype.nodes = function () {
	    var acc = [];
	    this.forEach(function (x) {
	        acc.push(this.node);
	    });
	    return acc;
	};
	
	Traverse.prototype.clone = function () {
	    var parents = [], nodes = [];
	    
	    return (function clone (src) {
	        for (var i = 0; i < parents.length; i++) {
	            if (parents[i] === src) {
	                return nodes[i];
	            }
	        }
	        
	        if (typeof src === 'object' && src !== null) {
	            var dst = copy(src);
	            
	            parents.push(src);
	            nodes.push(dst);
	            
	            forEach(objectKeys(src), function (key) {
	                dst[key] = clone(src[key]);
	            });
	            
	            parents.pop();
	            nodes.pop();
	            return dst;
	        }
	        else {
	            return src;
	        }
	    })(this.value);
	};
	
	function walk (root, cb, immutable) {
	    var path = [];
	    var parents = [];
	    var alive = true;
	    
	    return (function walker (node_) {
	        var node = immutable ? copy(node_) : node_;
	        var modifiers = {};
	        
	        var keepGoing = true;
	        
	        var state = {
	            node : node,
	            node_ : node_,
	            path : [].concat(path),
	            parent : parents[parents.length - 1],
	            parents : parents,
	            key : path.slice(-1)[0],
	            isRoot : path.length === 0,
	            level : path.length,
	            circular : null,
	            update : function (x, stopHere) {
	                if (!state.isRoot) {
	                    state.parent.node[state.key] = x;
	                }
	                state.node = x;
	                if (stopHere) keepGoing = false;
	            },
	            'delete' : function (stopHere) {
	                delete state.parent.node[state.key];
	                if (stopHere) keepGoing = false;
	            },
	            remove : function (stopHere) {
	                if (isArray(state.parent.node)) {
	                    state.parent.node.splice(state.key, 1);
	                }
	                else {
	                    delete state.parent.node[state.key];
	                }
	                if (stopHere) keepGoing = false;
	            },
	            keys : null,
	            before : function (f) { modifiers.before = f },
	            after : function (f) { modifiers.after = f },
	            pre : function (f) { modifiers.pre = f },
	            post : function (f) { modifiers.post = f },
	            stop : function () { alive = false },
	            block : function () { keepGoing = false }
	        };
	        
	        if (!alive) return state;
	        
	        function updateState() {
	            if (typeof state.node === 'object' && state.node !== null) {
	                if (!state.keys || state.node_ !== state.node) {
	                    state.keys = objectKeys(state.node)
	                }
	                
	                state.isLeaf = state.keys.length == 0;
	                
	                for (var i = 0; i < parents.length; i++) {
	                    if (parents[i].node_ === node_) {
	                        state.circular = parents[i];
	                        break;
	                    }
	                }
	            }
	            else {
	                state.isLeaf = true;
	                state.keys = null;
	            }
	            
	            state.notLeaf = !state.isLeaf;
	            state.notRoot = !state.isRoot;
	        }
	        
	        updateState();
	        
	        // use return values to update if defined
	        var ret = cb.call(state, state.node);
	        if (ret !== undefined && state.update) state.update(ret);
	        
	        if (modifiers.before) modifiers.before.call(state, state.node);
	        
	        if (!keepGoing) return state;
	        
	        if (typeof state.node == 'object'
	        && state.node !== null && !state.circular) {
	            parents.push(state);
	            
	            updateState();
	            
	            forEach(state.keys, function (key, i) {
	                path.push(key);
	                
	                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
	                
	                var child = walker(state.node[key]);
	                if (immutable && hasOwnProperty.call(state.node, key)) {
	                    state.node[key] = child.node;
	                }
	                
	                child.isLast = i == state.keys.length - 1;
	                child.isFirst = i == 0;
	                
	                if (modifiers.post) modifiers.post.call(state, child);
	                
	                path.pop();
	            });
	            parents.pop();
	        }
	        
	        if (modifiers.after) modifiers.after.call(state, state.node);
	        
	        return state;
	    })(root).node;
	}
	
	function copy (src) {
	    if (typeof src === 'object' && src !== null) {
	        var dst;
	        
	        if (isArray(src)) {
	            dst = [];
	        }
	        else if (isDate(src)) {
	            dst = new Date(src.getTime ? src.getTime() : src);
	        }
	        else if (isRegExp(src)) {
	            dst = new RegExp(src);
	        }
	        else if (isError(src)) {
	            dst = { message: src.message };
	        }
	        else if (isBoolean(src)) {
	            dst = new Boolean(src);
	        }
	        else if (isNumber(src)) {
	            dst = new Number(src);
	        }
	        else if (isString(src)) {
	            dst = new String(src);
	        }
	        else if (Object.create && Object.getPrototypeOf) {
	            dst = Object.create(Object.getPrototypeOf(src));
	        }
	        else if (src.constructor === Object) {
	            dst = {};
	        }
	        else {
	            var proto =
	                (src.constructor && src.constructor.prototype)
	                || src.__proto__
	                || {}
	            ;
	            var T = function () {};
	            T.prototype = proto;
	            dst = new T;
	        }
	        
	        forEach(objectKeys(src), function (key) {
	            dst[key] = src[key];
	        });
	        return dst;
	    }
	    else return src;
	}
	
	var objectKeys = Object.keys || function keys (obj) {
	    var res = [];
	    for (var key in obj) res.push(key)
	    return res;
	};
	
	function toS (obj) { return Object.prototype.toString.call(obj) }
	function isDate (obj) { return toS(obj) === '[object Date]' }
	function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
	function isError (obj) { return toS(obj) === '[object Error]' }
	function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
	function isNumber (obj) { return toS(obj) === '[object Number]' }
	function isString (obj) { return toS(obj) === '[object String]' }
	
	var isArray = Array.isArray || function isArray (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};
	
	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};
	
	forEach(objectKeys(Traverse.prototype), function (key) {
	    traverse[key] = function (obj) {
	        var args = [].slice.call(arguments, 1);
	        var t = new Traverse(obj);
	        return t[key].apply(t, args);
	    };
	});
	
	var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
	    return key in obj;
	};


/***/ },
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	// port of https://github.com/nodejs/node/blob/v6.3.0/lib/assert.js#L145-L248
	
	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var Buffer = __webpack_require__(163).Buffer;
	var compare = Buffer.compare;
	var indexOf = __webpack_require__(335);
	var filter = __webpack_require__(241);
	var getPrototypeOf = Object.getPrototypeOf || function(obj) {
	  return obj.__proto__ || (
	    obj.constructor
	      ? obj.constructor.prototype
	      : Object.prototype
	  );
	};
	function isEnumerable(obj, key) {
	  return Object.prototype.propertyIsEnumerable.call(obj, key);
	};
	function pToString(obj) {
	  return Object.prototype.toString.call(obj);
	};
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	function isDate(d) {
	  return isObject(d) && pToString(d) === '[object Date]';
	}
	function isRegExp(re) {
	  return isObject(re) && pToString(re) === '[object RegExp]';
	}
	var isArguments = (function () {
	  function isArg(obj) {
	    return isObject(obj) && pToString(obj) == '[object Arguments]';
	  }
	  // dealing with old IEs (There's no Arguments type)
	  if (!isArg(arguments)) {
	    return function(obj) {
	      return isObject(obj) &&
	        typeof obj.length === 'number' &&
	        obj.length >= 0 &&
	        pToString(obj) !== '[object Array]' &&
	        pToString(obj.callee) === '[object Function]';
	    };
	  } else {
	    return isArg;
	  }
	})();
	function fromBufferSupport() {
	  try {
	    return typeof Buffer.from === 'function' && !!Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
	  } catch (e) {
	    // Buffer.from under Node 4.x causes `TypeError: this is not a typed array.`
	    return false;
	  }
	}
	var toBuffer = (function () {
	  // check whether Buffer constructor accepts ArrayBuffer or not
	  function isBufferConstructorAcceptsArrayBuffer() {
	    try {
	      return typeof Uint8Array === 'function' && (new Buffer(new Uint8Array([1]).buffer)[0] === 1);
	    } catch (e) {
	      return false;
	    }
	  }
	  if (isBufferConstructorAcceptsArrayBuffer()) {
	    // Node 4.x
	    return function (ab) {
	      return new Buffer(ab);
	    };
	  } else {
	    // Node 0.10.x and 0.12.x
	    return function (ab) {
	      var buffer = new Buffer(ab.byteLength);
	      var view = new Uint8Array(ab);
	      for (var i = 0; i < buffer.length; ++i) {
	        buffer[i] = view[i];
	      }
	      return buffer;
	    };
	  }
	})();
	var bufferFrom = fromBufferSupport() ? Buffer.from : toBuffer;
	var objectKeys = (function () {
	  var OLD_V8_ARRAY_BUFFER_ENUM = ['BYTES_PER_ELEMENT','get','set','slice','subarray','buffer','length','byteOffset','byteLength'];
	  var keys = Object.keys || __webpack_require__(211);
	  return function objectKeys(obj) {
	    // avoid iterating enumerable properties of ArrayBuffer under old V8
	    if (isEnumerable(obj, 'buffer') &&
	        isEnumerable(obj, 'byteOffset') &&
	        isEnumerable(obj, 'byteLength')) {
	      return filter(keys(obj), function (k) {
	        return indexOf(OLD_V8_ARRAY_BUFFER_ENUM, k) === -1;
	      });
	    } else {
	      return keys(obj);
	    }
	  };
	})();
	
	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (actual instanceof Buffer && expected instanceof Buffer) {
	    return compare(actual, expected) === 0;
	
	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (isDate(actual) && isDate(expected)) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (isRegExp(actual) && isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;
	
	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;
	
	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (typeof ArrayBuffer === 'function' && typeof ArrayBuffer.isView === 'function' &&
	             ArrayBuffer.isView(actual) && ArrayBuffer.isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(bufferFrom(actual.buffer),
	                   bufferFrom(expected.buffer)) === 0;
	
	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    memos = memos || {actual: [], expected: []};
	
	    var actualIndex = indexOf(memos.actual, actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === indexOf(memos.expected, expected)) {
	        return true;
	      }
	    }
	
	    memos.actual.push(actual);
	    memos.expected.push(expected);
	
	    return objEquiv(actual, expected, strict, memos);
	  }
	}
	
	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (isPrimitive(a) || isPrimitive(b))
	    return a === b;
	  if (strict && getPrototypeOf(a) !== getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a),
	      bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  var ka = objectKeys(a),
	      kb = objectKeys(b),
	      key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}
	
	module.exports = _deepEqual;


/***/ },
/* 515 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 516 */
/***/ function(module, exports) {

	module.exports = extend
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	function extend() {
	    var target = {}
	
	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]
	
	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }
	
	    return target
	}


/***/ }
/******/ ])
});
;
//# sourceMappingURL=LyphRectangle.js.map